import { createHash, randomUUID } from 'crypto';
import require$$1$1 from 'tty';
import require$$0$1$1 from 'util';
import os$1 from 'os';
import require$$0$2 from 'node:async_hooks';
import Stream, { Transform } from 'stream';
import http2 from 'http';
import Url from 'url';
import require$$0$3 from 'punycode';
import https2 from 'https';
import zlib from 'zlib';
import pino from 'pino';
import pretty from 'pino-pretty';
import require$$2 from 'events';

// src/storage/constants.ts
var TABLE_WORKFLOW_SNAPSHOT = "mastra_workflow_snapshot";
var TABLE_EVALS = "mastra_evals";
var TABLE_MESSAGES = "mastra_messages";
var TABLE_THREADS = "mastra_threads";
var TABLE_TRACES = "mastra_traces";
var TABLE_SCHEMAS = {
  [TABLE_WORKFLOW_SNAPSHOT]: {
    workflow_name: {
      type: "text"
    },
    run_id: {
      type: "text"
    },
    resourceId: { type: "text", nullable: true },
    snapshot: {
      type: "text"
    },
    createdAt: {
      type: "timestamp"
    },
    updatedAt: {
      type: "timestamp"
    }
  },
  [TABLE_EVALS]: {
    input: {
      type: "text"
    },
    output: {
      type: "text"
    },
    result: {
      type: "jsonb"
    },
    agent_name: {
      type: "text"
    },
    metric_name: {
      type: "text"
    },
    instructions: {
      type: "text"
    },
    test_info: {
      type: "jsonb",
      nullable: true
    },
    global_run_id: {
      type: "text"
    },
    run_id: {
      type: "text"
    },
    created_at: {
      type: "timestamp"
    },
    createdAt: {
      type: "timestamp",
      nullable: true
    }
  },
  [TABLE_THREADS]: {
    id: { type: "text", nullable: false, primaryKey: true },
    resourceId: { type: "text", nullable: false },
    title: { type: "text", nullable: false },
    metadata: { type: "text", nullable: true },
    createdAt: { type: "timestamp", nullable: false },
    updatedAt: { type: "timestamp", nullable: false }
  },
  [TABLE_MESSAGES]: {
    id: { type: "text", nullable: false, primaryKey: true },
    thread_id: { type: "text", nullable: false },
    content: { type: "text", nullable: false },
    role: { type: "text", nullable: false },
    type: { type: "text", nullable: false },
    createdAt: { type: "timestamp", nullable: false }
  },
  [TABLE_TRACES]: {
    id: { type: "text", nullable: false, primaryKey: true },
    parentSpanId: { type: "text", nullable: true },
    name: { type: "text", nullable: false },
    traceId: { type: "text", nullable: false },
    scope: { type: "text", nullable: false },
    kind: { type: "integer", nullable: false },
    attributes: { type: "jsonb", nullable: true },
    status: { type: "jsonb", nullable: true },
    events: { type: "jsonb", nullable: true },
    links: { type: "jsonb", nullable: true },
    other: { type: "text", nullable: true },
    startTime: { type: "bigint", nullable: false },
    endTime: { type: "bigint", nullable: false },
    createdAt: { type: "timestamp", nullable: false }
  }
};

// src/logger/index.ts
var RegisteredLogger = {
  AGENT: "AGENT",
  WORKFLOW: "WORKFLOW",
  LLM: "LLM"};
var LogLevel = {
  INFO: "info",
  WARN: "warn"};
var Logger = class {
  logger;
  transports;
  constructor(options = {}) {
    this.transports = options.transports || {};
    const transportsAry = Object.entries(this.transports);
    this.logger = pino(
      {
        name: options.name || "app",
        level: options.level || LogLevel.INFO,
        formatters: {
          level: (label) => {
            return {
              level: label
            };
          }
        }
      },
      options.overrideDefaultTransports ? options?.transports?.default : transportsAry.length === 0 ? pretty({
        colorize: true,
        levelFirst: true,
        ignore: "pid,hostname",
        colorizeObjects: true,
        translateTime: "SYS:standard",
        singleLine: false
      }) : pino.multistream([
        ...transportsAry.map(([, transport]) => ({
          stream: transport,
          level: options.level || LogLevel.INFO
        })),
        {
          stream: pretty({
            colorize: true,
            levelFirst: true,
            ignore: "pid,hostname",
            colorizeObjects: true,
            translateTime: "SYS:standard",
            singleLine: false
          }),
          level: options.level || LogLevel.INFO
        }
      ])
    );
  }
  debug(message, args = {}) {
    this.logger.debug(args, message);
  }
  info(message, args = {}) {
    this.logger.info(args, message);
  }
  warn(message, args = {}) {
    this.logger.warn(args, message);
  }
  error(message, args = {}) {
    this.logger.error(args, message);
  }
  // Stream creation for process output handling
  createStream() {
    return new Transform({
      transform: (chunk, _encoding, callback) => {
        const line = chunk.toString().trim();
        if (line) {
          this.info(line);
        }
        callback(null, chunk);
      }
    });
  }
  async getLogs(transportId) {
    if (!transportId || !this.transports[transportId]) {
      return [];
    }
    return this.transports[transportId].getLogs();
  }
  async getLogsByRunId({ runId, transportId }) {
    return this.transports[transportId]?.getLogsByRunId({ runId });
  }
};
function createLogger(options) {
  return new Logger(options);
}
var noopLogger = {
  debug: () => {
  },
  info: () => {
  },
  warn: () => {
  },
  error: () => {
  },
  cleanup: async () => {
  }
};

// src/base.ts
var MastraBase = class {
  component = RegisteredLogger.LLM;
  logger;
  name;
  telemetry;
  constructor({ component, name }) {
    this.component = component || RegisteredLogger.LLM;
    this.name = name;
    this.logger = createLogger({ name: `${this.component} - ${this.name}` });
  }
  /**
   * Set the logger for the agent
   * @param logger
   */
  __setLogger(logger) {
    this.logger = logger;
    if (this.component !== RegisteredLogger.LLM) {
      this.logger.debug(`Logger updated [component=${this.component}] [name=${this.name}]`);
    }
  }
  /**
   * Set the telemetry for the
   * @param telemetry
   */
  __setTelemetry(telemetry) {
    this.telemetry = telemetry;
    if (this.component !== RegisteredLogger.LLM) {
      this.logger.debug(`Telemetry updated [component=${this.component}] [name=${this.telemetry.name}]`);
    }
  }
  /**
   * Get the telemetry on the vector
   * @returns telemetry
   */
  __getTelemetry() {
    return this.telemetry;
  }
  /* 
    get experimental_telemetry config
    */
  get experimental_telemetry() {
    return this.telemetry ? {
      // tracer: this.telemetry.tracer,
      tracer: this.telemetry.getBaggageTracer(),
      isEnabled: !!this.telemetry.tracer
    } : void 0;
  }
};

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** only globals that common to node and browsers are allowed */
// eslint-disable-next-line node/no-unsupported-features/es-builtins
var _globalThis = typeof globalThis === 'object' ? globalThis : global;

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// this is autogenerated file, see scripts/version-update.js
var VERSION = '1.9.0';

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
/**
 * Create a function to test an API version to see if it is compatible with the provided ownVersion.
 *
 * The returned function has the following semantics:
 * - Exact match is always compatible
 * - Major versions must match exactly
 *    - 1.x package cannot use global 2.x package
 *    - 2.x package cannot use global 1.x package
 * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API
 *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects
 *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3
 * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor
 * - Patch and build tag differences are not considered at this time
 *
 * @param ownVersion version which should be checked against
 */
function _makeCompatibilityCheck(ownVersion) {
    var acceptedVersions = new Set([ownVersion]);
    var rejectedVersions = new Set();
    var myVersionMatch = ownVersion.match(re);
    if (!myVersionMatch) {
        // we cannot guarantee compatibility so we always return noop
        return function () { return false; };
    }
    var ownVersionParsed = {
        major: +myVersionMatch[1],
        minor: +myVersionMatch[2],
        patch: +myVersionMatch[3],
        prerelease: myVersionMatch[4],
    };
    // if ownVersion has a prerelease tag, versions must match exactly
    if (ownVersionParsed.prerelease != null) {
        return function isExactmatch(globalVersion) {
            return globalVersion === ownVersion;
        };
    }
    function _reject(v) {
        rejectedVersions.add(v);
        return false;
    }
    function _accept(v) {
        acceptedVersions.add(v);
        return true;
    }
    return function isCompatible(globalVersion) {
        if (acceptedVersions.has(globalVersion)) {
            return true;
        }
        if (rejectedVersions.has(globalVersion)) {
            return false;
        }
        var globalVersionMatch = globalVersion.match(re);
        if (!globalVersionMatch) {
            // cannot parse other version
            // we cannot guarantee compatibility so we always noop
            return _reject(globalVersion);
        }
        var globalVersionParsed = {
            major: +globalVersionMatch[1],
            minor: +globalVersionMatch[2],
            patch: +globalVersionMatch[3],
            prerelease: globalVersionMatch[4],
        };
        // if globalVersion has a prerelease tag, versions must match exactly
        if (globalVersionParsed.prerelease != null) {
            return _reject(globalVersion);
        }
        // major versions must match
        if (ownVersionParsed.major !== globalVersionParsed.major) {
            return _reject(globalVersion);
        }
        if (ownVersionParsed.major === 0) {
            if (ownVersionParsed.minor === globalVersionParsed.minor &&
                ownVersionParsed.patch <= globalVersionParsed.patch) {
                return _accept(globalVersion);
            }
            return _reject(globalVersion);
        }
        if (ownVersionParsed.minor <= globalVersionParsed.minor) {
            return _accept(globalVersion);
        }
        return _reject(globalVersion);
    };
}
/**
 * Test an API version to see if it is compatible with this API.
 *
 * - Exact match is always compatible
 * - Major versions must match exactly
 *    - 1.x package cannot use global 2.x package
 *    - 2.x package cannot use global 1.x package
 * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API
 *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects
 *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3
 * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor
 * - Patch and build tag differences are not considered at this time
 *
 * @param version version of the API requesting an instance of the global API
 */
var isCompatible = _makeCompatibilityCheck(VERSION);

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var major = VERSION.split('.')[0];
var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
var _global = _globalThis;
function registerGlobal(type, instance, diag, allowOverride) {
    var _a;
    if (allowOverride === void 0) { allowOverride = false; }
    var api = (_global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== void 0 ? _a : {
        version: VERSION,
    });
    if (!allowOverride && api[type]) {
        // already registered an API of this type
        var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
        diag.error(err.stack || err.message);
        return false;
    }
    if (api.version !== VERSION) {
        // All registered APIs must be of the same version exactly
        var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION);
        diag.error(err.stack || err.message);
        return false;
    }
    api[type] = instance;
    diag.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION + ".");
    return true;
}
function getGlobal(type) {
    var _a, _b;
    var globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === void 0 ? void 0 : _a.version;
    if (!globalVersion || !isCompatible(globalVersion)) {
        return;
    }
    return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type];
}
function unregisterGlobal(type, diag) {
    diag.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION + ".");
    var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
    if (api) {
        delete api[type];
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __read$3 = function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray$3 = function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/**
 * Component Logger which is meant to be used as part of any component which
 * will add automatically additional namespace in front of the log message.
 * It will then forward all message to global diag logger
 * @example
 * const cLogger = diag.createComponentLogger({ namespace: '@opentelemetry/instrumentation-http' });
 * cLogger.debug('test');
 * // @opentelemetry/instrumentation-http test
 */
var DiagComponentLogger = /** @class */ (function () {
    function DiagComponentLogger(props) {
        this._namespace = props.namespace || 'DiagComponentLogger';
    }
    DiagComponentLogger.prototype.debug = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return logProxy('debug', this._namespace, args);
    };
    DiagComponentLogger.prototype.error = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return logProxy('error', this._namespace, args);
    };
    DiagComponentLogger.prototype.info = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return logProxy('info', this._namespace, args);
    };
    DiagComponentLogger.prototype.warn = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return logProxy('warn', this._namespace, args);
    };
    DiagComponentLogger.prototype.verbose = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return logProxy('verbose', this._namespace, args);
    };
    return DiagComponentLogger;
}());
function logProxy(funcName, namespace, args) {
    var logger = getGlobal('diag');
    // shortcut if logger not set
    if (!logger) {
        return;
    }
    args.unshift(namespace);
    return logger[funcName].apply(logger, __spreadArray$3([], __read$3(args), false));
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Defines the available internal logging levels for the diagnostic logger, the numeric values
 * of the levels are defined to match the original values from the initial LogLevel to avoid
 * compatibility/migration issues for any implementation that assume the numeric ordering.
 */
var DiagLogLevel;
(function (DiagLogLevel) {
    /** Diagnostic Logging level setting to disable all logging (except and forced logs) */
    DiagLogLevel[DiagLogLevel["NONE"] = 0] = "NONE";
    /** Identifies an error scenario */
    DiagLogLevel[DiagLogLevel["ERROR"] = 30] = "ERROR";
    /** Identifies a warning scenario */
    DiagLogLevel[DiagLogLevel["WARN"] = 50] = "WARN";
    /** General informational log message */
    DiagLogLevel[DiagLogLevel["INFO"] = 60] = "INFO";
    /** General debug log message */
    DiagLogLevel[DiagLogLevel["DEBUG"] = 70] = "DEBUG";
    /**
     * Detailed trace level logging should only be used for development, should only be set
     * in a development environment.
     */
    DiagLogLevel[DiagLogLevel["VERBOSE"] = 80] = "VERBOSE";
    /** Used to set the logging level to include all logging */
    DiagLogLevel[DiagLogLevel["ALL"] = 9999] = "ALL";
})(DiagLogLevel || (DiagLogLevel = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function createLogLevelDiagLogger(maxLevel, logger) {
    if (maxLevel < DiagLogLevel.NONE) {
        maxLevel = DiagLogLevel.NONE;
    }
    else if (maxLevel > DiagLogLevel.ALL) {
        maxLevel = DiagLogLevel.ALL;
    }
    // In case the logger is null or undefined
    logger = logger || {};
    function _filterFunc(funcName, theLevel) {
        var theFunc = logger[funcName];
        if (typeof theFunc === 'function' && maxLevel >= theLevel) {
            return theFunc.bind(logger);
        }
        return function () { };
    }
    return {
        error: _filterFunc('error', DiagLogLevel.ERROR),
        warn: _filterFunc('warn', DiagLogLevel.WARN),
        info: _filterFunc('info', DiagLogLevel.INFO),
        debug: _filterFunc('debug', DiagLogLevel.DEBUG),
        verbose: _filterFunc('verbose', DiagLogLevel.VERBOSE),
    };
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __read$2 = function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray$2 = function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME$2 = 'diag';
/**
 * Singleton object which represents the entry point to the OpenTelemetry internal
 * diagnostic API
 */
var DiagAPI = /** @class */ (function () {
    /**
     * Private internal constructor
     * @private
     */
    function DiagAPI() {
        function _logProxy(funcName) {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var logger = getGlobal('diag');
                // shortcut if logger not set
                if (!logger)
                    return;
                return logger[funcName].apply(logger, __spreadArray$2([], __read$2(args), false));
            };
        }
        // Using self local variable for minification purposes as 'this' cannot be minified
        var self = this;
        // DiagAPI specific functions
        var setLogger = function (logger, optionsOrLogLevel) {
            var _a, _b, _c;
            if (optionsOrLogLevel === void 0) { optionsOrLogLevel = { logLevel: DiagLogLevel.INFO }; }
            if (logger === self) {
                // There isn't much we can do here.
                // Logging to the console might break the user application.
                // Try to log to self. If a logger was previously registered it will receive the log.
                var err = new Error('Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation');
                self.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message);
                return false;
            }
            if (typeof optionsOrLogLevel === 'number') {
                optionsOrLogLevel = {
                    logLevel: optionsOrLogLevel,
                };
            }
            var oldLogger = getGlobal('diag');
            var newLogger = createLogLevelDiagLogger((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : DiagLogLevel.INFO, logger);
            // There already is an logger registered. We'll let it know before overwriting it.
            if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
                var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : '<failed to generate stacktrace>';
                oldLogger.warn("Current logger will be overwritten from " + stack);
                newLogger.warn("Current logger will overwrite one already registered from " + stack);
            }
            return registerGlobal('diag', newLogger, self, true);
        };
        self.setLogger = setLogger;
        self.disable = function () {
            unregisterGlobal(API_NAME$2, self);
        };
        self.createComponentLogger = function (options) {
            return new DiagComponentLogger(options);
        };
        self.verbose = _logProxy('verbose');
        self.debug = _logProxy('debug');
        self.info = _logProxy('info');
        self.warn = _logProxy('warn');
        self.error = _logProxy('error');
    }
    /** Get the singleton instance of the DiagAPI API */
    DiagAPI.instance = function () {
        if (!this._instance) {
            this._instance = new DiagAPI();
        }
        return this._instance;
    };
    return DiagAPI;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Get a key to uniquely identify a context value */
function createContextKey(description) {
    // The specification states that for the same input, multiple calls should
    // return different keys. Due to the nature of the JS dependency management
    // system, this creates problems where multiple versions of some package
    // could hold different keys for the same property.
    //
    // Therefore, we use Symbol.for which returns the same key for the same input.
    return Symbol.for(description);
}
var BaseContext = /** @class */ (function () {
    /**
     * Construct a new context which inherits values from an optional parent context.
     *
     * @param parentContext a context from which to inherit values
     */
    function BaseContext(parentContext) {
        // for minification
        var self = this;
        self._currentContext = parentContext ? new Map(parentContext) : new Map();
        self.getValue = function (key) { return self._currentContext.get(key); };
        self.setValue = function (key, value) {
            var context = new BaseContext(self._currentContext);
            context._currentContext.set(key, value);
            return context;
        };
        self.deleteValue = function (key) {
            var context = new BaseContext(self._currentContext);
            context._currentContext.delete(key);
            return context;
        };
    }
    return BaseContext;
}());
/** The root context is used as the default parent context when there is no active context */
var ROOT_CONTEXT = new BaseContext();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __read$1 = function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray$1 = function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var NoopContextManager = /** @class */ (function () {
    function NoopContextManager() {
    }
    NoopContextManager.prototype.active = function () {
        return ROOT_CONTEXT;
    };
    NoopContextManager.prototype.with = function (_context, fn, thisArg) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            args[_i - 3] = arguments[_i];
        }
        return fn.call.apply(fn, __spreadArray$1([thisArg], __read$1(args), false));
    };
    NoopContextManager.prototype.bind = function (_context, target) {
        return target;
    };
    NoopContextManager.prototype.enable = function () {
        return this;
    };
    NoopContextManager.prototype.disable = function () {
        return this;
    };
    return NoopContextManager;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __read$4 = function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME$1 = 'context';
var NOOP_CONTEXT_MANAGER = new NoopContextManager();
/**
 * Singleton object which represents the entry point to the OpenTelemetry Context API
 */
var ContextAPI = /** @class */ (function () {
    /** Empty private constructor prevents end users from constructing a new instance of the API */
    function ContextAPI() {
    }
    /** Get the singleton instance of the Context API */
    ContextAPI.getInstance = function () {
        if (!this._instance) {
            this._instance = new ContextAPI();
        }
        return this._instance;
    };
    /**
     * Set the current context manager.
     *
     * @returns true if the context manager was successfully registered, else false
     */
    ContextAPI.prototype.setGlobalContextManager = function (contextManager) {
        return registerGlobal(API_NAME$1, contextManager, DiagAPI.instance());
    };
    /**
     * Get the currently active context
     */
    ContextAPI.prototype.active = function () {
        return this._getContextManager().active();
    };
    /**
     * Execute a function with an active context
     *
     * @param context context to be active during function execution
     * @param fn function to execute in a context
     * @param thisArg optional receiver to be used for calling fn
     * @param args optional arguments forwarded to fn
     */
    ContextAPI.prototype.with = function (context, fn, thisArg) {
        var _a;
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            args[_i - 3] = arguments[_i];
        }
        return (_a = this._getContextManager()).with.apply(_a, __spreadArray([context, fn, thisArg], __read$4(args), false));
    };
    /**
     * Bind a context to a target function or event emitter
     *
     * @param context context to bind to the event emitter or function. Defaults to the currently active context
     * @param target function or event emitter to bind
     */
    ContextAPI.prototype.bind = function (context, target) {
        return this._getContextManager().bind(context, target);
    };
    ContextAPI.prototype._getContextManager = function () {
        return getGlobal(API_NAME$1) || NOOP_CONTEXT_MANAGER;
    };
    /** Disable and remove the global context manager */
    ContextAPI.prototype.disable = function () {
        this._getContextManager().disable();
        unregisterGlobal(API_NAME$1, DiagAPI.instance());
    };
    return ContextAPI;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var TraceFlags;
(function (TraceFlags) {
    /** Represents no flag set. */
    TraceFlags[TraceFlags["NONE"] = 0] = "NONE";
    /** Bit to represent whether trace is sampled in trace flags. */
    TraceFlags[TraceFlags["SAMPLED"] = 1] = "SAMPLED";
})(TraceFlags || (TraceFlags = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var INVALID_SPANID = '0000000000000000';
var INVALID_TRACEID = '00000000000000000000000000000000';
var INVALID_SPAN_CONTEXT = {
    traceId: INVALID_TRACEID,
    spanId: INVALID_SPANID,
    traceFlags: TraceFlags.NONE,
};

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The NonRecordingSpan is the default {@link Span} that is used when no Span
 * implementation is available. All operations are no-op including context
 * propagation.
 */
var NonRecordingSpan = /** @class */ (function () {
    function NonRecordingSpan(_spanContext) {
        if (_spanContext === void 0) { _spanContext = INVALID_SPAN_CONTEXT; }
        this._spanContext = _spanContext;
    }
    // Returns a SpanContext.
    NonRecordingSpan.prototype.spanContext = function () {
        return this._spanContext;
    };
    // By default does nothing
    NonRecordingSpan.prototype.setAttribute = function (_key, _value) {
        return this;
    };
    // By default does nothing
    NonRecordingSpan.prototype.setAttributes = function (_attributes) {
        return this;
    };
    // By default does nothing
    NonRecordingSpan.prototype.addEvent = function (_name, _attributes) {
        return this;
    };
    NonRecordingSpan.prototype.addLink = function (_link) {
        return this;
    };
    NonRecordingSpan.prototype.addLinks = function (_links) {
        return this;
    };
    // By default does nothing
    NonRecordingSpan.prototype.setStatus = function (_status) {
        return this;
    };
    // By default does nothing
    NonRecordingSpan.prototype.updateName = function (_name) {
        return this;
    };
    // By default does nothing
    NonRecordingSpan.prototype.end = function (_endTime) { };
    // isRecording always returns false for NonRecordingSpan.
    NonRecordingSpan.prototype.isRecording = function () {
        return false;
    };
    // By default does nothing
    NonRecordingSpan.prototype.recordException = function (_exception, _time) { };
    return NonRecordingSpan;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * span key
 */
var SPAN_KEY = createContextKey('OpenTelemetry Context Key SPAN');
/**
 * Return the span if one exists
 *
 * @param context context to get span from
 */
function getSpan(context) {
    return context.getValue(SPAN_KEY) || undefined;
}
/**
 * Gets the span from the current context, if one exists.
 */
function getActiveSpan() {
    return getSpan(ContextAPI.getInstance().active());
}
/**
 * Set the span on a context
 *
 * @param context context to use as parent
 * @param span span to set active
 */
function setSpan(context, span) {
    return context.setValue(SPAN_KEY, span);
}
/**
 * Remove current span stored in the context
 *
 * @param context context to delete span from
 */
function deleteSpan(context) {
    return context.deleteValue(SPAN_KEY);
}
/**
 * Wrap span context in a NoopSpan and set as span in a new
 * context
 *
 * @param context context to set active span on
 * @param spanContext span context to be wrapped
 */
function setSpanContext(context, spanContext) {
    return setSpan(context, new NonRecordingSpan(spanContext));
}
/**
 * Get the span context of the span if it exists.
 *
 * @param context context to get values from
 */
function getSpanContext(context) {
    var _a;
    return (_a = getSpan(context)) === null || _a === void 0 ? void 0 : _a.spanContext();
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
function isValidTraceId(traceId) {
    return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
}
function isValidSpanId(spanId) {
    return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
}
/**
 * Returns true if this {@link SpanContext} is valid.
 * @return true if this {@link SpanContext} is valid.
 */
function isSpanContextValid(spanContext) {
    return (isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId));
}
/**
 * Wrap the given {@link SpanContext} in a new non-recording {@link Span}
 *
 * @param spanContext span context to be wrapped
 * @returns a new non-recording {@link Span} with the provided context
 */
function wrapSpanContext(spanContext) {
    return new NonRecordingSpan(spanContext);
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var contextApi = ContextAPI.getInstance();
/**
 * No-op implementations of {@link Tracer}.
 */
var NoopTracer = /** @class */ (function () {
    function NoopTracer() {
    }
    // startSpan starts a noop span.
    NoopTracer.prototype.startSpan = function (name, options, context) {
        if (context === void 0) { context = contextApi.active(); }
        var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
        if (root) {
            return new NonRecordingSpan();
        }
        var parentFromContext = context && getSpanContext(context);
        if (isSpanContext(parentFromContext) &&
            isSpanContextValid(parentFromContext)) {
            return new NonRecordingSpan(parentFromContext);
        }
        else {
            return new NonRecordingSpan();
        }
    };
    NoopTracer.prototype.startActiveSpan = function (name, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
            return;
        }
        else if (arguments.length === 2) {
            fn = arg2;
        }
        else if (arguments.length === 3) {
            opts = arg2;
            fn = arg3;
        }
        else {
            opts = arg2;
            ctx = arg3;
            fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
        var span = this.startSpan(name, opts, parentContext);
        var contextWithSpanSet = setSpan(parentContext, span);
        return contextApi.with(contextWithSpanSet, fn, undefined, span);
    };
    return NoopTracer;
}());
function isSpanContext(spanContext) {
    return (typeof spanContext === 'object' &&
        typeof spanContext['spanId'] === 'string' &&
        typeof spanContext['traceId'] === 'string' &&
        typeof spanContext['traceFlags'] === 'number');
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var NOOP_TRACER = new NoopTracer();
/**
 * Proxy tracer provided by the proxy tracer provider
 */
var ProxyTracer = /** @class */ (function () {
    function ProxyTracer(_provider, name, version, options) {
        this._provider = _provider;
        this.name = name;
        this.version = version;
        this.options = options;
    }
    ProxyTracer.prototype.startSpan = function (name, options, context) {
        return this._getTracer().startSpan(name, options, context);
    };
    ProxyTracer.prototype.startActiveSpan = function (_name, _options, _context, _fn) {
        var tracer = this._getTracer();
        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    };
    /**
     * Try to get a tracer from the proxy tracer provider.
     * If the proxy tracer provider has no delegate, return a noop tracer.
     */
    ProxyTracer.prototype._getTracer = function () {
        if (this._delegate) {
            return this._delegate;
        }
        var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer) {
            return NOOP_TRACER;
        }
        this._delegate = tracer;
        return this._delegate;
    };
    return ProxyTracer;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An implementation of the {@link TracerProvider} which returns an impotent
 * Tracer for all calls to `getTracer`.
 *
 * All operations are no-op.
 */
var NoopTracerProvider = /** @class */ (function () {
    function NoopTracerProvider() {
    }
    NoopTracerProvider.prototype.getTracer = function (_name, _version, _options) {
        return new NoopTracer();
    };
    return NoopTracerProvider;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var NOOP_TRACER_PROVIDER = new NoopTracerProvider();
/**
 * Tracer provider which provides {@link ProxyTracer}s.
 *
 * Before a delegate is set, tracers provided are NoOp.
 *   When a delegate is set, traces are provided from the delegate.
 *   When a delegate is set after tracers have already been provided,
 *   all tracers already provided will use the provided delegate implementation.
 */
var ProxyTracerProvider = /** @class */ (function () {
    function ProxyTracerProvider() {
    }
    /**
     * Get a {@link ProxyTracer}
     */
    ProxyTracerProvider.prototype.getTracer = function (name, version, options) {
        var _a;
        return ((_a = this.getDelegateTracer(name, version, options)) !== null && _a !== void 0 ? _a : new ProxyTracer(this, name, version, options));
    };
    ProxyTracerProvider.prototype.getDelegate = function () {
        var _a;
        return (_a = this._delegate) !== null && _a !== void 0 ? _a : NOOP_TRACER_PROVIDER;
    };
    /**
     * Set the delegate tracer provider
     */
    ProxyTracerProvider.prototype.setDelegate = function (delegate) {
        this._delegate = delegate;
    };
    ProxyTracerProvider.prototype.getDelegateTracer = function (name, version, options) {
        var _a;
        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getTracer(name, version, options);
    };
    return ProxyTracerProvider;
}());

/**
 * An enumeration of status codes.
 */
var SpanStatusCode;
(function (SpanStatusCode) {
    /**
     * The default status.
     */
    SpanStatusCode[SpanStatusCode["UNSET"] = 0] = "UNSET";
    /**
     * The operation has been validated by an Application developer or
     * Operator to have completed successfully.
     */
    SpanStatusCode[SpanStatusCode["OK"] = 1] = "OK";
    /**
     * The operation contains an error.
     */
    SpanStatusCode[SpanStatusCode["ERROR"] = 2] = "ERROR";
})(SpanStatusCode || (SpanStatusCode = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var API_NAME$3 = 'trace';
/**
 * Singleton object which represents the entry point to the OpenTelemetry Tracing API
 */
var TraceAPI = /** @class */ (function () {
    /** Empty private constructor prevents end users from constructing a new instance of the API */
    function TraceAPI() {
        this._proxyTracerProvider = new ProxyTracerProvider();
        this.wrapSpanContext = wrapSpanContext;
        this.isSpanContextValid = isSpanContextValid;
        this.deleteSpan = deleteSpan;
        this.getSpan = getSpan;
        this.getActiveSpan = getActiveSpan;
        this.getSpanContext = getSpanContext;
        this.setSpan = setSpan;
        this.setSpanContext = setSpanContext;
    }
    /** Get the singleton instance of the Trace API */
    TraceAPI.getInstance = function () {
        if (!this._instance) {
            this._instance = new TraceAPI();
        }
        return this._instance;
    };
    /**
     * Set the current global tracer.
     *
     * @returns true if the tracer provider was successfully registered, else false
     */
    TraceAPI.prototype.setGlobalTracerProvider = function (provider) {
        var success = registerGlobal(API_NAME$3, this._proxyTracerProvider, DiagAPI.instance());
        if (success) {
            this._proxyTracerProvider.setDelegate(provider);
        }
        return success;
    };
    /**
     * Returns the global tracer provider.
     */
    TraceAPI.prototype.getTracerProvider = function () {
        return getGlobal(API_NAME$3) || this._proxyTracerProvider;
    };
    /**
     * Returns a tracer from the global tracer provider.
     */
    TraceAPI.prototype.getTracer = function (name, version) {
        return this.getTracerProvider().getTracer(name, version);
    };
    /** Remove the global tracer provider */
    TraceAPI.prototype.disable = function () {
        unregisterGlobal(API_NAME$3, DiagAPI.instance());
        this._proxyTracerProvider = new ProxyTracerProvider();
    };
    return TraceAPI;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Split module-level variable definition into separate files to allow
// tree-shaking on each api instance.
/** Entrypoint for trace API */
var trace = TraceAPI.getInstance();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __read = function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values$1 = function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var BaggageImpl = /** @class */ (function () {
    function BaggageImpl(entries) {
        this._entries = entries ? new Map(entries) : new Map();
    }
    BaggageImpl.prototype.getEntry = function (key) {
        var entry = this._entries.get(key);
        if (!entry) {
            return undefined;
        }
        return Object.assign({}, entry);
    };
    BaggageImpl.prototype.getAllEntries = function () {
        return Array.from(this._entries.entries()).map(function (_a) {
            var _b = __read(_a, 2), k = _b[0], v = _b[1];
            return [k, v];
        });
    };
    BaggageImpl.prototype.setEntry = function (key, entry) {
        var newBaggage = new BaggageImpl(this._entries);
        newBaggage._entries.set(key, entry);
        return newBaggage;
    };
    BaggageImpl.prototype.removeEntry = function (key) {
        var newBaggage = new BaggageImpl(this._entries);
        newBaggage._entries.delete(key);
        return newBaggage;
    };
    BaggageImpl.prototype.removeEntries = function () {
        var e_1, _a;
        var keys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            keys[_i] = arguments[_i];
        }
        var newBaggage = new BaggageImpl(this._entries);
        try {
            for (var keys_1 = __values$1(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
                var key = keys_1_1.value;
                newBaggage._entries.delete(key);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return newBaggage;
    };
    BaggageImpl.prototype.clear = function () {
        return new BaggageImpl();
    };
    return BaggageImpl;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
DiagAPI.instance();
/**
 * Create a new Baggage with optional entries
 *
 * @param entries An array of baggage entries the new baggage should contain
 */
function createBaggage(entries) {
    if (entries === void 0) { entries = {}; }
    return new BaggageImpl(new Map(Object.entries(entries)));
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var defaultTextMapGetter = {
    get: function (carrier, key) {
        if (carrier == null) {
            return undefined;
        }
        return carrier[key];
    },
    keys: function (carrier) {
        if (carrier == null) {
            return [];
        }
        return Object.keys(carrier);
    },
};
var defaultTextMapSetter = {
    set: function (carrier, key, value) {
        if (carrier == null) {
            return;
        }
        carrier[key] = value;
    },
};

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var SpanKind;
(function (SpanKind) {
    /** Default value. Indicates that the span is used internally. */
    SpanKind[SpanKind["INTERNAL"] = 0] = "INTERNAL";
    /**
     * Indicates that the span covers server-side handling of an RPC or other
     * remote request.
     */
    SpanKind[SpanKind["SERVER"] = 1] = "SERVER";
    /**
     * Indicates that the span covers the client-side wrapper around an RPC or
     * other remote request.
     */
    SpanKind[SpanKind["CLIENT"] = 2] = "CLIENT";
    /**
     * Indicates that the span describes producer sending a message to a
     * broker. Unlike client and server, there is no direct critical path latency
     * relationship between producer and consumer spans.
     */
    SpanKind[SpanKind["PRODUCER"] = 3] = "PRODUCER";
    /**
     * Indicates that the span describes consumer receiving a message from a
     * broker. Unlike client and server, there is no direct critical path latency
     * relationship between producer and consumer spans.
     */
    SpanKind[SpanKind["CONSUMER"] = 4] = "CONSUMER";
})(SpanKind || (SpanKind = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Split module-level variable definition into separate files to allow
// tree-shaking on each api instance.
/** Entrypoint for context API */
var context = ContextAPI.getInstance();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * No-op implementations of {@link TextMapPropagator}.
 */
var NoopTextMapPropagator = /** @class */ (function () {
    function NoopTextMapPropagator() {
    }
    /** Noop inject function does nothing */
    NoopTextMapPropagator.prototype.inject = function (_context, _carrier) { };
    /** Noop extract function does nothing and returns the input context */
    NoopTextMapPropagator.prototype.extract = function (context, _carrier) {
        return context;
    };
    NoopTextMapPropagator.prototype.fields = function () {
        return [];
    };
    return NoopTextMapPropagator;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Baggage key
 */
var BAGGAGE_KEY = createContextKey('OpenTelemetry Baggage Key');
/**
 * Retrieve the current baggage from the given context
 *
 * @param {Context} Context that manage all context values
 * @returns {Baggage} Extracted baggage from the context
 */
function getBaggage(context) {
    return context.getValue(BAGGAGE_KEY) || undefined;
}
/**
 * Retrieve the current baggage from the active/current context
 *
 * @returns {Baggage} Extracted baggage from the context
 */
function getActiveBaggage() {
    return getBaggage(ContextAPI.getInstance().active());
}
/**
 * Store a baggage in the given context
 *
 * @param {Context} Context that manage all context values
 * @param {Baggage} baggage that will be set in the actual context
 */
function setBaggage(context, baggage) {
    return context.setValue(BAGGAGE_KEY, baggage);
}
/**
 * Delete the baggage stored in the given context
 *
 * @param {Context} Context that manage all context values
 */
function deleteBaggage(context) {
    return context.deleteValue(BAGGAGE_KEY);
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var API_NAME = 'propagation';
var NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();
/**
 * Singleton object which represents the entry point to the OpenTelemetry Propagation API
 */
var PropagationAPI = /** @class */ (function () {
    /** Empty private constructor prevents end users from constructing a new instance of the API */
    function PropagationAPI() {
        this.createBaggage = createBaggage;
        this.getBaggage = getBaggage;
        this.getActiveBaggage = getActiveBaggage;
        this.setBaggage = setBaggage;
        this.deleteBaggage = deleteBaggage;
    }
    /** Get the singleton instance of the Propagator API */
    PropagationAPI.getInstance = function () {
        if (!this._instance) {
            this._instance = new PropagationAPI();
        }
        return this._instance;
    };
    /**
     * Set the current propagator.
     *
     * @returns true if the propagator was successfully registered, else false
     */
    PropagationAPI.prototype.setGlobalPropagator = function (propagator) {
        return registerGlobal(API_NAME, propagator, DiagAPI.instance());
    };
    /**
     * Inject context into a carrier to be propagated inter-process
     *
     * @param context Context carrying tracing data to inject
     * @param carrier carrier to inject context into
     * @param setter Function used to set values on the carrier
     */
    PropagationAPI.prototype.inject = function (context, carrier, setter) {
        if (setter === void 0) { setter = defaultTextMapSetter; }
        return this._getGlobalPropagator().inject(context, carrier, setter);
    };
    /**
     * Extract context from a carrier
     *
     * @param context Context which the newly created context will inherit from
     * @param carrier Carrier to extract context from
     * @param getter Function used to extract keys from a carrier
     */
    PropagationAPI.prototype.extract = function (context, carrier, getter) {
        if (getter === void 0) { getter = defaultTextMapGetter; }
        return this._getGlobalPropagator().extract(context, carrier, getter);
    };
    /**
     * Return a list of all fields which may be used by the propagator.
     */
    PropagationAPI.prototype.fields = function () {
        return this._getGlobalPropagator().fields();
    };
    /** Remove the global propagator */
    PropagationAPI.prototype.disable = function () {
        unregisterGlobal(API_NAME, DiagAPI.instance());
    };
    PropagationAPI.prototype._getGlobalPropagator = function () {
        return getGlobal(API_NAME) || NOOP_TEXT_MAP_PROPAGATOR;
    };
    return PropagationAPI;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Split module-level variable definition into separate files to allow
// tree-shaking on each api instance.
/** Entrypoint for propagation API */
var propagation = PropagationAPI.getInstance();

function hasActiveTelemetry(tracerName = "default-tracer") {
  try {
    return !!trace.getTracer(tracerName);
  } catch {
    return false;
  }
}
function getBaggageValues(ctx) {
  const currentBaggage = propagation.getBaggage(ctx);
  const requestId = currentBaggage?.getEntry("http.request_id")?.value;
  const componentName = currentBaggage?.getEntry("componentName")?.value;
  const runId = currentBaggage?.getEntry("runId")?.value;
  return {
    requestId,
    componentName,
    runId
  };
}

// src/telemetry/telemetry.decorators.ts
function withSpan(options) {
  return function(_target, propertyKey, descriptor) {
    if (!descriptor || typeof descriptor === "number") return;
    const originalMethod = descriptor.value;
    const methodName = String(propertyKey);
    descriptor.value = function(...args) {
      if (options?.skipIfNoTelemetry && !hasActiveTelemetry(options?.tracerName)) {
        return originalMethod.apply(this, args);
      }
      const tracer = trace.getTracer(options?.tracerName ?? "default-tracer");
      let spanName;
      let spanKind;
      if (typeof options === "string") {
        spanName = options;
      } else if (options) {
        spanName = options.spanName || methodName;
        spanKind = options.spanKind;
      } else {
        spanName = methodName;
      }
      const span = tracer.startSpan(spanName, { kind: spanKind });
      let ctx = trace.setSpan(context.active(), span);
      args.forEach((arg, index) => {
        try {
          span.setAttribute(`${spanName}.argument.${index}`, JSON.stringify(arg));
        } catch {
          span.setAttribute(`${spanName}.argument.${index}`, "[Not Serializable]");
        }
      });
      const { requestId, componentName, runId } = getBaggageValues(ctx);
      if (requestId) {
        span.setAttribute("http.request_id", requestId);
      }
      if (componentName) {
        span.setAttribute("componentName", componentName);
        span.setAttribute("runId", runId);
      } else if (this && this.name) {
        span.setAttribute("componentName", this.name);
        span.setAttribute("runId", this.runId);
        ctx = propagation.setBaggage(
          ctx,
          propagation.createBaggage({
            // @ts-ignore
            componentName: { value: this.name },
            // @ts-ignore
            runId: { value: this.runId },
            // @ts-ignore
            "http.request_id": { value: requestId }
          })
        );
      }
      let result;
      try {
        result = context.with(ctx, () => originalMethod.apply(this, args));
        if (result instanceof Promise) {
          return result.then((resolvedValue) => {
            try {
              span.setAttribute(`${spanName}.result`, JSON.stringify(resolvedValue));
            } catch {
              span.setAttribute(`${spanName}.result`, "[Not Serializable]");
            }
            return resolvedValue;
          }).finally(() => span.end());
        }
        try {
          span.setAttribute(`${spanName}.result`, JSON.stringify(result));
        } catch {
          span.setAttribute(`${spanName}.result`, "[Not Serializable]");
        }
        return result;
      } catch (error) {
        span.setStatus({
          code: SpanStatusCode.ERROR,
          message: error instanceof Error ? error.message : "Unknown error"
        });
        if (error instanceof Error) {
          span.recordException(error);
        }
        throw error;
      } finally {
        if (!(result instanceof Promise)) {
          span.end();
        }
      }
    };
    return descriptor;
  };
}
function InstrumentClass(options) {
  return function(target) {
    const methods = Object.getOwnPropertyNames(target.prototype);
    methods.forEach((method) => {
      if (options?.excludeMethods?.includes(method) || method === "constructor") return;
      if (options?.methodFilter && !options.methodFilter(method)) return;
      const descriptor = Object.getOwnPropertyDescriptor(target.prototype, method);
      if (descriptor && typeof descriptor.value === "function") {
        Object.defineProperty(
          target.prototype,
          method,
          withSpan({
            spanName: options?.prefix ? `${options.prefix}.${method}` : method,
            skipIfNoTelemetry: true,
            spanKind: options?.spanKind || SpanKind.INTERNAL,
            tracerName: options?.tracerName
          })(target, method, descriptor)
        );
      }
    });
    return target;
  };
}
var Telemetry = class _Telemetry {
  tracer = trace.getTracer("default");
  name = "default-service";
  constructor(config) {
    this.name = config.serviceName ?? "default-service";
    this.tracer = trace.getTracer(this.name);
  }
  /**
   * @deprecated This method does not do anything
   */
  async shutdown() {
  }
  /**
   * Initialize telemetry with the given configuration
   * @param config - Optional telemetry configuration object
   * @returns Telemetry instance that can be used for tracing
   */
  static init(config = {}) {
    try {
      if (!global.__TELEMETRY__) {
        global.__TELEMETRY__ = new _Telemetry(config);
      }
      return global.__TELEMETRY__;
    } catch (error) {
      console.error("Failed to initialize telemetry:", error);
      throw error;
    }
  }
  static getActiveSpan() {
    const span = trace.getActiveSpan();
    return span;
  }
  /**
   * Get the global telemetry instance
   * @throws {Error} If telemetry has not been initialized
   * @returns {Telemetry} The global telemetry instance
   */
  static get() {
    if (!global.__TELEMETRY__) {
      throw new Error("Telemetry not initialized");
    }
    return global.__TELEMETRY__;
  }
  /**
   * Wraps a class instance with telemetry tracing
   * @param instance The class instance to wrap
   * @param options Optional configuration for tracing
   * @returns Wrapped instance with all methods traced
   */
  traceClass(instance, options = {}) {
    const { skipIfNoTelemetry = true } = options;
    if (skipIfNoTelemetry && !hasActiveTelemetry()) {
      return instance;
    }
    const { spanNamePrefix = instance.constructor.name.toLowerCase(), attributes = {}, excludeMethods = [] } = options;
    return new Proxy(instance, {
      get: (target, prop) => {
        const value = target[prop];
        if (typeof value === "function" && prop !== "constructor" && !prop.toString().startsWith("_") && !excludeMethods.includes(prop.toString())) {
          return this.traceMethod(value.bind(target), {
            spanName: `${spanNamePrefix}.${prop.toString()}`,
            attributes: {
              ...attributes,
              [`${spanNamePrefix}.name`]: target.constructor.name,
              [`${spanNamePrefix}.method.name`]: prop.toString()
            }
          });
        }
        return value;
      }
    });
  }
  static setBaggage(baggage, ctx = context.active()) {
    const currentBaggage = Object.fromEntries(propagation.getBaggage(ctx)?.getAllEntries() ?? []);
    const newCtx = propagation.setBaggage(
      ctx,
      propagation.createBaggage({
        ...currentBaggage,
        ...baggage
      })
    );
    return newCtx;
  }
  static withContext(ctx, fn) {
    return context.with(ctx, fn);
  }
  /**
   * method to trace individual methods with proper context
   * @param method The method to trace
   * @param context Additional context for the trace
   * @returns Wrapped method with tracing
   */
  traceMethod(method, context3) {
    let ctx = context.active();
    const { skipIfNoTelemetry = true } = context3;
    if (skipIfNoTelemetry && !hasActiveTelemetry()) {
      return method;
    }
    return (...args) => {
      const span = this.tracer.startSpan(context3.spanName);
      function handleError(error) {
        span.recordException(error);
        span.setStatus({
          code: SpanStatusCode.ERROR,
          message: error.message
        });
        span.end();
        throw error;
      }
      try {
        let recordResult2 = function(res) {
          try {
            span.setAttribute(`${context3.spanName}.result`, JSON.stringify(res));
          } catch {
            span.setAttribute(`${context3.spanName}.result`, "[Not Serializable]");
          }
          span.end();
          return res;
        };
        const { requestId, componentName, runId } = getBaggageValues(ctx);
        if (context3.attributes) {
          span.setAttributes(context3.attributes);
        }
        if (requestId) {
          span.setAttribute("http.request_id", requestId);
        }
        if (context3.attributes?.componentName) {
          ctx = propagation.setBaggage(
            ctx,
            propagation.createBaggage({
              componentName: { value: context3.attributes.componentName },
              // @ts-ignore
              runId: { value: context3.attributes.runId },
              // @ts-ignore
              "http.request_id": { value: requestId }
            })
          );
        } else {
          if (componentName) {
            span.setAttribute("componentName", componentName);
            span.setAttribute("runId", runId);
          } else if (this && this.name) {
            span.setAttribute("componentName", this.name);
            span.setAttribute("runId", this.runId);
            ctx = propagation.setBaggage(
              ctx,
              propagation.createBaggage({
                componentName: { value: this.name },
                // @ts-ignore
                runId: { value: this.runId },
                // @ts-ignore
                "http.request_id": { value: requestId }
              })
            );
          }
        }
        args.forEach((arg, index) => {
          try {
            span.setAttribute(`${context3.spanName}.argument.${index}`, JSON.stringify(arg));
          } catch {
            span.setAttribute(`${context3.spanName}.argument.${index}`, "[Not Serializable]");
          }
        });
        let result;
        context.with(trace.setSpan(ctx, span), () => {
          result = method(...args);
        });
        if (result instanceof Promise) {
          return result.then(recordResult2).catch(handleError);
        } else {
          return recordResult2(result);
        }
      } catch (error) {
        handleError(error);
      }
    };
  }
  getBaggageTracer() {
    return new BaggageTracer(this.tracer);
  }
};
var BaggageTracer = class {
  _tracer;
  constructor(tracer) {
    this._tracer = tracer;
  }
  startSpan(name, options = {}, ctx) {
    ctx = ctx ?? context.active();
    const span = this._tracer.startSpan(name, options, ctx);
    const { componentName, runId, requestId } = getBaggageValues(ctx);
    span.setAttribute("componentName", componentName);
    span.setAttribute("runId", runId);
    span.setAttribute("http.request_id", requestId);
    return span;
  }
  startActiveSpan(name, optionsOrFn, ctxOrFn, fn) {
    if (typeof optionsOrFn === "function") {
      const wrappedFn2 = (span) => {
        const { componentName, runId, requestId } = getBaggageValues(context.active());
        span.setAttribute("componentName", componentName);
        span.setAttribute("runId", runId);
        span.setAttribute("http.request_id", requestId);
        return optionsOrFn(span);
      };
      return this._tracer.startActiveSpan(name, {}, context.active(), wrappedFn2);
    }
    if (typeof ctxOrFn === "function") {
      const wrappedFn2 = (span) => {
        const { componentName, runId, requestId } = getBaggageValues(context.active());
        span.setAttribute("componentName", componentName);
        span.setAttribute("runId", runId);
        span.setAttribute("http.request_id", requestId);
        return ctxOrFn(span);
      };
      return this._tracer.startActiveSpan(name, optionsOrFn, context.active(), wrappedFn2);
    }
    const wrappedFn = (span) => {
      const { componentName, runId, requestId } = getBaggageValues(ctxOrFn ?? context.active());
      span.setAttribute("componentName", componentName);
      span.setAttribute("runId", runId);
      span.setAttribute("http.request_id", requestId);
      return fn(span);
    };
    return this._tracer.startActiveSpan(name, optionsOrFn, ctxOrFn, wrappedFn);
  }
};

var __create = Object.create;
var __defProp$3 = Object.defineProperty;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = msg => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp$3(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __name = (target, value) => __defProp$3(target, "name", {
  value,
  configurable: true
});
var __decoratorStart = base => [,,, __create(base?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = fn => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({
  kind: __decoratorStrings[kind],
  name,
  metadata,
  addInitializer: fn => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null))
});
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) fns[i].call(self) ;
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var it,
    done,
    ctx,
    k = flags & 7;
  var j = 0;
  var extraInitializers = array[j] || (array[j] = []);
  __name(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    it = (0, decorators[i])(target, ctx), done._ = 1;
    __expectFn(it) && (target = it);
  }
  return __decoratorMetadata(array, target), target;
};

// src/storage/base.ts
var MastraStorage = class extends MastraBase {
  /** @deprecated import from { TABLE_WORKFLOW_SNAPSHOT } '@mastra/core/storage' instead */
  static TABLE_WORKFLOW_SNAPSHOT = TABLE_WORKFLOW_SNAPSHOT;
  /** @deprecated import from { TABLE_EVALS } '@mastra/core/storage' instead */
  static TABLE_EVALS = TABLE_EVALS;
  /** @deprecated import from { TABLE_MESSAGES } '@mastra/core/storage' instead */
  static TABLE_MESSAGES = TABLE_MESSAGES;
  /** @deprecated import from { TABLE_THREADS } '@mastra/core/storage' instead */
  static TABLE_THREADS = TABLE_THREADS;
  /** @deprecated import { TABLE_TRACES } from '@mastra/core/storage' instead */
  static TABLE_TRACES = TABLE_TRACES;
  hasInitialized = null;
  shouldCacheInit = true;
  constructor({ name }) {
    super({
      component: "STORAGE",
      name
    });
  }
  batchTraceInsert({ records }) {
    return this.batchInsert({ tableName: TABLE_TRACES, records });
  }
  async init() {
    if (this.shouldCacheInit && await this.hasInitialized) {
      return;
    }
    this.hasInitialized = Promise.all([
      this.createTable({
        tableName: TABLE_WORKFLOW_SNAPSHOT,
        schema: TABLE_SCHEMAS[TABLE_WORKFLOW_SNAPSHOT]
      }),
      this.createTable({
        tableName: TABLE_EVALS,
        schema: TABLE_SCHEMAS[TABLE_EVALS]
      }),
      this.createTable({
        tableName: TABLE_THREADS,
        schema: TABLE_SCHEMAS[TABLE_THREADS]
      }),
      this.createTable({
        tableName: TABLE_MESSAGES,
        schema: TABLE_SCHEMAS[TABLE_MESSAGES]
      }),
      this.createTable({
        tableName: TABLE_TRACES,
        schema: TABLE_SCHEMAS[TABLE_TRACES]
      })
    ]).then(() => true);
    await this.hasInitialized;
  }
  async persistWorkflowSnapshot({
    workflowName,
    runId,
    snapshot
  }) {
    await this.init();
    const data = {
      workflow_name: workflowName,
      run_id: runId,
      snapshot,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    };
    this.logger.debug("Persisting workflow snapshot", { workflowName, runId, data });
    await this.insert({
      tableName: TABLE_WORKFLOW_SNAPSHOT,
      record: data
    });
  }
  async loadWorkflowSnapshot({
    workflowName,
    runId
  }) {
    if (!this.hasInitialized) {
      await this.init();
    }
    this.logger.debug("Loading workflow snapshot", { workflowName, runId });
    const d = await this.load({
      tableName: TABLE_WORKFLOW_SNAPSHOT,
      keys: { workflow_name: workflowName, run_id: runId }
    });
    return d ? d.snapshot : null;
  }
};

// src/storage/default-proxy-storage.ts
var DefaultProxyStorage = class extends MastraStorage {
  storage = null;
  storageConfig;
  isInitializingPromise = null;
  constructor({ config }) {
    super({ name: "DefaultStorage" });
    this.storageConfig = config;
  }
  setupStorage() {
    if (!this.isInitializingPromise) {
      this.isInitializingPromise = new Promise((resolve, reject) => {
        import('./index2.mjs').then(({ DefaultStorage }) => {
          this.storage = new DefaultStorage({ config: this.storageConfig });
          resolve();
        }).catch(reject);
      });
    }
    return this.isInitializingPromise;
  }
  async createTable({
    tableName,
    schema
  }) {
    await this.setupStorage();
    return this.storage.createTable({ tableName, schema });
  }
  async clearTable({ tableName }) {
    await this.setupStorage();
    return this.storage.clearTable({ tableName });
  }
  async insert({ tableName, record }) {
    await this.setupStorage();
    return this.storage.insert({ tableName, record });
  }
  async batchInsert({ tableName, records }) {
    await this.setupStorage();
    return this.storage.batchInsert({ tableName, records });
  }
  async load({ tableName, keys }) {
    await this.setupStorage();
    return this.storage.load({ tableName, keys });
  }
  async getThreadById({ threadId }) {
    await this.setupStorage();
    return this.storage.getThreadById({ threadId });
  }
  async getThreadsByResourceId({ resourceId }) {
    await this.setupStorage();
    return this.storage.getThreadsByResourceId({ resourceId });
  }
  async saveThread({ thread }) {
    await this.setupStorage();
    return this.storage.saveThread({ thread });
  }
  async updateThread({
    id,
    title,
    metadata
  }) {
    await this.setupStorage();
    return this.storage.updateThread({ id, title, metadata });
  }
  async deleteThread({ threadId }) {
    await this.setupStorage();
    return this.storage.deleteThread({ threadId });
  }
  async getMessages({ threadId, selectBy }) {
    await this.setupStorage();
    return this.storage.getMessages({ threadId, selectBy });
  }
  async saveMessages({ messages }) {
    await this.setupStorage();
    return this.storage.saveMessages({ messages });
  }
  async getEvalsByAgentName(agentName, type) {
    await this.setupStorage();
    return this.storage.getEvalsByAgentName(agentName, type);
  }
  async getTraces(options) {
    await this.setupStorage();
    return this.storage.getTraces(options);
  }
  async getWorkflowRuns(args) {
    await this.setupStorage();
    return this.storage.getWorkflowRuns(args);
  }
  async getWorkflowRunById(args) {
    await this.setupStorage();
    return this.storage.getWorkflowRunById(args);
  }
};

// src/storage/storageWithInit.ts
var isAugmentedSymbol = Symbol("isAugmented");
function augmentWithInit(storage) {
  let hasInitialized = null;
  const ensureInit = async () => {
    if (!hasInitialized) {
      hasInitialized = storage.init();
    }
    await hasInitialized;
  };
  if (storage[isAugmentedSymbol]) {
    return storage;
  }
  const proxy = new Proxy(storage, {
    get(target, prop) {
      const value = target[prop];
      if (typeof value === "function" && prop !== "init") {
        return async (...args) => {
          await ensureInit();
          return Reflect.apply(value, target, args);
        };
      }
      return Reflect.get(target, prop);
    }
  });
  Object.defineProperty(proxy, isAugmentedSymbol, {
    value: true,
    enumerable: false,
    // Won't show up in Object.keys() or for...in loops
    configurable: true
    // Allows the property to be deleted or modified later if needed
  });
  return proxy;
}

// src/mastra/index.ts
var _Mastra_decorators, _init$2;
_Mastra_decorators = [InstrumentClass({
  prefix: "mastra",
  excludeMethods: ["getLogger", "getTelemetry"]
})];
var Mastra = class {
  #vectors;
  #agents;
  #logger;
  #workflows;
  #vnext_workflows;
  #tts;
  #deployer;
  #serverMiddleware = [];
  #telemetry;
  #storage;
  #memory;
  #networks;
  #server;
  #mcpServers;
  /**
   * @deprecated use getTelemetry() instead
   */
  get telemetry() {
    return this.#telemetry;
  }
  /**
   * @deprecated use getStorage() instead
   */
  get storage() {
    return this.#storage;
  }
  /**
   * @deprecated use getMemory() instead
   */
  get memory() {
    return this.#memory;
  }
  constructor(config) {
    if (config?.serverMiddleware) {
      this.#serverMiddleware = config.serverMiddleware.map(m => ({
        handler: m.handler,
        path: m.path || "/api/*"
      }));
    }
    let logger;
    if (config?.logger === false) {
      logger = noopLogger;
    } else {
      if (config?.logger) {
        logger = config.logger;
      } else {
        const levleOnEnv = process.env.NODE_ENV === "production" && process.env.MASTRA_DEV !== "true" ? LogLevel.WARN : LogLevel.INFO;
        logger = createLogger({
          name: "Mastra",
          level: levleOnEnv
        });
      }
    }
    this.#logger = logger;
    let storage = config?.storage;
    if (!storage) {
      storage = new DefaultProxyStorage({
        config: {
          url: process.env.MASTRA_DEFAULT_STORAGE_URL || `:memory:`
        }
      });
    }
    storage = augmentWithInit(storage);
    this.#telemetry = Telemetry.init(config?.telemetry);
    if (this.#telemetry) {
      this.#storage = this.#telemetry.traceClass(storage, {
        excludeMethods: ["__setTelemetry", "__getTelemetry", "batchTraceInsert"]
      });
      this.#storage.__setTelemetry(this.#telemetry);
    } else {
      this.#storage = storage;
    }
    if (config?.vectors) {
      let vectors = {};
      Object.entries(config.vectors).forEach(([key, vector]) => {
        if (this.#telemetry) {
          vectors[key] = this.#telemetry.traceClass(vector, {
            excludeMethods: ["__setTelemetry", "__getTelemetry"]
          });
          vectors[key].__setTelemetry(this.#telemetry);
        } else {
          vectors[key] = vector;
        }
      });
      this.#vectors = vectors;
    }
    if (config?.vectors) {
      this.#vectors = config.vectors;
    }
    if (config?.networks) {
      this.#networks = config.networks;
    }
    if (config?.mcpServers) {
      this.#mcpServers = config.mcpServers;
      Object.values(this.#mcpServers).forEach(server => {
        if (this.#telemetry) {
          server.__setTelemetry(this.#telemetry);
        }
        server.__registerMastra(this);
      });
    }
    if (config?.memory) {
      this.#memory = config.memory;
      if (this.#telemetry) {
        this.#memory = this.#telemetry.traceClass(config.memory, {
          excludeMethods: ["__setTelemetry", "__getTelemetry"]
        });
        this.#memory.__setTelemetry(this.#telemetry);
      }
    }
    if (config && `memory` in config) {
      this.#logger.warn(`
  Memory should be added to Agents, not to Mastra.

Instead of:
  new Mastra({ memory: new Memory() })

do:
  new Agent({ memory: new Memory() })

This is a warning for now, but will throw an error in the future
`);
    }
    if (config?.tts) {
      this.#tts = config.tts;
      Object.entries(this.#tts).forEach(([key, ttsCl]) => {
        if (this.#tts?.[key]) {
          if (this.#telemetry) {
            this.#tts[key] = this.#telemetry.traceClass(ttsCl, {
              excludeMethods: ["__setTelemetry", "__getTelemetry"]
            });
            this.#tts[key].__setTelemetry(this.#telemetry);
          }
        }
      });
    }
    const agents = {};
    if (config?.agents) {
      Object.entries(config.agents).forEach(([key, agent]) => {
        if (agents[key]) {
          throw new Error(`Agent with name ID:${key} already exists`);
        }
        agent.__registerMastra(this);
        agent.__registerPrimitives({
          logger: this.getLogger(),
          telemetry: this.#telemetry,
          storage: this.storage,
          memory: this.memory,
          agents,
          tts: this.#tts,
          vectors: this.#vectors
        });
        agents[key] = agent;
      });
    }
    this.#agents = agents;
    this.#networks = {};
    if (config?.networks) {
      Object.entries(config.networks).forEach(([key, network]) => {
        network.__registerMastra(this);
        this.#networks[key] = network;
      });
    }
    this.#workflows = {};
    if (config?.workflows) {
      Object.entries(config.workflows).forEach(([key, workflow]) => {
        workflow.__registerMastra(this);
        workflow.__registerPrimitives({
          logger: this.getLogger(),
          telemetry: this.#telemetry,
          storage: this.storage,
          memory: this.memory,
          agents,
          tts: this.#tts,
          vectors: this.#vectors
        });
        this.#workflows[key] = workflow;
        const workflowSteps = Object.values(workflow.steps).filter(step => !!step.workflowId && !!step.workflow);
        if (workflowSteps.length > 0) {
          workflowSteps.forEach(step => {
            this.#workflows[step.workflowId] = step.workflow;
          });
        }
      });
    }
    this.#vnext_workflows = {};
    if (config?.vnext_workflows) {
      Object.entries(config.vnext_workflows).forEach(([key, workflow]) => {
        workflow.__registerMastra(this);
        workflow.__registerPrimitives({
          logger: this.getLogger(),
          telemetry: this.#telemetry,
          storage: this.storage,
          memory: this.memory,
          agents,
          tts: this.#tts,
          vectors: this.#vectors
        });
        this.#vnext_workflows[key] = workflow;
      });
    }
    if (config?.server) {
      this.#server = config.server;
    }
    this.setLogger({
      logger
    });
  }
  getAgent(name) {
    const agent = this.#agents?.[name];
    if (!agent) {
      throw new Error(`Agent with name ${String(name)} not found`);
    }
    return this.#agents[name];
  }
  getAgents() {
    return this.#agents;
  }
  getVector(name) {
    const vector = this.#vectors?.[name];
    if (!vector) {
      throw new Error(`Vector with name ${String(name)} not found`);
    }
    return vector;
  }
  getVectors() {
    return this.#vectors;
  }
  getDeployer() {
    return this.#deployer;
  }
  getWorkflow(id, {
    serialized
  } = {}) {
    const workflow = this.#workflows?.[id];
    if (!workflow) {
      throw new Error(`Workflow with ID ${String(id)} not found`);
    }
    if (serialized) {
      return {
        name: workflow.name
      };
    }
    return workflow;
  }
  vnext_getWorkflow(id, {
    serialized
  } = {}) {
    const workflow = this.#vnext_workflows?.[id];
    if (!workflow) {
      throw new Error(`Workflow with ID ${String(id)} not found`);
    }
    if (serialized) {
      return {
        name: workflow.name
      };
    }
    return workflow;
  }
  getWorkflows(props = {}) {
    if (props.serialized) {
      return Object.entries(this.#workflows).reduce((acc, [k, v]) => {
        return {
          ...acc,
          [k]: {
            name: v.name
          }
        };
      }, {});
    }
    return this.#workflows;
  }
  vnext_getWorkflows(props = {}) {
    if (props.serialized) {
      return Object.entries(this.#vnext_workflows).reduce((acc, [k, v]) => {
        return {
          ...acc,
          [k]: {
            name: v.name
          }
        };
      }, {});
    }
    return this.#vnext_workflows;
  }
  setStorage(storage) {
    if (storage instanceof DefaultProxyStorage) {
      this.#logger.warn(`Importing "DefaultStorage" from '@mastra/core/storage/libsql' is deprecated.

Instead of:
  import { DefaultStorage } from '@mastra/core/storage/libsql';

Do:
  import { LibSQLStore } from '@mastra/libsql';
`);
    }
    this.#storage = augmentWithInit(storage);
  }
  setLogger({
    logger
  }) {
    this.#logger = logger;
    if (this.#agents) {
      Object.keys(this.#agents).forEach(key => {
        this.#agents?.[key]?.__setLogger(this.#logger);
      });
    }
    if (this.#memory) {
      this.#memory.__setLogger(this.#logger);
    }
    if (this.#deployer) {
      this.#deployer.__setLogger(this.#logger);
    }
    if (this.#tts) {
      Object.keys(this.#tts).forEach(key => {
        this.#tts?.[key]?.__setLogger(this.#logger);
      });
    }
    if (this.#storage) {
      this.#storage.__setLogger(this.#logger);
    }
    if (this.#vectors) {
      Object.keys(this.#vectors).forEach(key => {
        this.#vectors?.[key]?.__setLogger(this.#logger);
      });
    }
    if (this.#mcpServers) {
      Object.keys(this.#mcpServers).forEach(key => {
        this.#mcpServers?.[key]?.__setLogger(this.#logger);
      });
    }
  }
  setTelemetry(telemetry) {
    this.#telemetry = Telemetry.init(telemetry);
    if (this.#agents) {
      Object.keys(this.#agents).forEach(key => {
        if (this.#telemetry) {
          this.#agents?.[key]?.__setTelemetry(this.#telemetry);
        }
      });
    }
    if (this.#memory) {
      this.#memory = this.#telemetry.traceClass(this.#memory, {
        excludeMethods: ["__setTelemetry", "__getTelemetry"]
      });
      this.#memory.__setTelemetry(this.#telemetry);
    }
    if (this.#deployer) {
      this.#deployer = this.#telemetry.traceClass(this.#deployer, {
        excludeMethods: ["__setTelemetry", "__getTelemetry"]
      });
      this.#deployer.__setTelemetry(this.#telemetry);
    }
    if (this.#tts) {
      let tts = {};
      Object.entries(this.#tts).forEach(([key, ttsCl]) => {
        if (this.#telemetry) {
          tts[key] = this.#telemetry.traceClass(ttsCl, {
            excludeMethods: ["__setTelemetry", "__getTelemetry"]
          });
          tts[key].__setTelemetry(this.#telemetry);
        }
      });
      this.#tts = tts;
    }
    if (this.#storage) {
      this.#storage = this.#telemetry.traceClass(this.#storage, {
        excludeMethods: ["__setTelemetry", "__getTelemetry"]
      });
      this.#storage.__setTelemetry(this.#telemetry);
    }
    if (this.#vectors) {
      let vectors = {};
      Object.entries(this.#vectors).forEach(([key, vector]) => {
        if (this.#telemetry) {
          vectors[key] = this.#telemetry.traceClass(vector, {
            excludeMethods: ["__setTelemetry", "__getTelemetry"]
          });
          vectors[key].__setTelemetry(this.#telemetry);
        }
      });
      this.#vectors = vectors;
    }
  }
  getTTS() {
    return this.#tts;
  }
  getLogger() {
    return this.#logger;
  }
  getTelemetry() {
    return this.#telemetry;
  }
  getMemory() {
    return this.#memory;
  }
  getStorage() {
    return this.#storage;
  }
  getServerMiddleware() {
    return this.#serverMiddleware;
  }
  getNetworks() {
    return Object.values(this.#networks || {});
  }
  getServer() {
    return this.#server;
  }
  /**
   * Get a specific network by ID
   * @param networkId - The ID of the network to retrieve
   * @returns The network with the specified ID, or undefined if not found
   */
  getNetwork(networkId) {
    const networks = this.getNetworks();
    return networks.find(network => {
      const routingAgent = network.getRoutingAgent();
      return network.formatAgentId(routingAgent.name) === networkId;
    });
  }
  async getLogsByRunId({
    runId,
    transportId
  }) {
    if (!transportId) {
      throw new Error("Transport ID is required");
    }
    if (!this.#logger?.getLogsByRunId) {
      throw new Error("Logger is not set");
    }
    return await this.#logger.getLogsByRunId({
      runId,
      transportId
    });
  }
  async getLogs(transportId) {
    if (!transportId) {
      throw new Error("Transport ID is required");
    }
    if (!this.#logger?.getLogs) {
      throw new Error("Logger is not set");
    }
    console.log(this.#logger);
    return await this.#logger.getLogs(transportId);
  }
  /**
   * Get a specific MCP server by ID
   * @param serverId - The ID of the MCP server to retrieve
   * @returns The MCP server with the specified ID, or undefined if not found
   */
  getMCPServer(serverId) {
    return this.#mcpServers?.[serverId];
  }
  /**
   * Get all registered MCP servers as a Record, with keys being their IDs.
   * @returns Record of MCP server IDs to MCPServerBase instances, or undefined if none.
   */
  getMCPServers() {
    return this.#mcpServers;
  }
};
Mastra = /*@__PURE__*/(_ => {
  _init$2 = __decoratorStart(null);
  Mastra = __decorateElement(_init$2, 0, "Mastra", _Mastra_decorators, Mastra);
  __runInitializers(_init$2, 1, Mastra);
  return Mastra;
})();

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, '__esModule')) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var inngest$1 = {};

var dist$1 = {};

var adapters = {};

var anthropic$2 = {};

Object.defineProperty(anthropic$2, "__esModule", { value: true });

var gemini$2 = {};

Object.defineProperty(gemini$2, "__esModule", { value: true });
gemini$2.GeminiAiAdapter = void 0;
var GeminiAiAdapter;
(function (GeminiAiAdapter) {
    (function (HarmCategory) {
        HarmCategory["HARM_CATEGORY_UNSPECIFIED"] = "HARM_CATEGORY_UNSPECIFIED";
        HarmCategory["HARM_CATEGORY_HATE_SPEECH"] = "HARM_CATEGORY_HATE_SPEECH";
        HarmCategory["HARM_CATEGORY_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_SEXUALLY_EXPLICIT";
        HarmCategory["HARM_CATEGORY_DANGEROUS_CONTENT"] = "HARM_CATEGORY_DANGEROUS_CONTENT";
        HarmCategory["HARM_CATEGORY_HARASSMENT"] = "HARM_CATEGORY_HARASSMENT";
        HarmCategory["HARM_CATEGORY_CIVIC_INTEGRITY"] = "HARM_CATEGORY_CIVIC_INTEGRITY";
    })(GeminiAiAdapter.HarmCategory || (GeminiAiAdapter.HarmCategory = {}));
    (function (HarmBlockThreshold) {
        HarmBlockThreshold["HARM_BLOCK_THRESHOLD_UNSPECIFIED"] = "HARM_BLOCK_THRESHOLD_UNSPECIFIED";
        HarmBlockThreshold["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
        HarmBlockThreshold["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
        HarmBlockThreshold["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
        HarmBlockThreshold["BLOCK_NONE"] = "BLOCK_NONE";
        HarmBlockThreshold["OFF"] = "OFF";
    })(GeminiAiAdapter.HarmBlockThreshold || (GeminiAiAdapter.HarmBlockThreshold = {}));
})(GeminiAiAdapter || (gemini$2.GeminiAiAdapter = GeminiAiAdapter = {}));

var openai$2 = {};

Object.defineProperty(openai$2, "__esModule", { value: true });

var grok$2 = {};

Object.defineProperty(grok$2, "__esModule", { value: true });

(function (exports) {
	var __createBinding = (adapters && adapters.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (adapters && adapters.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar(anthropic$2, exports);
	__exportStar(gemini$2, exports);
	__exportStar(openai$2, exports);
	__exportStar(grok$2, exports);
	
} (adapters));

var models$1 = {};

var anthropic$1 = {};

var env$2$1 = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.envKeys = exports.processEnv = exports.allProcessEnv = void 0;
	/**
	 * allProcessEnv returns the current process environment variables, or an empty
	 * object if they cannot be read, making sure we support environments other than
	 * Node such as Deno, too.
	 *
	 * Using this ensures we don't dangerously access `process.env` in environments
	 * where it may not be defined, such as Deno or the browser.
	 */
	const allProcessEnv = () => {
	    // Node, or Node-like environments
	    try {
	        if (process.env) {
	            return process.env;
	        }
	    }
	    catch (_err) {
	        // noop
	    }
	    // Deno
	    try {
	        const env = Deno.env.toObject();
	        if (env) {
	            return env;
	        }
	    }
	    catch (_err) {
	        // noop
	    }
	    // Netlify
	    try {
	        const env = Netlify.env.toObject();
	        if (env) {
	            return env;
	        }
	    }
	    catch (_err) {
	        // noop
	    }
	    return {};
	};
	exports.allProcessEnv = allProcessEnv;
	const processEnv = (key) => {
	    return (0, exports.allProcessEnv)()[key];
	};
	exports.processEnv = processEnv;
	var envKeys;
	(function (envKeys) {
	    envKeys["OpenAiApiKey"] = "OPENAI_API_KEY";
	    envKeys["GeminiApiKey"] = "GEMINI_API_KEY";
	    envKeys["AnthropicApiKey"] = "ANTHROPIC_API_KEY";
	    envKeys["DeepSeekApiKey"] = "DEEPSEEK_API_KEY";
	    envKeys["GrokApiKey"] = "XAI_API_KEY";
	})(envKeys || (exports.envKeys = envKeys = {}));
	
} (env$2$1));

Object.defineProperty(anthropic$1, "__esModule", { value: true });
anthropic$1.anthropic = void 0;
const env_1$4 = env$2$1;
/**
 * Create an Anthropic model using the Anthropic chat format.
 *
 * By default it targets the `https://api.anthropic.com/v1/` base URL, with the
 * "2023-06-01" anthropic-version header.
 */
const anthropic = (options) => {
    var _a, _b;
    const authKey = options.apiKey || (0, env_1$4.processEnv)(env_1$4.envKeys.AnthropicApiKey) || "";
    // Ensure we add a trailing slash to our base URL if it doesn't have one,
    // otherwise we'll replace the path instead of appending it.
    let baseUrl = options.baseUrl || "https://api.anthropic.com/v1/";
    if (!baseUrl.endsWith("/")) {
        baseUrl += "/";
    }
    const url = new URL("messages", baseUrl);
    const headers = {
        "anthropic-version": "2023-06-01",
    };
    if ((((_a = options.betaHeaders) === null || _a === void 0 ? void 0 : _a.length) || 0) > 0) {
        headers["anthropic-beta"] = ((_b = options.betaHeaders) === null || _b === void 0 ? void 0 : _b.join(",")) || "";
    }
    return {
        url: url.href,
        authKey,
        format: "anthropic",
        onCall(_, body) {
            Object.assign(body, options.defaultParameters);
            body.model || (body.model = options.model);
        },
        headers,
        options,
    };
};
anthropic$1.anthropic = anthropic;

var gemini$1 = {};

Object.defineProperty(gemini$1, "__esModule", { value: true });
gemini$1.gemini = void 0;
const env_1$3 = env$2$1;
/**
 * Create a Gemini model using the OpenAI chat format.
 *
 * By default it targets the `https://generativelanguage.googleapis.com/v1beta/`
 * base URL.
 */
const gemini = (options) => {
    const authKey = options.apiKey || (0, env_1$3.processEnv)(env_1$3.envKeys.GeminiApiKey) || "";
    // Ensure we add a trailing slash to our base URL if it doesn't have one,
    // otherwise we'll replace the path instead of appending it.
    let baseUrl = options.baseUrl || "https://generativelanguage.googleapis.com/v1beta/";
    if (!baseUrl.endsWith("/")) {
        baseUrl += "/";
    }
    const url = new URL(`models/${options.model}:generateContent?key=${authKey}`, baseUrl);
    const headers = {};
    return {
        url: url.href,
        authKey,
        format: "gemini",
        onCall(_, body) {
            Object.assign(body, options.defaultParameters);
        },
        headers,
        options,
    };
};
gemini$1.gemini = gemini;

var openai$1 = {};

Object.defineProperty(openai$1, "__esModule", { value: true });
openai$1.openai = void 0;
const env_1$2$1 = env$2$1;
/**
 * Create an OpenAI model using the OpenAI chat format.
 *
 * By default it targets the `https://api.openai.com/v1/` base URL.
 */
const openai = (options) => {
    const authKey = options.apiKey || (0, env_1$2$1.processEnv)(env_1$2$1.envKeys.OpenAiApiKey) || "";
    // Ensure we add a trailing slash to our base URL if it doesn't have one,
    // otherwise we'll replace the path instead of appending it.
    let baseUrl = options.baseUrl || "https://api.openai.com/v1/";
    if (!baseUrl.endsWith("/")) {
        baseUrl += "/";
    }
    const url = new URL("chat/completions", baseUrl);
    return {
        url: url.href,
        authKey,
        format: "openai-chat",
        onCall(_, body) {
            Object.assign(body, options.defaultParameters);
            body.model || (body.model = options.model);
        },
        options,
    };
};
openai$1.openai = openai;

var deepseek$1 = {};

Object.defineProperty(deepseek$1, "__esModule", { value: true });
deepseek$1.deepseek = void 0;
const env_1$1$1 = env$2$1;
/**
 * Create a DeepSeek model using the OpenAI-compatible chat format.
 *
 * By default it targets the `https://api.deepseek.com/v1/` base URL.
 */
const deepseek = (options) => {
    const authKey = options.apiKey || (0, env_1$1$1.processEnv)(env_1$1$1.envKeys.DeepSeekApiKey) || "";
    // Ensure we add a trailing slash to our base URL if it doesn't have one,
    // otherwise we'll replace the path instead of appending it.
    let baseUrl = options.baseUrl || "https://api.deepseek.com/v1/";
    if (!baseUrl.endsWith("/")) {
        baseUrl += "/";
    }
    const url = new URL("chat/completions", baseUrl);
    return {
        url: url.href,
        authKey,
        format: "openai-chat",
        onCall(_, body) {
            Object.assign(body, options.defaultParameters);
            body.model || (body.model = options.model);
        },
        options,
    };
};
deepseek$1.deepseek = deepseek;

var grok$1 = {};

Object.defineProperty(grok$1, "__esModule", { value: true });
grok$1.grok = void 0;
const env_1$5 = env$2$1;
const openai_js_1 = openai$1;
/**
 * Create a Grok model using the OpenAI chat format.
 *
 * By default it targets the `https://api.x.ai/v1`
 * base URL.
 */
const grok = (options) => {
    const apiKey = options.apiKey || (0, env_1$5.processEnv)(env_1$5.envKeys.GrokApiKey);
    const baseUrl = options.baseUrl || "https://api.x.ai/v1";
    const model = options.model;
    const adapter = (0, openai_js_1.openai)(Object.assign(Object.assign({}, options), { apiKey,
        baseUrl,
        model }));
    adapter.format = "grok";
    return adapter;
};
grok$1.grok = grok;

(function (exports) {
	var __createBinding = (models$1 && models$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (models$1 && models$1.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar(anthropic$1, exports);
	__exportStar(gemini$1, exports);
	__exportStar(openai$1, exports);
	__exportStar(deepseek$1, exports);
	__exportStar(grok$1, exports);
	
} (models$1));

(function (exports) {
	var __createBinding = (dist$1 && dist$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (dist$1 && dist$1.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __exportStar = (dist$1 && dist$1.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	var __importStar = (dist$1 && dist$1.__importStar) || (function () {
	    var ownKeys = function(o) {
	        ownKeys = Object.getOwnPropertyNames || function (o) {
	            var ar = [];
	            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
	            return ar;
	        };
	        return ownKeys(o);
	    };
	    return function (mod) {
	        if (mod && mod.__esModule) return mod;
	        var result = {};
	        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
	        __setModuleDefault(result, mod);
	        return result;
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.models = void 0;
	__exportStar(adapters, exports);
	__exportStar(models$1, exports);
	exports.models = __importStar(models$1);
	
} (dist$1));

var EventSchemas$1 = {};

var __rest = (EventSchemas$1 && EventSchemas$1.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(EventSchemas$1, "__esModule", { value: true });
EventSchemas$1.EventSchemas = void 0;
/**
 * Provide an `EventSchemas` class to type events, providing type safety when
 * sending events and running functions via Inngest.
 *
 * You can provide generated Inngest types, custom types, types using Zod, or
 * a combination of the above. See {@link EventSchemas} for more information.
 *
 * @example
 *
 * ```ts
 * export const inngest = new Inngest({
 *   id: "my-app",
 *   schemas: new EventSchemas().fromZod({
 *     "app/user.created": {
 *       data: z.object({
 *         id: z.string(),
 *         name: z.string(),
 *       }),
 *     },
 *   }),
 * });
 * ```
 *
 * @public
 */
class EventSchemas {
    constructor() {
        this.runtimeSchemas = {};
    }
    addRuntimeSchemas(schemas) {
        this.runtimeSchemas = Object.assign(Object.assign({}, this.runtimeSchemas), schemas);
    }
    /**
     * Use generated Inngest types to type events.
     */
    fromGenerated() {
        return this;
    }
    /**
     * Use a `Record<>` type to type events.
     *
     * @example
     *
     * ```ts
     * export const inngest = new Inngest({
     *   id: "my-app",
     *   schemas: new EventSchemas().fromRecord<{
     *     "app/user.created": {
     *       data: {
     *         id: string;
     *         name: string;
     *       };
     *     };
     *   }>(),
     * });
     * ```
     */
    fromRecord(..._args) {
        return this;
    }
    /**
     * Use a union type to type events.
     *
     * @example
     *
     * ```ts
     * type AccountCreated = {
     *   name: "app/account.created";
     *   data: { org: string };
     *   user: { id: string };
     * };
     *
     * type AccountDeleted = {
     *   name: "app/account.deleted";
     *   data: { org: string };
     *   user: { id: string };
     * };
     *
     * type Events = AccountCreated | AccountDeleted;
     *
     * export const inngest = new Inngest({
     *   id: "my-app",
     *   schemas: new EventSchemas().fromUnion<Events>(),
     * });
     * ```
     */
    fromUnion() {
        return this;
    }
    /**
     * Use Zod to type events.
     *
     * @example
     *
     * ```ts
     * export const inngest = new Inngest({
     *   id: "my-app",
     *   schemas: new EventSchemas().fromZod({
     *     "app/user.created": {
     *       data: z.object({
     *         id: z.string(),
     *         name: z.string(),
     *       }),
     *     },
     *   }),
     * });
     * ```
     */
    fromZod(schemas) {
        let runtimeSchemas;
        if (Array.isArray(schemas)) {
            runtimeSchemas = schemas.reduce((acc, schema) => {
                const _a = schema.shape, { name: { value: name } } = _a, rest = __rest(_a, ["name"]);
                return Object.assign(Object.assign({}, acc), { [name]: rest });
            }, {});
        }
        else {
            runtimeSchemas = schemas;
        }
        this.addRuntimeSchemas(runtimeSchemas);
        return this;
    }
}
EventSchemas$1.EventSchemas = EventSchemas;

var Fetch = {};

var src = {exports: {}};

var browser = {exports: {}};

/**
 * Helpers.
 */

var s$1 = 1000;
var m = s$1 * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

var ms = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse$1(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse$1(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s$1;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s$1) {
    return Math.round(ms / s$1) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s$1) {
    return plural(ms, msAbs, s$1, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = ms;
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		const split = (typeof namespaces === 'string' ? namespaces : '')
			.trim()
			.replace(' ', ',')
			.split(',')
			.filter(Boolean);

		for (const ns of split) {
			if (ns[0] === '-') {
				createDebug.skips.push(ns.slice(1));
			} else {
				createDebug.names.push(ns);
			}
		}
	}

	/**
	 * Checks if the given string matches a namespace template, honoring
	 * asterisks as wildcards.
	 *
	 * @param {String} search
	 * @param {String} template
	 * @return {Boolean}
	 */
	function matchesTemplate(search, template) {
		let searchIndex = 0;
		let templateIndex = 0;
		let starIndex = -1;
		let matchIndex = 0;

		while (searchIndex < search.length) {
			if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
				// Match character or proceed with wildcard
				if (template[templateIndex] === '*') {
					starIndex = templateIndex;
					matchIndex = searchIndex;
					templateIndex++; // Skip the '*'
				} else {
					searchIndex++;
					templateIndex++;
				}
			} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition
				// Backtrack to the last '*' and try to match more characters
				templateIndex = starIndex + 1;
				matchIndex++;
				searchIndex = matchIndex;
			} else {
				return false; // No match
			}
		}

		// Handle trailing '*' in template
		while (templateIndex < template.length && template[templateIndex] === '*') {
			templateIndex++;
		}

		return templateIndex === template.length;
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names,
			...createDebug.skips.map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		for (const skip of createDebug.skips) {
			if (matchesTemplate(name, skip)) {
				return false;
			}
		}

		for (const ns of createDebug.names) {
			if (matchesTemplate(name, ns)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

var common$6 = setup;

/* eslint-env browser */

(function (module, exports) {
	/**
	 * This is the web browser implementation of `debug()`.
	 */

	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = localstorage();
	exports.destroy = (() => {
		let warned = false;

		return () => {
			if (!warned) {
				warned = true;
				console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
			}
		};
	})();

	/**
	 * Colors.
	 */

	exports.colors = [
		'#0000CC',
		'#0000FF',
		'#0033CC',
		'#0033FF',
		'#0066CC',
		'#0066FF',
		'#0099CC',
		'#0099FF',
		'#00CC00',
		'#00CC33',
		'#00CC66',
		'#00CC99',
		'#00CCCC',
		'#00CCFF',
		'#3300CC',
		'#3300FF',
		'#3333CC',
		'#3333FF',
		'#3366CC',
		'#3366FF',
		'#3399CC',
		'#3399FF',
		'#33CC00',
		'#33CC33',
		'#33CC66',
		'#33CC99',
		'#33CCCC',
		'#33CCFF',
		'#6600CC',
		'#6600FF',
		'#6633CC',
		'#6633FF',
		'#66CC00',
		'#66CC33',
		'#9900CC',
		'#9900FF',
		'#9933CC',
		'#9933FF',
		'#99CC00',
		'#99CC33',
		'#CC0000',
		'#CC0033',
		'#CC0066',
		'#CC0099',
		'#CC00CC',
		'#CC00FF',
		'#CC3300',
		'#CC3333',
		'#CC3366',
		'#CC3399',
		'#CC33CC',
		'#CC33FF',
		'#CC6600',
		'#CC6633',
		'#CC9900',
		'#CC9933',
		'#CCCC00',
		'#CCCC33',
		'#FF0000',
		'#FF0033',
		'#FF0066',
		'#FF0099',
		'#FF00CC',
		'#FF00FF',
		'#FF3300',
		'#FF3333',
		'#FF3366',
		'#FF3399',
		'#FF33CC',
		'#FF33FF',
		'#FF6600',
		'#FF6633',
		'#FF9900',
		'#FF9933',
		'#FFCC00',
		'#FFCC33'
	];

	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */

	// eslint-disable-next-line complexity
	function useColors() {
		// NB: In an Electron preload script, document will be defined but not fully
		// initialized. Since we know we're in Chrome, we'll just detect this case
		// explicitly
		if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
			return true;
		}

		// Internet Explorer and Edge do not support colors.
		if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
			return false;
		}

		let m;

		// Is webkit? http://stackoverflow.com/a/16459606/376773
		// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
		// eslint-disable-next-line no-return-assign
		return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
			// Is firebug? http://stackoverflow.com/a/398120/376773
			(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
			// Is firefox >= v31?
			// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
			(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31) ||
			// Double check webkit in userAgent just in case we are in a worker
			(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
	}

	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */

	function formatArgs(args) {
		args[0] = (this.useColors ? '%c' : '') +
			this.namespace +
			(this.useColors ? ' %c' : ' ') +
			args[0] +
			(this.useColors ? '%c ' : ' ') +
			'+' + module.exports.humanize(this.diff);

		if (!this.useColors) {
			return;
		}

		const c = 'color: ' + this.color;
		args.splice(1, 0, c, 'color: inherit');

		// The final "%c" is somewhat tricky, because there could be other
		// arguments passed either before or after the %c, so we need to
		// figure out the correct index to insert the CSS into
		let index = 0;
		let lastC = 0;
		args[0].replace(/%[a-zA-Z%]/g, match => {
			if (match === '%%') {
				return;
			}
			index++;
			if (match === '%c') {
				// We only are interested in the *last* %c
				// (the user may have provided their own)
				lastC = index;
			}
		});

		args.splice(lastC, 0, c);
	}

	/**
	 * Invokes `console.debug()` when available.
	 * No-op when `console.debug` is not a "function".
	 * If `console.debug` is not available, falls back
	 * to `console.log`.
	 *
	 * @api public
	 */
	exports.log = console.debug || console.log || (() => {});

	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	function save(namespaces) {
		try {
			if (namespaces) {
				exports.storage.setItem('debug', namespaces);
			} else {
				exports.storage.removeItem('debug');
			}
		} catch (error) {
			// Swallow
			// XXX (@Qix-) should we be logging these?
		}
	}

	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	function load() {
		let r;
		try {
			r = exports.storage.getItem('debug');
		} catch (error) {
			// Swallow
			// XXX (@Qix-) should we be logging these?
		}

		// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
		if (!r && typeof process !== 'undefined' && 'env' in process) {
			r = process.env.DEBUG;
		}

		return r;
	}

	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */

	function localstorage() {
		try {
			// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
			// The Browser also has localStorage in the global context.
			return localStorage;
		} catch (error) {
			// Swallow
			// XXX (@Qix-) should we be logging these?
		}
	}

	module.exports = common$6(exports);

	const {formatters} = module.exports;

	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */

	formatters.j = function (v) {
		try {
			return JSON.stringify(v);
		} catch (error) {
			return '[UnexpectedJSONParseError]: ' + error.message;
		}
	}; 
} (browser, browser.exports));

var browserExports = browser.exports;

var node = {exports: {}};

var hasFlag$1 = (flag, argv = process.argv) => {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};

const os = os$1;
const tty = require$$1$1;
const hasFlag = hasFlag$1;

const {env: env$1$1} = process;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false') ||
	hasFlag('color=never')) {
	forceColor = 0;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = 1;
}

if ('FORCE_COLOR' in env$1$1) {
	if (env$1$1.FORCE_COLOR === 'true') {
		forceColor = 1;
	} else if (env$1$1.FORCE_COLOR === 'false') {
		forceColor = 0;
	} else {
		forceColor = env$1$1.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env$1$1.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(haveStream, streamIsTTY) {
	if (forceColor === 0) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (!streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env$1$1.TERM === 'dumb') {
		return min;
	}

	if (process.platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env$1$1) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env$1$1) || env$1$1.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env$1$1) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env$1$1.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env$1$1.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env$1$1) {
		const version = parseInt((env$1$1.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env$1$1.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env$1$1.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env$1$1.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env$1$1) {
		return 1;
	}

	return min;
}

var supportsColor_1 = {
	stdout: translateLevel(supportsColor(true, tty.isatty(1))),
	stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};

/**
 * Module dependencies.
 */

(function (module, exports) {
	const tty = require$$1$1;
	const util = require$$0$1$1;

	/**
	 * This is the Node.js implementation of `debug()`.
	 */

	exports.init = init;
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.destroy = util.deprecate(
		() => {},
		'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
	);

	/**
	 * Colors.
	 */

	exports.colors = [6, 2, 3, 4, 5, 1];

	try {
		// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
		// eslint-disable-next-line import/no-extraneous-dependencies
		const supportsColor = supportsColor_1;

		if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
			exports.colors = [
				20,
				21,
				26,
				27,
				32,
				33,
				38,
				39,
				40,
				41,
				42,
				43,
				44,
				45,
				56,
				57,
				62,
				63,
				68,
				69,
				74,
				75,
				76,
				77,
				78,
				79,
				80,
				81,
				92,
				93,
				98,
				99,
				112,
				113,
				128,
				129,
				134,
				135,
				148,
				149,
				160,
				161,
				162,
				163,
				164,
				165,
				166,
				167,
				168,
				169,
				170,
				171,
				172,
				173,
				178,
				179,
				184,
				185,
				196,
				197,
				198,
				199,
				200,
				201,
				202,
				203,
				204,
				205,
				206,
				207,
				208,
				209,
				214,
				215,
				220,
				221
			];
		}
	} catch (error) {
		// Swallow - we only care if `supports-color` is available; it doesn't have to be.
	}

	/**
	 * Build up the default `inspectOpts` object from the environment variables.
	 *
	 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
	 */

	exports.inspectOpts = Object.keys(process.env).filter(key => {
		return /^debug_/i.test(key);
	}).reduce((obj, key) => {
		// Camel-case
		const prop = key
			.substring(6)
			.toLowerCase()
			.replace(/_([a-z])/g, (_, k) => {
				return k.toUpperCase();
			});

		// Coerce string value into JS value
		let val = process.env[key];
		if (/^(yes|on|true|enabled)$/i.test(val)) {
			val = true;
		} else if (/^(no|off|false|disabled)$/i.test(val)) {
			val = false;
		} else if (val === 'null') {
			val = null;
		} else {
			val = Number(val);
		}

		obj[prop] = val;
		return obj;
	}, {});

	/**
	 * Is stdout a TTY? Colored output is enabled when `true`.
	 */

	function useColors() {
		return 'colors' in exports.inspectOpts ?
			Boolean(exports.inspectOpts.colors) :
			tty.isatty(process.stderr.fd);
	}

	/**
	 * Adds ANSI color escape codes if enabled.
	 *
	 * @api public
	 */

	function formatArgs(args) {
		const {namespace: name, useColors} = this;

		if (useColors) {
			const c = this.color;
			const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
			const prefix = `  ${colorCode};1m${name} \u001B[0m`;

			args[0] = prefix + args[0].split('\n').join('\n' + prefix);
			args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
		} else {
			args[0] = getDate() + name + ' ' + args[0];
		}
	}

	function getDate() {
		if (exports.inspectOpts.hideDate) {
			return '';
		}
		return new Date().toISOString() + ' ';
	}

	/**
	 * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
	 */

	function log(...args) {
		return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\n');
	}

	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	function save(namespaces) {
		if (namespaces) {
			process.env.DEBUG = namespaces;
		} else {
			// If you set a process.env field to null or undefined, it gets cast to the
			// string 'null' or 'undefined'. Just delete instead.
			delete process.env.DEBUG;
		}
	}

	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */

	function load() {
		return process.env.DEBUG;
	}

	/**
	 * Init logic for `debug` instances.
	 *
	 * Create a new `inspectOpts` object in case `useColors` is set
	 * differently for a particular `debug` instance.
	 */

	function init(debug) {
		debug.inspectOpts = {};

		const keys = Object.keys(exports.inspectOpts);
		for (let i = 0; i < keys.length; i++) {
			debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
		}
	}

	module.exports = common$6(exports);

	const {formatters} = module.exports;

	/**
	 * Map %o to `util.inspect()`, all on a single line.
	 */

	formatters.o = function (v) {
		this.inspectOpts.colors = this.useColors;
		return util.inspect(v, this.inspectOpts)
			.split('\n')
			.map(str => str.trim())
			.join(' ');
	};

	/**
	 * Map %O to `util.inspect()`, allowing multiple lines if needed.
	 */

	formatters.O = function (v) {
		this.inspectOpts.colors = this.useColors;
		return util.inspect(v, this.inspectOpts);
	}; 
} (node, node.exports));

var nodeExports = node.exports;

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	src.exports = browserExports;
} else {
	src.exports = nodeExports;
}

var srcExports = src.exports;

var als = {};

(function (exports) {
	var __createBinding = (als && als.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (als && als.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (als && als.__importStar) || (function () {
	    var ownKeys = function(o) {
	        ownKeys = Object.getOwnPropertyNames || function (o) {
	            var ar = [];
	            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
	            return ar;
	        };
	        return ownKeys(o);
	    };
	    return function (mod) {
	        if (mod && mod.__esModule) return mod;
	        var result = {};
	        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
	        __setModuleDefault(result, mod);
	        return result;
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getAsyncLocalStorage = exports.getAsyncCtx = void 0;
	/**
	 * A local-only symbol used as a key in global state to store the async local
	 * storage instance.
	 */
	const alsSymbol = Symbol.for("inngest:als");
	/**
	 * Retrieve the async context for the current execution.
	 */
	const getAsyncCtx = async () => {
	    return (0, exports.getAsyncLocalStorage)().then((als) => als.getStore());
	};
	exports.getAsyncCtx = getAsyncCtx;
	/**
	 * Get a singleton instance of `AsyncLocalStorage` used to store and retrieve
	 * async context for the current execution.
	 */
	const getAsyncLocalStorage = async () => {
	    var _a;
	    var _b;
	    (_a = (_b = globalThis)[alsSymbol]) !== null && _a !== void 0 ? _a : (_b[alsSymbol] = new Promise(
	    // eslint-disable-next-line @typescript-eslint/no-misused-promises, no-async-promise-executor
	    async (resolve) => {
	        try {
	            const { AsyncLocalStorage } = await Promise.resolve().then(() => __importStar(require$$0$2));
	            resolve(new AsyncLocalStorage());
	        }
	        catch (err) {
	            console.warn("node:async_hooks is not supported in this runtime. Experimental async context is disabled.");
	            resolve({
	                getStore: () => undefined,
	                run: (_, fn) => fn(),
	            });
	        }
	    }));
	    return globalThis[alsSymbol];
	};
	exports.getAsyncLocalStorage = getAsyncLocalStorage;
	
} (als));

var InngestStepTools = {};

var lib$2 = {};

var external$1 = {};

var errors$1 = {};

var en$1 = {};

var util$2 = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getParsedType = exports.ZodParsedType = exports.objectUtil = exports.util = void 0;
	var util;
	(function (util) {
	    util.assertEqual = (val) => val;
	    function assertIs(_arg) { }
	    util.assertIs = assertIs;
	    function assertNever(_x) {
	        throw new Error();
	    }
	    util.assertNever = assertNever;
	    util.arrayToEnum = (items) => {
	        const obj = {};
	        for (const item of items) {
	            obj[item] = item;
	        }
	        return obj;
	    };
	    util.getValidEnumValues = (obj) => {
	        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
	        const filtered = {};
	        for (const k of validKeys) {
	            filtered[k] = obj[k];
	        }
	        return util.objectValues(filtered);
	    };
	    util.objectValues = (obj) => {
	        return util.objectKeys(obj).map(function (e) {
	            return obj[e];
	        });
	    };
	    util.objectKeys = typeof Object.keys === "function" // eslint-disable-line ban/ban
	        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban
	        : (object) => {
	            const keys = [];
	            for (const key in object) {
	                if (Object.prototype.hasOwnProperty.call(object, key)) {
	                    keys.push(key);
	                }
	            }
	            return keys;
	        };
	    util.find = (arr, checker) => {
	        for (const item of arr) {
	            if (checker(item))
	                return item;
	        }
	        return undefined;
	    };
	    util.isInteger = typeof Number.isInteger === "function"
	        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban
	        : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
	    function joinValues(array, separator = " | ") {
	        return array
	            .map((val) => (typeof val === "string" ? `'${val}'` : val))
	            .join(separator);
	    }
	    util.joinValues = joinValues;
	    util.jsonStringifyReplacer = (_, value) => {
	        if (typeof value === "bigint") {
	            return value.toString();
	        }
	        return value;
	    };
	})(util = exports.util || (exports.util = {}));
	(function (objectUtil) {
	    objectUtil.mergeShapes = (first, second) => {
	        return {
	            ...first,
	            ...second, // second overwrites first
	        };
	    };
	})(exports.objectUtil || (exports.objectUtil = {}));
	exports.ZodParsedType = util.arrayToEnum([
	    "string",
	    "nan",
	    "number",
	    "integer",
	    "float",
	    "boolean",
	    "date",
	    "bigint",
	    "symbol",
	    "function",
	    "undefined",
	    "null",
	    "array",
	    "object",
	    "unknown",
	    "promise",
	    "void",
	    "never",
	    "map",
	    "set",
	]);
	const getParsedType = (data) => {
	    const t = typeof data;
	    switch (t) {
	        case "undefined":
	            return exports.ZodParsedType.undefined;
	        case "string":
	            return exports.ZodParsedType.string;
	        case "number":
	            return isNaN(data) ? exports.ZodParsedType.nan : exports.ZodParsedType.number;
	        case "boolean":
	            return exports.ZodParsedType.boolean;
	        case "function":
	            return exports.ZodParsedType.function;
	        case "bigint":
	            return exports.ZodParsedType.bigint;
	        case "symbol":
	            return exports.ZodParsedType.symbol;
	        case "object":
	            if (Array.isArray(data)) {
	                return exports.ZodParsedType.array;
	            }
	            if (data === null) {
	                return exports.ZodParsedType.null;
	            }
	            if (data.then &&
	                typeof data.then === "function" &&
	                data.catch &&
	                typeof data.catch === "function") {
	                return exports.ZodParsedType.promise;
	            }
	            if (typeof Map !== "undefined" && data instanceof Map) {
	                return exports.ZodParsedType.map;
	            }
	            if (typeof Set !== "undefined" && data instanceof Set) {
	                return exports.ZodParsedType.set;
	            }
	            if (typeof Date !== "undefined" && data instanceof Date) {
	                return exports.ZodParsedType.date;
	            }
	            return exports.ZodParsedType.object;
	        default:
	            return exports.ZodParsedType.unknown;
	    }
	};
	exports.getParsedType = getParsedType; 
} (util$2));

var ZodError$1$1 = {};

Object.defineProperty(ZodError$1$1, "__esModule", { value: true });
ZodError$1$1.ZodError = ZodError$1$1.quotelessJson = ZodError$1$1.ZodIssueCode = void 0;
const util_1$1$2 = util$2;
ZodError$1$1.ZodIssueCode = util_1$1$2.util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite",
]);
const quotelessJson$1 = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
};
ZodError$1$1.quotelessJson = quotelessJson$1;
let ZodError$2 = class ZodError extends Error {
    constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
            this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
            this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
            // eslint-disable-next-line ban/ban
            Object.setPrototypeOf(this, actualProto);
        }
        else {
            this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
    }
    get errors() {
        return this.issues;
    }
    format(_mapper) {
        const mapper = _mapper ||
            function (issue) {
                return issue.message;
            };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
            for (const issue of error.issues) {
                if (issue.code === "invalid_union") {
                    issue.unionErrors.map(processError);
                }
                else if (issue.code === "invalid_return_type") {
                    processError(issue.returnTypeError);
                }
                else if (issue.code === "invalid_arguments") {
                    processError(issue.argumentsError);
                }
                else if (issue.path.length === 0) {
                    fieldErrors._errors.push(mapper(issue));
                }
                else {
                    let curr = fieldErrors;
                    let i = 0;
                    while (i < issue.path.length) {
                        const el = issue.path[i];
                        const terminal = i === issue.path.length - 1;
                        if (!terminal) {
                            curr[el] = curr[el] || { _errors: [] };
                            // if (typeof el === "string") {
                            //   curr[el] = curr[el] || { _errors: [] };
                            // } else if (typeof el === "number") {
                            //   const errorArray: any = [];
                            //   errorArray._errors = [];
                            //   curr[el] = curr[el] || errorArray;
                            // }
                        }
                        else {
                            curr[el] = curr[el] || { _errors: [] };
                            curr[el]._errors.push(mapper(issue));
                        }
                        curr = curr[el];
                        i++;
                    }
                }
            }
        };
        processError(this);
        return fieldErrors;
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, util_1$1$2.util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
            if (sub.path.length > 0) {
                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
                fieldErrors[sub.path[0]].push(mapper(sub));
            }
            else {
                formErrors.push(mapper(sub));
            }
        }
        return { formErrors, fieldErrors };
    }
    get formErrors() {
        return this.flatten();
    }
};
ZodError$1$1.ZodError = ZodError$2;
ZodError$2.create = (issues) => {
    const error = new ZodError$2(issues);
    return error;
};

Object.defineProperty(en$1, "__esModule", { value: true });
const util_1$4 = util$2;
const ZodError_1$2 = ZodError$1$1;
const errorMap$1 = (issue, _ctx) => {
    let message;
    switch (issue.code) {
        case ZodError_1$2.ZodIssueCode.invalid_type:
            if (issue.received === util_1$4.ZodParsedType.undefined) {
                message = "Required";
            }
            else {
                message = `Expected ${issue.expected}, received ${issue.received}`;
            }
            break;
        case ZodError_1$2.ZodIssueCode.invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_1$4.util.jsonStringifyReplacer)}`;
            break;
        case ZodError_1$2.ZodIssueCode.unrecognized_keys:
            message = `Unrecognized key(s) in object: ${util_1$4.util.joinValues(issue.keys, ", ")}`;
            break;
        case ZodError_1$2.ZodIssueCode.invalid_union:
            message = `Invalid input`;
            break;
        case ZodError_1$2.ZodIssueCode.invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${util_1$4.util.joinValues(issue.options)}`;
            break;
        case ZodError_1$2.ZodIssueCode.invalid_enum_value:
            message = `Invalid enum value. Expected ${util_1$4.util.joinValues(issue.options)}, received '${issue.received}'`;
            break;
        case ZodError_1$2.ZodIssueCode.invalid_arguments:
            message = `Invalid function arguments`;
            break;
        case ZodError_1$2.ZodIssueCode.invalid_return_type:
            message = `Invalid function return type`;
            break;
        case ZodError_1$2.ZodIssueCode.invalid_date:
            message = `Invalid date`;
            break;
        case ZodError_1$2.ZodIssueCode.invalid_string:
            if (typeof issue.validation === "object") {
                if ("includes" in issue.validation) {
                    message = `Invalid input: must include "${issue.validation.includes}"`;
                    if (typeof issue.validation.position === "number") {
                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                    }
                }
                else if ("startsWith" in issue.validation) {
                    message = `Invalid input: must start with "${issue.validation.startsWith}"`;
                }
                else if ("endsWith" in issue.validation) {
                    message = `Invalid input: must end with "${issue.validation.endsWith}"`;
                }
                else {
                    util_1$4.util.assertNever(issue.validation);
                }
            }
            else if (issue.validation !== "regex") {
                message = `Invalid ${issue.validation}`;
            }
            else {
                message = "Invalid";
            }
            break;
        case ZodError_1$2.ZodIssueCode.too_small:
            if (issue.type === "array")
                message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be ${issue.exact
                    ? `exactly equal to `
                    : issue.inclusive
                        ? `greater than or equal to `
                        : `greater than `}${issue.minimum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact
                    ? `exactly equal to `
                    : issue.inclusive
                        ? `greater than or equal to `
                        : `greater than `}${new Date(Number(issue.minimum))}`;
            else
                message = "Invalid input";
            break;
        case ZodError_1$2.ZodIssueCode.too_big:
            if (issue.type === "array")
                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `less than or equal to`
                        : `less than`} ${issue.maximum}`;
            else if (issue.type === "bigint")
                message = `BigInt must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `less than or equal to`
                        : `less than`} ${issue.maximum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `smaller than or equal to`
                        : `smaller than`} ${new Date(Number(issue.maximum))}`;
            else
                message = "Invalid input";
            break;
        case ZodError_1$2.ZodIssueCode.custom:
            message = `Invalid input`;
            break;
        case ZodError_1$2.ZodIssueCode.invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
        case ZodError_1$2.ZodIssueCode.not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
        case ZodError_1$2.ZodIssueCode.not_finite:
            message = "Number must be finite";
            break;
        default:
            message = _ctx.defaultError;
            util_1$4.util.assertNever(issue);
    }
    return { message };
};
en$1.default = errorMap$1;

var __importDefault$7 = (errors$1 && errors$1.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(errors$1, "__esModule", { value: true });
errors$1.getErrorMap = errors$1.setErrorMap = errors$1.defaultErrorMap = void 0;
const en_1$1 = __importDefault$7(en$1);
errors$1.defaultErrorMap = en_1$1.default;
let overrideErrorMap$1 = en_1$1.default;
function setErrorMap$1(map) {
    overrideErrorMap$1 = map;
}
errors$1.setErrorMap = setErrorMap$1;
function getErrorMap$1() {
    return overrideErrorMap$1;
}
errors$1.getErrorMap = getErrorMap$1;

var parseUtil$1 = {};

(function (exports) {
	var __importDefault = (parseUtil$1 && parseUtil$1.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isAsync = exports.isValid = exports.isDirty = exports.isAborted = exports.OK = exports.DIRTY = exports.INVALID = exports.ParseStatus = exports.addIssueToContext = exports.EMPTY_PATH = exports.makeIssue = void 0;
	const errors_1 = errors$1;
	const en_1 = __importDefault(en$1);
	const makeIssue = (params) => {
	    const { data, path, errorMaps, issueData } = params;
	    const fullPath = [...path, ...(issueData.path || [])];
	    const fullIssue = {
	        ...issueData,
	        path: fullPath,
	    };
	    let errorMessage = "";
	    const maps = errorMaps
	        .filter((m) => !!m)
	        .slice()
	        .reverse();
	    for (const map of maps) {
	        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
	    }
	    return {
	        ...issueData,
	        path: fullPath,
	        message: issueData.message || errorMessage,
	    };
	};
	exports.makeIssue = makeIssue;
	exports.EMPTY_PATH = [];
	function addIssueToContext(ctx, issueData) {
	    const issue = (0, exports.makeIssue)({
	        issueData: issueData,
	        data: ctx.data,
	        path: ctx.path,
	        errorMaps: [
	            ctx.common.contextualErrorMap,
	            ctx.schemaErrorMap,
	            (0, errors_1.getErrorMap)(),
	            en_1.default, // then global default map
	        ].filter((x) => !!x),
	    });
	    ctx.common.issues.push(issue);
	}
	exports.addIssueToContext = addIssueToContext;
	class ParseStatus {
	    constructor() {
	        this.value = "valid";
	    }
	    dirty() {
	        if (this.value === "valid")
	            this.value = "dirty";
	    }
	    abort() {
	        if (this.value !== "aborted")
	            this.value = "aborted";
	    }
	    static mergeArray(status, results) {
	        const arrayValue = [];
	        for (const s of results) {
	            if (s.status === "aborted")
	                return exports.INVALID;
	            if (s.status === "dirty")
	                status.dirty();
	            arrayValue.push(s.value);
	        }
	        return { status: status.value, value: arrayValue };
	    }
	    static async mergeObjectAsync(status, pairs) {
	        const syncPairs = [];
	        for (const pair of pairs) {
	            syncPairs.push({
	                key: await pair.key,
	                value: await pair.value,
	            });
	        }
	        return ParseStatus.mergeObjectSync(status, syncPairs);
	    }
	    static mergeObjectSync(status, pairs) {
	        const finalObject = {};
	        for (const pair of pairs) {
	            const { key, value } = pair;
	            if (key.status === "aborted")
	                return exports.INVALID;
	            if (value.status === "aborted")
	                return exports.INVALID;
	            if (key.status === "dirty")
	                status.dirty();
	            if (value.status === "dirty")
	                status.dirty();
	            if (key.value !== "__proto__" &&
	                (typeof value.value !== "undefined" || pair.alwaysSet)) {
	                finalObject[key.value] = value.value;
	            }
	        }
	        return { status: status.value, value: finalObject };
	    }
	}
	exports.ParseStatus = ParseStatus;
	exports.INVALID = Object.freeze({
	    status: "aborted",
	});
	const DIRTY = (value) => ({ status: "dirty", value });
	exports.DIRTY = DIRTY;
	const OK = (value) => ({ status: "valid", value });
	exports.OK = OK;
	const isAborted = (x) => x.status === "aborted";
	exports.isAborted = isAborted;
	const isDirty = (x) => x.status === "dirty";
	exports.isDirty = isDirty;
	const isValid = (x) => x.status === "valid";
	exports.isValid = isValid;
	const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
	exports.isAsync = isAsync; 
} (parseUtil$1));

var typeAliases$1 = {};

Object.defineProperty(typeAliases$1, "__esModule", { value: true });

var types$1$1 = {};

var errorUtil$2 = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.errorUtil = void 0;
	(function (errorUtil) {
	    errorUtil.errToObj = (message) => typeof message === "string" ? { message } : message || {};
	    errorUtil.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
	})(exports.errorUtil || (exports.errorUtil = {})); 
} (errorUtil$2));

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.date = exports.boolean = exports.bigint = exports.array = exports.any = exports.coerce = exports.ZodFirstPartyTypeKind = exports.late = exports.ZodSchema = exports.Schema = exports.custom = exports.ZodReadonly = exports.ZodPipeline = exports.ZodBranded = exports.BRAND = exports.ZodNaN = exports.ZodCatch = exports.ZodDefault = exports.ZodNullable = exports.ZodOptional = exports.ZodTransformer = exports.ZodEffects = exports.ZodPromise = exports.ZodNativeEnum = exports.ZodEnum = exports.ZodLiteral = exports.ZodLazy = exports.ZodFunction = exports.ZodSet = exports.ZodMap = exports.ZodRecord = exports.ZodTuple = exports.ZodIntersection = exports.ZodDiscriminatedUnion = exports.ZodUnion = exports.ZodObject = exports.ZodArray = exports.ZodVoid = exports.ZodNever = exports.ZodUnknown = exports.ZodAny = exports.ZodNull = exports.ZodUndefined = exports.ZodSymbol = exports.ZodDate = exports.ZodBoolean = exports.ZodBigInt = exports.ZodNumber = exports.ZodString = exports.ZodType = void 0;
	exports.NEVER = exports.void = exports.unknown = exports.union = exports.undefined = exports.tuple = exports.transformer = exports.symbol = exports.string = exports.strictObject = exports.set = exports.record = exports.promise = exports.preprocess = exports.pipeline = exports.ostring = exports.optional = exports.onumber = exports.oboolean = exports.object = exports.number = exports.nullable = exports.null = exports.never = exports.nativeEnum = exports.nan = exports.map = exports.literal = exports.lazy = exports.intersection = exports.instanceof = exports.function = exports.enum = exports.effect = exports.discriminatedUnion = void 0;
	const errors_1 = errors$1;
	const errorUtil_1 = errorUtil$2;
	const parseUtil_1 = parseUtil$1;
	const util_1 = util$2;
	const ZodError_1 = ZodError$1$1;
	class ParseInputLazyPath {
	    constructor(parent, value, path, key) {
	        this._cachedPath = [];
	        this.parent = parent;
	        this.data = value;
	        this._path = path;
	        this._key = key;
	    }
	    get path() {
	        if (!this._cachedPath.length) {
	            if (this._key instanceof Array) {
	                this._cachedPath.push(...this._path, ...this._key);
	            }
	            else {
	                this._cachedPath.push(...this._path, this._key);
	            }
	        }
	        return this._cachedPath;
	    }
	}
	const handleResult = (ctx, result) => {
	    if ((0, parseUtil_1.isValid)(result)) {
	        return { success: true, data: result.value };
	    }
	    else {
	        if (!ctx.common.issues.length) {
	            throw new Error("Validation failed but no issues detected.");
	        }
	        return {
	            success: false,
	            get error() {
	                if (this._error)
	                    return this._error;
	                const error = new ZodError_1.ZodError(ctx.common.issues);
	                this._error = error;
	                return this._error;
	            },
	        };
	    }
	};
	function processCreateParams(params) {
	    if (!params)
	        return {};
	    const { errorMap, invalid_type_error, required_error, description } = params;
	    if (errorMap && (invalid_type_error || required_error)) {
	        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
	    }
	    if (errorMap)
	        return { errorMap: errorMap, description };
	    const customMap = (iss, ctx) => {
	        if (iss.code !== "invalid_type")
	            return { message: ctx.defaultError };
	        if (typeof ctx.data === "undefined") {
	            return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
	        }
	        return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
	    };
	    return { errorMap: customMap, description };
	}
	class ZodType {
	    constructor(def) {
	        /** Alias of safeParseAsync */
	        this.spa = this.safeParseAsync;
	        this._def = def;
	        this.parse = this.parse.bind(this);
	        this.safeParse = this.safeParse.bind(this);
	        this.parseAsync = this.parseAsync.bind(this);
	        this.safeParseAsync = this.safeParseAsync.bind(this);
	        this.spa = this.spa.bind(this);
	        this.refine = this.refine.bind(this);
	        this.refinement = this.refinement.bind(this);
	        this.superRefine = this.superRefine.bind(this);
	        this.optional = this.optional.bind(this);
	        this.nullable = this.nullable.bind(this);
	        this.nullish = this.nullish.bind(this);
	        this.array = this.array.bind(this);
	        this.promise = this.promise.bind(this);
	        this.or = this.or.bind(this);
	        this.and = this.and.bind(this);
	        this.transform = this.transform.bind(this);
	        this.brand = this.brand.bind(this);
	        this.default = this.default.bind(this);
	        this.catch = this.catch.bind(this);
	        this.describe = this.describe.bind(this);
	        this.pipe = this.pipe.bind(this);
	        this.readonly = this.readonly.bind(this);
	        this.isNullable = this.isNullable.bind(this);
	        this.isOptional = this.isOptional.bind(this);
	    }
	    get description() {
	        return this._def.description;
	    }
	    _getType(input) {
	        return (0, util_1.getParsedType)(input.data);
	    }
	    _getOrReturnCtx(input, ctx) {
	        return (ctx || {
	            common: input.parent.common,
	            data: input.data,
	            parsedType: (0, util_1.getParsedType)(input.data),
	            schemaErrorMap: this._def.errorMap,
	            path: input.path,
	            parent: input.parent,
	        });
	    }
	    _processInputParams(input) {
	        return {
	            status: new parseUtil_1.ParseStatus(),
	            ctx: {
	                common: input.parent.common,
	                data: input.data,
	                parsedType: (0, util_1.getParsedType)(input.data),
	                schemaErrorMap: this._def.errorMap,
	                path: input.path,
	                parent: input.parent,
	            },
	        };
	    }
	    _parseSync(input) {
	        const result = this._parse(input);
	        if ((0, parseUtil_1.isAsync)(result)) {
	            throw new Error("Synchronous parse encountered promise.");
	        }
	        return result;
	    }
	    _parseAsync(input) {
	        const result = this._parse(input);
	        return Promise.resolve(result);
	    }
	    parse(data, params) {
	        const result = this.safeParse(data, params);
	        if (result.success)
	            return result.data;
	        throw result.error;
	    }
	    safeParse(data, params) {
	        var _a;
	        const ctx = {
	            common: {
	                issues: [],
	                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
	                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
	            },
	            path: (params === null || params === void 0 ? void 0 : params.path) || [],
	            schemaErrorMap: this._def.errorMap,
	            parent: null,
	            data,
	            parsedType: (0, util_1.getParsedType)(data),
	        };
	        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
	        return handleResult(ctx, result);
	    }
	    async parseAsync(data, params) {
	        const result = await this.safeParseAsync(data, params);
	        if (result.success)
	            return result.data;
	        throw result.error;
	    }
	    async safeParseAsync(data, params) {
	        const ctx = {
	            common: {
	                issues: [],
	                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
	                async: true,
	            },
	            path: (params === null || params === void 0 ? void 0 : params.path) || [],
	            schemaErrorMap: this._def.errorMap,
	            parent: null,
	            data,
	            parsedType: (0, util_1.getParsedType)(data),
	        };
	        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
	        const result = await ((0, parseUtil_1.isAsync)(maybeAsyncResult)
	            ? maybeAsyncResult
	            : Promise.resolve(maybeAsyncResult));
	        return handleResult(ctx, result);
	    }
	    refine(check, message) {
	        const getIssueProperties = (val) => {
	            if (typeof message === "string" || typeof message === "undefined") {
	                return { message };
	            }
	            else if (typeof message === "function") {
	                return message(val);
	            }
	            else {
	                return message;
	            }
	        };
	        return this._refinement((val, ctx) => {
	            const result = check(val);
	            const setError = () => ctx.addIssue({
	                code: ZodError_1.ZodIssueCode.custom,
	                ...getIssueProperties(val),
	            });
	            if (typeof Promise !== "undefined" && result instanceof Promise) {
	                return result.then((data) => {
	                    if (!data) {
	                        setError();
	                        return false;
	                    }
	                    else {
	                        return true;
	                    }
	                });
	            }
	            if (!result) {
	                setError();
	                return false;
	            }
	            else {
	                return true;
	            }
	        });
	    }
	    refinement(check, refinementData) {
	        return this._refinement((val, ctx) => {
	            if (!check(val)) {
	                ctx.addIssue(typeof refinementData === "function"
	                    ? refinementData(val, ctx)
	                    : refinementData);
	                return false;
	            }
	            else {
	                return true;
	            }
	        });
	    }
	    _refinement(refinement) {
	        return new ZodEffects({
	            schema: this,
	            typeName: ZodFirstPartyTypeKind.ZodEffects,
	            effect: { type: "refinement", refinement },
	        });
	    }
	    superRefine(refinement) {
	        return this._refinement(refinement);
	    }
	    optional() {
	        return ZodOptional.create(this, this._def);
	    }
	    nullable() {
	        return ZodNullable.create(this, this._def);
	    }
	    nullish() {
	        return this.nullable().optional();
	    }
	    array() {
	        return ZodArray.create(this, this._def);
	    }
	    promise() {
	        return ZodPromise.create(this, this._def);
	    }
	    or(option) {
	        return ZodUnion.create([this, option], this._def);
	    }
	    and(incoming) {
	        return ZodIntersection.create(this, incoming, this._def);
	    }
	    transform(transform) {
	        return new ZodEffects({
	            ...processCreateParams(this._def),
	            schema: this,
	            typeName: ZodFirstPartyTypeKind.ZodEffects,
	            effect: { type: "transform", transform },
	        });
	    }
	    default(def) {
	        const defaultValueFunc = typeof def === "function" ? def : () => def;
	        return new ZodDefault({
	            ...processCreateParams(this._def),
	            innerType: this,
	            defaultValue: defaultValueFunc,
	            typeName: ZodFirstPartyTypeKind.ZodDefault,
	        });
	    }
	    brand() {
	        return new ZodBranded({
	            typeName: ZodFirstPartyTypeKind.ZodBranded,
	            type: this,
	            ...processCreateParams(this._def),
	        });
	    }
	    catch(def) {
	        const catchValueFunc = typeof def === "function" ? def : () => def;
	        return new ZodCatch({
	            ...processCreateParams(this._def),
	            innerType: this,
	            catchValue: catchValueFunc,
	            typeName: ZodFirstPartyTypeKind.ZodCatch,
	        });
	    }
	    describe(description) {
	        const This = this.constructor;
	        return new This({
	            ...this._def,
	            description,
	        });
	    }
	    pipe(target) {
	        return ZodPipeline.create(this, target);
	    }
	    readonly() {
	        return ZodReadonly.create(this);
	    }
	    isOptional() {
	        return this.safeParse(undefined).success;
	    }
	    isNullable() {
	        return this.safeParse(null).success;
	    }
	}
	exports.ZodType = ZodType;
	exports.Schema = ZodType;
	exports.ZodSchema = ZodType;
	const cuidRegex = /^c[^\s-]{8,}$/i;
	const cuid2Regex = /^[a-z][a-z0-9]*$/;
	const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
	// const uuidRegex =
	//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
	const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
	// from https://stackoverflow.com/a/46181/1550155
	// old version: too slow, didn't support unicode
	// const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
	//old email regex
	// const emailRegex = /^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@((?!-)([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{1,})[^-<>()[\].,;:\s@"]$/i;
	// eslint-disable-next-line
	// const emailRegex =
	//   /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
	// const emailRegex =
	//   /^[a-zA-Z0-9\.\!\#\$\%\&\'\*\+\/\=\?\^\_\`\{\|\}\~\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
	// const emailRegex =
	//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i;
	const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
	// const emailRegex =
	//   /^[a-z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\.[a-z0-9\-]+)*$/i;
	// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
	const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
	let emojiRegex;
	const ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
	const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
	// Adapted from https://stackoverflow.com/a/3143231
	const datetimeRegex = (args) => {
	    if (args.precision) {
	        if (args.offset) {
	            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
	        }
	        else {
	            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
	        }
	    }
	    else if (args.precision === 0) {
	        if (args.offset) {
	            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
	        }
	        else {
	            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
	        }
	    }
	    else {
	        if (args.offset) {
	            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
	        }
	        else {
	            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
	        }
	    }
	};
	function isValidIP(ip, version) {
	    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
	        return true;
	    }
	    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
	        return true;
	    }
	    return false;
	}
	class ZodString extends ZodType {
	    _parse(input) {
	        if (this._def.coerce) {
	            input.data = String(input.data);
	        }
	        const parsedType = this._getType(input);
	        if (parsedType !== util_1.ZodParsedType.string) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.string,
	                received: ctx.parsedType,
	            }
	            //
	            );
	            return parseUtil_1.INVALID;
	        }
	        const status = new parseUtil_1.ParseStatus();
	        let ctx = undefined;
	        for (const check of this._def.checks) {
	            if (check.kind === "min") {
	                if (input.data.length < check.value) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.too_small,
	                        minimum: check.value,
	                        type: "string",
	                        inclusive: true,
	                        exact: false,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "max") {
	                if (input.data.length > check.value) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.too_big,
	                        maximum: check.value,
	                        type: "string",
	                        inclusive: true,
	                        exact: false,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "length") {
	                const tooBig = input.data.length > check.value;
	                const tooSmall = input.data.length < check.value;
	                if (tooBig || tooSmall) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    if (tooBig) {
	                        (0, parseUtil_1.addIssueToContext)(ctx, {
	                            code: ZodError_1.ZodIssueCode.too_big,
	                            maximum: check.value,
	                            type: "string",
	                            inclusive: true,
	                            exact: true,
	                            message: check.message,
	                        });
	                    }
	                    else if (tooSmall) {
	                        (0, parseUtil_1.addIssueToContext)(ctx, {
	                            code: ZodError_1.ZodIssueCode.too_small,
	                            minimum: check.value,
	                            type: "string",
	                            inclusive: true,
	                            exact: true,
	                            message: check.message,
	                        });
	                    }
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "email") {
	                if (!emailRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        validation: "email",
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "emoji") {
	                if (!emojiRegex) {
	                    emojiRegex = new RegExp(_emojiRegex, "u");
	                }
	                if (!emojiRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        validation: "emoji",
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "uuid") {
	                if (!uuidRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        validation: "uuid",
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "cuid") {
	                if (!cuidRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        validation: "cuid",
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "cuid2") {
	                if (!cuid2Regex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        validation: "cuid2",
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "ulid") {
	                if (!ulidRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        validation: "ulid",
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "url") {
	                try {
	                    new URL(input.data);
	                }
	                catch (_a) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        validation: "url",
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "regex") {
	                check.regex.lastIndex = 0;
	                const testResult = check.regex.test(input.data);
	                if (!testResult) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        validation: "regex",
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "trim") {
	                input.data = input.data.trim();
	            }
	            else if (check.kind === "includes") {
	                if (!input.data.includes(check.value, check.position)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        validation: { includes: check.value, position: check.position },
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "toLowerCase") {
	                input.data = input.data.toLowerCase();
	            }
	            else if (check.kind === "toUpperCase") {
	                input.data = input.data.toUpperCase();
	            }
	            else if (check.kind === "startsWith") {
	                if (!input.data.startsWith(check.value)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        validation: { startsWith: check.value },
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "endsWith") {
	                if (!input.data.endsWith(check.value)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        validation: { endsWith: check.value },
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "datetime") {
	                const regex = datetimeRegex(check);
	                if (!regex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        validation: "datetime",
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "ip") {
	                if (!isValidIP(input.data, check.version)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        validation: "ip",
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else {
	                util_1.util.assertNever(check);
	            }
	        }
	        return { status: status.value, value: input.data };
	    }
	    _regex(regex, validation, message) {
	        return this.refinement((data) => regex.test(data), {
	            validation,
	            code: ZodError_1.ZodIssueCode.invalid_string,
	            ...errorUtil_1.errorUtil.errToObj(message),
	        });
	    }
	    _addCheck(check) {
	        return new ZodString({
	            ...this._def,
	            checks: [...this._def.checks, check],
	        });
	    }
	    email(message) {
	        return this._addCheck({ kind: "email", ...errorUtil_1.errorUtil.errToObj(message) });
	    }
	    url(message) {
	        return this._addCheck({ kind: "url", ...errorUtil_1.errorUtil.errToObj(message) });
	    }
	    emoji(message) {
	        return this._addCheck({ kind: "emoji", ...errorUtil_1.errorUtil.errToObj(message) });
	    }
	    uuid(message) {
	        return this._addCheck({ kind: "uuid", ...errorUtil_1.errorUtil.errToObj(message) });
	    }
	    cuid(message) {
	        return this._addCheck({ kind: "cuid", ...errorUtil_1.errorUtil.errToObj(message) });
	    }
	    cuid2(message) {
	        return this._addCheck({ kind: "cuid2", ...errorUtil_1.errorUtil.errToObj(message) });
	    }
	    ulid(message) {
	        return this._addCheck({ kind: "ulid", ...errorUtil_1.errorUtil.errToObj(message) });
	    }
	    ip(options) {
	        return this._addCheck({ kind: "ip", ...errorUtil_1.errorUtil.errToObj(options) });
	    }
	    datetime(options) {
	        var _a;
	        if (typeof options === "string") {
	            return this._addCheck({
	                kind: "datetime",
	                precision: null,
	                offset: false,
	                message: options,
	            });
	        }
	        return this._addCheck({
	            kind: "datetime",
	            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
	            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
	            ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
	        });
	    }
	    regex(regex, message) {
	        return this._addCheck({
	            kind: "regex",
	            regex: regex,
	            ...errorUtil_1.errorUtil.errToObj(message),
	        });
	    }
	    includes(value, options) {
	        return this._addCheck({
	            kind: "includes",
	            value: value,
	            position: options === null || options === void 0 ? void 0 : options.position,
	            ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
	        });
	    }
	    startsWith(value, message) {
	        return this._addCheck({
	            kind: "startsWith",
	            value: value,
	            ...errorUtil_1.errorUtil.errToObj(message),
	        });
	    }
	    endsWith(value, message) {
	        return this._addCheck({
	            kind: "endsWith",
	            value: value,
	            ...errorUtil_1.errorUtil.errToObj(message),
	        });
	    }
	    min(minLength, message) {
	        return this._addCheck({
	            kind: "min",
	            value: minLength,
	            ...errorUtil_1.errorUtil.errToObj(message),
	        });
	    }
	    max(maxLength, message) {
	        return this._addCheck({
	            kind: "max",
	            value: maxLength,
	            ...errorUtil_1.errorUtil.errToObj(message),
	        });
	    }
	    length(len, message) {
	        return this._addCheck({
	            kind: "length",
	            value: len,
	            ...errorUtil_1.errorUtil.errToObj(message),
	        });
	    }
	    /**
	     * @deprecated Use z.string().min(1) instead.
	     * @see {@link ZodString.min}
	     */
	    nonempty(message) {
	        return this.min(1, errorUtil_1.errorUtil.errToObj(message));
	    }
	    trim() {
	        return new ZodString({
	            ...this._def,
	            checks: [...this._def.checks, { kind: "trim" }],
	        });
	    }
	    toLowerCase() {
	        return new ZodString({
	            ...this._def,
	            checks: [...this._def.checks, { kind: "toLowerCase" }],
	        });
	    }
	    toUpperCase() {
	        return new ZodString({
	            ...this._def,
	            checks: [...this._def.checks, { kind: "toUpperCase" }],
	        });
	    }
	    get isDatetime() {
	        return !!this._def.checks.find((ch) => ch.kind === "datetime");
	    }
	    get isEmail() {
	        return !!this._def.checks.find((ch) => ch.kind === "email");
	    }
	    get isURL() {
	        return !!this._def.checks.find((ch) => ch.kind === "url");
	    }
	    get isEmoji() {
	        return !!this._def.checks.find((ch) => ch.kind === "emoji");
	    }
	    get isUUID() {
	        return !!this._def.checks.find((ch) => ch.kind === "uuid");
	    }
	    get isCUID() {
	        return !!this._def.checks.find((ch) => ch.kind === "cuid");
	    }
	    get isCUID2() {
	        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
	    }
	    get isULID() {
	        return !!this._def.checks.find((ch) => ch.kind === "ulid");
	    }
	    get isIP() {
	        return !!this._def.checks.find((ch) => ch.kind === "ip");
	    }
	    get minLength() {
	        let min = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "min") {
	                if (min === null || ch.value > min)
	                    min = ch.value;
	            }
	        }
	        return min;
	    }
	    get maxLength() {
	        let max = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "max") {
	                if (max === null || ch.value < max)
	                    max = ch.value;
	            }
	        }
	        return max;
	    }
	}
	exports.ZodString = ZodString;
	ZodString.create = (params) => {
	    var _a;
	    return new ZodString({
	        checks: [],
	        typeName: ZodFirstPartyTypeKind.ZodString,
	        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
	        ...processCreateParams(params),
	    });
	};
	// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
	function floatSafeRemainder(val, step) {
	    const valDecCount = (val.toString().split(".")[1] || "").length;
	    const stepDecCount = (step.toString().split(".")[1] || "").length;
	    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
	    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
	    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
	    return (valInt % stepInt) / Math.pow(10, decCount);
	}
	class ZodNumber extends ZodType {
	    constructor() {
	        super(...arguments);
	        this.min = this.gte;
	        this.max = this.lte;
	        this.step = this.multipleOf;
	    }
	    _parse(input) {
	        if (this._def.coerce) {
	            input.data = Number(input.data);
	        }
	        const parsedType = this._getType(input);
	        if (parsedType !== util_1.ZodParsedType.number) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.number,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        let ctx = undefined;
	        const status = new parseUtil_1.ParseStatus();
	        for (const check of this._def.checks) {
	            if (check.kind === "int") {
	                if (!util_1.util.isInteger(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.invalid_type,
	                        expected: "integer",
	                        received: "float",
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "min") {
	                const tooSmall = check.inclusive
	                    ? input.data < check.value
	                    : input.data <= check.value;
	                if (tooSmall) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.too_small,
	                        minimum: check.value,
	                        type: "number",
	                        inclusive: check.inclusive,
	                        exact: false,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "max") {
	                const tooBig = check.inclusive
	                    ? input.data > check.value
	                    : input.data >= check.value;
	                if (tooBig) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.too_big,
	                        maximum: check.value,
	                        type: "number",
	                        inclusive: check.inclusive,
	                        exact: false,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "multipleOf") {
	                if (floatSafeRemainder(input.data, check.value) !== 0) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.not_multiple_of,
	                        multipleOf: check.value,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "finite") {
	                if (!Number.isFinite(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.not_finite,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else {
	                util_1.util.assertNever(check);
	            }
	        }
	        return { status: status.value, value: input.data };
	    }
	    gte(value, message) {
	        return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
	    }
	    gt(value, message) {
	        return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
	    }
	    lte(value, message) {
	        return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
	    }
	    lt(value, message) {
	        return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
	    }
	    setLimit(kind, value, inclusive, message) {
	        return new ZodNumber({
	            ...this._def,
	            checks: [
	                ...this._def.checks,
	                {
	                    kind,
	                    value,
	                    inclusive,
	                    message: errorUtil_1.errorUtil.toString(message),
	                },
	            ],
	        });
	    }
	    _addCheck(check) {
	        return new ZodNumber({
	            ...this._def,
	            checks: [...this._def.checks, check],
	        });
	    }
	    int(message) {
	        return this._addCheck({
	            kind: "int",
	            message: errorUtil_1.errorUtil.toString(message),
	        });
	    }
	    positive(message) {
	        return this._addCheck({
	            kind: "min",
	            value: 0,
	            inclusive: false,
	            message: errorUtil_1.errorUtil.toString(message),
	        });
	    }
	    negative(message) {
	        return this._addCheck({
	            kind: "max",
	            value: 0,
	            inclusive: false,
	            message: errorUtil_1.errorUtil.toString(message),
	        });
	    }
	    nonpositive(message) {
	        return this._addCheck({
	            kind: "max",
	            value: 0,
	            inclusive: true,
	            message: errorUtil_1.errorUtil.toString(message),
	        });
	    }
	    nonnegative(message) {
	        return this._addCheck({
	            kind: "min",
	            value: 0,
	            inclusive: true,
	            message: errorUtil_1.errorUtil.toString(message),
	        });
	    }
	    multipleOf(value, message) {
	        return this._addCheck({
	            kind: "multipleOf",
	            value: value,
	            message: errorUtil_1.errorUtil.toString(message),
	        });
	    }
	    finite(message) {
	        return this._addCheck({
	            kind: "finite",
	            message: errorUtil_1.errorUtil.toString(message),
	        });
	    }
	    safe(message) {
	        return this._addCheck({
	            kind: "min",
	            inclusive: true,
	            value: Number.MIN_SAFE_INTEGER,
	            message: errorUtil_1.errorUtil.toString(message),
	        })._addCheck({
	            kind: "max",
	            inclusive: true,
	            value: Number.MAX_SAFE_INTEGER,
	            message: errorUtil_1.errorUtil.toString(message),
	        });
	    }
	    get minValue() {
	        let min = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "min") {
	                if (min === null || ch.value > min)
	                    min = ch.value;
	            }
	        }
	        return min;
	    }
	    get maxValue() {
	        let max = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "max") {
	                if (max === null || ch.value < max)
	                    max = ch.value;
	            }
	        }
	        return max;
	    }
	    get isInt() {
	        return !!this._def.checks.find((ch) => ch.kind === "int" ||
	            (ch.kind === "multipleOf" && util_1.util.isInteger(ch.value)));
	    }
	    get isFinite() {
	        let max = null, min = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "finite" ||
	                ch.kind === "int" ||
	                ch.kind === "multipleOf") {
	                return true;
	            }
	            else if (ch.kind === "min") {
	                if (min === null || ch.value > min)
	                    min = ch.value;
	            }
	            else if (ch.kind === "max") {
	                if (max === null || ch.value < max)
	                    max = ch.value;
	            }
	        }
	        return Number.isFinite(min) && Number.isFinite(max);
	    }
	}
	exports.ZodNumber = ZodNumber;
	ZodNumber.create = (params) => {
	    return new ZodNumber({
	        checks: [],
	        typeName: ZodFirstPartyTypeKind.ZodNumber,
	        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
	        ...processCreateParams(params),
	    });
	};
	class ZodBigInt extends ZodType {
	    constructor() {
	        super(...arguments);
	        this.min = this.gte;
	        this.max = this.lte;
	    }
	    _parse(input) {
	        if (this._def.coerce) {
	            input.data = BigInt(input.data);
	        }
	        const parsedType = this._getType(input);
	        if (parsedType !== util_1.ZodParsedType.bigint) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.bigint,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        let ctx = undefined;
	        const status = new parseUtil_1.ParseStatus();
	        for (const check of this._def.checks) {
	            if (check.kind === "min") {
	                const tooSmall = check.inclusive
	                    ? input.data < check.value
	                    : input.data <= check.value;
	                if (tooSmall) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.too_small,
	                        type: "bigint",
	                        minimum: check.value,
	                        inclusive: check.inclusive,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "max") {
	                const tooBig = check.inclusive
	                    ? input.data > check.value
	                    : input.data >= check.value;
	                if (tooBig) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.too_big,
	                        type: "bigint",
	                        maximum: check.value,
	                        inclusive: check.inclusive,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "multipleOf") {
	                if (input.data % check.value !== BigInt(0)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.not_multiple_of,
	                        multipleOf: check.value,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else {
	                util_1.util.assertNever(check);
	            }
	        }
	        return { status: status.value, value: input.data };
	    }
	    gte(value, message) {
	        return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
	    }
	    gt(value, message) {
	        return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
	    }
	    lte(value, message) {
	        return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
	    }
	    lt(value, message) {
	        return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
	    }
	    setLimit(kind, value, inclusive, message) {
	        return new ZodBigInt({
	            ...this._def,
	            checks: [
	                ...this._def.checks,
	                {
	                    kind,
	                    value,
	                    inclusive,
	                    message: errorUtil_1.errorUtil.toString(message),
	                },
	            ],
	        });
	    }
	    _addCheck(check) {
	        return new ZodBigInt({
	            ...this._def,
	            checks: [...this._def.checks, check],
	        });
	    }
	    positive(message) {
	        return this._addCheck({
	            kind: "min",
	            value: BigInt(0),
	            inclusive: false,
	            message: errorUtil_1.errorUtil.toString(message),
	        });
	    }
	    negative(message) {
	        return this._addCheck({
	            kind: "max",
	            value: BigInt(0),
	            inclusive: false,
	            message: errorUtil_1.errorUtil.toString(message),
	        });
	    }
	    nonpositive(message) {
	        return this._addCheck({
	            kind: "max",
	            value: BigInt(0),
	            inclusive: true,
	            message: errorUtil_1.errorUtil.toString(message),
	        });
	    }
	    nonnegative(message) {
	        return this._addCheck({
	            kind: "min",
	            value: BigInt(0),
	            inclusive: true,
	            message: errorUtil_1.errorUtil.toString(message),
	        });
	    }
	    multipleOf(value, message) {
	        return this._addCheck({
	            kind: "multipleOf",
	            value,
	            message: errorUtil_1.errorUtil.toString(message),
	        });
	    }
	    get minValue() {
	        let min = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "min") {
	                if (min === null || ch.value > min)
	                    min = ch.value;
	            }
	        }
	        return min;
	    }
	    get maxValue() {
	        let max = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "max") {
	                if (max === null || ch.value < max)
	                    max = ch.value;
	            }
	        }
	        return max;
	    }
	}
	exports.ZodBigInt = ZodBigInt;
	ZodBigInt.create = (params) => {
	    var _a;
	    return new ZodBigInt({
	        checks: [],
	        typeName: ZodFirstPartyTypeKind.ZodBigInt,
	        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
	        ...processCreateParams(params),
	    });
	};
	class ZodBoolean extends ZodType {
	    _parse(input) {
	        if (this._def.coerce) {
	            input.data = Boolean(input.data);
	        }
	        const parsedType = this._getType(input);
	        if (parsedType !== util_1.ZodParsedType.boolean) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.boolean,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        return (0, parseUtil_1.OK)(input.data);
	    }
	}
	exports.ZodBoolean = ZodBoolean;
	ZodBoolean.create = (params) => {
	    return new ZodBoolean({
	        typeName: ZodFirstPartyTypeKind.ZodBoolean,
	        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
	        ...processCreateParams(params),
	    });
	};
	class ZodDate extends ZodType {
	    _parse(input) {
	        if (this._def.coerce) {
	            input.data = new Date(input.data);
	        }
	        const parsedType = this._getType(input);
	        if (parsedType !== util_1.ZodParsedType.date) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.date,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        if (isNaN(input.data.getTime())) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_date,
	            });
	            return parseUtil_1.INVALID;
	        }
	        const status = new parseUtil_1.ParseStatus();
	        let ctx = undefined;
	        for (const check of this._def.checks) {
	            if (check.kind === "min") {
	                if (input.data.getTime() < check.value) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.too_small,
	                        message: check.message,
	                        inclusive: true,
	                        exact: false,
	                        minimum: check.value,
	                        type: "date",
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "max") {
	                if (input.data.getTime() > check.value) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.too_big,
	                        message: check.message,
	                        inclusive: true,
	                        exact: false,
	                        maximum: check.value,
	                        type: "date",
	                    });
	                    status.dirty();
	                }
	            }
	            else {
	                util_1.util.assertNever(check);
	            }
	        }
	        return {
	            status: status.value,
	            value: new Date(input.data.getTime()),
	        };
	    }
	    _addCheck(check) {
	        return new ZodDate({
	            ...this._def,
	            checks: [...this._def.checks, check],
	        });
	    }
	    min(minDate, message) {
	        return this._addCheck({
	            kind: "min",
	            value: minDate.getTime(),
	            message: errorUtil_1.errorUtil.toString(message),
	        });
	    }
	    max(maxDate, message) {
	        return this._addCheck({
	            kind: "max",
	            value: maxDate.getTime(),
	            message: errorUtil_1.errorUtil.toString(message),
	        });
	    }
	    get minDate() {
	        let min = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "min") {
	                if (min === null || ch.value > min)
	                    min = ch.value;
	            }
	        }
	        return min != null ? new Date(min) : null;
	    }
	    get maxDate() {
	        let max = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "max") {
	                if (max === null || ch.value < max)
	                    max = ch.value;
	            }
	        }
	        return max != null ? new Date(max) : null;
	    }
	}
	exports.ZodDate = ZodDate;
	ZodDate.create = (params) => {
	    return new ZodDate({
	        checks: [],
	        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
	        typeName: ZodFirstPartyTypeKind.ZodDate,
	        ...processCreateParams(params),
	    });
	};
	class ZodSymbol extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType !== util_1.ZodParsedType.symbol) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.symbol,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        return (0, parseUtil_1.OK)(input.data);
	    }
	}
	exports.ZodSymbol = ZodSymbol;
	ZodSymbol.create = (params) => {
	    return new ZodSymbol({
	        typeName: ZodFirstPartyTypeKind.ZodSymbol,
	        ...processCreateParams(params),
	    });
	};
	class ZodUndefined extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType !== util_1.ZodParsedType.undefined) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.undefined,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        return (0, parseUtil_1.OK)(input.data);
	    }
	}
	exports.ZodUndefined = ZodUndefined;
	ZodUndefined.create = (params) => {
	    return new ZodUndefined({
	        typeName: ZodFirstPartyTypeKind.ZodUndefined,
	        ...processCreateParams(params),
	    });
	};
	class ZodNull extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType !== util_1.ZodParsedType.null) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.null,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        return (0, parseUtil_1.OK)(input.data);
	    }
	}
	exports.ZodNull = ZodNull;
	ZodNull.create = (params) => {
	    return new ZodNull({
	        typeName: ZodFirstPartyTypeKind.ZodNull,
	        ...processCreateParams(params),
	    });
	};
	class ZodAny extends ZodType {
	    constructor() {
	        super(...arguments);
	        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
	        this._any = true;
	    }
	    _parse(input) {
	        return (0, parseUtil_1.OK)(input.data);
	    }
	}
	exports.ZodAny = ZodAny;
	ZodAny.create = (params) => {
	    return new ZodAny({
	        typeName: ZodFirstPartyTypeKind.ZodAny,
	        ...processCreateParams(params),
	    });
	};
	class ZodUnknown extends ZodType {
	    constructor() {
	        super(...arguments);
	        // required
	        this._unknown = true;
	    }
	    _parse(input) {
	        return (0, parseUtil_1.OK)(input.data);
	    }
	}
	exports.ZodUnknown = ZodUnknown;
	ZodUnknown.create = (params) => {
	    return new ZodUnknown({
	        typeName: ZodFirstPartyTypeKind.ZodUnknown,
	        ...processCreateParams(params),
	    });
	};
	class ZodNever extends ZodType {
	    _parse(input) {
	        const ctx = this._getOrReturnCtx(input);
	        (0, parseUtil_1.addIssueToContext)(ctx, {
	            code: ZodError_1.ZodIssueCode.invalid_type,
	            expected: util_1.ZodParsedType.never,
	            received: ctx.parsedType,
	        });
	        return parseUtil_1.INVALID;
	    }
	}
	exports.ZodNever = ZodNever;
	ZodNever.create = (params) => {
	    return new ZodNever({
	        typeName: ZodFirstPartyTypeKind.ZodNever,
	        ...processCreateParams(params),
	    });
	};
	class ZodVoid extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType !== util_1.ZodParsedType.undefined) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.void,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        return (0, parseUtil_1.OK)(input.data);
	    }
	}
	exports.ZodVoid = ZodVoid;
	ZodVoid.create = (params) => {
	    return new ZodVoid({
	        typeName: ZodFirstPartyTypeKind.ZodVoid,
	        ...processCreateParams(params),
	    });
	};
	class ZodArray extends ZodType {
	    _parse(input) {
	        const { ctx, status } = this._processInputParams(input);
	        const def = this._def;
	        if (ctx.parsedType !== util_1.ZodParsedType.array) {
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.array,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        if (def.exactLength !== null) {
	            const tooBig = ctx.data.length > def.exactLength.value;
	            const tooSmall = ctx.data.length < def.exactLength.value;
	            if (tooBig || tooSmall) {
	                (0, parseUtil_1.addIssueToContext)(ctx, {
	                    code: tooBig ? ZodError_1.ZodIssueCode.too_big : ZodError_1.ZodIssueCode.too_small,
	                    minimum: (tooSmall ? def.exactLength.value : undefined),
	                    maximum: (tooBig ? def.exactLength.value : undefined),
	                    type: "array",
	                    inclusive: true,
	                    exact: true,
	                    message: def.exactLength.message,
	                });
	                status.dirty();
	            }
	        }
	        if (def.minLength !== null) {
	            if (ctx.data.length < def.minLength.value) {
	                (0, parseUtil_1.addIssueToContext)(ctx, {
	                    code: ZodError_1.ZodIssueCode.too_small,
	                    minimum: def.minLength.value,
	                    type: "array",
	                    inclusive: true,
	                    exact: false,
	                    message: def.minLength.message,
	                });
	                status.dirty();
	            }
	        }
	        if (def.maxLength !== null) {
	            if (ctx.data.length > def.maxLength.value) {
	                (0, parseUtil_1.addIssueToContext)(ctx, {
	                    code: ZodError_1.ZodIssueCode.too_big,
	                    maximum: def.maxLength.value,
	                    type: "array",
	                    inclusive: true,
	                    exact: false,
	                    message: def.maxLength.message,
	                });
	                status.dirty();
	            }
	        }
	        if (ctx.common.async) {
	            return Promise.all([...ctx.data].map((item, i) => {
	                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
	            })).then((result) => {
	                return parseUtil_1.ParseStatus.mergeArray(status, result);
	            });
	        }
	        const result = [...ctx.data].map((item, i) => {
	            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
	        });
	        return parseUtil_1.ParseStatus.mergeArray(status, result);
	    }
	    get element() {
	        return this._def.type;
	    }
	    min(minLength, message) {
	        return new ZodArray({
	            ...this._def,
	            minLength: { value: minLength, message: errorUtil_1.errorUtil.toString(message) },
	        });
	    }
	    max(maxLength, message) {
	        return new ZodArray({
	            ...this._def,
	            maxLength: { value: maxLength, message: errorUtil_1.errorUtil.toString(message) },
	        });
	    }
	    length(len, message) {
	        return new ZodArray({
	            ...this._def,
	            exactLength: { value: len, message: errorUtil_1.errorUtil.toString(message) },
	        });
	    }
	    nonempty(message) {
	        return this.min(1, message);
	    }
	}
	exports.ZodArray = ZodArray;
	ZodArray.create = (schema, params) => {
	    return new ZodArray({
	        type: schema,
	        minLength: null,
	        maxLength: null,
	        exactLength: null,
	        typeName: ZodFirstPartyTypeKind.ZodArray,
	        ...processCreateParams(params),
	    });
	};
	function deepPartialify(schema) {
	    if (schema instanceof ZodObject) {
	        const newShape = {};
	        for (const key in schema.shape) {
	            const fieldSchema = schema.shape[key];
	            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
	        }
	        return new ZodObject({
	            ...schema._def,
	            shape: () => newShape,
	        });
	    }
	    else if (schema instanceof ZodArray) {
	        return new ZodArray({
	            ...schema._def,
	            type: deepPartialify(schema.element),
	        });
	    }
	    else if (schema instanceof ZodOptional) {
	        return ZodOptional.create(deepPartialify(schema.unwrap()));
	    }
	    else if (schema instanceof ZodNullable) {
	        return ZodNullable.create(deepPartialify(schema.unwrap()));
	    }
	    else if (schema instanceof ZodTuple) {
	        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
	    }
	    else {
	        return schema;
	    }
	}
	class ZodObject extends ZodType {
	    constructor() {
	        super(...arguments);
	        this._cached = null;
	        /**
	         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
	         * If you want to pass through unknown properties, use `.passthrough()` instead.
	         */
	        this.nonstrict = this.passthrough;
	        // extend<
	        //   Augmentation extends ZodRawShape,
	        //   NewOutput extends util.flatten<{
	        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
	        //       ? Augmentation[k]["_output"]
	        //       : k extends keyof Output
	        //       ? Output[k]
	        //       : never;
	        //   }>,
	        //   NewInput extends util.flatten<{
	        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
	        //       ? Augmentation[k]["_input"]
	        //       : k extends keyof Input
	        //       ? Input[k]
	        //       : never;
	        //   }>
	        // >(
	        //   augmentation: Augmentation
	        // ): ZodObject<
	        //   extendShape<T, Augmentation>,
	        //   UnknownKeys,
	        //   Catchall,
	        //   NewOutput,
	        //   NewInput
	        // > {
	        //   return new ZodObject({
	        //     ...this._def,
	        //     shape: () => ({
	        //       ...this._def.shape(),
	        //       ...augmentation,
	        //     }),
	        //   }) as any;
	        // }
	        /**
	         * @deprecated Use `.extend` instead
	         *  */
	        this.augment = this.extend;
	    }
	    _getCached() {
	        if (this._cached !== null)
	            return this._cached;
	        const shape = this._def.shape();
	        const keys = util_1.util.objectKeys(shape);
	        return (this._cached = { shape, keys });
	    }
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType !== util_1.ZodParsedType.object) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.object,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        const { status, ctx } = this._processInputParams(input);
	        const { shape, keys: shapeKeys } = this._getCached();
	        const extraKeys = [];
	        if (!(this._def.catchall instanceof ZodNever &&
	            this._def.unknownKeys === "strip")) {
	            for (const key in ctx.data) {
	                if (!shapeKeys.includes(key)) {
	                    extraKeys.push(key);
	                }
	            }
	        }
	        const pairs = [];
	        for (const key of shapeKeys) {
	            const keyValidator = shape[key];
	            const value = ctx.data[key];
	            pairs.push({
	                key: { status: "valid", value: key },
	                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
	                alwaysSet: key in ctx.data,
	            });
	        }
	        if (this._def.catchall instanceof ZodNever) {
	            const unknownKeys = this._def.unknownKeys;
	            if (unknownKeys === "passthrough") {
	                for (const key of extraKeys) {
	                    pairs.push({
	                        key: { status: "valid", value: key },
	                        value: { status: "valid", value: ctx.data[key] },
	                    });
	                }
	            }
	            else if (unknownKeys === "strict") {
	                if (extraKeys.length > 0) {
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.unrecognized_keys,
	                        keys: extraKeys,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (unknownKeys === "strip") ;
	            else {
	                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
	            }
	        }
	        else {
	            // run catchall validation
	            const catchall = this._def.catchall;
	            for (const key of extraKeys) {
	                const value = ctx.data[key];
	                pairs.push({
	                    key: { status: "valid", value: key },
	                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)
	                    ),
	                    alwaysSet: key in ctx.data,
	                });
	            }
	        }
	        if (ctx.common.async) {
	            return Promise.resolve()
	                .then(async () => {
	                const syncPairs = [];
	                for (const pair of pairs) {
	                    const key = await pair.key;
	                    syncPairs.push({
	                        key,
	                        value: await pair.value,
	                        alwaysSet: pair.alwaysSet,
	                    });
	                }
	                return syncPairs;
	            })
	                .then((syncPairs) => {
	                return parseUtil_1.ParseStatus.mergeObjectSync(status, syncPairs);
	            });
	        }
	        else {
	            return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
	        }
	    }
	    get shape() {
	        return this._def.shape();
	    }
	    strict(message) {
	        return new ZodObject({
	            ...this._def,
	            unknownKeys: "strict",
	            ...(message !== undefined
	                ? {
	                    errorMap: (issue, ctx) => {
	                        var _a, _b, _c, _d;
	                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
	                        if (issue.code === "unrecognized_keys")
	                            return {
	                                message: (_d = errorUtil_1.errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,
	                            };
	                        return {
	                            message: defaultError,
	                        };
	                    },
	                }
	                : {}),
	        });
	    }
	    strip() {
	        return new ZodObject({
	            ...this._def,
	            unknownKeys: "strip",
	        });
	    }
	    passthrough() {
	        return new ZodObject({
	            ...this._def,
	            unknownKeys: "passthrough",
	        });
	    }
	    // const AugmentFactory =
	    //   <Def extends ZodObjectDef>(def: Def) =>
	    //   <Augmentation extends ZodRawShape>(
	    //     augmentation: Augmentation
	    //   ): ZodObject<
	    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
	    //     Def["unknownKeys"],
	    //     Def["catchall"]
	    //   > => {
	    //     return new ZodObject({
	    //       ...def,
	    //       shape: () => ({
	    //         ...def.shape(),
	    //         ...augmentation,
	    //       }),
	    //     }) as any;
	    //   };
	    extend(augmentation) {
	        return new ZodObject({
	            ...this._def,
	            shape: () => ({
	                ...this._def.shape(),
	                ...augmentation,
	            }),
	        });
	    }
	    /**
	     * Prior to zod@1.0.12 there was a bug in the
	     * inferred type of merged objects. Please
	     * upgrade if you are experiencing issues.
	     */
	    merge(merging) {
	        const merged = new ZodObject({
	            unknownKeys: merging._def.unknownKeys,
	            catchall: merging._def.catchall,
	            shape: () => ({
	                ...this._def.shape(),
	                ...merging._def.shape(),
	            }),
	            typeName: ZodFirstPartyTypeKind.ZodObject,
	        });
	        return merged;
	    }
	    // merge<
	    //   Incoming extends AnyZodObject,
	    //   Augmentation extends Incoming["shape"],
	    //   NewOutput extends {
	    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
	    //       ? Augmentation[k]["_output"]
	    //       : k extends keyof Output
	    //       ? Output[k]
	    //       : never;
	    //   },
	    //   NewInput extends {
	    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
	    //       ? Augmentation[k]["_input"]
	    //       : k extends keyof Input
	    //       ? Input[k]
	    //       : never;
	    //   }
	    // >(
	    //   merging: Incoming
	    // ): ZodObject<
	    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
	    //   Incoming["_def"]["unknownKeys"],
	    //   Incoming["_def"]["catchall"],
	    //   NewOutput,
	    //   NewInput
	    // > {
	    //   const merged: any = new ZodObject({
	    //     unknownKeys: merging._def.unknownKeys,
	    //     catchall: merging._def.catchall,
	    //     shape: () =>
	    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
	    //     typeName: ZodFirstPartyTypeKind.ZodObject,
	    //   }) as any;
	    //   return merged;
	    // }
	    setKey(key, schema) {
	        return this.augment({ [key]: schema });
	    }
	    // merge<Incoming extends AnyZodObject>(
	    //   merging: Incoming
	    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
	    // ZodObject<
	    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
	    //   Incoming["_def"]["unknownKeys"],
	    //   Incoming["_def"]["catchall"]
	    // > {
	    //   // const mergedShape = objectUtil.mergeShapes(
	    //   //   this._def.shape(),
	    //   //   merging._def.shape()
	    //   // );
	    //   const merged: any = new ZodObject({
	    //     unknownKeys: merging._def.unknownKeys,
	    //     catchall: merging._def.catchall,
	    //     shape: () =>
	    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
	    //     typeName: ZodFirstPartyTypeKind.ZodObject,
	    //   }) as any;
	    //   return merged;
	    // }
	    catchall(index) {
	        return new ZodObject({
	            ...this._def,
	            catchall: index,
	        });
	    }
	    pick(mask) {
	        const shape = {};
	        util_1.util.objectKeys(mask).forEach((key) => {
	            if (mask[key] && this.shape[key]) {
	                shape[key] = this.shape[key];
	            }
	        });
	        return new ZodObject({
	            ...this._def,
	            shape: () => shape,
	        });
	    }
	    omit(mask) {
	        const shape = {};
	        util_1.util.objectKeys(this.shape).forEach((key) => {
	            if (!mask[key]) {
	                shape[key] = this.shape[key];
	            }
	        });
	        return new ZodObject({
	            ...this._def,
	            shape: () => shape,
	        });
	    }
	    /**
	     * @deprecated
	     */
	    deepPartial() {
	        return deepPartialify(this);
	    }
	    partial(mask) {
	        const newShape = {};
	        util_1.util.objectKeys(this.shape).forEach((key) => {
	            const fieldSchema = this.shape[key];
	            if (mask && !mask[key]) {
	                newShape[key] = fieldSchema;
	            }
	            else {
	                newShape[key] = fieldSchema.optional();
	            }
	        });
	        return new ZodObject({
	            ...this._def,
	            shape: () => newShape,
	        });
	    }
	    required(mask) {
	        const newShape = {};
	        util_1.util.objectKeys(this.shape).forEach((key) => {
	            if (mask && !mask[key]) {
	                newShape[key] = this.shape[key];
	            }
	            else {
	                const fieldSchema = this.shape[key];
	                let newField = fieldSchema;
	                while (newField instanceof ZodOptional) {
	                    newField = newField._def.innerType;
	                }
	                newShape[key] = newField;
	            }
	        });
	        return new ZodObject({
	            ...this._def,
	            shape: () => newShape,
	        });
	    }
	    keyof() {
	        return createZodEnum(util_1.util.objectKeys(this.shape));
	    }
	}
	exports.ZodObject = ZodObject;
	ZodObject.create = (shape, params) => {
	    return new ZodObject({
	        shape: () => shape,
	        unknownKeys: "strip",
	        catchall: ZodNever.create(),
	        typeName: ZodFirstPartyTypeKind.ZodObject,
	        ...processCreateParams(params),
	    });
	};
	ZodObject.strictCreate = (shape, params) => {
	    return new ZodObject({
	        shape: () => shape,
	        unknownKeys: "strict",
	        catchall: ZodNever.create(),
	        typeName: ZodFirstPartyTypeKind.ZodObject,
	        ...processCreateParams(params),
	    });
	};
	ZodObject.lazycreate = (shape, params) => {
	    return new ZodObject({
	        shape,
	        unknownKeys: "strip",
	        catchall: ZodNever.create(),
	        typeName: ZodFirstPartyTypeKind.ZodObject,
	        ...processCreateParams(params),
	    });
	};
	class ZodUnion extends ZodType {
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        const options = this._def.options;
	        function handleResults(results) {
	            // return first issue-free validation if it exists
	            for (const result of results) {
	                if (result.result.status === "valid") {
	                    return result.result;
	                }
	            }
	            for (const result of results) {
	                if (result.result.status === "dirty") {
	                    // add issues from dirty option
	                    ctx.common.issues.push(...result.ctx.common.issues);
	                    return result.result;
	                }
	            }
	            // return invalid
	            const unionErrors = results.map((result) => new ZodError_1.ZodError(result.ctx.common.issues));
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_union,
	                unionErrors,
	            });
	            return parseUtil_1.INVALID;
	        }
	        if (ctx.common.async) {
	            return Promise.all(options.map(async (option) => {
	                const childCtx = {
	                    ...ctx,
	                    common: {
	                        ...ctx.common,
	                        issues: [],
	                    },
	                    parent: null,
	                };
	                return {
	                    result: await option._parseAsync({
	                        data: ctx.data,
	                        path: ctx.path,
	                        parent: childCtx,
	                    }),
	                    ctx: childCtx,
	                };
	            })).then(handleResults);
	        }
	        else {
	            let dirty = undefined;
	            const issues = [];
	            for (const option of options) {
	                const childCtx = {
	                    ...ctx,
	                    common: {
	                        ...ctx.common,
	                        issues: [],
	                    },
	                    parent: null,
	                };
	                const result = option._parseSync({
	                    data: ctx.data,
	                    path: ctx.path,
	                    parent: childCtx,
	                });
	                if (result.status === "valid") {
	                    return result;
	                }
	                else if (result.status === "dirty" && !dirty) {
	                    dirty = { result, ctx: childCtx };
	                }
	                if (childCtx.common.issues.length) {
	                    issues.push(childCtx.common.issues);
	                }
	            }
	            if (dirty) {
	                ctx.common.issues.push(...dirty.ctx.common.issues);
	                return dirty.result;
	            }
	            const unionErrors = issues.map((issues) => new ZodError_1.ZodError(issues));
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_union,
	                unionErrors,
	            });
	            return parseUtil_1.INVALID;
	        }
	    }
	    get options() {
	        return this._def.options;
	    }
	}
	exports.ZodUnion = ZodUnion;
	ZodUnion.create = (types, params) => {
	    return new ZodUnion({
	        options: types,
	        typeName: ZodFirstPartyTypeKind.ZodUnion,
	        ...processCreateParams(params),
	    });
	};
	/////////////////////////////////////////////////////
	/////////////////////////////////////////////////////
	//////////                                 //////////
	//////////      ZodDiscriminatedUnion      //////////
	//////////                                 //////////
	/////////////////////////////////////////////////////
	/////////////////////////////////////////////////////
	const getDiscriminator = (type) => {
	    if (type instanceof ZodLazy) {
	        return getDiscriminator(type.schema);
	    }
	    else if (type instanceof ZodEffects) {
	        return getDiscriminator(type.innerType());
	    }
	    else if (type instanceof ZodLiteral) {
	        return [type.value];
	    }
	    else if (type instanceof ZodEnum) {
	        return type.options;
	    }
	    else if (type instanceof ZodNativeEnum) {
	        // eslint-disable-next-line ban/ban
	        return Object.keys(type.enum);
	    }
	    else if (type instanceof ZodDefault) {
	        return getDiscriminator(type._def.innerType);
	    }
	    else if (type instanceof ZodUndefined) {
	        return [undefined];
	    }
	    else if (type instanceof ZodNull) {
	        return [null];
	    }
	    else {
	        return null;
	    }
	};
	class ZodDiscriminatedUnion extends ZodType {
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== util_1.ZodParsedType.object) {
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.object,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        const discriminator = this.discriminator;
	        const discriminatorValue = ctx.data[discriminator];
	        const option = this.optionsMap.get(discriminatorValue);
	        if (!option) {
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_union_discriminator,
	                options: Array.from(this.optionsMap.keys()),
	                path: [discriminator],
	            });
	            return parseUtil_1.INVALID;
	        }
	        if (ctx.common.async) {
	            return option._parseAsync({
	                data: ctx.data,
	                path: ctx.path,
	                parent: ctx,
	            });
	        }
	        else {
	            return option._parseSync({
	                data: ctx.data,
	                path: ctx.path,
	                parent: ctx,
	            });
	        }
	    }
	    get discriminator() {
	        return this._def.discriminator;
	    }
	    get options() {
	        return this._def.options;
	    }
	    get optionsMap() {
	        return this._def.optionsMap;
	    }
	    /**
	     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
	     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
	     * have a different value for each object in the union.
	     * @param discriminator the name of the discriminator property
	     * @param types an array of object schemas
	     * @param params
	     */
	    static create(discriminator, options, params) {
	        // Get all the valid discriminator values
	        const optionsMap = new Map();
	        // try {
	        for (const type of options) {
	            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
	            if (!discriminatorValues) {
	                throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
	            }
	            for (const value of discriminatorValues) {
	                if (optionsMap.has(value)) {
	                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
	                }
	                optionsMap.set(value, type);
	            }
	        }
	        return new ZodDiscriminatedUnion({
	            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
	            discriminator,
	            options,
	            optionsMap,
	            ...processCreateParams(params),
	        });
	    }
	}
	exports.ZodDiscriminatedUnion = ZodDiscriminatedUnion;
	function mergeValues(a, b) {
	    const aType = (0, util_1.getParsedType)(a);
	    const bType = (0, util_1.getParsedType)(b);
	    if (a === b) {
	        return { valid: true, data: a };
	    }
	    else if (aType === util_1.ZodParsedType.object && bType === util_1.ZodParsedType.object) {
	        const bKeys = util_1.util.objectKeys(b);
	        const sharedKeys = util_1.util
	            .objectKeys(a)
	            .filter((key) => bKeys.indexOf(key) !== -1);
	        const newObj = { ...a, ...b };
	        for (const key of sharedKeys) {
	            const sharedValue = mergeValues(a[key], b[key]);
	            if (!sharedValue.valid) {
	                return { valid: false };
	            }
	            newObj[key] = sharedValue.data;
	        }
	        return { valid: true, data: newObj };
	    }
	    else if (aType === util_1.ZodParsedType.array && bType === util_1.ZodParsedType.array) {
	        if (a.length !== b.length) {
	            return { valid: false };
	        }
	        const newArray = [];
	        for (let index = 0; index < a.length; index++) {
	            const itemA = a[index];
	            const itemB = b[index];
	            const sharedValue = mergeValues(itemA, itemB);
	            if (!sharedValue.valid) {
	                return { valid: false };
	            }
	            newArray.push(sharedValue.data);
	        }
	        return { valid: true, data: newArray };
	    }
	    else if (aType === util_1.ZodParsedType.date &&
	        bType === util_1.ZodParsedType.date &&
	        +a === +b) {
	        return { valid: true, data: a };
	    }
	    else {
	        return { valid: false };
	    }
	}
	class ZodIntersection extends ZodType {
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        const handleParsed = (parsedLeft, parsedRight) => {
	            if ((0, parseUtil_1.isAborted)(parsedLeft) || (0, parseUtil_1.isAborted)(parsedRight)) {
	                return parseUtil_1.INVALID;
	            }
	            const merged = mergeValues(parsedLeft.value, parsedRight.value);
	            if (!merged.valid) {
	                (0, parseUtil_1.addIssueToContext)(ctx, {
	                    code: ZodError_1.ZodIssueCode.invalid_intersection_types,
	                });
	                return parseUtil_1.INVALID;
	            }
	            if ((0, parseUtil_1.isDirty)(parsedLeft) || (0, parseUtil_1.isDirty)(parsedRight)) {
	                status.dirty();
	            }
	            return { status: status.value, value: merged.data };
	        };
	        if (ctx.common.async) {
	            return Promise.all([
	                this._def.left._parseAsync({
	                    data: ctx.data,
	                    path: ctx.path,
	                    parent: ctx,
	                }),
	                this._def.right._parseAsync({
	                    data: ctx.data,
	                    path: ctx.path,
	                    parent: ctx,
	                }),
	            ]).then(([left, right]) => handleParsed(left, right));
	        }
	        else {
	            return handleParsed(this._def.left._parseSync({
	                data: ctx.data,
	                path: ctx.path,
	                parent: ctx,
	            }), this._def.right._parseSync({
	                data: ctx.data,
	                path: ctx.path,
	                parent: ctx,
	            }));
	        }
	    }
	}
	exports.ZodIntersection = ZodIntersection;
	ZodIntersection.create = (left, right, params) => {
	    return new ZodIntersection({
	        left: left,
	        right: right,
	        typeName: ZodFirstPartyTypeKind.ZodIntersection,
	        ...processCreateParams(params),
	    });
	};
	class ZodTuple extends ZodType {
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== util_1.ZodParsedType.array) {
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.array,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        if (ctx.data.length < this._def.items.length) {
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.too_small,
	                minimum: this._def.items.length,
	                inclusive: true,
	                exact: false,
	                type: "array",
	            });
	            return parseUtil_1.INVALID;
	        }
	        const rest = this._def.rest;
	        if (!rest && ctx.data.length > this._def.items.length) {
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.too_big,
	                maximum: this._def.items.length,
	                inclusive: true,
	                exact: false,
	                type: "array",
	            });
	            status.dirty();
	        }
	        const items = [...ctx.data]
	            .map((item, itemIndex) => {
	            const schema = this._def.items[itemIndex] || this._def.rest;
	            if (!schema)
	                return null;
	            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
	        })
	            .filter((x) => !!x); // filter nulls
	        if (ctx.common.async) {
	            return Promise.all(items).then((results) => {
	                return parseUtil_1.ParseStatus.mergeArray(status, results);
	            });
	        }
	        else {
	            return parseUtil_1.ParseStatus.mergeArray(status, items);
	        }
	    }
	    get items() {
	        return this._def.items;
	    }
	    rest(rest) {
	        return new ZodTuple({
	            ...this._def,
	            rest,
	        });
	    }
	}
	exports.ZodTuple = ZodTuple;
	ZodTuple.create = (schemas, params) => {
	    if (!Array.isArray(schemas)) {
	        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
	    }
	    return new ZodTuple({
	        items: schemas,
	        typeName: ZodFirstPartyTypeKind.ZodTuple,
	        rest: null,
	        ...processCreateParams(params),
	    });
	};
	class ZodRecord extends ZodType {
	    get keySchema() {
	        return this._def.keyType;
	    }
	    get valueSchema() {
	        return this._def.valueType;
	    }
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== util_1.ZodParsedType.object) {
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.object,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        const pairs = [];
	        const keyType = this._def.keyType;
	        const valueType = this._def.valueType;
	        for (const key in ctx.data) {
	            pairs.push({
	                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
	                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
	            });
	        }
	        if (ctx.common.async) {
	            return parseUtil_1.ParseStatus.mergeObjectAsync(status, pairs);
	        }
	        else {
	            return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
	        }
	    }
	    get element() {
	        return this._def.valueType;
	    }
	    static create(first, second, third) {
	        if (second instanceof ZodType) {
	            return new ZodRecord({
	                keyType: first,
	                valueType: second,
	                typeName: ZodFirstPartyTypeKind.ZodRecord,
	                ...processCreateParams(third),
	            });
	        }
	        return new ZodRecord({
	            keyType: ZodString.create(),
	            valueType: first,
	            typeName: ZodFirstPartyTypeKind.ZodRecord,
	            ...processCreateParams(second),
	        });
	    }
	}
	exports.ZodRecord = ZodRecord;
	class ZodMap extends ZodType {
	    get keySchema() {
	        return this._def.keyType;
	    }
	    get valueSchema() {
	        return this._def.valueType;
	    }
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== util_1.ZodParsedType.map) {
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.map,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        const keyType = this._def.keyType;
	        const valueType = this._def.valueType;
	        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
	            return {
	                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
	                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"])),
	            };
	        });
	        if (ctx.common.async) {
	            const finalMap = new Map();
	            return Promise.resolve().then(async () => {
	                for (const pair of pairs) {
	                    const key = await pair.key;
	                    const value = await pair.value;
	                    if (key.status === "aborted" || value.status === "aborted") {
	                        return parseUtil_1.INVALID;
	                    }
	                    if (key.status === "dirty" || value.status === "dirty") {
	                        status.dirty();
	                    }
	                    finalMap.set(key.value, value.value);
	                }
	                return { status: status.value, value: finalMap };
	            });
	        }
	        else {
	            const finalMap = new Map();
	            for (const pair of pairs) {
	                const key = pair.key;
	                const value = pair.value;
	                if (key.status === "aborted" || value.status === "aborted") {
	                    return parseUtil_1.INVALID;
	                }
	                if (key.status === "dirty" || value.status === "dirty") {
	                    status.dirty();
	                }
	                finalMap.set(key.value, value.value);
	            }
	            return { status: status.value, value: finalMap };
	        }
	    }
	}
	exports.ZodMap = ZodMap;
	ZodMap.create = (keyType, valueType, params) => {
	    return new ZodMap({
	        valueType,
	        keyType,
	        typeName: ZodFirstPartyTypeKind.ZodMap,
	        ...processCreateParams(params),
	    });
	};
	class ZodSet extends ZodType {
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== util_1.ZodParsedType.set) {
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.set,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        const def = this._def;
	        if (def.minSize !== null) {
	            if (ctx.data.size < def.minSize.value) {
	                (0, parseUtil_1.addIssueToContext)(ctx, {
	                    code: ZodError_1.ZodIssueCode.too_small,
	                    minimum: def.minSize.value,
	                    type: "set",
	                    inclusive: true,
	                    exact: false,
	                    message: def.minSize.message,
	                });
	                status.dirty();
	            }
	        }
	        if (def.maxSize !== null) {
	            if (ctx.data.size > def.maxSize.value) {
	                (0, parseUtil_1.addIssueToContext)(ctx, {
	                    code: ZodError_1.ZodIssueCode.too_big,
	                    maximum: def.maxSize.value,
	                    type: "set",
	                    inclusive: true,
	                    exact: false,
	                    message: def.maxSize.message,
	                });
	                status.dirty();
	            }
	        }
	        const valueType = this._def.valueType;
	        function finalizeSet(elements) {
	            const parsedSet = new Set();
	            for (const element of elements) {
	                if (element.status === "aborted")
	                    return parseUtil_1.INVALID;
	                if (element.status === "dirty")
	                    status.dirty();
	                parsedSet.add(element.value);
	            }
	            return { status: status.value, value: parsedSet };
	        }
	        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
	        if (ctx.common.async) {
	            return Promise.all(elements).then((elements) => finalizeSet(elements));
	        }
	        else {
	            return finalizeSet(elements);
	        }
	    }
	    min(minSize, message) {
	        return new ZodSet({
	            ...this._def,
	            minSize: { value: minSize, message: errorUtil_1.errorUtil.toString(message) },
	        });
	    }
	    max(maxSize, message) {
	        return new ZodSet({
	            ...this._def,
	            maxSize: { value: maxSize, message: errorUtil_1.errorUtil.toString(message) },
	        });
	    }
	    size(size, message) {
	        return this.min(size, message).max(size, message);
	    }
	    nonempty(message) {
	        return this.min(1, message);
	    }
	}
	exports.ZodSet = ZodSet;
	ZodSet.create = (valueType, params) => {
	    return new ZodSet({
	        valueType,
	        minSize: null,
	        maxSize: null,
	        typeName: ZodFirstPartyTypeKind.ZodSet,
	        ...processCreateParams(params),
	    });
	};
	class ZodFunction extends ZodType {
	    constructor() {
	        super(...arguments);
	        this.validate = this.implement;
	    }
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== util_1.ZodParsedType.function) {
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.function,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        function makeArgsIssue(args, error) {
	            return (0, parseUtil_1.makeIssue)({
	                data: args,
	                path: ctx.path,
	                errorMaps: [
	                    ctx.common.contextualErrorMap,
	                    ctx.schemaErrorMap,
	                    (0, errors_1.getErrorMap)(),
	                    errors_1.defaultErrorMap,
	                ].filter((x) => !!x),
	                issueData: {
	                    code: ZodError_1.ZodIssueCode.invalid_arguments,
	                    argumentsError: error,
	                },
	            });
	        }
	        function makeReturnsIssue(returns, error) {
	            return (0, parseUtil_1.makeIssue)({
	                data: returns,
	                path: ctx.path,
	                errorMaps: [
	                    ctx.common.contextualErrorMap,
	                    ctx.schemaErrorMap,
	                    (0, errors_1.getErrorMap)(),
	                    errors_1.defaultErrorMap,
	                ].filter((x) => !!x),
	                issueData: {
	                    code: ZodError_1.ZodIssueCode.invalid_return_type,
	                    returnTypeError: error,
	                },
	            });
	        }
	        const params = { errorMap: ctx.common.contextualErrorMap };
	        const fn = ctx.data;
	        if (this._def.returns instanceof ZodPromise) {
	            // Would love a way to avoid disabling this rule, but we need
	            // an alias (using an arrow function was what caused 2651).
	            // eslint-disable-next-line @typescript-eslint/no-this-alias
	            const me = this;
	            return (0, parseUtil_1.OK)(async function (...args) {
	                const error = new ZodError_1.ZodError([]);
	                const parsedArgs = await me._def.args
	                    .parseAsync(args, params)
	                    .catch((e) => {
	                    error.addIssue(makeArgsIssue(args, e));
	                    throw error;
	                });
	                const result = await Reflect.apply(fn, this, parsedArgs);
	                const parsedReturns = await me._def.returns._def.type
	                    .parseAsync(result, params)
	                    .catch((e) => {
	                    error.addIssue(makeReturnsIssue(result, e));
	                    throw error;
	                });
	                return parsedReturns;
	            });
	        }
	        else {
	            // Would love a way to avoid disabling this rule, but we need
	            // an alias (using an arrow function was what caused 2651).
	            // eslint-disable-next-line @typescript-eslint/no-this-alias
	            const me = this;
	            return (0, parseUtil_1.OK)(function (...args) {
	                const parsedArgs = me._def.args.safeParse(args, params);
	                if (!parsedArgs.success) {
	                    throw new ZodError_1.ZodError([makeArgsIssue(args, parsedArgs.error)]);
	                }
	                const result = Reflect.apply(fn, this, parsedArgs.data);
	                const parsedReturns = me._def.returns.safeParse(result, params);
	                if (!parsedReturns.success) {
	                    throw new ZodError_1.ZodError([makeReturnsIssue(result, parsedReturns.error)]);
	                }
	                return parsedReturns.data;
	            });
	        }
	    }
	    parameters() {
	        return this._def.args;
	    }
	    returnType() {
	        return this._def.returns;
	    }
	    args(...items) {
	        return new ZodFunction({
	            ...this._def,
	            args: ZodTuple.create(items).rest(ZodUnknown.create()),
	        });
	    }
	    returns(returnType) {
	        return new ZodFunction({
	            ...this._def,
	            returns: returnType,
	        });
	    }
	    implement(func) {
	        const validatedFunc = this.parse(func);
	        return validatedFunc;
	    }
	    strictImplement(func) {
	        const validatedFunc = this.parse(func);
	        return validatedFunc;
	    }
	    static create(args, returns, params) {
	        return new ZodFunction({
	            args: (args
	                ? args
	                : ZodTuple.create([]).rest(ZodUnknown.create())),
	            returns: returns || ZodUnknown.create(),
	            typeName: ZodFirstPartyTypeKind.ZodFunction,
	            ...processCreateParams(params),
	        });
	    }
	}
	exports.ZodFunction = ZodFunction;
	class ZodLazy extends ZodType {
	    get schema() {
	        return this._def.getter();
	    }
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        const lazySchema = this._def.getter();
	        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
	    }
	}
	exports.ZodLazy = ZodLazy;
	ZodLazy.create = (getter, params) => {
	    return new ZodLazy({
	        getter: getter,
	        typeName: ZodFirstPartyTypeKind.ZodLazy,
	        ...processCreateParams(params),
	    });
	};
	class ZodLiteral extends ZodType {
	    _parse(input) {
	        if (input.data !== this._def.value) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                received: ctx.data,
	                code: ZodError_1.ZodIssueCode.invalid_literal,
	                expected: this._def.value,
	            });
	            return parseUtil_1.INVALID;
	        }
	        return { status: "valid", value: input.data };
	    }
	    get value() {
	        return this._def.value;
	    }
	}
	exports.ZodLiteral = ZodLiteral;
	ZodLiteral.create = (value, params) => {
	    return new ZodLiteral({
	        value: value,
	        typeName: ZodFirstPartyTypeKind.ZodLiteral,
	        ...processCreateParams(params),
	    });
	};
	function createZodEnum(values, params) {
	    return new ZodEnum({
	        values,
	        typeName: ZodFirstPartyTypeKind.ZodEnum,
	        ...processCreateParams(params),
	    });
	}
	class ZodEnum extends ZodType {
	    _parse(input) {
	        if (typeof input.data !== "string") {
	            const ctx = this._getOrReturnCtx(input);
	            const expectedValues = this._def.values;
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                expected: util_1.util.joinValues(expectedValues),
	                received: ctx.parsedType,
	                code: ZodError_1.ZodIssueCode.invalid_type,
	            });
	            return parseUtil_1.INVALID;
	        }
	        if (this._def.values.indexOf(input.data) === -1) {
	            const ctx = this._getOrReturnCtx(input);
	            const expectedValues = this._def.values;
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                received: ctx.data,
	                code: ZodError_1.ZodIssueCode.invalid_enum_value,
	                options: expectedValues,
	            });
	            return parseUtil_1.INVALID;
	        }
	        return (0, parseUtil_1.OK)(input.data);
	    }
	    get options() {
	        return this._def.values;
	    }
	    get enum() {
	        const enumValues = {};
	        for (const val of this._def.values) {
	            enumValues[val] = val;
	        }
	        return enumValues;
	    }
	    get Values() {
	        const enumValues = {};
	        for (const val of this._def.values) {
	            enumValues[val] = val;
	        }
	        return enumValues;
	    }
	    get Enum() {
	        const enumValues = {};
	        for (const val of this._def.values) {
	            enumValues[val] = val;
	        }
	        return enumValues;
	    }
	    extract(values) {
	        return ZodEnum.create(values);
	    }
	    exclude(values) {
	        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
	    }
	}
	exports.ZodEnum = ZodEnum;
	ZodEnum.create = createZodEnum;
	class ZodNativeEnum extends ZodType {
	    _parse(input) {
	        const nativeEnumValues = util_1.util.getValidEnumValues(this._def.values);
	        const ctx = this._getOrReturnCtx(input);
	        if (ctx.parsedType !== util_1.ZodParsedType.string &&
	            ctx.parsedType !== util_1.ZodParsedType.number) {
	            const expectedValues = util_1.util.objectValues(nativeEnumValues);
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                expected: util_1.util.joinValues(expectedValues),
	                received: ctx.parsedType,
	                code: ZodError_1.ZodIssueCode.invalid_type,
	            });
	            return parseUtil_1.INVALID;
	        }
	        if (nativeEnumValues.indexOf(input.data) === -1) {
	            const expectedValues = util_1.util.objectValues(nativeEnumValues);
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                received: ctx.data,
	                code: ZodError_1.ZodIssueCode.invalid_enum_value,
	                options: expectedValues,
	            });
	            return parseUtil_1.INVALID;
	        }
	        return (0, parseUtil_1.OK)(input.data);
	    }
	    get enum() {
	        return this._def.values;
	    }
	}
	exports.ZodNativeEnum = ZodNativeEnum;
	ZodNativeEnum.create = (values, params) => {
	    return new ZodNativeEnum({
	        values: values,
	        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
	        ...processCreateParams(params),
	    });
	};
	class ZodPromise extends ZodType {
	    unwrap() {
	        return this._def.type;
	    }
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== util_1.ZodParsedType.promise &&
	            ctx.common.async === false) {
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.promise,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        const promisified = ctx.parsedType === util_1.ZodParsedType.promise
	            ? ctx.data
	            : Promise.resolve(ctx.data);
	        return (0, parseUtil_1.OK)(promisified.then((data) => {
	            return this._def.type.parseAsync(data, {
	                path: ctx.path,
	                errorMap: ctx.common.contextualErrorMap,
	            });
	        }));
	    }
	}
	exports.ZodPromise = ZodPromise;
	ZodPromise.create = (schema, params) => {
	    return new ZodPromise({
	        type: schema,
	        typeName: ZodFirstPartyTypeKind.ZodPromise,
	        ...processCreateParams(params),
	    });
	};
	class ZodEffects extends ZodType {
	    innerType() {
	        return this._def.schema;
	    }
	    sourceType() {
	        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects
	            ? this._def.schema.sourceType()
	            : this._def.schema;
	    }
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        const effect = this._def.effect || null;
	        const checkCtx = {
	            addIssue: (arg) => {
	                (0, parseUtil_1.addIssueToContext)(ctx, arg);
	                if (arg.fatal) {
	                    status.abort();
	                }
	                else {
	                    status.dirty();
	                }
	            },
	            get path() {
	                return ctx.path;
	            },
	        };
	        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
	        if (effect.type === "preprocess") {
	            const processed = effect.transform(ctx.data, checkCtx);
	            if (ctx.common.issues.length) {
	                return {
	                    status: "dirty",
	                    value: ctx.data,
	                };
	            }
	            if (ctx.common.async) {
	                return Promise.resolve(processed).then((processed) => {
	                    return this._def.schema._parseAsync({
	                        data: processed,
	                        path: ctx.path,
	                        parent: ctx,
	                    });
	                });
	            }
	            else {
	                return this._def.schema._parseSync({
	                    data: processed,
	                    path: ctx.path,
	                    parent: ctx,
	                });
	            }
	        }
	        if (effect.type === "refinement") {
	            const executeRefinement = (acc
	            // effect: RefinementEffect<any>
	            ) => {
	                const result = effect.refinement(acc, checkCtx);
	                if (ctx.common.async) {
	                    return Promise.resolve(result);
	                }
	                if (result instanceof Promise) {
	                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
	                }
	                return acc;
	            };
	            if (ctx.common.async === false) {
	                const inner = this._def.schema._parseSync({
	                    data: ctx.data,
	                    path: ctx.path,
	                    parent: ctx,
	                });
	                if (inner.status === "aborted")
	                    return parseUtil_1.INVALID;
	                if (inner.status === "dirty")
	                    status.dirty();
	                // return value is ignored
	                executeRefinement(inner.value);
	                return { status: status.value, value: inner.value };
	            }
	            else {
	                return this._def.schema
	                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
	                    .then((inner) => {
	                    if (inner.status === "aborted")
	                        return parseUtil_1.INVALID;
	                    if (inner.status === "dirty")
	                        status.dirty();
	                    return executeRefinement(inner.value).then(() => {
	                        return { status: status.value, value: inner.value };
	                    });
	                });
	            }
	        }
	        if (effect.type === "transform") {
	            if (ctx.common.async === false) {
	                const base = this._def.schema._parseSync({
	                    data: ctx.data,
	                    path: ctx.path,
	                    parent: ctx,
	                });
	                if (!(0, parseUtil_1.isValid)(base))
	                    return base;
	                const result = effect.transform(base.value, checkCtx);
	                if (result instanceof Promise) {
	                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
	                }
	                return { status: status.value, value: result };
	            }
	            else {
	                return this._def.schema
	                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
	                    .then((base) => {
	                    if (!(0, parseUtil_1.isValid)(base))
	                        return base;
	                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
	                });
	            }
	        }
	        util_1.util.assertNever(effect);
	    }
	}
	exports.ZodEffects = ZodEffects;
	exports.ZodTransformer = ZodEffects;
	ZodEffects.create = (schema, effect, params) => {
	    return new ZodEffects({
	        schema,
	        typeName: ZodFirstPartyTypeKind.ZodEffects,
	        effect,
	        ...processCreateParams(params),
	    });
	};
	ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
	    return new ZodEffects({
	        schema,
	        effect: { type: "preprocess", transform: preprocess },
	        typeName: ZodFirstPartyTypeKind.ZodEffects,
	        ...processCreateParams(params),
	    });
	};
	class ZodOptional extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType === util_1.ZodParsedType.undefined) {
	            return (0, parseUtil_1.OK)(undefined);
	        }
	        return this._def.innerType._parse(input);
	    }
	    unwrap() {
	        return this._def.innerType;
	    }
	}
	exports.ZodOptional = ZodOptional;
	ZodOptional.create = (type, params) => {
	    return new ZodOptional({
	        innerType: type,
	        typeName: ZodFirstPartyTypeKind.ZodOptional,
	        ...processCreateParams(params),
	    });
	};
	class ZodNullable extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType === util_1.ZodParsedType.null) {
	            return (0, parseUtil_1.OK)(null);
	        }
	        return this._def.innerType._parse(input);
	    }
	    unwrap() {
	        return this._def.innerType;
	    }
	}
	exports.ZodNullable = ZodNullable;
	ZodNullable.create = (type, params) => {
	    return new ZodNullable({
	        innerType: type,
	        typeName: ZodFirstPartyTypeKind.ZodNullable,
	        ...processCreateParams(params),
	    });
	};
	class ZodDefault extends ZodType {
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        let data = ctx.data;
	        if (ctx.parsedType === util_1.ZodParsedType.undefined) {
	            data = this._def.defaultValue();
	        }
	        return this._def.innerType._parse({
	            data,
	            path: ctx.path,
	            parent: ctx,
	        });
	    }
	    removeDefault() {
	        return this._def.innerType;
	    }
	}
	exports.ZodDefault = ZodDefault;
	ZodDefault.create = (type, params) => {
	    return new ZodDefault({
	        innerType: type,
	        typeName: ZodFirstPartyTypeKind.ZodDefault,
	        defaultValue: typeof params.default === "function"
	            ? params.default
	            : () => params.default,
	        ...processCreateParams(params),
	    });
	};
	class ZodCatch extends ZodType {
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        // newCtx is used to not collect issues from inner types in ctx
	        const newCtx = {
	            ...ctx,
	            common: {
	                ...ctx.common,
	                issues: [],
	            },
	        };
	        const result = this._def.innerType._parse({
	            data: newCtx.data,
	            path: newCtx.path,
	            parent: {
	                ...newCtx,
	            },
	        });
	        if ((0, parseUtil_1.isAsync)(result)) {
	            return result.then((result) => {
	                return {
	                    status: "valid",
	                    value: result.status === "valid"
	                        ? result.value
	                        : this._def.catchValue({
	                            get error() {
	                                return new ZodError_1.ZodError(newCtx.common.issues);
	                            },
	                            input: newCtx.data,
	                        }),
	                };
	            });
	        }
	        else {
	            return {
	                status: "valid",
	                value: result.status === "valid"
	                    ? result.value
	                    : this._def.catchValue({
	                        get error() {
	                            return new ZodError_1.ZodError(newCtx.common.issues);
	                        },
	                        input: newCtx.data,
	                    }),
	            };
	        }
	    }
	    removeCatch() {
	        return this._def.innerType;
	    }
	}
	exports.ZodCatch = ZodCatch;
	ZodCatch.create = (type, params) => {
	    return new ZodCatch({
	        innerType: type,
	        typeName: ZodFirstPartyTypeKind.ZodCatch,
	        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
	        ...processCreateParams(params),
	    });
	};
	class ZodNaN extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType !== util_1.ZodParsedType.nan) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.nan,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        return { status: "valid", value: input.data };
	    }
	}
	exports.ZodNaN = ZodNaN;
	ZodNaN.create = (params) => {
	    return new ZodNaN({
	        typeName: ZodFirstPartyTypeKind.ZodNaN,
	        ...processCreateParams(params),
	    });
	};
	exports.BRAND = Symbol("zod_brand");
	class ZodBranded extends ZodType {
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        const data = ctx.data;
	        return this._def.type._parse({
	            data,
	            path: ctx.path,
	            parent: ctx,
	        });
	    }
	    unwrap() {
	        return this._def.type;
	    }
	}
	exports.ZodBranded = ZodBranded;
	class ZodPipeline extends ZodType {
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        if (ctx.common.async) {
	            const handleAsync = async () => {
	                const inResult = await this._def.in._parseAsync({
	                    data: ctx.data,
	                    path: ctx.path,
	                    parent: ctx,
	                });
	                if (inResult.status === "aborted")
	                    return parseUtil_1.INVALID;
	                if (inResult.status === "dirty") {
	                    status.dirty();
	                    return (0, parseUtil_1.DIRTY)(inResult.value);
	                }
	                else {
	                    return this._def.out._parseAsync({
	                        data: inResult.value,
	                        path: ctx.path,
	                        parent: ctx,
	                    });
	                }
	            };
	            return handleAsync();
	        }
	        else {
	            const inResult = this._def.in._parseSync({
	                data: ctx.data,
	                path: ctx.path,
	                parent: ctx,
	            });
	            if (inResult.status === "aborted")
	                return parseUtil_1.INVALID;
	            if (inResult.status === "dirty") {
	                status.dirty();
	                return {
	                    status: "dirty",
	                    value: inResult.value,
	                };
	            }
	            else {
	                return this._def.out._parseSync({
	                    data: inResult.value,
	                    path: ctx.path,
	                    parent: ctx,
	                });
	            }
	        }
	    }
	    static create(a, b) {
	        return new ZodPipeline({
	            in: a,
	            out: b,
	            typeName: ZodFirstPartyTypeKind.ZodPipeline,
	        });
	    }
	}
	exports.ZodPipeline = ZodPipeline;
	class ZodReadonly extends ZodType {
	    _parse(input) {
	        const result = this._def.innerType._parse(input);
	        if ((0, parseUtil_1.isValid)(result)) {
	            result.value = Object.freeze(result.value);
	        }
	        return result;
	    }
	}
	exports.ZodReadonly = ZodReadonly;
	ZodReadonly.create = (type, params) => {
	    return new ZodReadonly({
	        innerType: type,
	        typeName: ZodFirstPartyTypeKind.ZodReadonly,
	        ...processCreateParams(params),
	    });
	};
	const custom = (check, params = {}, 
	/**
	 * @deprecated
	 *
	 * Pass `fatal` into the params object instead:
	 *
	 * ```ts
	 * z.string().custom((val) => val.length > 5, { fatal: false })
	 * ```
	 *
	 */
	fatal) => {
	    if (check)
	        return ZodAny.create().superRefine((data, ctx) => {
	            var _a, _b;
	            if (!check(data)) {
	                const p = typeof params === "function"
	                    ? params(data)
	                    : typeof params === "string"
	                        ? { message: params }
	                        : params;
	                const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
	                const p2 = typeof p === "string" ? { message: p } : p;
	                ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
	            }
	        });
	    return ZodAny.create();
	};
	exports.custom = custom;
	exports.late = {
	    object: ZodObject.lazycreate,
	};
	var ZodFirstPartyTypeKind;
	(function (ZodFirstPartyTypeKind) {
	    ZodFirstPartyTypeKind["ZodString"] = "ZodString";
	    ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
	    ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
	    ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
	    ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
	    ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
	    ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
	    ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
	    ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
	    ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
	    ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
	    ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
	    ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
	    ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
	    ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
	    ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
	    ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
	    ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
	    ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
	    ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
	    ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
	    ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
	    ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
	    ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
	    ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
	    ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
	    ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
	    ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
	    ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
	    ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
	    ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
	    ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
	    ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
	    ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
	    ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
	    ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
	})(ZodFirstPartyTypeKind = exports.ZodFirstPartyTypeKind || (exports.ZodFirstPartyTypeKind = {}));
	const instanceOfType = (
	// const instanceOfType = <T extends new (...args: any[]) => any>(
	cls, params = {
	    message: `Input not instance of ${cls.name}`,
	}) => (0, exports.custom)((data) => data instanceof cls, params);
	exports.instanceof = instanceOfType;
	const stringType = ZodString.create;
	exports.string = stringType;
	const numberType = ZodNumber.create;
	exports.number = numberType;
	const nanType = ZodNaN.create;
	exports.nan = nanType;
	const bigIntType = ZodBigInt.create;
	exports.bigint = bigIntType;
	const booleanType = ZodBoolean.create;
	exports.boolean = booleanType;
	const dateType = ZodDate.create;
	exports.date = dateType;
	const symbolType = ZodSymbol.create;
	exports.symbol = symbolType;
	const undefinedType = ZodUndefined.create;
	exports.undefined = undefinedType;
	const nullType = ZodNull.create;
	exports.null = nullType;
	const anyType = ZodAny.create;
	exports.any = anyType;
	const unknownType = ZodUnknown.create;
	exports.unknown = unknownType;
	const neverType = ZodNever.create;
	exports.never = neverType;
	const voidType = ZodVoid.create;
	exports.void = voidType;
	const arrayType = ZodArray.create;
	exports.array = arrayType;
	const objectType = ZodObject.create;
	exports.object = objectType;
	const strictObjectType = ZodObject.strictCreate;
	exports.strictObject = strictObjectType;
	const unionType = ZodUnion.create;
	exports.union = unionType;
	const discriminatedUnionType = ZodDiscriminatedUnion.create;
	exports.discriminatedUnion = discriminatedUnionType;
	const intersectionType = ZodIntersection.create;
	exports.intersection = intersectionType;
	const tupleType = ZodTuple.create;
	exports.tuple = tupleType;
	const recordType = ZodRecord.create;
	exports.record = recordType;
	const mapType = ZodMap.create;
	exports.map = mapType;
	const setType = ZodSet.create;
	exports.set = setType;
	const functionType = ZodFunction.create;
	exports.function = functionType;
	const lazyType = ZodLazy.create;
	exports.lazy = lazyType;
	const literalType = ZodLiteral.create;
	exports.literal = literalType;
	const enumType = ZodEnum.create;
	exports.enum = enumType;
	const nativeEnumType = ZodNativeEnum.create;
	exports.nativeEnum = nativeEnumType;
	const promiseType = ZodPromise.create;
	exports.promise = promiseType;
	const effectsType = ZodEffects.create;
	exports.effect = effectsType;
	exports.transformer = effectsType;
	const optionalType = ZodOptional.create;
	exports.optional = optionalType;
	const nullableType = ZodNullable.create;
	exports.nullable = nullableType;
	const preprocessType = ZodEffects.createWithPreprocess;
	exports.preprocess = preprocessType;
	const pipelineType = ZodPipeline.create;
	exports.pipeline = pipelineType;
	const ostring = () => stringType().optional();
	exports.ostring = ostring;
	const onumber = () => numberType().optional();
	exports.onumber = onumber;
	const oboolean = () => booleanType().optional();
	exports.oboolean = oboolean;
	exports.coerce = {
	    string: ((arg) => ZodString.create({ ...arg, coerce: true })),
	    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),
	    boolean: ((arg) => ZodBoolean.create({
	        ...arg,
	        coerce: true,
	    })),
	    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),
	    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),
	};
	exports.NEVER = parseUtil_1.INVALID; 
} (types$1$1));

(function (exports) {
	var __createBinding = (external$1 && external$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (external$1 && external$1.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar(errors$1, exports);
	__exportStar(parseUtil$1, exports);
	__exportStar(typeAliases$1, exports);
	__exportStar(util$2, exports);
	__exportStar(types$1$1, exports);
	__exportStar(ZodError$1$1, exports); 
} (external$1));

(function (exports) {
	var __createBinding = (lib$2 && lib$2.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (lib$2 && lib$2.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (lib$2 && lib$2.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __exportStar = (lib$2 && lib$2.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.z = void 0;
	const z = __importStar(external$1);
	exports.z = z;
	__exportStar(external$1, exports);
	exports.default = z; 
} (lib$2));

var consts = {};

var ansiStyles$1 = {exports: {}};

var colorName = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

/* MIT license */

/* eslint-disable no-mixed-operators */
const cssKeywords = colorName;

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

const reverseKeywords = {};
for (const key of Object.keys(cssKeywords)) {
	reverseKeywords[cssKeywords[key]] = key;
}

const convert$2 = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

var conversions$3 = convert$2;

// Hide .channels and .labels properties
for (const model of Object.keys(convert$2)) {
	if (!('channels' in convert$2[model])) {
		throw new Error('missing channels property: ' + model);
	}

	if (!('labels' in convert$2[model])) {
		throw new Error('missing channel labels property: ' + model);
	}

	if (convert$2[model].labels.length !== convert$2[model].channels) {
		throw new Error('channel and label counts mismatch: ' + model);
	}

	const {channels, labels} = convert$2[model];
	delete convert$2[model].channels;
	delete convert$2[model].labels;
	Object.defineProperty(convert$2[model], 'channels', {value: channels});
	Object.defineProperty(convert$2[model], 'labels', {value: labels});
}

convert$2.rgb.hsl = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const min = Math.min(r, g, b);
	const max = Math.max(r, g, b);
	const delta = max - min;
	let h;
	let s;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	const l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert$2.rgb.hsv = function (rgb) {
	let rdif;
	let gdif;
	let bdif;
	let h;
	let s;

	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const v = Math.max(r, g, b);
	const diff = v - Math.min(r, g, b);
	const diffc = function (c) {
		return (v - c) / 6 / diff + 1 / 2;
	};

	if (diff === 0) {
		h = 0;
		s = 0;
	} else {
		s = diff / v;
		rdif = diffc(r);
		gdif = diffc(g);
		bdif = diffc(b);

		if (r === v) {
			h = bdif - gdif;
		} else if (g === v) {
			h = (1 / 3) + rdif - bdif;
		} else if (b === v) {
			h = (2 / 3) + gdif - rdif;
		}

		if (h < 0) {
			h += 1;
		} else if (h > 1) {
			h -= 1;
		}
	}

	return [
		h * 360,
		s * 100,
		v * 100
	];
};

convert$2.rgb.hwb = function (rgb) {
	const r = rgb[0];
	const g = rgb[1];
	let b = rgb[2];
	const h = convert$2.rgb.hsl(rgb)[0];
	const w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert$2.rgb.cmyk = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;

	const k = Math.min(1 - r, 1 - g, 1 - b);
	const c = (1 - r - k) / (1 - k) || 0;
	const m = (1 - g - k) / (1 - k) || 0;
	const y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

function comparativeDistance(x, y) {
	/*
		See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
	*/
	return (
		((x[0] - y[0]) ** 2) +
		((x[1] - y[1]) ** 2) +
		((x[2] - y[2]) ** 2)
	);
}

convert$2.rgb.keyword = function (rgb) {
	const reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	let currentClosestDistance = Infinity;
	let currentClosestKeyword;

	for (const keyword of Object.keys(cssKeywords)) {
		const value = cssKeywords[keyword];

		// Compute comparative distance
		const distance = comparativeDistance(rgb, value);

		// Check if its less, if so set as closest
		if (distance < currentClosestDistance) {
			currentClosestDistance = distance;
			currentClosestKeyword = keyword;
		}
	}

	return currentClosestKeyword;
};

convert$2.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert$2.rgb.xyz = function (rgb) {
	let r = rgb[0] / 255;
	let g = rgb[1] / 255;
	let b = rgb[2] / 255;

	// Assume sRGB
	r = r > 0.04045 ? (((r + 0.055) / 1.055) ** 2.4) : (r / 12.92);
	g = g > 0.04045 ? (((g + 0.055) / 1.055) ** 2.4) : (g / 12.92);
	b = b > 0.04045 ? (((b + 0.055) / 1.055) ** 2.4) : (b / 12.92);

	const x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	const y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	const z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert$2.rgb.lab = function (rgb) {
	const xyz = convert$2.rgb.xyz(rgb);
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert$2.hsl.rgb = function (hsl) {
	const h = hsl[0] / 360;
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;
	let t2;
	let t3;
	let val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	const t1 = 2 * l - t2;

	const rgb = [0, 0, 0];
	for (let i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}

		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert$2.hsl.hsv = function (hsl) {
	const h = hsl[0];
	let s = hsl[1] / 100;
	let l = hsl[2] / 100;
	let smin = s;
	const lmin = Math.max(l, 0.01);

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	const v = (l + s) / 2;
	const sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert$2.hsv.rgb = function (hsv) {
	const h = hsv[0] / 60;
	const s = hsv[1] / 100;
	let v = hsv[2] / 100;
	const hi = Math.floor(h) % 6;

	const f = h - Math.floor(h);
	const p = 255 * v * (1 - s);
	const q = 255 * v * (1 - (s * f));
	const t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert$2.hsv.hsl = function (hsv) {
	const h = hsv[0];
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;
	const vmin = Math.max(v, 0.01);
	let sl;
	let l;

	l = (2 - s) * v;
	const lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert$2.hwb.rgb = function (hwb) {
	const h = hwb[0] / 360;
	let wh = hwb[1] / 100;
	let bl = hwb[2] / 100;
	const ratio = wh + bl;
	let f;

	// Wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	const i = Math.floor(6 * h);
	const v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	const n = wh + f * (v - wh); // Linear interpolation

	let r;
	let g;
	let b;
	/* eslint-disable max-statements-per-line,no-multi-spaces */
	switch (i) {
		default:
		case 6:
		case 0: r = v;  g = n;  b = wh; break;
		case 1: r = n;  g = v;  b = wh; break;
		case 2: r = wh; g = v;  b = n; break;
		case 3: r = wh; g = n;  b = v; break;
		case 4: r = n;  g = wh; b = v; break;
		case 5: r = v;  g = wh; b = n; break;
	}
	/* eslint-enable max-statements-per-line,no-multi-spaces */

	return [r * 255, g * 255, b * 255];
};

convert$2.cmyk.rgb = function (cmyk) {
	const c = cmyk[0] / 100;
	const m = cmyk[1] / 100;
	const y = cmyk[2] / 100;
	const k = cmyk[3] / 100;

	const r = 1 - Math.min(1, c * (1 - k) + k);
	const g = 1 - Math.min(1, m * (1 - k) + k);
	const b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert$2.xyz.rgb = function (xyz) {
	const x = xyz[0] / 100;
	const y = xyz[1] / 100;
	const z = xyz[2] / 100;
	let r;
	let g;
	let b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.204) + (z * 1.0570);

	// Assume sRGB
	r = r > 0.0031308
		? ((1.055 * (r ** (1.0 / 2.4))) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * (g ** (1.0 / 2.4))) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * (b ** (1.0 / 2.4))) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert$2.xyz.lab = function (xyz) {
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert$2.lab.xyz = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let x;
	let y;
	let z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	const y2 = y ** 3;
	const x2 = x ** 3;
	const z2 = z ** 3;
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert$2.lab.lch = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let h;

	const hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	const c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert$2.lch.lab = function (lch) {
	const l = lch[0];
	const c = lch[1];
	const h = lch[2];

	const hr = h / 360 * 2 * Math.PI;
	const a = c * Math.cos(hr);
	const b = c * Math.sin(hr);

	return [l, a, b];
};

convert$2.rgb.ansi16 = function (args, saturation = null) {
	const [r, g, b] = args;
	let value = saturation === null ? convert$2.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	let ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert$2.hsv.ansi16 = function (args) {
	// Optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert$2.rgb.ansi16(convert$2.hsv.rgb(args), args[2]);
};

convert$2.rgb.ansi256 = function (args) {
	const r = args[0];
	const g = args[1];
	const b = args[2];

	// We use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	const ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert$2.ansi16.rgb = function (args) {
	let color = args % 10;

	// Handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	const mult = (~~(args > 50) + 1) * 0.5;
	const r = ((color & 1) * mult) * 255;
	const g = (((color >> 1) & 1) * mult) * 255;
	const b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert$2.ansi256.rgb = function (args) {
	// Handle greyscale
	if (args >= 232) {
		const c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	let rem;
	const r = Math.floor(args / 36) / 5 * 255;
	const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	const b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert$2.rgb.hex = function (args) {
	const integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	const string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert$2.hex.rgb = function (args) {
	const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	let colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(char => {
			return char + char;
		}).join('');
	}

	const integer = parseInt(colorString, 16);
	const r = (integer >> 16) & 0xFF;
	const g = (integer >> 8) & 0xFF;
	const b = integer & 0xFF;

	return [r, g, b];
};

convert$2.rgb.hcg = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const max = Math.max(Math.max(r, g), b);
	const min = Math.min(Math.min(r, g), b);
	const chroma = (max - min);
	let grayscale;
	let hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert$2.hsl.hcg = function (hsl) {
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;

	const c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));

	let f = 0;
	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert$2.hsv.hcg = function (hsv) {
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;

	const c = s * v;
	let f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert$2.hcg.rgb = function (hcg) {
	const h = hcg[0] / 360;
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	const pure = [0, 0, 0];
	const hi = (h % 1) * 6;
	const v = hi % 1;
	const w = 1 - v;
	let mg = 0;

	/* eslint-disable max-statements-per-line */
	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}
	/* eslint-enable max-statements-per-line */

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert$2.hcg.hsv = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const v = c + g * (1.0 - c);
	let f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert$2.hcg.hsl = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const l = g * (1.0 - c) + 0.5 * c;
	let s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert$2.hcg.hwb = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;
	const v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert$2.hwb.hcg = function (hwb) {
	const w = hwb[1] / 100;
	const b = hwb[2] / 100;
	const v = 1 - b;
	const c = v - w;
	let g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert$2.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert$2.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert$2.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert$2.gray.hsl = function (args) {
	return [0, 0, args[0]];
};

convert$2.gray.hsv = convert$2.gray.hsl;

convert$2.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert$2.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert$2.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert$2.gray.hex = function (gray) {
	const val = Math.round(gray[0] / 100 * 255) & 0xFF;
	const integer = (val << 16) + (val << 8) + val;

	const string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert$2.rgb.gray = function (rgb) {
	const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};

const conversions$2 = conversions$3;

/*
	This function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	const graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	const models = Object.keys(conversions$2);

	for (let len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	const graph = buildGraph();
	const queue = [fromModel]; // Unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		const current = queue.pop();
		const adjacents = Object.keys(conversions$2[current]);

		for (let len = adjacents.length, i = 0; i < len; i++) {
			const adjacent = adjacents[i];
			const node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	const path = [graph[toModel].parent, toModel];
	let fn = conversions$2[graph[toModel].parent][toModel];

	let cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions$2[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

var route$1 = function (fromModel) {
	const graph = deriveBFS(fromModel);
	const conversion = {};

	const models = Object.keys(graph);
	for (let len = models.length, i = 0; i < len; i++) {
		const toModel = models[i];
		const node = graph[toModel];

		if (node.parent === null) {
			// No possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};

const conversions$1 = conversions$3;
const route = route$1;

const convert$1 = {};

const models = Object.keys(conversions$1);

function wrapRaw(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];
		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		return fn(args);
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];

		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		const result = fn(args);

		// We're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (let len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(fromModel => {
	convert$1[fromModel] = {};

	Object.defineProperty(convert$1[fromModel], 'channels', {value: conversions$1[fromModel].channels});
	Object.defineProperty(convert$1[fromModel], 'labels', {value: conversions$1[fromModel].labels});

	const routes = route(fromModel);
	const routeModels = Object.keys(routes);

	routeModels.forEach(toModel => {
		const fn = routes[toModel];

		convert$1[fromModel][toModel] = wrapRounded(fn);
		convert$1[fromModel][toModel].raw = wrapRaw(fn);
	});
});

var colorConvert = convert$1;

(function (module) {

	const wrapAnsi16 = (fn, offset) => (...args) => {
		const code = fn(...args);
		return `\u001B[${code + offset}m`;
	};

	const wrapAnsi256 = (fn, offset) => (...args) => {
		const code = fn(...args);
		return `\u001B[${38 + offset};5;${code}m`;
	};

	const wrapAnsi16m = (fn, offset) => (...args) => {
		const rgb = fn(...args);
		return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
	};

	const ansi2ansi = n => n;
	const rgb2rgb = (r, g, b) => [r, g, b];

	const setLazyProperty = (object, property, get) => {
		Object.defineProperty(object, property, {
			get: () => {
				const value = get();

				Object.defineProperty(object, property, {
					value,
					enumerable: true,
					configurable: true
				});

				return value;
			},
			enumerable: true,
			configurable: true
		});
	};

	/** @type {typeof import('color-convert')} */
	let colorConvert$1;
	const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
		if (colorConvert$1 === undefined) {
			colorConvert$1 = colorConvert;
		}

		const offset = isBackground ? 10 : 0;
		const styles = {};

		for (const [sourceSpace, suite] of Object.entries(colorConvert$1)) {
			const name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;
			if (sourceSpace === targetSpace) {
				styles[name] = wrap(identity, offset);
			} else if (typeof suite === 'object') {
				styles[name] = wrap(suite[targetSpace], offset);
			}
		}

		return styles;
	};

	function assembleStyles() {
		const codes = new Map();
		const styles = {
			modifier: {
				reset: [0, 0],
				// 21 isn't widely supported and 22 does the same thing
				bold: [1, 22],
				dim: [2, 22],
				italic: [3, 23],
				underline: [4, 24],
				inverse: [7, 27],
				hidden: [8, 28],
				strikethrough: [9, 29]
			},
			color: {
				black: [30, 39],
				red: [31, 39],
				green: [32, 39],
				yellow: [33, 39],
				blue: [34, 39],
				magenta: [35, 39],
				cyan: [36, 39],
				white: [37, 39],

				// Bright color
				blackBright: [90, 39],
				redBright: [91, 39],
				greenBright: [92, 39],
				yellowBright: [93, 39],
				blueBright: [94, 39],
				magentaBright: [95, 39],
				cyanBright: [96, 39],
				whiteBright: [97, 39]
			},
			bgColor: {
				bgBlack: [40, 49],
				bgRed: [41, 49],
				bgGreen: [42, 49],
				bgYellow: [43, 49],
				bgBlue: [44, 49],
				bgMagenta: [45, 49],
				bgCyan: [46, 49],
				bgWhite: [47, 49],

				// Bright color
				bgBlackBright: [100, 49],
				bgRedBright: [101, 49],
				bgGreenBright: [102, 49],
				bgYellowBright: [103, 49],
				bgBlueBright: [104, 49],
				bgMagentaBright: [105, 49],
				bgCyanBright: [106, 49],
				bgWhiteBright: [107, 49]
			}
		};

		// Alias bright black as gray (and grey)
		styles.color.gray = styles.color.blackBright;
		styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
		styles.color.grey = styles.color.blackBright;
		styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;

		for (const [groupName, group] of Object.entries(styles)) {
			for (const [styleName, style] of Object.entries(group)) {
				styles[styleName] = {
					open: `\u001B[${style[0]}m`,
					close: `\u001B[${style[1]}m`
				};

				group[styleName] = styles[styleName];

				codes.set(style[0], style[1]);
			}

			Object.defineProperty(styles, groupName, {
				value: group,
				enumerable: false
			});
		}

		Object.defineProperty(styles, 'codes', {
			value: codes,
			enumerable: false
		});

		styles.color.close = '\u001B[39m';
		styles.bgColor.close = '\u001B[49m';

		setLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));
		setLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));
		setLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));
		setLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));
		setLazyProperty(styles.bgColor, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));
		setLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));

		return styles;
	}

	// Make the export immutable
	Object.defineProperty(module, 'exports', {
		enumerable: true,
		get: assembleStyles
	}); 
} (ansiStyles$1));

var ansiStylesExports = ansiStyles$1.exports;

const stringReplaceAll$1 = (string, substring, replacer) => {
	let index = string.indexOf(substring);
	if (index === -1) {
		return string;
	}

	const substringLength = substring.length;
	let endIndex = 0;
	let returnValue = '';
	do {
		returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
		endIndex = index + substringLength;
		index = string.indexOf(substring, endIndex);
	} while (index !== -1);

	returnValue += string.substr(endIndex);
	return returnValue;
};

const stringEncaseCRLFWithFirstIndex$1 = (string, prefix, postfix, index) => {
	let endIndex = 0;
	let returnValue = '';
	do {
		const gotCR = string[index - 1] === '\r';
		returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
		endIndex = index + 1;
		index = string.indexOf('\n', endIndex);
	} while (index !== -1);

	returnValue += string.substr(endIndex);
	return returnValue;
};

var util$1$1 = {
	stringReplaceAll: stringReplaceAll$1,
	stringEncaseCRLFWithFirstIndex: stringEncaseCRLFWithFirstIndex$1
};

const TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
const ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;

const ESCAPES = new Map([
	['n', '\n'],
	['r', '\r'],
	['t', '\t'],
	['b', '\b'],
	['f', '\f'],
	['v', '\v'],
	['0', '\0'],
	['\\', '\\'],
	['e', '\u001B'],
	['a', '\u0007']
]);

function unescape(c) {
	const u = c[0] === 'u';
	const bracket = c[1] === '{';

	if ((u && !bracket && c.length === 5) || (c[0] === 'x' && c.length === 3)) {
		return String.fromCharCode(parseInt(c.slice(1), 16));
	}

	if (u && bracket) {
		return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
	}

	return ESCAPES.get(c) || c;
}

function parseArguments(name, arguments_) {
	const results = [];
	const chunks = arguments_.trim().split(/\s*,\s*/g);
	let matches;

	for (const chunk of chunks) {
		const number = Number(chunk);
		if (!Number.isNaN(number)) {
			results.push(number);
		} else if ((matches = chunk.match(STRING_REGEX))) {
			results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
		} else {
			throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
		}
	}

	return results;
}

function parseStyle(style) {
	STYLE_REGEX.lastIndex = 0;

	const results = [];
	let matches;

	while ((matches = STYLE_REGEX.exec(style)) !== null) {
		const name = matches[1];

		if (matches[2]) {
			const args = parseArguments(name, matches[2]);
			results.push([name].concat(args));
		} else {
			results.push([name]);
		}
	}

	return results;
}

function buildStyle(chalk, styles) {
	const enabled = {};

	for (const layer of styles) {
		for (const style of layer.styles) {
			enabled[style[0]] = layer.inverse ? null : style.slice(1);
		}
	}

	let current = chalk;
	for (const [styleName, styles] of Object.entries(enabled)) {
		if (!Array.isArray(styles)) {
			continue;
		}

		if (!(styleName in current)) {
			throw new Error(`Unknown Chalk style: ${styleName}`);
		}

		current = styles.length > 0 ? current[styleName](...styles) : current[styleName];
	}

	return current;
}

var templates = (chalk, temporary) => {
	const styles = [];
	const chunks = [];
	let chunk = [];

	// eslint-disable-next-line max-params
	temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
		if (escapeCharacter) {
			chunk.push(unescape(escapeCharacter));
		} else if (style) {
			const string = chunk.join('');
			chunk = [];
			chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
			styles.push({inverse, styles: parseStyle(style)});
		} else if (close) {
			if (styles.length === 0) {
				throw new Error('Found extraneous } in Chalk template literal');
			}

			chunks.push(buildStyle(chalk, styles)(chunk.join('')));
			chunk = [];
			styles.pop();
		} else {
			chunk.push(character);
		}
	});

	chunks.push(chunk.join(''));

	if (styles.length > 0) {
		const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`;
		throw new Error(errMessage);
	}

	return chunks.join('');
};

const ansiStyles = ansiStylesExports;
const {stdout: stdoutColor, stderr: stderrColor} = supportsColor_1;
const {
	stringReplaceAll,
	stringEncaseCRLFWithFirstIndex
} = util$1$1;

const {isArray} = Array;

// `supportsColor.level` → `ansiStyles.color[name]` mapping
const levelMapping = [
	'ansi',
	'ansi',
	'ansi256',
	'ansi16m'
];

const styles = Object.create(null);

const applyOptions = (object, options = {}) => {
	if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
		throw new Error('The `level` option should be an integer from 0 to 3');
	}

	// Detect level if not set manually
	const colorLevel = stdoutColor ? stdoutColor.level : 0;
	object.level = options.level === undefined ? colorLevel : options.level;
};

class ChalkClass {
	constructor(options) {
		// eslint-disable-next-line no-constructor-return
		return chalkFactory(options);
	}
}

const chalkFactory = options => {
	const chalk = {};
	applyOptions(chalk, options);

	chalk.template = (...arguments_) => chalkTag(chalk.template, ...arguments_);

	Object.setPrototypeOf(chalk, Chalk.prototype);
	Object.setPrototypeOf(chalk.template, chalk);

	chalk.template.constructor = () => {
		throw new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');
	};

	chalk.template.Instance = ChalkClass;

	return chalk.template;
};

function Chalk(options) {
	return chalkFactory(options);
}

for (const [styleName, style] of Object.entries(ansiStyles)) {
	styles[styleName] = {
		get() {
			const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
			Object.defineProperty(this, styleName, {value: builder});
			return builder;
		}
	};
}

styles.visible = {
	get() {
		const builder = createBuilder(this, this._styler, true);
		Object.defineProperty(this, 'visible', {value: builder});
		return builder;
	}
};

const usedModels = ['rgb', 'hex', 'keyword', 'hsl', 'hsv', 'hwb', 'ansi', 'ansi256'];

for (const model of usedModels) {
	styles[model] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			};
		}
	};
}

for (const model of usedModels) {
	const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	styles[bgModel] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			};
		}
	};
}

const proto = Object.defineProperties(() => {}, {
	...styles,
	level: {
		enumerable: true,
		get() {
			return this._generator.level;
		},
		set(level) {
			this._generator.level = level;
		}
	}
});

const createStyler = (open, close, parent) => {
	let openAll;
	let closeAll;
	if (parent === undefined) {
		openAll = open;
		closeAll = close;
	} else {
		openAll = parent.openAll + open;
		closeAll = close + parent.closeAll;
	}

	return {
		open,
		close,
		openAll,
		closeAll,
		parent
	};
};

const createBuilder = (self, _styler, _isEmpty) => {
	const builder = (...arguments_) => {
		if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
			// Called as a template literal, for example: chalk.red`2 + 3 = {bold ${2+3}}`
			return applyStyle(builder, chalkTag(builder, ...arguments_));
		}

		// Single argument is hot path, implicit coercion is faster than anything
		// eslint-disable-next-line no-implicit-coercion
		return applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));
	};

	// We alter the prototype because we must return a function, but there is
	// no way to create a function with a different prototype
	Object.setPrototypeOf(builder, proto);

	builder._generator = self;
	builder._styler = _styler;
	builder._isEmpty = _isEmpty;

	return builder;
};

const applyStyle = (self, string) => {
	if (self.level <= 0 || !string) {
		return self._isEmpty ? '' : string;
	}

	let styler = self._styler;

	if (styler === undefined) {
		return string;
	}

	const {openAll, closeAll} = styler;
	if (string.indexOf('\u001B') !== -1) {
		while (styler !== undefined) {
			// Replace any instances already present with a re-opening code
			// otherwise only the part of the string until said closing code
			// will be colored, and the rest will simply be 'plain'.
			string = stringReplaceAll(string, styler.close, styler.open);

			styler = styler.parent;
		}
	}

	// We can move both next actions out of loop, because remaining actions in loop won't have
	// any/visible effect on parts we add here. Close the styling before a linebreak and reopen
	// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
	const lfIndex = string.indexOf('\n');
	if (lfIndex !== -1) {
		string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
	}

	return openAll + string + closeAll;
};

let template;
const chalkTag = (chalk, ...strings) => {
	const [firstString] = strings;

	if (!isArray(firstString) || !isArray(firstString.raw)) {
		// If chalk() was called by itself or with a string,
		// return the string itself as a string.
		return strings.join(' ');
	}

	const arguments_ = strings.slice(1);
	const parts = [firstString.raw[0]];

	for (let i = 1; i < firstString.length; i++) {
		parts.push(
			String(arguments_[i - 1]).replace(/[{}\\]/g, '\\$&'),
			String(firstString.raw[i])
		);
	}

	if (template === undefined) {
		template = templates;
	}

	return template(chalk, parts.join(''));
};

Object.defineProperties(Chalk.prototype, styles);

const chalk = Chalk(); // eslint-disable-line new-cap
chalk.supportsColor = stdoutColor;
chalk.stderr = Chalk({level: stderrColor ? stderrColor.level : 0}); // eslint-disable-line new-cap
chalk.stderr.supportsColor = stderrColor;

var source = chalk;

var __importDefault$6 = (consts && consts.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(consts, "__esModule", { value: true });
consts.syncKind = consts.serverKind = consts.dummyEventKey = consts.debugPrefix = consts.logPrefix = consts.internalEvents = consts.defaultDevServerHost = consts.defaultInngestEventBaseUrl = consts.defaultInngestApiBaseUrl = consts.headerKeys = consts.envKeys = consts.probe = consts.queryKeys = void 0;
const chalk_1 = __importDefault$6(source);
/**
 * Keys for accessing query parameters included in requests from Inngest to run
 * functions.
 *
 * Used internally to create handlers using `InngestCommHandler`, but can be
 * imported to be used if creating a custom handler outside of the package.
 *
 * @public
 */
var queryKeys;
(function (queryKeys) {
    queryKeys["DeployId"] = "deployId";
    queryKeys["FnId"] = "fnId";
    queryKeys["Probe"] = "probe";
    queryKeys["StepId"] = "stepId";
})(queryKeys || (consts.queryKeys = queryKeys = {}));
var probe;
(function (probe) {
    probe["Trust"] = "trust";
})(probe || (consts.probe = probe = {}));
var envKeys;
(function (envKeys) {
    envKeys["InngestSigningKey"] = "INNGEST_SIGNING_KEY";
    envKeys["InngestSigningKeyFallback"] = "INNGEST_SIGNING_KEY_FALLBACK";
    envKeys["InngestEventKey"] = "INNGEST_EVENT_KEY";
    /**
     * @deprecated Removed in v3. Use {@link InngestBaseUrl} instead.
     */
    envKeys["InngestDevServerUrl"] = "INNGEST_DEVSERVER_URL";
    envKeys["InngestEnvironment"] = "INNGEST_ENV";
    envKeys["InngestBaseUrl"] = "INNGEST_BASE_URL";
    envKeys["InngestEventApiBaseUrl"] = "INNGEST_EVENT_API_BASE_URL";
    envKeys["InngestApiBaseUrl"] = "INNGEST_API_BASE_URL";
    envKeys["InngestServeHost"] = "INNGEST_SERVE_HOST";
    envKeys["InngestServePath"] = "INNGEST_SERVE_PATH";
    envKeys["InngestLogLevel"] = "INNGEST_LOG_LEVEL";
    envKeys["InngestStreaming"] = "INNGEST_STREAMING";
    envKeys["InngestDevMode"] = "INNGEST_DEV";
    envKeys["InngestAllowInBandSync"] = "INNGEST_ALLOW_IN_BAND_SYNC";
    /**
     * @deprecated It's unknown what this env var was used for, but we do not
     * provide explicit support for it. Prefer using `INNGEST_ENV` instead.
     */
    envKeys["BranchName"] = "BRANCH_NAME";
    /**
     * The git branch of the commit the deployment was triggered by. Example:
     * `improve-about-page`.
     *
     * {@link https://vercel.com/docs/concepts/projects/environment-variables/system-environment-variables#system-environment-variables}
     */
    envKeys["VercelBranch"] = "VERCEL_GIT_COMMIT_REF";
    /**
     * Expected to be `"1"` if defined.
     */
    envKeys["IsVercel"] = "VERCEL";
    /**
     * The branch name of the current deployment. May only be accessible at build
     * time, but included here just in case.
     *
     * {@link https://developers.cloudflare.com/pages/platform/build-configuration/#environment-variables}
     */
    envKeys["CloudflarePagesBranch"] = "CF_PAGES_BRANCH";
    /**
     * Expected to be `"1"` if defined.
     */
    envKeys["IsCloudflarePages"] = "CF_PAGES";
    /**
     * The branch name of the deployment from Git to Netlify, if available.
     *
     * {@link https://docs.netlify.com/configure-builds/environment-variables/#git-metadata}
     */
    envKeys["NetlifyBranch"] = "BRANCH";
    /**
     * Expected to be `"true"` if defined.
     */
    envKeys["IsNetlify"] = "NETLIFY";
    /**
     * The Git branch for a service or deploy.
     *
     * {@link https://render.com/docs/environment-variables#all-services}
     */
    envKeys["RenderBranch"] = "RENDER_GIT_BRANCH";
    /**
     * Expected to be `"true"` if defined.
     */
    envKeys["IsRender"] = "RENDER";
    /**
     * The branch that triggered the deployment. Example: `main`
     *
     * {@link https://docs.railway.app/develop/variables#railway-provided-variables}
     */
    envKeys["RailwayBranch"] = "RAILWAY_GIT_BRANCH";
    /**
     * The railway environment for the deployment. Example: `production`
     *
     * {@link https://docs.railway.app/develop/variables#railway-provided-variables}
     */
    envKeys["RailwayEnvironment"] = "RAILWAY_ENVIRONMENT";
    envKeys["VercelEnvKey"] = "VERCEL_ENV";
    envKeys["OpenAiApiKey"] = "OPENAI_API_KEY";
    envKeys["GeminiApiKey"] = "GEMINI_API_KEY";
    envKeys["AnthropicApiKey"] = "ANTHROPIC_API_KEY";
})(envKeys || (consts.envKeys = envKeys = {}));
/**
 * Keys for accessing headers included in requests from Inngest to run
 * functions.
 *
 * Used internally to create handlers using `InngestCommHandler`, but can be
 * imported to be used if creating a custom handler outside of the package.
 *
 * @public
 */
var headerKeys;
(function (headerKeys) {
    headerKeys["ContentLength"] = "content-length";
    headerKeys["Signature"] = "x-inngest-signature";
    headerKeys["SdkVersion"] = "x-inngest-sdk";
    headerKeys["Environment"] = "x-inngest-env";
    headerKeys["Platform"] = "x-inngest-platform";
    headerKeys["Framework"] = "x-inngest-framework";
    headerKeys["NoRetry"] = "x-inngest-no-retry";
    headerKeys["RequestVersion"] = "x-inngest-req-version";
    headerKeys["RetryAfter"] = "retry-after";
    headerKeys["InngestServerKind"] = "x-inngest-server-kind";
    headerKeys["InngestExpectedServerKind"] = "x-inngest-expected-server-kind";
    headerKeys["InngestSyncKind"] = "x-inngest-sync-kind";
    headerKeys["EventIdSeed"] = "x-inngest-event-id-seed";
    headerKeys["TraceParent"] = "traceparent";
    headerKeys["TraceState"] = "tracestate";
})(headerKeys || (consts.headerKeys = headerKeys = {}));
consts.defaultInngestApiBaseUrl = "https://api.inngest.com/";
consts.defaultInngestEventBaseUrl = "https://inn.gs/";
consts.defaultDevServerHost = "http://localhost:8288/";
/**
 * Events that Inngest may send internally that can be used to trigger
 * functions.
 *
 * @public
 */
var internalEvents;
(function (internalEvents) {
    /**
     * A function has failed after exhausting all available retries. This event
     * will contain the original event and the error that caused the failure.
     */
    internalEvents["FunctionFailed"] = "inngest/function.failed";
    internalEvents["FunctionInvoked"] = "inngest/function.invoked";
    internalEvents["FunctionFinished"] = "inngest/function.finished";
    internalEvents["FunctionCancelled"] = "inngest/function.cancelled";
    internalEvents["ScheduledTimer"] = "inngest/scheduled.timer";
})(internalEvents || (consts.internalEvents = internalEvents = {}));
consts.logPrefix = chalk_1.default.magenta.bold("[Inngest]");
consts.debugPrefix = "inngest";
consts.dummyEventKey = "NO_EVENT_KEY_SET";
var serverKind;
(function (serverKind) {
    serverKind["Dev"] = "dev";
    serverKind["Cloud"] = "cloud";
})(serverKind || (consts.serverKind = serverKind = {}));
var syncKind;
(function (syncKind) {
    syncKind["InBand"] = "in_band";
    syncKind["OutOfBand"] = "out_of_band";
})(syncKind || (consts.syncKind = syncKind = {}));

var strings = {};

var hash = {};

var utils$a = {};

var minimalisticAssert = assert$5;

function assert$5(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert$5.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};

var inherits$1 = {exports: {}};

var inherits_browser = {exports: {}};

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  inherits_browser.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  inherits_browser.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}

var inherits_browserExports = inherits_browser.exports;

try {
  var util$3 = require$$0$1$1;
  /* istanbul ignore next */
  if (typeof util$3.inherits !== 'function') throw '';
  inherits$1.exports = util$3.inherits;
} catch (e) {
  /* istanbul ignore next */
  inherits$1.exports = inherits_browserExports;
}

var inheritsExports = inherits$1.exports;

var assert$4 = minimalisticAssert;
var inherits = inheritsExports;

utils$a.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        } else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
utils$a.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils$a.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
utils$a.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
utils$a.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils$a.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
utils$a.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert$4(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
utils$a.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
utils$a.split32 = split32;

function rotr32$1(w, b) {
  return (w >>> b) | (w << (32 - b));
}
utils$a.rotr32 = rotr32$1;

function rotl32$2(w, b) {
  return (w << b) | (w >>> (32 - b));
}
utils$a.rotl32 = rotl32$2;

function sum32$3(a, b) {
  return (a + b) >>> 0;
}
utils$a.sum32 = sum32$3;

function sum32_3$1(a, b, c) {
  return (a + b + c) >>> 0;
}
utils$a.sum32_3 = sum32_3$1;

function sum32_4$2(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
utils$a.sum32_4 = sum32_4$2;

function sum32_5$2(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
utils$a.sum32_5 = sum32_5$2;

function sum64$1(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
utils$a.sum64 = sum64$1;

function sum64_hi$1(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
utils$a.sum64_hi = sum64_hi$1;

function sum64_lo$1(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
utils$a.sum64_lo = sum64_lo$1;

function sum64_4_hi$1(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
utils$a.sum64_4_hi = sum64_4_hi$1;

function sum64_4_lo$1(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
utils$a.sum64_4_lo = sum64_4_lo$1;

function sum64_5_hi$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
utils$a.sum64_5_hi = sum64_5_hi$1;

function sum64_5_lo$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
utils$a.sum64_5_lo = sum64_5_lo$1;

function rotr64_hi$1(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
utils$a.rotr64_hi = rotr64_hi$1;

function rotr64_lo$1(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
utils$a.rotr64_lo = rotr64_lo$1;

function shr64_hi$1(ah, al, num) {
  return ah >>> num;
}
utils$a.shr64_hi = shr64_hi$1;

function shr64_lo$1(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
utils$a.shr64_lo = shr64_lo$1;

var common$5 = {};

var utils$9 = utils$a;
var assert$3 = minimalisticAssert;

function BlockHash$4() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;

BlockHash$4.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils$9.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils$9.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash$4.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert$3(this.pending === null);

  return this._digest(enc);
};

BlockHash$4.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};

var sha = {};

var common$4 = {};

var utils$8 = utils$a;
var rotr32 = utils$8.rotr32;

function ft_1$1(s, x, y, z) {
  if (s === 0)
    return ch32$1(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32$1(x, y, z);
}
common$4.ft_1 = ft_1$1;

function ch32$1(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
common$4.ch32 = ch32$1;

function maj32$1(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
common$4.maj32 = maj32$1;

function p32(x, y, z) {
  return x ^ y ^ z;
}
common$4.p32 = p32;

function s0_256$1(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
common$4.s0_256 = s0_256$1;

function s1_256$1(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
common$4.s1_256 = s1_256$1;

function g0_256$1(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
common$4.g0_256 = g0_256$1;

function g1_256$1(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
common$4.g1_256 = g1_256$1;

var utils$7 = utils$a;
var common$3 = common$5;
var shaCommon$1 = common$4;

var rotl32$1 = utils$7.rotl32;
var sum32$2 = utils$7.sum32;
var sum32_5$1 = utils$7.sum32_5;
var ft_1 = shaCommon$1.ft_1;
var BlockHash$3 = common$3.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash$3.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils$7.inherits(SHA1, BlockHash$3);
var _1 = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32$1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5$1(rotl32$1(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32$1(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32$2(this.h[0], a);
  this.h[1] = sum32$2(this.h[1], b);
  this.h[2] = sum32$2(this.h[2], c);
  this.h[3] = sum32$2(this.h[3], d);
  this.h[4] = sum32$2(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils$7.toHex32(this.h, 'big');
  else
    return utils$7.split32(this.h, 'big');
};

var utils$6 = utils$a;
var common$2 = common$5;
var shaCommon = common$4;
var assert$2 = minimalisticAssert;

var sum32$1 = utils$6.sum32;
var sum32_4$1 = utils$6.sum32_4;
var sum32_5 = utils$6.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;

var BlockHash$2 = common$2.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();

  BlockHash$2.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils$6.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;

SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;

SHA256$1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4$1(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert$2(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32$1(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32$1(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32$1(T1, T2);
  }

  this.h[0] = sum32$1(this.h[0], a);
  this.h[1] = sum32$1(this.h[1], b);
  this.h[2] = sum32$1(this.h[2], c);
  this.h[3] = sum32$1(this.h[3], d);
  this.h[4] = sum32$1(this.h[4], e);
  this.h[5] = sum32$1(this.h[5], f);
  this.h[6] = sum32$1(this.h[6], g);
  this.h[7] = sum32$1(this.h[7], h);
};

SHA256$1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils$6.toHex32(this.h, 'big');
  else
    return utils$6.split32(this.h, 'big');
};

var utils$5 = utils$a;
var SHA256 = _256;

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils$5.inherits(SHA224, SHA256);
var _224 = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils$5.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils$5.split32(this.h.slice(0, 7), 'big');
};

var utils$4 = utils$a;
var common$1 = common$5;
var assert$1 = minimalisticAssert;

var rotr64_hi = utils$4.rotr64_hi;
var rotr64_lo = utils$4.rotr64_lo;
var shr64_hi = utils$4.shr64_hi;
var shr64_lo = utils$4.shr64_lo;
var sum64 = utils$4.sum64;
var sum64_hi = utils$4.sum64_hi;
var sum64_lo = utils$4.sum64_lo;
var sum64_4_hi = utils$4.sum64_4_hi;
var sum64_4_lo = utils$4.sum64_4_lo;
var sum64_5_hi = utils$4.sum64_5_hi;
var sum64_5_lo = utils$4.sum64_5_lo;

var BlockHash$1 = common$1.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();

  BlockHash$1.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils$4.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;

SHA512$1.blockSize = 1024;
SHA512$1.outSize = 512;
SHA512$1.hmacStrength = 192;
SHA512$1.padLength = 128;

SHA512$1.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512$1.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert$1(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512$1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils$4.toHex32(this.h, 'big');
  else
    return utils$4.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

var utils$3 = utils$a;

var SHA512 = _512;

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils$3.inherits(SHA384, SHA512);
var _384 = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils$3.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils$3.split32(this.h.slice(0, 12), 'big');
};

sha.sha1 = _1;
sha.sha224 = _224;
sha.sha256 = _256;
sha.sha384 = _384;
sha.sha512 = _512;

var ripemd = {};

var utils$2 = utils$a;
var common = common$5;

var rotl32 = utils$2.rotl32;
var sum32 = utils$2.sum32;
var sum32_3 = utils$2.sum32_3;
var sum32_4 = utils$2.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils$2.inherits(RIPEMD160, BlockHash);
ripemd.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils$2.toHex32(this.h, 'little');
  else
    return utils$2.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];

var utils$1 = utils$a;
var assert = minimalisticAssert;

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils$1.toArray(key, enc));
}
var hmac = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};

(function (exports) {
	var hash = exports;

	hash.utils = utils$a;
	hash.common = common$5;
	hash.sha = sha;
	hash.ripemd = ripemd;
	hash.hmac = hmac;

	// Proxy hash functions to the main object
	hash.sha1 = hash.sha.sha1;
	hash.sha256 = hash.sha.sha256;
	hash.sha224 = hash.sha.sha224;
	hash.sha384 = hash.sha.sha384;
	hash.sha512 = hash.sha.sha512;
	hash.ripemd160 = hash.ripemd.ripemd160; 
} (hash));

var stringify$1 = {exports: {}};

(function (module, exports) {
	exports = module.exports = stringify;
	exports.getSerialize = serializer;

	function stringify(obj, replacer, spaces, cycleReplacer) {
	  return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)
	}

	function serializer(replacer, cycleReplacer) {
	  var stack = [], keys = [];

	  if (cycleReplacer == null) cycleReplacer = function(key, value) {
	    if (stack[0] === value) return "[Circular ~]"
	    return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]"
	  };

	  return function(key, value) {
	    if (stack.length > 0) {
	      var thisPos = stack.indexOf(this);
	      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
	      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
	      if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value);
	    }
	    else stack.push(value);

	    return replacer == null ? value : replacer.call(this, key, value)
	  }
	} 
} (stringify$1, stringify$1.exports));

var stringifyExports = stringify$1.exports;

var __importDefault$5 = (strings && strings.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(strings, "__esModule", { value: true });
strings.hashSigningKey = strings.hashEventKey = strings.stringifyUnknown = strings.timeStr = strings.slugify = strings.stringify = void 0;
const hash_js_1$1 = hash;
const json_stringify_safe_1 = __importDefault$5(stringifyExports);
const ms_1$1 = __importDefault$5(ms);
/**
 * Safely `JSON.stringify()` an `input`, handling circular refernences and
 * removing `BigInt` values.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const stringify = (input) => {
    return (0, json_stringify_safe_1.default)(input, (key, value) => {
        if (typeof value !== "bigint") {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return value;
        }
    });
};
strings.stringify = stringify;
/**
 * Returns a slugified string used to generate consistent IDs.
 *
 * This can be used to generate a consistent ID for a function when migrating
 * from v2 to v3 of the SDK.
 *
 * @public
 */
const slugify = (str) => {
    const join = "-";
    return str
        .toLowerCase()
        .replace(/[^a-z0-9-]+/g, join)
        .replace(/-+/g, join)
        .split(join)
        .filter(Boolean)
        .join(join);
};
strings.slugify = slugify;
const millisecond = 1;
const second = millisecond * 1000;
const minute = second * 60;
const hour = minute * 60;
const day = hour * 24;
const week = day * 7;
/**
 * A collection of periods in milliseconds and their suffixes used when creating
 * time strings.
 */
const periods = [
    ["w", week],
    ["d", day],
    ["h", hour],
    ["m", minute],
    ["s", second],
];
/**
 * Convert a given `Date`, `number`, or `ms`-compatible `string` to a
 * Inngest sleep-compatible time string (e.g. `"1d"` or `"2h3010s"`).
 *
 * Can optionally provide a `now` date to use as the base for the calculation,
 * otherwise a new date will be created on invocation.
 */
const timeStr = (
/**
 * The future date to use to convert to a time string.
 */
input) => {
    if (input instanceof Date) {
        return input.toISOString();
    }
    const milliseconds = typeof input === "string" ? (0, ms_1$1.default)(input) : input;
    const [, timeStr] = periods.reduce(([num, str], [suffix, period]) => {
        const numPeriods = Math.floor(num / period);
        if (numPeriods > 0) {
            return [num % period, `${str}${numPeriods}${suffix}`];
        }
        return [num, str];
    }, [milliseconds, ""]);
    return timeStr;
};
strings.timeStr = timeStr;
/**
 * Given an unknown input, stringify it if it's a boolean, a number, or a
 * string, else return `undefined`.
 */
const stringifyUnknown = (input) => {
    if (typeof input === "boolean" ||
        typeof input === "number" ||
        typeof input === "string") {
        return input.toString();
    }
};
strings.stringifyUnknown = stringifyUnknown;
const hashEventKey = (eventKey) => {
    return (0, hash_js_1$1.sha256)().update(eventKey).digest("hex");
};
strings.hashEventKey = hashEventKey;
const hashSigningKey = (signingKey) => {
    var _a;
    if (!signingKey) {
        return "";
    }
    const prefix = ((_a = signingKey.match(/^signkey-[\w]+-/)) === null || _a === void 0 ? void 0 : _a.shift()) || "";
    const key = signingKey.replace(/^signkey-[\w]+-/, "");
    // Decode the key from its hex representation into a bytestream
    return `${prefix}${(0, hash_js_1$1.sha256)().update(key, "hex").digest("hex")}`;
};
strings.hashSigningKey = hashSigningKey;

var temporal = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getISOString = exports.isTemporalZonedDateTime = exports.isTemporalInstant = exports.isTemporalDuration = void 0;
	/**
	 * Asserts that the given `input` is a `Temporal.Duration` object.
	 */
	const isTemporalDuration = (
	/**
	 * The input to check.
	 */
	input) => {
	    try {
	        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access
	        return input[Symbol.toStringTag] === "Temporal.Duration";
	    }
	    catch (_a) {
	        return false;
	    }
	};
	exports.isTemporalDuration = isTemporalDuration;
	/**
	 * Asserts that the given `input` is a `Temporal.TimeZone` object.
	 */
	const isTemporalInstant = (
	/**
	 * The input to check.
	 */
	input) => {
	    try {
	        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access
	        return input[Symbol.toStringTag] === "Temporal.Instant";
	    }
	    catch (_a) {
	        return false;
	    }
	};
	exports.isTemporalInstant = isTemporalInstant;
	/**
	 * Asserts that the given `input` is a `Temporal.ZonedDateTime` object.
	 */
	const isTemporalZonedDateTime = (
	/**
	 * The input to check.
	 */
	input) => {
	    try {
	        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access
	        return input[Symbol.toStringTag] === "Temporal.ZonedDateTime";
	    }
	    catch (_a) {
	        return false;
	    }
	};
	exports.isTemporalZonedDateTime = isTemporalZonedDateTime;
	/**
	 * Converts a given `Date`, `string`, `Temporal.Instant`, or
	 * `Temporal.ZonedDateTime` to an ISO 8601 string.
	 */
	const getISOString = (time) => {
	    if (typeof time === "string") {
	        return new Date(time).toISOString();
	    }
	    if (time instanceof Date) {
	        return time.toISOString();
	    }
	    if ((0, exports.isTemporalZonedDateTime)(time)) {
	        return time.toInstant().toString();
	    }
	    if ((0, exports.isTemporalInstant)(time)) {
	        return time.toString();
	    }
	    throw new TypeError("Invalid date input");
	};
	exports.getISOString = getISOString;
	
} (temporal));

var types$2 = {};

/**
 * Internal types and schemas used throughout the Inngest SDK.
 *
 * Note that types intended to be imported and utilized in userland code will be
 * exported from the main entrypoint of the SDK, `inngest`; importing types
 * directly from this file may result in breaking changes in non-major bumps as
 * only those exported from `inngest` are considered stable.
 *
 * @module
 */
Object.defineProperty(types$2, "__esModule", { value: true });
types$2.inBandSyncRequestBodySchema = types$2.err = types$2.ok = types$2.functionConfigSchema = types$2.logLevels = types$2.sendEventResponseSchema = types$2.incomingOpSchema = types$2.StepOpCode = types$2.jsonErrorSchema = void 0;
const zod_1$4 = lib$2;
const baseJsonErrorSchema = zod_1$4.z.object({
    name: zod_1$4.z.string().trim().optional(),
    error: zod_1$4.z.string().trim().optional(),
    message: zod_1$4.z.string().trim().optional(),
    stack: zod_1$4.z.string().trim().optional(),
});
const maybeJsonErrorSchema = zod_1$4.z.lazy(() => zod_1$4.z.object({
    name: zod_1$4.z.string().trim(),
    message: zod_1$4.z.string().trim(),
    stack: zod_1$4.z.string().trim().optional(),
    cause: zod_1$4.z.union([maybeJsonErrorSchema, zod_1$4.z.unknown()]).optional(),
}));
types$2.jsonErrorSchema = baseJsonErrorSchema
    .extend({
    cause: zod_1$4.z.union([maybeJsonErrorSchema, zod_1$4.z.unknown()]).optional(),
})
    .passthrough()
    .catch({})
    .transform((val) => {
    return Object.assign(Object.assign({}, val), { name: val.name || "Error", message: val.message || val.error || "Unknown error", stack: val.stack });
});
/**
 * Unique codes for the different types of operation that can be sent to Inngest
 * from SDK step functions.
 */
var StepOpCode;
(function (StepOpCode) {
    StepOpCode["WaitForEvent"] = "WaitForEvent";
    /**
     * Legacy equivalent to `"StepRun"`. Has mixed data wrapping (e.g. `data` or
     * `data.data` depending on SDK version), so this is phased out in favour of
     * `"StepRun"`, which never wraps.
     *
     * Note that it is still used for v0 executions for backwards compatibility.
     *
     * @deprecated Only used for v0 executions; use `"StepRun"` instead.
     */
    StepOpCode["Step"] = "Step";
    StepOpCode["StepRun"] = "StepRun";
    StepOpCode["StepError"] = "StepError";
    StepOpCode["StepPlanned"] = "StepPlanned";
    StepOpCode["Sleep"] = "Sleep";
    /**
     * Used to signify that the executor has requested that a step run, but we
     * could not find that step.
     *
     * This is likely indicative that a step was renamed or removed from the
     * function.
     */
    StepOpCode["StepNotFound"] = "StepNotFound";
    StepOpCode["InvokeFunction"] = "InvokeFunction";
    StepOpCode["AiGateway"] = "AIGateway";
    StepOpCode["Gateway"] = "Gateway";
})(StepOpCode || (types$2.StepOpCode = StepOpCode = {}));
types$2.incomingOpSchema = zod_1$4.z.object({
    id: zod_1$4.z.string().min(1),
    data: zod_1$4.z.any().optional(),
    error: zod_1$4.z.any().optional(),
    input: zod_1$4.z.any().optional(),
});
types$2.sendEventResponseSchema = zod_1$4.z.object({
    /**
     * Event IDs
     */
    ids: zod_1$4.z.array(zod_1$4.z.string()).default([]),
    /**
     * HTTP Status Code. Will be undefined if no request was sent.
     */
    status: zod_1$4.z.number().default(0),
    /**
     * Error message. Will be undefined if no error occurred.
     */
    error: zod_1$4.z.string().optional(),
});
/**
 * A set of log levels that can be used to control the amount of logging output
 * from various parts of the Inngest library.
 *
 * @public
 */
types$2.logLevels = [
    "fatal",
    "error",
    "warn",
    "info",
    "debug",
    "silent",
];
/**
 * This schema is used internally to share the shape of a concurrency option
 * when validating config. We cannot add comments to Zod fields, so we just use
 * an extra type check to ensure it matches our exported expectations.
 */
const concurrencyOptionSchema = zod_1$4.z.strictObject({
    limit: zod_1$4.z.number(),
    key: zod_1$4.z.string().optional(),
    scope: zod_1$4.z.enum(["fn", "env", "account"]).optional(),
});
/**
 * The schema used to represent an individual function being synced with
 * Inngest.
 *
 * Note that this should only be used to validate the shape of a config object
 * and not used for feature compatibility, such as feature X being exclusive
 * with feature Y; these should be handled on the Inngest side.
 */
types$2.functionConfigSchema = zod_1$4.z.strictObject({
    name: zod_1$4.z.string().optional(),
    id: zod_1$4.z.string(),
    triggers: zod_1$4.z.array(zod_1$4.z.union([
        zod_1$4.z.strictObject({
            event: zod_1$4.z.string(),
            expression: zod_1$4.z.string().optional(),
        }),
        zod_1$4.z.strictObject({
            cron: zod_1$4.z.string(),
        }),
    ])),
    steps: zod_1$4.z.record(zod_1$4.z.strictObject({
        id: zod_1$4.z.string(),
        name: zod_1$4.z.string(),
        runtime: zod_1$4.z.strictObject({
            type: zod_1$4.z.union([zod_1$4.z.literal("http"), zod_1$4.z.literal("ws")]),
            url: zod_1$4.z.string(),
        }),
        retries: zod_1$4.z
            .strictObject({
            attempts: zod_1$4.z.number().optional(),
        })
            .optional(),
    })),
    idempotency: zod_1$4.z.string().optional(),
    batchEvents: zod_1$4.z
        .strictObject({
        maxSize: zod_1$4.z.number(),
        timeout: zod_1$4.z.string(),
        key: zod_1$4.z.string().optional(),
    })
        .optional(),
    rateLimit: zod_1$4.z
        .strictObject({
        key: zod_1$4.z.string().optional(),
        limit: zod_1$4.z.number(),
        period: zod_1$4.z.string().transform((x) => x),
    })
        .optional(),
    throttle: zod_1$4.z
        .strictObject({
        key: zod_1$4.z.string().optional(),
        limit: zod_1$4.z.number(),
        period: zod_1$4.z.string().transform((x) => x),
        burst: zod_1$4.z.number().optional(),
    })
        .optional(),
    cancel: zod_1$4.z
        .array(zod_1$4.z.strictObject({
        event: zod_1$4.z.string(),
        if: zod_1$4.z.string().optional(),
        timeout: zod_1$4.z.string().optional(),
    }))
        .optional(),
    debounce: zod_1$4.z
        .strictObject({
        key: zod_1$4.z.string().optional(),
        period: zod_1$4.z.string().transform((x) => x),
        timeout: zod_1$4.z
            .string()
            .transform((x) => x)
            .optional(),
    })
        .optional(),
    timeouts: zod_1$4.z
        .strictObject({
        start: zod_1$4.z
            .string()
            .transform((x) => x)
            .optional(),
        finish: zod_1$4.z
            .string()
            .transform((x) => x)
            .optional(),
    })
        .optional(),
    priority: zod_1$4.z
        .strictObject({
        run: zod_1$4.z.string().optional(),
    })
        .optional(),
    concurrency: zod_1$4.z
        .union([
        zod_1$4.z.number(),
        concurrencyOptionSchema.transform((x) => x),
        zod_1$4.z
            .array(concurrencyOptionSchema.transform((x) => x))
            .min(1)
            .max(2),
    ])
        .optional(),
});
const ok = (data) => {
    return { ok: true, value: data };
};
types$2.ok = ok;
const err = (error) => {
    return { ok: false, error };
};
types$2.err = err;
types$2.inBandSyncRequestBodySchema = zod_1$4.z.strictObject({
    url: zod_1$4.z.string(),
});

var InngestFunction$1 = {};

var InngestExecution$1 = {};

var __importDefault$4 = (InngestExecution$1 && InngestExecution$1.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(InngestExecution$1, "__esModule", { value: true });
InngestExecution$1.InngestExecution = InngestExecution$1.PREFERRED_EXECUTION_VERSION = InngestExecution$1.ExecutionVersion = void 0;
const debug_1$2 = __importDefault$4(srcExports);
const consts_js_1$3 = consts;
/**
 * The execution models the SDK is aware of.
 *
 * This is used in a number of places to ensure all execution versions are
 * accounted for for a given operation.
 */
var ExecutionVersion;
(function (ExecutionVersion) {
    ExecutionVersion[ExecutionVersion["V0"] = 0] = "V0";
    ExecutionVersion[ExecutionVersion["V1"] = 1] = "V1";
    ExecutionVersion[ExecutionVersion["V2"] = 2] = "V2";
})(ExecutionVersion || (InngestExecution$1.ExecutionVersion = ExecutionVersion = {}));
/**
 * The preferred execution version that will be used by the SDK when handling
 * brand new runs where the Executor is allowing us to choose.
 *
 * Changing this should not ever be a breaking change, as this will only change
 * new runs, not existing ones.
 */
InngestExecution$1.PREFERRED_EXECUTION_VERSION = ExecutionVersion.V1;
class InngestExecution {
    constructor(options) {
        this.options = options;
        this.debug = (0, debug_1$2.default)(`${consts_js_1$3.debugPrefix}:${this.options.runId}`);
    }
}
InngestExecution$1.InngestExecution = InngestExecution;

var v0 = {};

/* jshint esversion: 6 */

var canonicalize = function serialize (object) {
  if (object === null || typeof object !== 'object' || object.toJSON != null) {
    return JSON.stringify(object);
  }

  if (Array.isArray(object)) {
    return '[' + object.reduce((t, cv, ci) => {
      const comma = ci === 0 ? '' : ',';
      const value = cv === undefined || typeof cv === 'symbol' ? null : cv;
      return t + comma + serialize(value);
    }, '') + ']';
  }

  return '{' + Object.keys(object).sort().reduce((t, cv, ci) => {
    if (object[cv] === undefined ||
        typeof object[cv] === 'symbol') {
      return t;
    }
    const comma = t.length === 0 ? '' : ',';
    return t + comma + serialize(cv) + ':' + serialize(object[cv]);
  }, '') + '}';
};

var errors$2 = {};

var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$1 = Object.getOwnPropertyNames;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __export$1 = (target, all) => {
  for (var name in all)
    __defProp$1(target, name, { get: all[name], enumerable: true });
};
var __copyProps$1 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames$1(from))
      if (!__hasOwnProp$1.call(to, key) && key !== except)
        __defProp$1(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc$1(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS$1 = (mod) => __copyProps$1(__defProp$1({}, "__esModule", { value: true }), mod);
var constructors_exports = {};
__export$1(constructors_exports, {
  errorConstructors: () => errorConstructors
});
var constructors = __toCommonJS$1(constructors_exports);
const list = [
  Error,
  EvalError,
  RangeError,
  ReferenceError,
  SyntaxError,
  TypeError,
  URIError,
  globalThis.DOMException,
  globalThis.AssertionError,
  globalThis.SystemError
].filter(Boolean).map(
  (constructor) => [constructor.name, constructor]
);
const errorConstructors = new Map(list);

var __defProp$2 = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export$2 = (target, all) => {
  for (var name in all)
    __defProp$2(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp$2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp$2({}, "__esModule", { value: true }), mod);
var index_exports = {};
__export$2(index_exports, {
  deserializeError: () => deserializeError,
  errorConstructors: () => import_constructors.errorConstructors,
  serializeError: () => serializeError
});
var dist$2 = __toCommonJS(index_exports);
var import_constructors = constructors;
const getErrorConstructor = (name) => {
  var _a;
  return (_a = import_constructors.errorConstructors.get(name)) != null ? _a : Error;
};
const commonProperties = [
  {
    property: "message",
    enumerable: false
  },
  {
    property: "stack",
    enumerable: false
  },
  {
    property: "code",
    enumerable: true
  },
  {
    property: "cause",
    enumerable: false
  }
];
function serializeError(subject) {
  const data = {
    name: "Error",
    message: "",
    stack: ""
  };
  for (const { property } of commonProperties) {
    if (!(property in subject)) continue;
    data[property] = subject[property];
  }
  if (globalThis.DOMException && subject instanceof globalThis.DOMException) {
    data.name = "DOMException";
  } else {
    data.name = Object.getPrototypeOf(subject).name;
  }
  return data;
}
function deserializeError(subject) {
  const fn = getErrorConstructor(subject.name);
  const output = new fn();
  for (const { property, enumerable } of commonProperties) {
    if (!(property in subject)) continue;
    Object.defineProperty(output, property, {
      value: subject[property],
      enumerable,
      configurable: true,
      writable: true
    });
  }
  return output;
}

var stripAnsi$1 = {exports: {}};

var ansiRegex$1 = options => {
	options = Object.assign({
		onlyFirst: false
	}, options);

	const pattern = [
		'[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
		'(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'
	].join('|');

	return new RegExp(pattern, options.onlyFirst ? undefined : 'g');
};

const ansiRegex = ansiRegex$1;

const stripAnsi = string => typeof string === 'string' ? string.replace(ansiRegex(), '') : string;

stripAnsi$1.exports = stripAnsi;
stripAnsi$1.exports.default = stripAnsi;

var stripAnsiExports = stripAnsi$1.exports;

var NonRetriableError$1 = {};

Object.defineProperty(NonRetriableError$1, "__esModule", { value: true });
NonRetriableError$1.NonRetriableError = void 0;
/**
 * An error that, when thrown, indicates to Inngest that the function should
 * cease all execution and not retry.
 *
 * A `message` must be provided, and an optional `cause` can be provided to
 * provide more context to the error.
 *
 * @public
 */
class NonRetriableError extends Error {
    constructor(message, options) {
        super(message);
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        this.cause = options === null || options === void 0 ? void 0 : options.cause;
        this.name = "NonRetriableError";
    }
}
NonRetriableError$1.NonRetriableError = NonRetriableError;

(function (exports) {
	var __importDefault = (errors$2 && errors$2.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.functionStoppedRunningErr = exports.rethrowError = exports.OutgoingResultError = exports.fixEventKeyMissingSteps = exports.prettyError = exports.getErrorMessage = exports.minifyPrettyError = exports.prettyErrorSplitter = exports.ErrCode = exports.deserializeError = exports.isSerializedError = exports.serializeError = void 0;
	const chalk_1 = __importDefault(source);
	const json_stringify_safe_1 = __importDefault(stringifyExports);
	const serialize_error_cjs_1 = dist$2;
	const strip_ansi_1 = __importDefault(stripAnsiExports);
	const zod_1 = lib$2;
	const NonRetriableError_js_1 = NonRetriableError$1;
	const SERIALIZED_KEY = "__serialized";
	const SERIALIZED_VALUE = true;
	/**
	 * Add first-class support for certain errors that we control, in addition to
	 * built-in errors such as `TypeError`.
	 *
	 * Adding these allows these non-standard errors to be correctly serialized,
	 * sent to Inngest, then deserialized back into the correct error type for users
	 * to react to correctly.
	 *
	 * Note that these errors only support `message?: string | undefined` as the
	 * input; more custom errors are not supported with this current strategy.
	 */
	serialize_error_cjs_1.errorConstructors.set("NonRetriableError", NonRetriableError_js_1.NonRetriableError);
	/**
	 * Serialise an error to a serialized JSON string.
	 *
	 * Errors do not serialise nicely to JSON, so we use this function to convert
	 * them to a serialized JSON string. Doing this is also non-trivial for some
	 * errors, so we use the `serialize-error` package to do it for us.
	 *
	 * See {@link https://www.npmjs.com/package/serialize-error}
	 *
	 * This function is a small wrapper around that package to also add a `type`
	 * property to the serialised error, so that we can distinguish between
	 * serialised errors and other objects.
	 *
	 * Will not reserialise existing serialised errors.
	 */
	const serializeError = (
	/**
	 * The suspected error to serialize.
	 */
	subject, 
	/**
	 * If `true` and the error is not serializable, will return the original value
	 * as `unknown` instead of coercing it to a serialized error.
	 */
	allowUnknown = false) => {
	    try {
	        // Try to understand if this is already done.
	        // Will handle stringified errors.
	        const existingSerializedError = (0, exports.isSerializedError)(subject);
	        if (existingSerializedError) {
	            return existingSerializedError;
	        }
	        if (typeof subject === "object" && subject !== null) {
	            // Is an object, so let's try and serialize it.
	            const serializedErr = (0, serialize_error_cjs_1.serializeError)(subject);
	            // Not a proper error was caught, so give us a chance to return `unknown`.
	            if (!serializedErr.name && allowUnknown) {
	                return subject;
	            }
	            // Serialization can succeed but assign no name or message, so we'll
	            // map over the result here to ensure we have everything.
	            // We'll just stringify the entire subject for the message, as this at
	            // least provides some context for the user.
	            const ret = Object.assign(Object.assign({}, serializedErr), { name: serializedErr.name || "Error", message: serializedErr.message ||
	                    (0, json_stringify_safe_1.default)(subject) ||
	                    "Unknown error; error serialization could not find a message.", stack: serializedErr.stack || "", [SERIALIZED_KEY]: SERIALIZED_VALUE });
	            // If we have a cause, make sure we recursively serialize them too. We are
	            // lighter with causes though; attempt to recursively serialize them, but
	            // stop if we find something that doesn't work and just return `unknown`.
	            let target = ret;
	            const maxDepth = 5;
	            for (let i = 0; i < maxDepth; i++) {
	                if (typeof target === "object" &&
	                    target !== null &&
	                    "cause" in target &&
	                    target.cause) {
	                    target = target.cause = (0, exports.serializeError)(target.cause, true);
	                    continue;
	                }
	                break;
	            }
	            return ret;
	        }
	        // If it's not an object, it's hard to parse this as an Error. In this case,
	        // we'll throw an error to start attempting backup strategies.
	        throw new Error("Error is not an object; strange throw value.");
	    }
	    catch (err) {
	        if (allowUnknown) {
	            // If we are allowed to return unknown, we'll just return the original
	            // value.
	            return subject;
	        }
	        try {
	            // If serialization fails, fall back to a regular Error and use the
	            // original object as the message for an Error. We don't know what this
	            // object looks like, so we can't do anything else with it.
	            return Object.assign(Object.assign({}, (0, exports.serializeError)(new Error(typeof subject === "string" ? subject : (0, json_stringify_safe_1.default)(subject)), false)), { 
	                // Remove the stack; it's not relevant here
	                stack: "", [SERIALIZED_KEY]: SERIALIZED_VALUE });
	        }
	        catch (err) {
	            // If this failed, then stringifying the object also failed, so we'll just
	            // return a completely generic error.
	            // Failing to stringify the object is very unlikely.
	            return {
	                name: "Could not serialize source error",
	                message: "Serializing the source error failed.",
	                stack: "",
	                [SERIALIZED_KEY]: SERIALIZED_VALUE,
	            };
	        }
	    }
	};
	exports.serializeError = serializeError;
	/**
	 * Check if an object or a string is a serialised error created by
	 * {@link serializeError}.
	 */
	const isSerializedError = (value) => {
	    try {
	        if (typeof value === "string") {
	            const parsed = zod_1.z
	                .object({
	                [SERIALIZED_KEY]: zod_1.z.literal(SERIALIZED_VALUE),
	                name: zod_1.z.enum([...Array.from(serialize_error_cjs_1.errorConstructors.keys())]),
	                message: zod_1.z.string(),
	                stack: zod_1.z.string(),
	            })
	                .passthrough()
	                .safeParse(JSON.parse(value));
	            if (parsed.success) {
	                return parsed.data;
	            }
	        }
	        if (typeof value === "object" && value !== null) {
	            const objIsSerializedErr = Object.prototype.hasOwnProperty.call(value, SERIALIZED_KEY) &&
	                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
	                value[SERIALIZED_KEY] ===
	                    SERIALIZED_VALUE;
	            if (objIsSerializedErr) {
	                return value;
	            }
	        }
	    }
	    catch (_a) {
	        // no-op; we'll return undefined if parsing failed, as it isn't a serialized
	        // error
	    }
	};
	exports.isSerializedError = isSerializedError;
	/**
	 * Deserialise an error created by {@link serializeError}.
	 *
	 * Ensures we only deserialise errors that meet a minimum level of
	 * applicability, inclusive of error handling to ensure that badly serialized
	 * errors are still handled.
	 */
	const deserializeError = (subject, allowUnknown = false) => {
	    const requiredFields = ["name", "message"];
	    try {
	        const hasRequiredFields = requiredFields.every((field) => {
	            return Object.prototype.hasOwnProperty.call(subject, field);
	        });
	        if (!hasRequiredFields) {
	            throw new Error();
	        }
	        const deserializedErr = (0, serialize_error_cjs_1.deserializeError)(subject);
	        if ("cause" in deserializedErr) {
	            deserializedErr.cause = (0, exports.deserializeError)(deserializedErr.cause, true);
	        }
	        return deserializedErr;
	    }
	    catch (_a) {
	        if (allowUnknown) {
	            // If we are allowed to return unknown, we'll just return the original
	            // value.
	            return subject;
	        }
	        const err = new Error("Unknown error; could not reserialize");
	        /**
	         * Remove the stack so that it's not misleadingly shown as the Inngest
	         * internals.
	         */
	        err.stack = undefined;
	        return err;
	    }
	};
	exports.deserializeError = deserializeError;
	var ErrCode;
	(function (ErrCode) {
	    ErrCode["NESTING_STEPS"] = "NESTING_STEPS";
	    /**
	     * Legacy v0 execution error code for when a function has changed and no
	     * longer matches its in-progress state.
	     *
	     * @deprecated Not for use in latest execution method.
	     */
	    ErrCode["NON_DETERMINISTIC_FUNCTION"] = "NON_DETERMINISTIC_FUNCTION";
	    /**
	     * Legacy v0 execution error code for when a function is found to be using
	     * async actions after memoziation has occurred, which v0 doesn't support.
	     *
	     * @deprecated Not for use in latest execution method.
	     */
	    ErrCode["ASYNC_DETECTED_AFTER_MEMOIZATION"] = "ASYNC_DETECTED_AFTER_MEMOIZATION";
	    /**
	     * Legacy v0 execution error code for when a function is found to be using
	     * steps after a non-step async action has occurred.
	     *
	     * @deprecated Not for use in latest execution method.
	     */
	    ErrCode["STEP_USED_AFTER_ASYNC"] = "STEP_USED_AFTER_ASYNC";
	    ErrCode["AUTOMATIC_PARALLEL_INDEXING"] = "AUTOMATIC_PARALLEL_INDEXING";
	})(ErrCode || (exports.ErrCode = ErrCode = {}));
	exports.prettyErrorSplitter = "=================================================";
	/**
	 * Given an unknown `err`, mutate it to minify any pretty errors that it
	 * contains.
	 */
	const minifyPrettyError = (err) => {
	    var _a, _b, _c, _d;
	    try {
	        if (!isError(err)) {
	            return err;
	        }
	        const isPrettyError = err.message.includes(exports.prettyErrorSplitter);
	        if (!isPrettyError) {
	            return err;
	        }
	        const sanitizedMessage = (0, strip_ansi_1.default)(err.message);
	        const message = ((_b = (_a = sanitizedMessage.split("  ")[1]) === null || _a === void 0 ? void 0 : _a.split("\n")[0]) === null || _b === void 0 ? void 0 : _b.trim()) || err.message;
	        const code = ((_d = (_c = sanitizedMessage.split("\n\nCode: ")[1]) === null || _c === void 0 ? void 0 : _c.split("\n\n")[0]) === null || _d === void 0 ? void 0 : _d.trim()) ||
	            undefined;
	        err.message = [code, message].filter(Boolean).join(" - ");
	        if (err.stack) {
	            const sanitizedStack = (0, strip_ansi_1.default)(err.stack);
	            const stackRest = sanitizedStack
	                .split(`${exports.prettyErrorSplitter}\n`)
	                .slice(2)
	                .join("\n");
	            err.stack = `${err.name}: ${err.message}\n${stackRest}`;
	        }
	        return err;
	    }
	    catch (noopErr) {
	        return err;
	    }
	};
	exports.minifyPrettyError = minifyPrettyError;
	/**
	 * Given an `err`, return a boolean representing whether it is in the shape of
	 * an `Error` or not.
	 */
	const isError = (err) => {
	    try {
	        if (err instanceof Error) {
	            return true;
	        }
	        const hasName = Object.prototype.hasOwnProperty.call(err, "name");
	        const hasMessage = Object.prototype.hasOwnProperty.call(err, "message");
	        return hasName && hasMessage;
	    }
	    catch (noopErr) {
	        return false;
	    }
	};
	/**
	 * Given an `unknown` object, retrieve the `message` property from it, or fall
	 * back to the `fallback` string if it doesn't exist or is empty.
	 */
	const getErrorMessage = (err, fallback) => {
	    const { message } = zod_1.z
	        .object({ message: zod_1.z.string().min(1) })
	        .catch({ message: fallback })
	        .parse(err);
	    return message;
	};
	exports.getErrorMessage = getErrorMessage;
	/**
	 * Given a {@link PrettyError}, return a nicely-formatted string ready to log
	 * or throw.
	 *
	 * Useful for ensuring that errors are logged in a consistent, helpful format
	 * across the SDK by prompting for key pieces of information.
	 */
	const prettyError = ({ type = "error", whatHappened, otherwise, reassurance, toFixNow, why, consequences, stack, code, }) => {
	    var _a, _b;
	    const { icon, colorFn } = {
	        error: { icon: "❌", colorFn: chalk_1.default.red },
	        warn: { icon: "⚠️", colorFn: chalk_1.default.yellow },
	    }[type];
	    let header = `${icon}  ${chalk_1.default.bold.underline(whatHappened.trim())}`;
	    if (stack) {
	        header +=
	            "\n" +
	                [...(((_a = new Error().stack) === null || _a === void 0 ? void 0 : _a.split("\n").slice(1).filter(Boolean)) || [])].join("\n");
	    }
	    let toFixNowStr = (_b = (Array.isArray(toFixNow)
	        ? toFixNow
	            .map((s) => s.trim())
	            .filter(Boolean)
	            .map((s, i) => `\t${i + 1}. ${s}`)
	            .join("\n")
	        : toFixNow === null || toFixNow === void 0 ? void 0 : toFixNow.trim())) !== null && _b !== void 0 ? _b : "";
	    if (Array.isArray(toFixNow) && toFixNowStr) {
	        toFixNowStr = `To fix this, you can take one of the following courses of action:\n\n${toFixNowStr}`;
	    }
	    let body = [reassurance === null || reassurance === void 0 ? void 0 : reassurance.trim(), why === null || why === void 0 ? void 0 : why.trim(), consequences === null || consequences === void 0 ? void 0 : consequences.trim()]
	        .filter(Boolean)
	        .join(" ");
	    body += body ? `\n\n${toFixNowStr}` : toFixNowStr;
	    const trailer = [otherwise === null || otherwise === void 0 ? void 0 : otherwise.trim()].filter(Boolean).join(" ");
	    const message = [
	        exports.prettyErrorSplitter,
	        header,
	        body,
	        trailer,
	        code ? `Code: ${code}` : "",
	        exports.prettyErrorSplitter,
	    ]
	        .filter(Boolean)
	        .join("\n\n");
	    return colorFn(message);
	};
	exports.prettyError = prettyError;
	exports.fixEventKeyMissingSteps = [
	    "Set the `INNGEST_EVENT_KEY` environment variable",
	    `Pass a key to the \`new Inngest()\` constructor using the \`${"eventKey"}\` option`,
	    `Use \`inngest.${"setEventKey"}()\` at runtime`,
	];
	/**
	 * An error that, when thrown, indicates internally that an outgoing operation
	 * contains an error.
	 *
	 * We use this because serialized `data` sent back to Inngest may differ from
	 * the error instance itself due to middleware.
	 *
	 * @internal
	 */
	class OutgoingResultError extends Error {
	    constructor(result) {
	        super("OutgoingOpError");
	        this.result = result;
	    }
	}
	exports.OutgoingResultError = OutgoingResultError;
	/**
	 * Create a function that will rethrow an error with a prefix added to the
	 * message.
	 *
	 * Useful for adding context to errors that are rethrown.
	 *
	 * @example
	 * ```ts
	 * await doSomeAction().catch(rethrowError("Failed to do some action"));
	 * ```
	 */
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	const rethrowError = (prefix) => {
	    return (err) => {
	        try {
	            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/restrict-template-expressions
	            err.message && (err.message = `${prefix}; ${err.message}`);
	        }
	        catch (noopErr) {
	            // no-op
	        }
	        finally {
	            // eslint-disable-next-line no-unsafe-finally
	            throw err;
	        }
	    };
	};
	exports.rethrowError = rethrowError;
	/**
	 * Legacy v0 execution error for functions that don't support mixing steps and
	 * regular async actions.
	 */
	const functionStoppedRunningErr = (code) => {
	    return (0, exports.prettyError)({
	        whatHappened: "Your function was stopped from running",
	        why: "We detected a mix of asynchronous logic, some using step tooling and some not.",
	        consequences: "This can cause unexpected behaviour when a function is paused and resumed and is therefore strongly discouraged; we stopped your function to ensure nothing unexpected happened!",
	        stack: true,
	        toFixNow: "Ensure that your function is either entirely step-based or entirely non-step-based, by either wrapping all asynchronous logic in `step.run()` calls or by removing all `step.*()` calls.",
	        otherwise: "For more information on why step functions work in this manner, see https://www.inngest.com/docs/functions/multi-step#gotchas",
	        code,
	    });
	};
	exports.functionStoppedRunningErr = functionStoppedRunningErr;
	
} (errors$2));

var functions = {};

var schema = {};

Object.defineProperty(schema, "__esModule", { value: true });
schema.batchSchema = schema.stepsSchemas = schema.errorSchema = void 0;
const zod_1$3 = lib$2;
const InngestExecution_js_1$3 = InngestExecution$1;
const types_js_1$4 = types$2;
schema.errorSchema = zod_1$3.z.object({
    error: zod_1$3.z.string(),
    status: zod_1$3.z.number(),
});
const v0StepSchema = zod_1$3.z
    .record(zod_1$3.z.any().refine((v) => typeof v !== "undefined", {
    message: "Values in steps must be defined",
}))
    .optional()
    .nullable();
const v1StepSchema = zod_1$3.z
    .record(zod_1$3.z
    .object({
    type: zod_1$3.z.literal("data").optional().default("data"),
    data: zod_1$3.z.any().refine((v) => typeof v !== "undefined", {
        message: "Data in steps must be defined",
    }),
})
    .strict()
    .or(zod_1$3.z
    .object({
    type: zod_1$3.z.literal("error").optional().default("error"),
    error: types_js_1$4.jsonErrorSchema,
})
    .strict())
    .or(zod_1$3.z
    .object({
    type: zod_1$3.z.literal("input").optional().default("input"),
    input: zod_1$3.z.any().refine((v) => typeof v !== "undefined", {
        message: "If input is present it must not be `undefined`",
    }),
})
    .strict())
    /**
     * If the result isn't a distcint `data` or `error` object, then it's
     * likely that the executor has set this directly to a value, for example
     * in the case of `sleep` or `waitForEvent`.
     *
     * In this case, pull the entire value through as data.
     */
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    .or(zod_1$3.z.any().transform((v) => ({ type: "data", data: v }))))
    .default({});
const v2StepSchema = v1StepSchema;
schema.stepsSchemas = {
    [InngestExecution_js_1$3.ExecutionVersion.V0]: v0StepSchema,
    [InngestExecution_js_1$3.ExecutionVersion.V1]: v1StepSchema,
    [InngestExecution_js_1$3.ExecutionVersion.V2]: v2StepSchema,
};
schema.batchSchema = zod_1$3.z.array(zod_1$3.z.record(zod_1$3.z.any()).transform((v) => v));

Object.defineProperty(functions, "__esModule", { value: true });
functions.fetchAllFnData = functions.parseFnData = functions.undefinedToNull = functions.waterfall = functions.cacheFn = void 0;
const zod_1$2 = lib$2;
const schema_js_1$1 = schema;
const InngestExecution_js_1$2 = InngestExecution$1;
const types_js_1$3 = types$2;
const errors_js_1$3 = errors$2;
/**
 * Wraps a function with a cache. When the returned function is run, it will
 * cache the result and return it on subsequent calls.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const cacheFn = (fn) => {
    const key = "value";
    const cache = new Map();
    return ((...args) => {
        if (!cache.has(key)) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            cache.set(key, fn(...args));
        }
        return cache.get(key);
    });
};
functions.cacheFn = cacheFn;
/**
 * Given an array of functions, return a new function that will run each
 * function in series and return the result of the final function. Regardless of
 * if the functions are synchronous or asynchronous, they'll be made into an
 * async promise chain.
 *
 * If an error is thrown, the waterfall will stop and return the error.
 *
 * Because this needs to support both sync and async functions, it only allows
 * functions that accept a single argument.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const waterfall = (fns, 
/**
 * A function that transforms the result of each function in the waterfall,
 * ready for the next function.
 *
 * Will not be called on the final function.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
transform) => {
    return (...args) => {
        const chain = fns.reduce(async (acc, fn) => {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            const prev = await acc;
            const output = (await fn(prev));
            if (transform) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                return await transform(prev, output);
            }
            if (typeof output === "undefined") {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                return prev;
            }
            return output;
        }, Promise.resolve(args[0]));
        return chain;
    };
};
functions.waterfall = waterfall;
/**
 * Given a value `v`, return `v` if it's not undefined, otherwise return `null`.
 */
const undefinedToNull = (v) => {
    const isUndefined = typeof v === "undefined";
    return isUndefined ? null : v;
};
functions.undefinedToNull = undefinedToNull;
const fnDataVersionSchema = zod_1$2.z.object({
    version: zod_1$2.z
        .literal(-1)
        .or(zod_1$2.z.literal(0))
        .or(zod_1$2.z.literal(1))
        .or(zod_1$2.z.literal(2))
        .optional()
        .transform((v) => {
        if (typeof v === "undefined") {
            console.debug(`No request version specified by executor; defaulting to v${InngestExecution_js_1$2.PREFERRED_EXECUTION_VERSION}`);
            return InngestExecution_js_1$2.PREFERRED_EXECUTION_VERSION;
        }
        return v === -1 ? InngestExecution_js_1$2.PREFERRED_EXECUTION_VERSION : v;
    }),
});
const parseFnData = (data) => {
    let version;
    try {
        ({ version } = fnDataVersionSchema.parse(data));
        const versionHandlers = {
            [InngestExecution_js_1$2.ExecutionVersion.V0]: () => (Object.assign({ version: InngestExecution_js_1$2.ExecutionVersion.V0 }, zod_1$2.z
                .object({
                event: zod_1$2.z.record(zod_1$2.z.any()),
                events: zod_1$2.z.array(zod_1$2.z.record(zod_1$2.z.any())).default([]),
                steps: schema_js_1$1.stepsSchemas[InngestExecution_js_1$2.ExecutionVersion.V0],
                ctx: zod_1$2.z
                    .object({
                    run_id: zod_1$2.z.string(),
                    attempt: zod_1$2.z.number().default(0),
                    stack: zod_1$2.z
                        .object({
                        stack: zod_1$2.z
                            .array(zod_1$2.z.string())
                            .nullable()
                            .transform((v) => (Array.isArray(v) ? v : [])),
                        current: zod_1$2.z.number(),
                    })
                        .passthrough()
                        .optional()
                        .nullable(),
                })
                    .optional()
                    .nullable(),
                use_api: zod_1$2.z.boolean().default(false),
            })
                .parse(data))),
            [InngestExecution_js_1$2.ExecutionVersion.V1]: () => (Object.assign({ version: InngestExecution_js_1$2.ExecutionVersion.V1 }, zod_1$2.z
                .object({
                event: zod_1$2.z.record(zod_1$2.z.any()),
                events: zod_1$2.z.array(zod_1$2.z.record(zod_1$2.z.any())).default([]),
                steps: schema_js_1$1.stepsSchemas[InngestExecution_js_1$2.ExecutionVersion.V1],
                ctx: zod_1$2.z
                    .object({
                    run_id: zod_1$2.z.string(),
                    attempt: zod_1$2.z.number().default(0),
                    disable_immediate_execution: zod_1$2.z.boolean().default(false),
                    use_api: zod_1$2.z.boolean().default(false),
                    stack: zod_1$2.z
                        .object({
                        stack: zod_1$2.z
                            .array(zod_1$2.z.string())
                            .nullable()
                            .transform((v) => (Array.isArray(v) ? v : [])),
                        current: zod_1$2.z.number(),
                    })
                        .passthrough()
                        .optional()
                        .nullable(),
                })
                    .optional()
                    .nullable(),
            })
                .parse(data))),
            [InngestExecution_js_1$2.ExecutionVersion.V2]: () => (Object.assign({ version: InngestExecution_js_1$2.ExecutionVersion.V2 }, zod_1$2.z
                .object({
                event: zod_1$2.z.record(zod_1$2.z.any()),
                events: zod_1$2.z.array(zod_1$2.z.record(zod_1$2.z.any())).default([]),
                steps: schema_js_1$1.stepsSchemas[InngestExecution_js_1$2.ExecutionVersion.V2],
                ctx: zod_1$2.z
                    .object({
                    run_id: zod_1$2.z.string(),
                    attempt: zod_1$2.z.number().default(0),
                    disable_immediate_execution: zod_1$2.z.boolean().default(false),
                    use_api: zod_1$2.z.boolean().default(false),
                    stack: zod_1$2.z
                        .object({
                        stack: zod_1$2.z
                            .array(zod_1$2.z.string())
                            .nullable()
                            .transform((v) => (Array.isArray(v) ? v : [])),
                        current: zod_1$2.z.number(),
                    })
                        .passthrough()
                        .optional()
                        .nullable(),
                })
                    .optional()
                    .nullable(),
            })
                .parse(data))),
        };
        return versionHandlers[version]();
    }
    catch (err) {
        throw new Error(parseFailureErr(err));
    }
};
functions.parseFnData = parseFnData;
const fetchAllFnData = async ({ data, api, version, }) => {
    var _a, _b, _c, _d;
    const result = Object.assign({}, data);
    try {
        if ((result.version === InngestExecution_js_1$2.ExecutionVersion.V0 && result.use_api) ||
            (result.version === InngestExecution_js_1$2.ExecutionVersion.V1 && ((_a = result.ctx) === null || _a === void 0 ? void 0 : _a.use_api))) {
            if (!((_b = result.ctx) === null || _b === void 0 ? void 0 : _b.run_id)) {
                return (0, types_js_1$3.err)((0, errors_js_1$3.prettyError)({
                    whatHappened: "failed to attempt retrieving data from API",
                    consequences: "function execution can't continue",
                    why: "run_id is missing from context",
                    stack: true,
                }));
            }
            const [evtResp, stepResp] = await Promise.all([
                api.getRunBatch(result.ctx.run_id),
                api.getRunSteps(result.ctx.run_id, version),
            ]);
            if (evtResp.ok) {
                result.events = evtResp.value;
            }
            else {
                return (0, types_js_1$3.err)((0, errors_js_1$3.prettyError)({
                    whatHappened: "failed to retrieve list of events",
                    consequences: "function execution can't continue",
                    why: (_c = evtResp.error) === null || _c === void 0 ? void 0 : _c.error,
                    stack: true,
                }));
            }
            if (stepResp.ok) {
                result.steps = stepResp.value;
            }
            else {
                return (0, types_js_1$3.err)((0, errors_js_1$3.prettyError)({
                    whatHappened: "failed to retrieve steps for function run",
                    consequences: "function execution can't continue",
                    why: (_d = stepResp.error) === null || _d === void 0 ? void 0 : _d.error,
                    stack: true,
                }));
            }
        }
        return (0, types_js_1$3.ok)(result);
    }
    catch (error) {
        // print it out for now.
        // move to something like protobuf so we don't have to deal with this
        console.error(error);
        return (0, types_js_1$3.err)(parseFailureErr(error));
    }
};
functions.fetchAllFnData = fetchAllFnData;
const parseFailureErr = (err) => {
    let why;
    if (err instanceof zod_1$2.ZodError) {
        why = err.toString();
    }
    return (0, errors_js_1$3.prettyError)({
        whatHappened: "Failed to parse data from executor.",
        consequences: "Function execution can't continue.",
        toFixNow: "Make sure that your API is set up to parse incoming request bodies as JSON, like body-parser for Express (https://expressjs.com/en/resources/middleware/body-parser.html).",
        stack: true,
        why,
    });
};

var promises = {};

(function (exports) {
	var __await = (promises && promises.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); };
	var __asyncGenerator = (promises && promises.__asyncGenerator) || function (thisArg, _arguments, generator) {
	    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	    var g = generator.apply(thisArg, _arguments || []), i, q = [];
	    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;
	    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }
	    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }
	    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
	    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
	    function fulfill(value) { resume("next", value); }
	    function reject(value) { resume("throw", value); }
	    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.retryWithBackoff = exports.resolveNextTick = exports.runAsPromise = exports.createTimeoutPromise = exports.createDeferredPromiseWithStack = exports.createDeferredPromise = exports.resolveAfterPending = exports.createFrozenPromise = void 0;
	/**
	 * Some environments don't allow access to the global queueMicrotask(). While we
	 * had assumed this was only true for those powered by earlier versions of Node
	 * (<14) that we don't officially support, Vercel's Edge Functions also obscure
	 * the function in dev, even though the platform it's based on (Cloudflare
	 * Workers) appropriately exposes it. Even worse, production Vercel Edge
	 * Functions can see the function, but it immediately blows up the function when
	 * used.
	 *
	 * Therefore, we can fall back to a reasonable alternative of
	 * `Promise.resolve().then(fn)` instead. This _may_ be slightly slower in modern
	 * environments, but at least we can still work in these environments.
	 */
	const shimQueueMicrotask = (callback) => {
	    void Promise.resolve().then(callback);
	};
	/**
	 * A helper function to create a `Promise` that will never settle.
	 *
	 * It purposefully creates no references to `resolve` or `reject` so that the
	 * returned `Promise` will remain unsettled until it falls out of scope and is
	 * garbage collected.
	 *
	 * This should be used within transient closures to fake asynchronous action, so
	 * long as it's guaranteed that they will fall out of scope.
	 */
	const createFrozenPromise = () => {
	    return new Promise(() => undefined);
	};
	exports.createFrozenPromise = createFrozenPromise;
	/**
	 * Returns a Promise that resolves after the current event loop's microtasks
	 * have finished, but before the next event loop tick.
	 */
	const resolveAfterPending = (count = 100) => {
	    /**
	     * This uses a brute force implementation that will continue to enqueue
	     * microtasks 10 times before resolving. This is to ensure that the microtask
	     * queue is drained, even if the microtask queue is being manipulated by other
	     * code.
	     *
	     * While this still doesn't guarantee that the microtask queue is drained,
	     * it's our best bet for giving other non-controlled promises a chance to
	     * resolve before we continue without resorting to falling in to the next
	     * tick.
	     */
	    return new Promise((resolve) => {
	        let i = 0;
	        const iterate = () => {
	            shimQueueMicrotask(() => {
	                if (i++ > count) {
	                    return resolve();
	                }
	                iterate();
	            });
	        };
	        iterate();
	    });
	};
	exports.resolveAfterPending = resolveAfterPending;
	/**
	 * Creates and returns Promise that can be resolved or rejected with the
	 * returned `resolve` and `reject` functions.
	 *
	 * Resolving or rejecting the function will return a new set of Promise control
	 * functions. These can be ignored if the original Promise is all that's needed.
	 */
	const createDeferredPromise = () => {
	    let resolve;
	    let reject;
	    const promise = new Promise((_resolve, _reject) => {
	        resolve = (value) => {
	            _resolve(value);
	            return (0, exports.createDeferredPromise)();
	        };
	        reject = (reason) => {
	            _reject(reason);
	            return (0, exports.createDeferredPromise)();
	        };
	    });
	    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
	    return { promise, resolve: resolve, reject: reject };
	};
	exports.createDeferredPromise = createDeferredPromise;
	/**
	 * Creates and returns a deferred Promise that can be resolved or rejected with
	 * the returned `resolve` and `reject` functions.
	 *
	 * For each Promise resolved or rejected this way, this will also keep a stack
	 * of all unhandled Promises, resolved or rejected.
	 *
	 * Once a Promise is read, it is removed from the stack.
	 */
	const createDeferredPromiseWithStack = () => {
	    const settledPromises = [];
	    let rotateQueue = () => { };
	    const results = (function () {
	        return __asyncGenerator(this, arguments, function* () {
	            while (true) {
	                const next = settledPromises.shift();
	                if (next) {
	                    yield yield __await(next);
	                }
	                else {
	                    yield __await(new Promise((resolve) => {
	                        rotateQueue = resolve;
	                    }));
	                }
	            }
	        });
	    })();
	    const shimDeferredPromise = (deferred) => {
	        const originalResolve = deferred.resolve;
	        const originalReject = deferred.reject;
	        deferred.resolve = (value) => {
	            settledPromises.push(deferred.promise);
	            rotateQueue();
	            return shimDeferredPromise(originalResolve(value));
	        };
	        deferred.reject = (reason) => {
	            settledPromises.push(deferred.promise);
	            rotateQueue();
	            return shimDeferredPromise(originalReject(reason));
	        };
	        return deferred;
	    };
	    const deferred = shimDeferredPromise((0, exports.createDeferredPromise)());
	    return { deferred, results };
	};
	exports.createDeferredPromiseWithStack = createDeferredPromiseWithStack;
	/**
	 * Creates a Promise that will resolve after the given duration, along with
	 * methods to start, clear, and reset the timeout.
	 */
	const createTimeoutPromise = (duration) => {
	    const { promise, resolve } = (0, exports.createDeferredPromise)();
	    let timeout;
	    // eslint-disable-next-line prefer-const
	    let ret;
	    const start = () => {
	        if (timeout)
	            return ret;
	        timeout = setTimeout(() => {
	            resolve();
	        }, duration);
	        return ret;
	    };
	    const clear = () => {
	        clearTimeout(timeout);
	        timeout = undefined;
	    };
	    const reset = () => {
	        clear();
	        return start();
	    };
	    ret = Object.assign(promise, { start, clear, reset });
	    return ret;
	};
	exports.createTimeoutPromise = createTimeoutPromise;
	/**
	 * Take any function and safely promisify such that both synchronous and
	 * asynchronous errors are caught and returned as a rejected Promise.
	 *
	 * The passed `fn` can be undefined to support functions that may conditionally
	 * be defined.
	 */
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	const runAsPromise = (fn
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	) => {
	    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
	    return Promise.resolve().then(fn);
	};
	exports.runAsPromise = runAsPromise;
	/**
	 * Returns a Promise that resolve after the current event loop tick.
	 */
	const resolveNextTick = () => {
	    return new Promise((resolve) => setTimeout(resolve));
	};
	exports.resolveNextTick = resolveNextTick;
	const retryWithBackoff = async (fn, opts) => {
	    var _a;
	    const maxAttempts = (opts === null || opts === void 0 ? void 0 : opts.maxAttempts) || 5;
	    const baseDelay = (_a = opts === null || opts === void 0 ? void 0 : opts.baseDelay) !== null && _a !== void 0 ? _a : 100;
	    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
	        try {
	            return await fn();
	        }
	        catch (err) {
	            if (attempt >= maxAttempts) {
	                throw err;
	            }
	            const jitter = Math.random() * baseDelay;
	            const delay = baseDelay * Math.pow(2, attempt - 1) + jitter;
	            await new Promise((resolve) => setTimeout(resolve, delay));
	        }
	    }
	    throw new Error("Max retries reached; this should be unreachable.");
	};
	exports.retryWithBackoff = retryWithBackoff;
	
} (promises));

var InngestMiddleware$1 = {};

Object.defineProperty(InngestMiddleware$1, "__esModule", { value: true });
InngestMiddleware$1.getHookStack = InngestMiddleware$1.InngestMiddleware = void 0;
const functions_js_1$1 = functions;
/**
 * A middleware that can be registered with Inngest to hook into various
 * lifecycles of the SDK and affect input and output of Inngest functionality.
 *
 * See {@link https://innge.st/middleware}
 *
 * @example
 *
 * ```ts
 * export const inngest = new Inngest({
 *   middleware: [
 *     new InngestMiddleware({
 *       name: "My Middleware",
 *       init: () => {
 *         // ...
 *       }
 *     })
 *   ]
 * });
 * ```
 *
 * @public
 */
class InngestMiddleware {
    constructor({ name, init }) {
        this.name = name;
        this.init = init;
    }
}
InngestMiddleware$1.InngestMiddleware = InngestMiddleware;
/**
 * Given some middleware and an entrypoint, runs the initializer for the given
 * `key` and returns functions that will pass arguments through a stack of each
 * given hook in a middleware's lifecycle.
 *
 * Lets the middleware initialize before starting.
 */
const getHookStack = async (
/**
 * The stack of middleware that will be used to run hooks.
 */
middleware, 
/**
 * The hook type to initialize.
 */
key, 
/**
 * Arguments for the initial hook.
 */
arg, transforms) => {
    // Wait for middleware to initialize
    const mwStack = await middleware;
    // Step through each middleware and get the hook for the given key
    const keyFns = mwStack.reduce((acc, mw) => {
        const fn = mw[key];
        if (fn) {
            return [...acc, fn];
        }
        return acc;
    }, []);
    // Run each hook found in sequence and collect the results
    const hooksRegistered = await keyFns.reduce(async (acc, fn) => {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return [...(await acc), await fn(arg)];
    }, Promise.resolve([]));
    // Prepare the return object - mutating this instead of using reduce as it
    // results in cleaner code.
    const ret = {};
    // Step through each hook result and create a waterfall joining each key
    for (const hook of hooksRegistered) {
        const hookKeys = Object.keys(hook);
        for (const key of hookKeys) {
            let fns = [hook[key]];
            const existingWaterfall = ret[key];
            if (existingWaterfall) {
                fns = [existingWaterfall, hook[key]];
            }
            const transform = transforms[key];
            ret[key] = (0, functions_js_1$1.waterfall)(fns, transform);
        }
    }
    // Cache each function in the stack to ensure each can only be called once
    for (const k of Object.keys(ret)) {
        const key = k;
        ret[key] = (0, functions_js_1$1.cacheFn)(ret[key]);
    }
    return ret;
};
InngestMiddleware$1.getHookStack = getHookStack;

var RetryAfterError$1 = {};

var __importDefault$3 = (RetryAfterError$1 && RetryAfterError$1.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(RetryAfterError$1, "__esModule", { value: true });
RetryAfterError$1.RetryAfterError = void 0;
const ms_1 = __importDefault$3(ms);
/**
 * An error that, when thrown, indicates to Inngest that the function should be
 * retried after a given amount of time.
 *
 * A `message` must be provided, as well as a `retryAfter` parameter, which can
 * be a `number` of milliseconds, an `ms`-compatible time string, or a `Date`.
 *
 * An optional `cause` can be provided to provide more context to the error.
 *
 * @public
 */
class RetryAfterError extends Error {
    constructor(message, 
    /**
     * The time after which the function should be retried. Represents either a
     * number of milliseconds or a RFC3339 date.
     */
    retryAfter, options) {
        super(message);
        if (retryAfter instanceof Date) {
            this.retryAfter = retryAfter.toISOString();
        }
        else {
            const seconds = `${Math.ceil((typeof retryAfter === "string" ? (0, ms_1.default)(retryAfter) : retryAfter) / 1000)}`;
            if (!isFinite(Number(seconds))) {
                throw new Error("retryAfter must be a number of milliseconds, a ms-compatible string, or a Date");
            }
            this.retryAfter = seconds;
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        this.cause = options === null || options === void 0 ? void 0 : options.cause;
    }
}
RetryAfterError$1.RetryAfterError = RetryAfterError;

(function (exports) {
	var __rest = (v0 && v0.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var __importDefault = (v0 && v0.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports._internals = exports.V0InngestExecution = exports.createV0InngestExecution = void 0;
	const canonicalize_1 = __importDefault(canonicalize);
	const hash_js_1 = hash;
	const zod_1 = lib$2;
	const errors_js_1 = errors$2;
	const functions_js_1 = functions;
	const promises_js_1 = promises;
	const types_js_1 = types$2;
	const InngestMiddleware_js_1 = InngestMiddleware$1;
	const InngestStepTools_js_1 = InngestStepTools;
	const NonRetriableError_js_1 = NonRetriableError$1;
	const RetryAfterError_js_1 = RetryAfterError$1;
	const InngestExecution_js_1 = InngestExecution$1;
	const createV0InngestExecution = (options) => {
	    return new V0InngestExecution(options);
	};
	exports.createV0InngestExecution = createV0InngestExecution;
	class V0InngestExecution extends InngestExecution_js_1.InngestExecution {
	    constructor(options) {
	        super(options);
	        this.userFnToRun = this.getUserFnToRun();
	        this.state = this.createExecutionState();
	        this.fnArg = this.createFnArg();
	    }
	    start() {
	        var _a;
	        this.debug("starting V0 execution");
	        return ((_a = this.execution) !== null && _a !== void 0 ? _a : (this.execution = this._start().then((result) => {
	            this.debug("result:", result);
	            return result;
	        })));
	    }
	    async _start() {
	        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
	        this.state.hooks = await this.initializeMiddleware();
	        try {
	            await this.transformInput();
	            await ((_b = (_a = this.state.hooks).beforeMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));
	            if (this.state.opStack.length === 0 && !this.options.requestedRunStep) {
	                await ((_d = (_c = this.state.hooks).afterMemoization) === null || _d === void 0 ? void 0 : _d.call(_c));
	                await ((_f = (_e = this.state.hooks).beforeExecution) === null || _f === void 0 ? void 0 : _f.call(_e));
	            }
	            const userFnPromise = (0, promises_js_1.runAsPromise)(() => this.userFnToRun(this.fnArg));
	            let pos = -1;
	            do {
	                if (pos >= 0) {
	                    if (!this.options.requestedRunStep &&
	                        pos === this.state.opStack.length - 1) {
	                        await ((_h = (_g = this.state.hooks).afterMemoization) === null || _h === void 0 ? void 0 : _h.call(_g));
	                        await ((_k = (_j = this.state.hooks).beforeExecution) === null || _k === void 0 ? void 0 : _k.call(_j));
	                    }
	                    this.state.tickOps = {};
	                    const incomingOp = this.state.opStack[pos];
	                    this.state.currentOp = this.state.allFoundOps[incomingOp.id];
	                    if (!this.state.currentOp) {
	                        /**
	                         * We're trying to resume the function, but we can't find where to go.
	                         *
	                         * This means that either the function has changed or there are async
	                         * actions in-between steps that we haven't noticed in previous
	                         * executions.
	                         *
	                         * Whichever the case, this is bad and we can't continue in this
	                         * undefined state.
	                         */
	                        throw new NonRetriableError_js_1.NonRetriableError((0, errors_js_1.prettyError)({
	                            whatHappened: " Your function was stopped from running",
	                            why: "We couldn't resume your function's state because it may have changed since the run started or there are async actions in-between steps that we haven't noticed in previous executions.",
	                            consequences: "Continuing to run the function may result in unexpected behaviour, so we've stopped your function to ensure nothing unexpected happened!",
	                            toFixNow: "Ensure that your function is either entirely step-based or entirely non-step-based, by either wrapping all asynchronous logic in `step.run()` calls or by removing all `step.*()` calls.",
	                            otherwise: "For more information on why step functions work in this manner, see https://www.inngest.com/docs/functions/multi-step#gotchas",
	                            stack: true,
	                            code: errors_js_1.ErrCode.NON_DETERMINISTIC_FUNCTION,
	                        }));
	                    }
	                    this.state.currentOp.fulfilled = true;
	                    if (typeof incomingOp.data !== "undefined") {
	                        this.state.currentOp.resolve(incomingOp.data);
	                    }
	                    else {
	                        this.state.currentOp.reject(incomingOp.error);
	                    }
	                }
	                await (0, promises_js_1.resolveAfterPending)();
	                this.state.reset();
	                pos++;
	            } while (pos < this.state.opStack.length);
	            await ((_m = (_l = this.state.hooks).afterMemoization) === null || _m === void 0 ? void 0 : _m.call(_l));
	            const discoveredOps = Object.values(this.state.tickOps).map(tickOpToOutgoing);
	            const runStep = this.options.requestedRunStep ||
	                this.getEarlyExecRunStep(discoveredOps);
	            if (runStep) {
	                const userFnOp = this.state.allFoundOps[runStep];
	                const stepToRun = userFnOp === null || userFnOp === void 0 ? void 0 : userFnOp.fn;
	                if (!stepToRun) {
	                    throw new Error(`Bad stack; executor requesting to run unknown step "${runStep}"`);
	                }
	                const outgoingUserFnOp = Object.assign(Object.assign({}, tickOpToOutgoing(userFnOp)), { op: types_js_1.StepOpCode.Step });
	                await ((_p = (_o = this.state.hooks).beforeExecution) === null || _p === void 0 ? void 0 : _p.call(_o));
	                this.state.executingStep = true;
	                const result = await (0, promises_js_1.runAsPromise)(stepToRun)
	                    .finally(() => {
	                    this.state.executingStep = false;
	                })
	                    .catch(async (error) => {
	                    return await this.transformOutput({ error }, outgoingUserFnOp);
	                })
	                    .then(async (data) => {
	                    var _a, _b;
	                    await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterExecution) === null || _b === void 0 ? void 0 : _b.call(_a));
	                    return await this.transformOutput({ data }, outgoingUserFnOp);
	                });
	                const rest = __rest(result, ["type"]);
	                return {
	                    type: "step-ran",
	                    ctx: this.fnArg,
	                    ops: this.ops,
	                    step: Object.assign(Object.assign({}, outgoingUserFnOp), rest),
	                };
	            }
	            if (!discoveredOps.length) {
	                const fnRet = await Promise.race([
	                    userFnPromise.then((data) => ({ type: "complete", data })),
	                    (0, promises_js_1.resolveNextTick)().then(() => ({ type: "incomplete" })),
	                ]);
	                if (fnRet.type === "complete") {
	                    await ((_r = (_q = this.state.hooks).afterExecution) === null || _r === void 0 ? void 0 : _r.call(_q));
	                    const allOpsFulfilled = Object.values(this.state.allFoundOps).every((op) => {
	                        return op.fulfilled;
	                    });
	                    if (allOpsFulfilled) {
	                        return await this.transformOutput({ data: fnRet.data });
	                    }
	                }
	                else if (!this.state.hasUsedTools) {
	                    this.state.nonStepFnDetected = true;
	                    const data = await userFnPromise;
	                    await ((_t = (_s = this.state.hooks).afterExecution) === null || _t === void 0 ? void 0 : _t.call(_s));
	                    return await this.transformOutput({ data });
	                }
	                else {
	                    const hasOpsPending = Object.values(this.state.allFoundOps).some((op) => {
	                        return op.fulfilled === false;
	                    });
	                    if (!hasOpsPending) {
	                        throw new NonRetriableError_js_1.NonRetriableError((0, errors_js_1.functionStoppedRunningErr)(errors_js_1.ErrCode.ASYNC_DETECTED_AFTER_MEMOIZATION));
	                    }
	                }
	            }
	            await ((_v = (_u = this.state.hooks).afterExecution) === null || _v === void 0 ? void 0 : _v.call(_u));
	            return {
	                type: "steps-found",
	                ctx: this.fnArg,
	                ops: this.ops,
	                steps: discoveredOps,
	            };
	        }
	        catch (error) {
	            return await this.transformOutput({ error });
	        }
	        finally {
	            await ((_x = (_w = this.state.hooks).beforeResponse) === null || _x === void 0 ? void 0 : _x.call(_w));
	        }
	    }
	    async initializeMiddleware() {
	        const ctx = this.options.data;
	        const hooks = await (0, InngestMiddleware_js_1.getHookStack)(this.options.fn["middleware"], "onFunctionRun", {
	            ctx,
	            fn: this.options.fn,
	            steps: Object.values(this.options.stepState),
	            reqArgs: this.options.reqArgs,
	        }, {
	            transformInput: (prev, output) => {
	                return {
	                    ctx: Object.assign(Object.assign({}, prev.ctx), output === null || output === void 0 ? void 0 : output.ctx),
	                    fn: this.options.fn,
	                    steps: prev.steps.map((step, i) => {
	                        var _a;
	                        return (Object.assign(Object.assign({}, step), (_a = output === null || output === void 0 ? void 0 : output.steps) === null || _a === void 0 ? void 0 : _a[i]));
	                    }),
	                    reqArgs: prev.reqArgs,
	                };
	            },
	            transformOutput: (prev, output) => {
	                return {
	                    result: Object.assign(Object.assign({}, prev.result), output === null || output === void 0 ? void 0 : output.result),
	                    step: prev.step,
	                };
	            },
	        });
	        return hooks;
	    }
	    createExecutionState() {
	        const state = {
	            allFoundOps: {},
	            tickOps: {},
	            tickOpHashes: {},
	            currentOp: undefined,
	            hasUsedTools: false,
	            reset: () => {
	                state.tickOpHashes = {};
	                state.allFoundOps = Object.assign(Object.assign({}, state.allFoundOps), state.tickOps);
	            },
	            nonStepFnDetected: false,
	            executingStep: false,
	            opStack: this.options.stepCompletionOrder.reduce((acc, stepId) => {
	                const stepState = this.options.stepState[stepId];
	                if (!stepState) {
	                    return acc;
	                }
	                return [...acc, stepState];
	            }, []),
	        };
	        return state;
	    }
	    get ops() {
	        return Object.fromEntries(Object.entries(this.state.allFoundOps).map(([id, op]) => [
	            id,
	            {
	                id: op.id,
	                rawArgs: op.rawArgs,
	                data: op.data,
	                error: op.error,
	                fulfilled: op.fulfilled,
	                seen: true,
	            },
	        ]));
	    }
	    getUserFnToRun() {
	        if (!this.options.isFailureHandler) {
	            return this.options.fn["fn"];
	        }
	        if (!this.options.fn["onFailureFn"]) {
	            /**
	             * Somehow, we've ended up detecting that this is a failure handler but
	             * doesn't have an `onFailure` function. This should never happen.
	             */
	            throw new Error("Cannot find function `onFailure` handler");
	        }
	        // TODO: Review; inferred types results in an `any` here!
	        return this.options.fn["onFailureFn"];
	    }
	    createFnArg() {
	        var _a, _b, _c, _d;
	        // Start referencing everything
	        this.state.tickOps = this.state.allFoundOps;
	        /**
	         * Create a unique hash of an operation using only a subset of the operation's
	         * properties; will never use `data` and will guarantee the order of the
	         * object so we don't rely on individual tools for that.
	         *
	         * If the operation already contains an ID, the current ID will be used
	         * instead, so that users can provide their own IDs.
	         */
	        const hashOp = (
	        /**
	         * The op to generate a hash from. We only use a subset of the op's
	         * properties when creating the hash.
	         */
	        op) => {
	            var _a, _b, _c, _d;
	            /**
	             * It's difficult for v0 to understand whether or not an op has
	             * historically contained a custom ID, as all step usage now require them.
	             *
	             * For this reason, we make the assumption that steps in v0 do not have a
	             * custom ID and generate one for them as we would in all recommendations
	             * and examples.
	             */
	            const obj = {
	                parent: (_b = (_a = this.state.currentOp) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : null,
	                op: op.op,
	                name: op.name,
	                // Historically, no v0 runs could have options for `step.run()` call,
	                // but this object can be specified in future versions.
	                //
	                // For this purpose, we change this to always use `null` if the op is
	                // that of a `step.run()`.
	                opts: op.op === types_js_1.StepOpCode.StepPlanned ? null : (_c = op.opts) !== null && _c !== void 0 ? _c : null,
	            };
	            const collisionHash = exports._internals.hashData(obj);
	            const pos = (this.state.tickOpHashes[collisionHash] =
	                ((_d = this.state.tickOpHashes[collisionHash]) !== null && _d !== void 0 ? _d : -1) + 1);
	            return Object.assign(Object.assign({}, op), { id: exports._internals.hashData(Object.assign({ pos }, obj)) });
	        };
	        const stepHandler = ({ args, matchOp, opts }) => {
	            if (this.state.nonStepFnDetected) {
	                throw new NonRetriableError_js_1.NonRetriableError((0, errors_js_1.functionStoppedRunningErr)(errors_js_1.ErrCode.STEP_USED_AFTER_ASYNC));
	            }
	            if (this.state.executingStep) {
	                throw new NonRetriableError_js_1.NonRetriableError((0, errors_js_1.prettyError)({
	                    whatHappened: "Your function was stopped from running",
	                    why: "We detected that you have nested `step.*` tooling.",
	                    consequences: "Nesting `step.*` tooling is not supported.",
	                    stack: true,
	                    toFixNow: "Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.",
	                    otherwise: "For more information on step functions with Inngest, see https://www.inngest.com/docs/functions/multi-step",
	                    code: errors_js_1.ErrCode.NESTING_STEPS,
	                }));
	            }
	            this.state.hasUsedTools = true;
	            const stepOptions = (0, InngestStepTools_js_1.getStepOptions)(args[0]);
	            const opId = hashOp(matchOp(stepOptions, ...args.slice(1)));
	            return new Promise((resolve, reject) => {
	                this.state.tickOps[opId.id] = Object.assign(Object.assign(Object.assign({}, opId), ((opts === null || opts === void 0 ? void 0 : opts.fn) ? { fn: () => { var _a; return (_a = opts.fn) === null || _a === void 0 ? void 0 : _a.call(opts, ...args); } } : {})), { rawArgs: args, resolve,
	                    reject, fulfilled: false });
	            });
	        };
	        const step = (0, InngestStepTools_js_1.createStepTools)(this.options.client, this, stepHandler);
	        let fnArg = Object.assign(Object.assign({}, this.options.data), { step });
	        if (this.options.isFailureHandler) {
	            const eventData = zod_1.z
	                .object({ error: types_js_1.jsonErrorSchema })
	                .parse((_a = fnArg.event) === null || _a === void 0 ? void 0 : _a.data);
	            fnArg = Object.assign(Object.assign({}, fnArg), { error: (0, errors_js_1.deserializeError)(eventData.error) });
	        }
	        return (_d = (_c = (_b = this.options).transformCtx) === null || _c === void 0 ? void 0 : _c.call(_b, fnArg)) !== null && _d !== void 0 ? _d : fnArg;
	    }
	    /**
	     * Using middleware, transform input before running.
	     */
	    async transformInput() {
	        var _a, _b;
	        const inputMutations = await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.transformInput) === null || _b === void 0 ? void 0 : _b.call(_a, {
	            ctx: Object.assign({}, this.fnArg),
	            steps: Object.values(this.options.stepState),
	            fn: this.options.fn,
	            reqArgs: this.options.reqArgs,
	        }));
	        if (inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.ctx) {
	            this.fnArg = inputMutations.ctx;
	        }
	        if (inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.steps) {
	            this.state.opStack = [...inputMutations.steps];
	        }
	    }
	    getEarlyExecRunStep(ops) {
	        if (ops.length !== 1)
	            return;
	        const op = ops[0];
	        if (op &&
	            op.op === types_js_1.StepOpCode.StepPlanned
	        // TODO We must individually check properties here that we do not want to
	        // execute on, such as retry counts. Nothing exists here that falls in to
	        // this case, but should be accounted for when we add them.
	        // && typeof op.opts === "undefined"
	        ) {
	            return op.id;
	        }
	    }
	    /**
	     * Using middleware, transform output before returning.
	     */
	    async transformOutput(dataOrError, step) {
	        var _a, _b, _c, _d;
	        const output = Object.assign({}, dataOrError);
	        if (typeof output.error !== "undefined") {
	            output.data = (0, errors_js_1.serializeError)(output.error);
	        }
	        const transformedOutput = await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.transformOutput) === null || _b === void 0 ? void 0 : _b.call(_a, {
	            result: Object.assign({}, output),
	            step,
	        }));
	        const { data, error } = Object.assign(Object.assign({}, output), transformedOutput === null || transformedOutput === void 0 ? void 0 : transformedOutput.result);
	        if (!step) {
	            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.finished) === null || _d === void 0 ? void 0 : _d.call(_c, {
	                result: Object.assign({}, (typeof error !== "undefined" ? { error } : { data })),
	            }));
	        }
	        if (typeof error !== "undefined") {
	            /**
	             * Ensure we give middleware the chance to decide on retriable behaviour
	             * by looking at the error returned from output transformation.
	             */
	            let retriable = !(error instanceof NonRetriableError_js_1.NonRetriableError);
	            if (retriable && error instanceof RetryAfterError_js_1.RetryAfterError) {
	                retriable = error.retryAfter;
	            }
	            const serializedError = (0, errors_js_1.serializeError)(error);
	            return {
	                type: "function-rejected",
	                ctx: this.fnArg,
	                ops: this.ops,
	                error: serializedError,
	                retriable,
	            };
	        }
	        return {
	            type: "function-resolved",
	            ctx: this.fnArg,
	            ops: this.ops,
	            data: (0, functions_js_1.undefinedToNull)(data),
	        };
	    }
	}
	exports.V0InngestExecution = V0InngestExecution;
	const tickOpToOutgoing = (op) => {
	    return {
	        op: op.op,
	        id: op.id,
	        name: op.name,
	        opts: op.opts,
	    };
	};
	const hashData = (op) => {
	    return (0, hash_js_1.sha1)().update((0, canonicalize_1.default)(op)).digest("hex");
	};
	/**
	 * Exported for testing.
	 */
	exports._internals = { hashData };
	
} (v0));

var v1 = {};

var StepError$1 = {};

Object.defineProperty(StepError$1, "__esModule", { value: true });
StepError$1.StepError = void 0;
const errors_js_1$2 = errors$2;
const types_js_1$2 = types$2;
/**
 * An error that represents a step exhausting all retries and failing. This is
 * thrown by an Inngest step if it fails.
 *
 * It's synonymous with an `Error`, with the addition of the `stepId` that
 * failed.
 *
 * @public
 */
class StepError extends Error {
    constructor(
    /**
     * The ID of the step that failed.
     */
    stepId, err) {
        var _a;
        const parsedErr = types_js_1$2.jsonErrorSchema.parse(err);
        super(parsedErr.message);
        this.stepId = stepId;
        this.name = parsedErr.name;
        this.stepId = stepId;
        // Don't show the internal stack trace if we don't have one.
        this.stack = (_a = parsedErr.stack) !== null && _a !== void 0 ? _a : undefined;
        // Try setting the cause if we have one
        this.cause = parsedErr.cause
            ? (0, errors_js_1$2.deserializeError)(parsedErr.cause)
            : undefined;
    }
}
StepError$1.StepError = StepError;

(function (exports) {
	var __asyncValues = (v1 && v1.__asyncValues) || function (o) {
	    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	    var m = o[Symbol.asyncIterator], i;
	    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
	    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
	    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
	};
	var __await = (v1 && v1.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); };
	var __asyncGenerator = (v1 && v1.__asyncGenerator) || function (thisArg, _arguments, generator) {
	    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	    var g = generator.apply(thisArg, _arguments || []), i, q = [];
	    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;
	    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }
	    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }
	    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
	    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
	    function fulfill(value) { resume("next", value); }
	    function reject(value) { resume("throw", value); }
	    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports._internals = exports.createV1InngestExecution = void 0;
	const hash_js_1 = hash;
	const zod_1 = lib$2;
	const consts_js_1 = consts;
	const errors_js_1 = errors$2;
	const functions_js_1 = functions;
	const promises_js_1 = promises;
	const types_js_1 = types$2;
	const InngestMiddleware_js_1 = InngestMiddleware$1;
	const InngestStepTools_js_1 = InngestStepTools;
	const NonRetriableError_js_1 = NonRetriableError$1;
	const RetryAfterError_js_1 = RetryAfterError$1;
	const StepError_js_1 = StepError$1;
	const InngestExecution_js_1 = InngestExecution$1;
	const als_js_1 = als;
	const createV1InngestExecution = (options) => {
	    return new V1InngestExecution(options);
	};
	exports.createV1InngestExecution = createV1InngestExecution;
	class V1InngestExecution extends InngestExecution_js_1.InngestExecution {
	    constructor(options) {
	        super(options);
	        this.timeoutDuration = 1000 * 10;
	        this.userFnToRun = this.getUserFnToRun();
	        this.state = this.createExecutionState();
	        this.fnArg = this.createFnArg();
	        this.checkpointHandlers = this.createCheckpointHandlers();
	        this.initializeTimer(this.state);
	        this.debug("created new V1 execution for run;", this.options.requestedRunStep
	            ? `wanting to run step "${this.options.requestedRunStep}"`
	            : "discovering steps");
	        this.debug("existing state keys:", Object.keys(this.state.stepState));
	    }
	    /**
	     * Idempotently start the execution of the user's function.
	     */
	    start() {
	        if (!this.execution) {
	            this.debug("starting V1 execution");
	            this.execution = (0, als_js_1.getAsyncLocalStorage)().then((als) => {
	                return als.run({ ctx: this.fnArg }, async () => {
	                    return this._start().then((result) => {
	                        this.debug("result:", result);
	                        return result;
	                    });
	                });
	            });
	        }
	        return this.execution;
	    }
	    /**
	     * Starts execution of the user's function and the core loop.
	     */
	    async _start() {
	        var _a, e_1, _b, _c;
	        var _d, _e;
	        try {
	            const allCheckpointHandler = this.getCheckpointHandler("");
	            this.state.hooks = await this.initializeMiddleware();
	            await this.startExecution();
	            try {
	                for (var _f = true, _g = __asyncValues(this.state.loop), _h; _h = await _g.next(), _a = _h.done, !_a; _f = true) {
	                    _c = _h.value;
	                    _f = false;
	                    const checkpoint = _c;
	                    await allCheckpointHandler(checkpoint);
	                    const handler = this.getCheckpointHandler(checkpoint.type);
	                    const result = await handler(checkpoint);
	                    if (result) {
	                        return result;
	                    }
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (!_f && !_a && (_b = _g.return)) await _b.call(_g);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }
	        catch (error) {
	            return await this.transformOutput({ error });
	        }
	        finally {
	            void this.state.loop.return();
	            await ((_e = (_d = this.state.hooks) === null || _d === void 0 ? void 0 : _d.beforeResponse) === null || _e === void 0 ? void 0 : _e.call(_d));
	        }
	        /**
	         * If we're here, the generator somehow finished without returning a value.
	         * This should never happen.
	         */
	        throw new Error("Core loop finished without returning a value");
	    }
	    /**
	     * Creates a handler for every checkpoint type, defining what to do when we
	     * reach that checkpoint in the core loop.
	     */
	    createCheckpointHandlers() {
	        return {
	            /**
	             * Run for all checkpoints. Best used for logging or common actions.
	             * Use other handlers to return values and interrupt the core loop.
	             */
	            "": (checkpoint) => {
	                this.debug("checkpoint:", checkpoint);
	            },
	            /**
	             * The user's function has completed and returned a value.
	             */
	            "function-resolved": async (checkpoint) => {
	                return await this.transformOutput({ data: checkpoint.data });
	            },
	            /**
	             * The user's function has thrown an error.
	             */
	            "function-rejected": async (checkpoint) => {
	                return await this.transformOutput({ error: checkpoint.error });
	            },
	            /**
	             * We've found one or more steps. Here we may want to run a step or report
	             * them back to Inngest.
	             */
	            "steps-found": async ({ steps }) => {
	                const stepResult = await this.tryExecuteStep(steps);
	                if (stepResult) {
	                    const transformResult = await this.transformOutput(stepResult);
	                    /**
	                     * Transforming output will always return either function rejection or
	                     * resolution. In most cases, this can be immediately returned, but in
	                     * this particular case we want to handle it differently.
	                     */
	                    if (transformResult.type === "function-resolved") {
	                        return {
	                            type: "step-ran",
	                            ctx: transformResult.ctx,
	                            ops: transformResult.ops,
	                            step: exports._internals.hashOp(Object.assign(Object.assign({}, stepResult), { data: transformResult.data })),
	                        };
	                    }
	                    else if (transformResult.type === "function-rejected") {
	                        return {
	                            type: "step-ran",
	                            ctx: transformResult.ctx,
	                            ops: transformResult.ops,
	                            step: exports._internals.hashOp(Object.assign(Object.assign({}, stepResult), { error: transformResult.error })),
	                            retriable: transformResult.retriable,
	                        };
	                    }
	                    return transformResult;
	                }
	                const newSteps = await this.filterNewSteps(Array.from(this.state.steps.values()));
	                if (newSteps) {
	                    return {
	                        type: "steps-found",
	                        ctx: this.fnArg,
	                        ops: this.ops,
	                        steps: newSteps,
	                    };
	                }
	            },
	            /**
	             * While trying to find a step that Inngest has told us to run, we've
	             * timed out or have otherwise decided that it doesn't exist.
	             */
	            "step-not-found": ({ step }) => {
	                return { type: "step-not-found", ctx: this.fnArg, ops: this.ops, step };
	            },
	        };
	    }
	    getCheckpointHandler(type) {
	        return this.checkpointHandlers[type];
	    }
	    async tryExecuteStep(steps) {
	        var _a;
	        const hashedStepIdToRun = this.options.requestedRunStep || this.getEarlyExecRunStep(steps);
	        if (!hashedStepIdToRun) {
	            return;
	        }
	        const step = steps.find((step) => step.hashedId === hashedStepIdToRun && step.fn);
	        if (step) {
	            return await this.executeStep(step);
	        }
	        /**
	         * Ensure we reset the timeout if we have a requested run step but couldn't
	         * find it, but also that we don't reset if we found and executed it.
	         */
	        void ((_a = this.timeout) === null || _a === void 0 ? void 0 : _a.reset());
	    }
	    /**
	     * Given a list of outgoing ops, decide if we can execute an op early and
	     * return the ID of the step to execute if we can.
	     */
	    getEarlyExecRunStep(steps) {
	        /**
	         * We may have been disabled due to parallelism, in which case we can't
	         * immediately execute unless explicitly requested.
	         */
	        if (this.options.disableImmediateExecution)
	            return;
	        const unfulfilledSteps = steps.filter((step) => !step.fulfilled);
	        if (unfulfilledSteps.length !== 1)
	            return;
	        const op = unfulfilledSteps[0];
	        if (op &&
	            op.op === types_js_1.StepOpCode.StepPlanned
	        // TODO We must individually check properties here that we do not want to
	        // execute on, such as retry counts. Nothing exists here that falls in to
	        // this case, but should be accounted for when we add them.
	        // && typeof op.opts === "undefined"
	        ) {
	            return op.hashedId;
	        }
	    }
	    async filterNewSteps(foundSteps) {
	        var _a, _b, _c, _d, _e, _f;
	        if (this.options.requestedRunStep) {
	            return;
	        }
	        /**
	         * Gather any steps that aren't memoized and report them.
	         */
	        const newSteps = foundSteps.filter((step) => !step.fulfilled);
	        if (!newSteps.length) {
	            return;
	        }
	        /**
	         * Warn if we've found new steps but haven't yet seen all previous
	         * steps. This may indicate that step presence isn't determinate.
	         */
	        let knownSteps = 0;
	        for (const step of foundSteps) {
	            if (step.fulfilled) {
	                knownSteps++;
	            }
	        }
	        const foundAllCompletedSteps = this.state.stepsToFulfill === knownSteps;
	        if (!foundAllCompletedSteps) {
	            // TODO Tag
	            console.warn((0, errors_js_1.prettyError)({
	                type: "warn",
	                whatHappened: "Function may be indeterminate",
	                why: "We found new steps before seeing all previous steps, which may indicate that the function is non-deterministic.",
	                consequences: "This may cause unexpected behaviour as Inngest executes your function.",
	                reassurance: "This is expected if a function is updated in the middle of a run, but may indicate a bug if not.",
	            }));
	        }
	        /**
	         * We're finishing up; let's trigger the last of the hooks.
	         */
	        await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));
	        await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));
	        await ((_f = (_e = this.state.hooks) === null || _e === void 0 ? void 0 : _e.afterExecution) === null || _f === void 0 ? void 0 : _f.call(_e));
	        const stepList = newSteps.map((step) => ({
	            displayName: step.displayName,
	            op: step.op,
	            id: step.hashedId,
	            name: step.name,
	            opts: step.opts,
	        }));
	        /**
	         * We also run `onSendEvent` middleware hooks against `step.invoke()` steps
	         * to ensure that their `data` is transformed correctly.
	         */
	        return await this.transformNewSteps(stepList);
	    }
	    /**
	     * Using middleware, transform any newly-found steps before returning them to
	     * an Inngest Server.
	     */
	    async transformNewSteps(steps) {
	        return Promise.all(steps.map(async (step) => {
	            var _a, _b, _c, _d, _e, _f, _g;
	            if (step.op !== types_js_1.StepOpCode.InvokeFunction) {
	                return step;
	            }
	            const onSendEventHooks = await (0, InngestMiddleware_js_1.getHookStack)(this.options.fn["middleware"], "onSendEvent", undefined, {
	                transformInput: (prev, output) => {
	                    return Object.assign(Object.assign({}, prev), output);
	                },
	                transformOutput: (prev, output) => {
	                    return {
	                        result: Object.assign(Object.assign({}, prev.result), output === null || output === void 0 ? void 0 : output.result),
	                    };
	                },
	            });
	            /**
	             * For each event being sent, create a new `onSendEvent` hook stack to
	             * process it. We do this as middleware hooks are intended to run once
	             * during each lifecycle (onFunctionRun or onSendEvent) and here, a hook
	             * is run for every single event.
	             *
	             * This is done because a developer can use this hook to filter out
	             * events entirely; if we batch all of the events together, we can't
	             * tell which ones were filtered out if we're processing >1 invocation
	             * here.
	             */
	            const transformedPayload = await ((_a = onSendEventHooks.transformInput) === null || _a === void 0 ? void 0 : _a.call(onSendEventHooks, {
	                payloads: [
	                    Object.assign(Object.assign({}, ((_c = (_b = step.opts) === null || _b === void 0 ? void 0 : _b.payload) !== null && _c !== void 0 ? _c : {})), { name: consts_js_1.internalEvents.FunctionInvoked }),
	                ],
	            }));
	            const newPayload = InngestStepTools_js_1.invokePayloadSchema.parse((_e = (_d = transformedPayload === null || transformedPayload === void 0 ? void 0 : transformedPayload.payloads) === null || _d === void 0 ? void 0 : _d[0]) !== null && _e !== void 0 ? _e : {});
	            return Object.assign(Object.assign({}, step), { opts: Object.assign(Object.assign({}, step.opts), { payload: Object.assign(Object.assign({}, ((_g = (_f = step.opts) === null || _f === void 0 ? void 0 : _f.payload) !== null && _g !== void 0 ? _g : {})), newPayload) }) });
	        }));
	    }
	    async executeStep({ id, name, opts, fn, displayName, }) {
	        var _a, _b, _c, _d, _e;
	        (_a = this.timeout) === null || _a === void 0 ? void 0 : _a.clear();
	        await ((_c = (_b = this.state.hooks) === null || _b === void 0 ? void 0 : _b.afterMemoization) === null || _c === void 0 ? void 0 : _c.call(_b));
	        await ((_e = (_d = this.state.hooks) === null || _d === void 0 ? void 0 : _d.beforeExecution) === null || _e === void 0 ? void 0 : _e.call(_d));
	        const outgoingOp = {
	            id,
	            op: types_js_1.StepOpCode.StepRun,
	            name,
	            opts,
	            displayName,
	        };
	        this.state.executingStep = outgoingOp;
	        const store = await (0, als_js_1.getAsyncCtx)();
	        if (store) {
	            store.executingStep = {
	                id,
	                name: displayName,
	            };
	        }
	        this.debug(`executing step "${id}"`);
	        return ((0, promises_js_1.runAsPromise)(fn)
	            // eslint-disable-next-line @typescript-eslint/no-misused-promises
	            .finally(async () => {
	            var _a, _b;
	            if (store) {
	                delete store.executingStep;
	            }
	            await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterExecution) === null || _b === void 0 ? void 0 : _b.call(_a));
	        })
	            .then((data) => {
	            return Object.assign(Object.assign({}, outgoingOp), { data });
	        })
	            .catch((error) => {
	            return Object.assign(Object.assign({}, outgoingOp), { op: types_js_1.StepOpCode.StepError, 
	                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
	                error });
	        }));
	    }
	    /**
	     * Starts execution of the user's function, including triggering checkpoints
	     * and middleware hooks where appropriate.
	     */
	    async startExecution() {
	        var _a, _b, _c, _d, _e, _f, _g;
	        /**
	         * Mutate input as neccessary based on middleware.
	         */
	        await this.transformInput();
	        /**
	         * Start the timer to time out the run if needed.
	         */
	        void ((_a = this.timeout) === null || _a === void 0 ? void 0 : _a.start());
	        await ((_c = (_b = this.state.hooks) === null || _b === void 0 ? void 0 : _b.beforeMemoization) === null || _c === void 0 ? void 0 : _c.call(_b));
	        /**
	         * If we had no state to begin with, immediately end the memoization phase.
	         */
	        if (this.state.allStateUsed()) {
	            await ((_e = (_d = this.state.hooks) === null || _d === void 0 ? void 0 : _d.afterMemoization) === null || _e === void 0 ? void 0 : _e.call(_d));
	            await ((_g = (_f = this.state.hooks) === null || _f === void 0 ? void 0 : _f.beforeExecution) === null || _g === void 0 ? void 0 : _g.call(_f));
	        }
	        /**
	         * Trigger the user's function.
	         */
	        (0, promises_js_1.runAsPromise)(() => this.userFnToRun(this.fnArg))
	            // eslint-disable-next-line @typescript-eslint/no-misused-promises
	            .finally(async () => {
	            var _a, _b, _c, _d, _e, _f;
	            await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));
	            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));
	            await ((_f = (_e = this.state.hooks) === null || _e === void 0 ? void 0 : _e.afterExecution) === null || _f === void 0 ? void 0 : _f.call(_e));
	        })
	            .then((data) => {
	            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
	            this.state.setCheckpoint({ type: "function-resolved", data });
	        })
	            .catch((error) => {
	            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
	            this.state.setCheckpoint({ type: "function-rejected", error });
	        });
	    }
	    /**
	     * Using middleware, transform input before running.
	     */
	    async transformInput() {
	        var _a, _b;
	        const inputMutations = await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.transformInput) === null || _b === void 0 ? void 0 : _b.call(_a, {
	            ctx: Object.assign({}, this.fnArg),
	            steps: Object.values(this.state.stepState),
	            fn: this.options.fn,
	            reqArgs: this.options.reqArgs,
	        }));
	        if (inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.ctx) {
	            this.fnArg = inputMutations.ctx;
	        }
	        if (inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.steps) {
	            this.state.stepState = Object.fromEntries(inputMutations.steps.map((step) => [step.id, step]));
	        }
	    }
	    /**
	     * Using middleware, transform output before returning.
	     */
	    async transformOutput(dataOrError) {
	        var _a, _b, _c, _d;
	        const output = Object.assign({}, dataOrError);
	        /**
	         * If we've been given an error and it's one that we just threw from a step,
	         * we should return a `NonRetriableError` to stop execution.
	         */
	        if (typeof output.error !== "undefined") {
	            output.data = (0, errors_js_1.serializeError)(output.error);
	        }
	        const isStepExecution = Boolean(this.state.executingStep);
	        const transformedOutput = await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.transformOutput) === null || _b === void 0 ? void 0 : _b.call(_a, {
	            result: Object.assign({}, output),
	            step: this.state.executingStep,
	        }));
	        const { data, error } = Object.assign(Object.assign({}, output), transformedOutput === null || transformedOutput === void 0 ? void 0 : transformedOutput.result);
	        if (!isStepExecution) {
	            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.finished) === null || _d === void 0 ? void 0 : _d.call(_c, {
	                result: Object.assign({}, (typeof error !== "undefined" ? { error } : { data })),
	            }));
	        }
	        if (typeof error !== "undefined") {
	            /**
	             * Ensure we give middleware the chance to decide on retriable behaviour
	             * by looking at the error returned from output transformation.
	             */
	            let retriable = !(error instanceof NonRetriableError_js_1.NonRetriableError || error instanceof StepError_js_1.StepError);
	            if (retriable && error instanceof RetryAfterError_js_1.RetryAfterError) {
	                retriable = error.retryAfter;
	            }
	            const serializedError = (0, errors_js_1.minifyPrettyError)((0, errors_js_1.serializeError)(error));
	            return {
	                type: "function-rejected",
	                ctx: this.fnArg,
	                ops: this.ops,
	                error: serializedError,
	                retriable,
	            };
	        }
	        return {
	            type: "function-resolved",
	            ctx: this.fnArg,
	            ops: this.ops,
	            data: (0, functions_js_1.undefinedToNull)(data),
	        };
	    }
	    createExecutionState() {
	        const d = (0, promises_js_1.createDeferredPromiseWithStack)();
	        let checkpointResolve = d.deferred.resolve;
	        const checkpointResults = d.results;
	        const loop = (function (cleanUp) {
	            return __asyncGenerator(this, arguments, function* () {
	                try {
	                    while (true) {
	                        const res = (yield __await(checkpointResults.next())).value;
	                        if (res) {
	                            yield yield __await(res);
	                        }
	                    }
	                }
	                finally {
	                    cleanUp === null || cleanUp === void 0 ? void 0 : cleanUp();
	                }
	            });
	        })(() => {
	            var _a;
	            (_a = this.timeout) === null || _a === void 0 ? void 0 : _a.clear();
	            void checkpointResults.return();
	        });
	        const stepsToFulfill = Object.keys(this.options.stepState).length;
	        const state = {
	            stepState: this.options.stepState,
	            stepsToFulfill,
	            steps: new Map(),
	            loop,
	            hasSteps: Boolean(stepsToFulfill),
	            stepCompletionOrder: [...this.options.stepCompletionOrder],
	            remainingStepsToBeSeen: new Set(this.options.stepCompletionOrder),
	            setCheckpoint: (checkpoint) => {
	                ({ resolve: checkpointResolve } = checkpointResolve(checkpoint));
	            },
	            allStateUsed: () => {
	                return this.state.remainingStepsToBeSeen.size === 0;
	            },
	        };
	        return state;
	    }
	    get ops() {
	        return Object.fromEntries(this.state.steps);
	    }
	    createFnArg() {
	        var _a, _b, _c, _d;
	        const step = this.createStepTools();
	        let fnArg = Object.assign(Object.assign({}, this.options.data), { step });
	        /**
	         * Handle use of the `onFailure` option by deserializing the error.
	         */
	        if (this.options.isFailureHandler) {
	            const eventData = zod_1.z
	                .object({ error: types_js_1.jsonErrorSchema })
	                .parse((_a = fnArg.event) === null || _a === void 0 ? void 0 : _a.data);
	            fnArg = Object.assign(Object.assign({}, fnArg), { error: (0, errors_js_1.deserializeError)(eventData.error) });
	        }
	        return (_d = (_c = (_b = this.options).transformCtx) === null || _c === void 0 ? void 0 : _c.call(_b, fnArg)) !== null && _d !== void 0 ? _d : fnArg;
	    }
	    createStepTools() {
	        /**
	         * A list of steps that have been found and are being rolled up before being
	         * reported to the core loop.
	         */
	        const foundStepsToReport = new Map();
	        /**
	         * A map of the subset of found steps to report that have not yet been
	         * handled. Used for fast access to steps that need to be handled in order.
	         */
	        const unhandledFoundStepsToReport = new Map();
	        /**
	         * A map of the latest sequential step indexes found for each step ID. Used
	         * to ensure that we don't index steps in parallel.
	         *
	         * Note that these must be sequential; if we've seen or assigned `a:1`,
	         * `a:2` and `a:4`, the latest sequential step index is `2`.
	         *
	         */
	        const expectedNextStepIndexes = new Map();
	        /**
	         * An ordered list of step IDs that have yet to be handled in this
	         * execution. Used to ensure that we handle steps in the order they were
	         * found and based on the `stepCompletionOrder` in this execution's state.
	         */
	        const remainingStepCompletionOrder = this.state.stepCompletionOrder.slice();
	        /**
	         * A promise that's used to ensure that step reporting cannot be run more than
	         * once in a given asynchronous time span.
	         */
	        let foundStepsReportPromise;
	        /**
	         * A promise that's used to represent middleware hooks running before
	         * execution.
	         */
	        let beforeExecHooksPromise;
	        /**
	         * A flag used to ensure that we only warn about parallel indexing once per
	         * execution to avoid spamming the console.
	         */
	        let warnOfParallelIndexing = false;
	        /**
	         * Counts the number of times we've extended this tick.
	         */
	        let tickExtensionCount = 0;
	        /**
	         * Given a colliding step ID, maybe warn the user about parallel indexing.
	         */
	        const maybeWarnOfParallelIndexing = (collisionId) => {
	            if (warnOfParallelIndexing) {
	                return;
	            }
	            const stepExists = this.state.steps.has(collisionId);
	            if (stepExists) {
	                const stepFoundThisTick = foundStepsToReport.has(collisionId);
	                if (!stepFoundThisTick) {
	                    warnOfParallelIndexing = true;
	                    console.warn((0, errors_js_1.prettyError)({
	                        type: "warn",
	                        whatHappened: "We detected that you have multiple steps with the same ID.",
	                        code: errors_js_1.ErrCode.AUTOMATIC_PARALLEL_INDEXING,
	                        why: `This can happen if you're using the same ID for multiple steps across different chains of parallel work. We found the issue with step "${collisionId}".`,
	                        reassurance: "Your function is still running, though it may exhibit unexpected behaviour.",
	                        consequences: "Using the same IDs across parallel chains of work can cause unexpected behaviour.",
	                        toFixNow: "We recommend using a unique ID for each step, especially those happening in parallel.",
	                    }));
	                }
	            }
	        };
	        /**
	         * A helper used to report steps to the core loop. Used after adding an item
	         * to `foundStepsToReport`.
	         */
	        const reportNextTick = () => {
	            // Being explicit instead of using `??=` to appease TypeScript.
	            if (foundStepsReportPromise) {
	                return;
	            }
	            let extensionPromise;
	            if (++tickExtensionCount >= 10) {
	                tickExtensionCount = 0;
	                extensionPromise = new Promise((resolve) => setTimeout(resolve));
	            }
	            else {
	                extensionPromise = (0, promises_js_1.resolveAfterPending)();
	            }
	            foundStepsReportPromise = extensionPromise
	                /**
	                 * Ensure that we wait for this promise to resolve before continuing.
	                 *
	                 * The groups in which steps are reported can affect how we detect some
	                 * more complex determinism issues like parallel indexing. This promise
	                 * can represent middleware hooks being run early, in the middle of
	                 * ingesting steps to report.
	                 *
	                 * Because of this, it's important we wait for this middleware to resolve
	                 * before continuing to report steps to ensure that all steps have a
	                 * chance to be reported throughout this asynchronous action.
	                 */
	                .then(() => beforeExecHooksPromise)
	                .then(() => {
	                var _a;
	                foundStepsReportPromise = undefined;
	                for (let i = 0; i < remainingStepCompletionOrder.length; i++) {
	                    const nextStepId = remainingStepCompletionOrder[i];
	                    if (!nextStepId) {
	                        // Strange - skip this empty index
	                        continue;
	                    }
	                    const handled = (_a = unhandledFoundStepsToReport
	                        .get(nextStepId)) === null || _a === void 0 ? void 0 : _a.handle();
	                    if (handled) {
	                        remainingStepCompletionOrder.splice(i, 1);
	                        unhandledFoundStepsToReport.delete(nextStepId);
	                        return void reportNextTick();
	                    }
	                }
	                // If we've handled no steps in this "tick," roll up everything we've
	                // found and report it.
	                const steps = [...foundStepsToReport.values()];
	                foundStepsToReport.clear();
	                unhandledFoundStepsToReport.clear();
	                return void this.state.setCheckpoint({
	                    type: "steps-found",
	                    steps: steps,
	                });
	            });
	        };
	        /**
	         * A helper used to push a step to the list of steps to report.
	         */
	        const pushStepToReport = (step) => {
	            foundStepsToReport.set(step.id, step);
	            unhandledFoundStepsToReport.set(step.hashedId, step);
	            reportNextTick();
	        };
	        const stepHandler = async ({ args, matchOp, opts, }) => {
	            var _a, _b, _c, _d;
	            await beforeExecHooksPromise;
	            const stepOptions = (0, InngestStepTools_js_1.getStepOptions)(args[0]);
	            const opId = matchOp(stepOptions, ...args.slice(1));
	            if (this.state.executingStep) {
	                /**
	                 * If a step is found after asynchronous actions during another step's
	                 * execution, everything is fine. The problem here is if we've found
	                 * that a step nested inside another a step, which is something we don't
	                 * support at the time of writing.
	                 *
	                 * In this case, we could use something like Async Hooks to understand
	                 * how the step is being triggered, though this isn't available in all
	                 * environments.
	                 *
	                 * Therefore, we'll only show a warning here to indicate that this is
	                 * potentially an issue.
	                 */
	                console.warn((0, errors_js_1.prettyError)({
	                    whatHappened: `We detected that you have nested \`step.*\` tooling in \`${(_a = opId.displayName) !== null && _a !== void 0 ? _a : opId.id}\``,
	                    consequences: "Nesting `step.*` tooling is not supported.",
	                    type: "warn",
	                    reassurance: "It's possible to see this warning if steps are separated by regular asynchronous calls, which is fine.",
	                    stack: true,
	                    toFixNow: "Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.",
	                    code: errors_js_1.ErrCode.NESTING_STEPS,
	                }));
	            }
	            if (this.state.steps.has(opId.id)) {
	                const originalId = opId.id;
	                maybeWarnOfParallelIndexing(originalId);
	                const expectedNextIndex = (_b = expectedNextStepIndexes.get(originalId)) !== null && _b !== void 0 ? _b : 1;
	                for (let i = expectedNextIndex;; i++) {
	                    const newId = originalId + InngestStepTools_js_1.STEP_INDEXING_SUFFIX + i;
	                    if (!this.state.steps.has(newId)) {
	                        expectedNextStepIndexes.set(originalId, i + 1);
	                        opId.id = newId;
	                        break;
	                    }
	                }
	            }
	            const { promise, resolve, reject } = (0, promises_js_1.createDeferredPromise)();
	            const hashedId = exports._internals.hashId(opId.id);
	            const stepState = this.state.stepState[hashedId];
	            let isFulfilled = false;
	            if (stepState) {
	                stepState.seen = true;
	                this.state.remainingStepsToBeSeen.delete(hashedId);
	                if (typeof stepState.input === "undefined") {
	                    isFulfilled = true;
	                }
	            }
	            let extraOpts;
	            let fnArgs = [...args];
	            if (typeof (stepState === null || stepState === void 0 ? void 0 : stepState.input) !== "undefined" &&
	                Array.isArray(stepState.input)) {
	                switch (opId.op) {
	                    // `step.run()` has its function input affected
	                    case types_js_1.StepOpCode.StepPlanned: {
	                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
	                        fnArgs = [...args.slice(0, 2), ...stepState.input];
	                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
	                        extraOpts = { input: [...stepState.input] };
	                        break;
	                    }
	                    // `step.ai.infer()` has its body affected
	                    case types_js_1.StepOpCode.AiGateway: {
	                        extraOpts = {
	                            body: Object.assign(Object.assign({}, (typeof ((_c = opId.opts) === null || _c === void 0 ? void 0 : _c.body) === "object"
	                                ? Object.assign({}, opId.opts.body) : {})), stepState.input[0]),
	                        };
	                        break;
	                    }
	                }
	            }
	            const step = Object.assign(Object.assign({}, opId), { opts: Object.assign(Object.assign({}, opId.opts), extraOpts), rawArgs: fnArgs, // TODO What is the right value here? Should this be raw args without affected input?
	                hashedId, input: stepState === null || stepState === void 0 ? void 0 : stepState.input, 
	                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
	                fn: (opts === null || opts === void 0 ? void 0 : opts.fn) ? () => { var _a; return (_a = opts.fn) === null || _a === void 0 ? void 0 : _a.call(opts, ...fnArgs); } : undefined, promise, fulfilled: isFulfilled, hasStepState: Boolean(stepState), displayName: (_d = opId.displayName) !== null && _d !== void 0 ? _d : opId.id, handled: false, handle: () => {
	                    if (step.handled) {
	                        return false;
	                    }
	                    step.handled = true;
	                    if (isFulfilled && stepState) {
	                        stepState.fulfilled = true;
	                        // For some execution scenarios such as testing, `data`, `error`,
	                        // and `input` may be `Promises`. This could also be the case for
	                        // future middleware applications. For this reason, we'll make sure
	                        // the values are fully resolved before continuing.
	                        void Promise.all([
	                            stepState.data,
	                            stepState.error,
	                            stepState.input,
	                        ]).then(() => {
	                            if (typeof stepState.data !== "undefined") {
	                                resolve(stepState.data);
	                            }
	                            else {
	                                this.state.recentlyRejectedStepError = new StepError_js_1.StepError(opId.id, stepState.error);
	                                reject(this.state.recentlyRejectedStepError);
	                            }
	                        });
	                    }
	                    return true;
	                } });
	            this.state.steps.set(opId.id, step);
	            this.state.hasSteps = true;
	            pushStepToReport(step);
	            /**
	             * If this is the last piece of state we had, we've now finished
	             * memoizing.
	             */
	            if (!beforeExecHooksPromise && this.state.allStateUsed()) {
	                await (beforeExecHooksPromise = (async () => {
	                    var _a, _b, _c, _d;
	                    await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));
	                    await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));
	                })());
	            }
	            return promise;
	        };
	        return (0, InngestStepTools_js_1.createStepTools)(this.options.client, this, stepHandler);
	    }
	    getUserFnToRun() {
	        if (!this.options.isFailureHandler) {
	            return this.options.fn["fn"];
	        }
	        if (!this.options.fn["onFailureFn"]) {
	            /**
	             * Somehow, we've ended up detecting that this is a failure handler but
	             * doesn't have an `onFailure` function. This should never happen.
	             */
	            throw new Error("Cannot find function `onFailure` handler");
	        }
	        return this.options.fn["onFailureFn"];
	    }
	    initializeTimer(state) {
	        if (!this.options.requestedRunStep) {
	            return;
	        }
	        this.timeout = (0, promises_js_1.createTimeoutPromise)(this.timeoutDuration);
	        void this.timeout.then(async () => {
	            var _a, _b, _c, _d, _e, _f;
	            await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));
	            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));
	            await ((_f = (_e = this.state.hooks) === null || _e === void 0 ? void 0 : _e.afterExecution) === null || _f === void 0 ? void 0 : _f.call(_e));
	            state.setCheckpoint({
	                type: "step-not-found",
	                step: {
	                    id: this.options.requestedRunStep,
	                    op: types_js_1.StepOpCode.StepNotFound,
	                },
	            });
	        });
	    }
	    async initializeMiddleware() {
	        const ctx = this.options.data;
	        const hooks = await (0, InngestMiddleware_js_1.getHookStack)(this.options.fn["middleware"], "onFunctionRun", {
	            ctx,
	            fn: this.options.fn,
	            steps: Object.values(this.options.stepState),
	            reqArgs: this.options.reqArgs,
	        }, {
	            transformInput: (prev, output) => {
	                return {
	                    ctx: Object.assign(Object.assign({}, prev.ctx), output === null || output === void 0 ? void 0 : output.ctx),
	                    fn: this.options.fn,
	                    steps: prev.steps.map((step, i) => {
	                        var _a;
	                        return (Object.assign(Object.assign({}, step), (_a = output === null || output === void 0 ? void 0 : output.steps) === null || _a === void 0 ? void 0 : _a[i]));
	                    }),
	                    reqArgs: prev.reqArgs,
	                };
	            },
	            transformOutput: (prev, output) => {
	                return {
	                    result: Object.assign(Object.assign({}, prev.result), output === null || output === void 0 ? void 0 : output.result),
	                    step: prev.step,
	                };
	            },
	        });
	        return hooks;
	    }
	}
	const hashId = (id) => {
	    return (0, hash_js_1.sha1)().update(id).digest("hex");
	};
	const hashOp = (op) => {
	    return Object.assign(Object.assign({}, op), { id: hashId(op.id) });
	};
	/**
	 * Exported for testing.
	 */
	exports._internals = { hashOp, hashId };
	
} (v1));

var v2 = {};

(function (exports) {
	var __asyncValues = (v2 && v2.__asyncValues) || function (o) {
	    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	    var m = o[Symbol.asyncIterator], i;
	    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
	    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
	    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
	};
	var __await = (v2 && v2.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); };
	var __asyncGenerator = (v2 && v2.__asyncGenerator) || function (thisArg, _arguments, generator) {
	    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	    var g = generator.apply(thisArg, _arguments || []), i, q = [];
	    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;
	    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }
	    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }
	    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
	    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
	    function fulfill(value) { resume("next", value); }
	    function reject(value) { resume("throw", value); }
	    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports._internals = exports.createV2InngestExecution = void 0;
	const hash_js_1 = hash;
	const zod_1 = lib$2;
	const consts_js_1 = consts;
	const errors_js_1 = errors$2;
	const functions_js_1 = functions;
	const promises_js_1 = promises;
	const types_js_1 = types$2;
	const InngestMiddleware_js_1 = InngestMiddleware$1;
	const InngestStepTools_js_1 = InngestStepTools;
	const NonRetriableError_js_1 = NonRetriableError$1;
	const RetryAfterError_js_1 = RetryAfterError$1;
	const StepError_js_1 = StepError$1;
	const InngestExecution_js_1 = InngestExecution$1;
	const als_js_1 = als;
	const createV2InngestExecution = (options) => {
	    return new V2InngestExecution(options);
	};
	exports.createV2InngestExecution = createV2InngestExecution;
	class V2InngestExecution extends InngestExecution_js_1.InngestExecution {
	    constructor(options) {
	        super(options);
	        this.timeoutDuration = 1000 * 10;
	        this.userFnToRun = this.getUserFnToRun();
	        this.state = this.createExecutionState();
	        this.fnArg = this.createFnArg();
	        this.checkpointHandlers = this.createCheckpointHandlers();
	        this.initializeTimer(this.state);
	        this.debug("created new V2 execution for run;", this.options.requestedRunStep
	            ? `wanting to run step "${this.options.requestedRunStep}"`
	            : "discovering steps");
	        this.debug("existing state keys:", Object.keys(this.state.stepState));
	    }
	    /**
	     * Idempotently start the execution of the user's function.
	     */
	    start() {
	        if (!this.execution) {
	            this.debug("starting V2 execution");
	            this.execution = (0, als_js_1.getAsyncLocalStorage)().then((als) => {
	                return als.run({ ctx: this.fnArg }, async () => {
	                    return this._start().then((result) => {
	                        this.debug("result:", result);
	                        return result;
	                    });
	                });
	            });
	        }
	        return this.execution;
	    }
	    /**
	     * Starts execution of the user's function and the core loop.
	     */
	    async _start() {
	        var _a, e_1, _b, _c;
	        var _d, _e;
	        try {
	            const allCheckpointHandler = this.getCheckpointHandler("");
	            this.state.hooks = await this.initializeMiddleware();
	            await this.startExecution();
	            try {
	                for (var _f = true, _g = __asyncValues(this.state.loop), _h; _h = await _g.next(), _a = _h.done, !_a; _f = true) {
	                    _c = _h.value;
	                    _f = false;
	                    const checkpoint = _c;
	                    await allCheckpointHandler(checkpoint);
	                    const handler = this.getCheckpointHandler(checkpoint.type);
	                    const result = await handler(checkpoint);
	                    if (result) {
	                        return result;
	                    }
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (!_f && !_a && (_b = _g.return)) await _b.call(_g);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }
	        catch (error) {
	            return await this.transformOutput({ error });
	        }
	        finally {
	            void this.state.loop.return();
	            await ((_e = (_d = this.state.hooks) === null || _d === void 0 ? void 0 : _d.beforeResponse) === null || _e === void 0 ? void 0 : _e.call(_d));
	        }
	        /**
	         * If we're here, the generator somehow finished without returning a value.
	         * This should never happen.
	         */
	        throw new Error("Core loop finished without returning a value");
	    }
	    /**
	     * Creates a handler for every checkpoint type, defining what to do when we
	     * reach that checkpoint in the core loop.
	     */
	    createCheckpointHandlers() {
	        return {
	            /**
	             * Run for all checkpoints. Best used for logging or common actions.
	             * Use other handlers to return values and interrupt the core loop.
	             */
	            "": (checkpoint) => {
	                this.debug("checkpoint:", checkpoint);
	            },
	            /**
	             * The user's function has completed and returned a value.
	             */
	            "function-resolved": async (checkpoint) => {
	                return await this.transformOutput({ data: checkpoint.data });
	            },
	            /**
	             * The user's function has thrown an error.
	             */
	            "function-rejected": async (checkpoint) => {
	                return await this.transformOutput({ error: checkpoint.error });
	            },
	            /**
	             * We've found one or more steps. Here we may want to run a step or report
	             * them back to Inngest.
	             */
	            "steps-found": async ({ steps }) => {
	                const stepResult = await this.tryExecuteStep(steps);
	                if (stepResult) {
	                    const transformResult = await this.transformOutput(stepResult);
	                    /**
	                     * Transforming output will always return either function rejection or
	                     * resolution. In most cases, this can be immediately returned, but in
	                     * this particular case we want to handle it differently.
	                     */
	                    if (transformResult.type === "function-resolved") {
	                        return {
	                            type: "step-ran",
	                            ctx: transformResult.ctx,
	                            ops: transformResult.ops,
	                            step: exports._internals.hashOp(Object.assign(Object.assign({}, stepResult), { data: transformResult.data })),
	                        };
	                    }
	                    else if (transformResult.type === "function-rejected") {
	                        return {
	                            type: "step-ran",
	                            ctx: transformResult.ctx,
	                            ops: transformResult.ops,
	                            step: exports._internals.hashOp(Object.assign(Object.assign({}, stepResult), { error: transformResult.error })),
	                            retriable: transformResult.retriable,
	                        };
	                    }
	                    return transformResult;
	                }
	                const newSteps = await this.filterNewSteps(Array.from(this.state.steps.values()));
	                if (newSteps) {
	                    return {
	                        type: "steps-found",
	                        ctx: this.fnArg,
	                        ops: this.ops,
	                        steps: newSteps,
	                    };
	                }
	            },
	            /**
	             * While trying to find a step that Inngest has told us to run, we've
	             * timed out or have otherwise decided that it doesn't exist.
	             */
	            "step-not-found": ({ step }) => {
	                return { type: "step-not-found", ctx: this.fnArg, ops: this.ops, step };
	            },
	        };
	    }
	    getCheckpointHandler(type) {
	        return this.checkpointHandlers[type];
	    }
	    async tryExecuteStep(steps) {
	        var _a;
	        const hashedStepIdToRun = this.options.requestedRunStep || this.getEarlyExecRunStep(steps);
	        if (!hashedStepIdToRun) {
	            return;
	        }
	        const step = steps.find((step) => step.hashedId === hashedStepIdToRun && step.fn);
	        if (step) {
	            return await this.executeStep(step);
	        }
	        /**
	         * Ensure we reset the timeout if we have a requested run step but couldn't
	         * find it, but also that we don't reset if we found and executed it.
	         */
	        void ((_a = this.timeout) === null || _a === void 0 ? void 0 : _a.reset());
	    }
	    /**
	     * Given a list of outgoing ops, decide if we can execute an op early and
	     * return the ID of the step to execute if we can.
	     */
	    getEarlyExecRunStep(steps) {
	        /**
	         * We may have been disabled due to parallelism, in which case we can't
	         * immediately execute unless explicitly requested.
	         */
	        if (this.options.disableImmediateExecution)
	            return;
	        const unfulfilledSteps = steps.filter((step) => !step.fulfilled);
	        if (unfulfilledSteps.length !== 1)
	            return;
	        const op = unfulfilledSteps[0];
	        if (op &&
	            op.op === types_js_1.StepOpCode.StepPlanned
	        // TODO We must individually check properties here that we do not want to
	        // execute on, such as retry counts. Nothing exists here that falls in to
	        // this case, but should be accounted for when we add them.
	        // && typeof op.opts === "undefined"
	        ) {
	            return op.hashedId;
	        }
	    }
	    async filterNewSteps(foundSteps) {
	        var _a, _b, _c, _d, _e, _f;
	        if (this.options.requestedRunStep) {
	            return;
	        }
	        /**
	         * Gather any steps that aren't memoized and report them.
	         */
	        const newSteps = foundSteps.filter((step) => !step.fulfilled);
	        if (!newSteps.length) {
	            return;
	        }
	        /**
	         * Warn if we've found new steps but haven't yet seen all previous
	         * steps. This may indicate that step presence isn't determinate.
	         */
	        let knownSteps = 0;
	        for (const step of foundSteps) {
	            if (step.fulfilled) {
	                knownSteps++;
	            }
	        }
	        const foundAllCompletedSteps = this.state.stepsToFulfill === knownSteps;
	        if (!foundAllCompletedSteps) {
	            // TODO Tag
	            console.warn((0, errors_js_1.prettyError)({
	                type: "warn",
	                whatHappened: "Function may be indeterminate",
	                why: "We found new steps before seeing all previous steps, which may indicate that the function is non-deterministic.",
	                consequences: "This may cause unexpected behaviour as Inngest executes your function.",
	                reassurance: "This is expected if a function is updated in the middle of a run, but may indicate a bug if not.",
	            }));
	        }
	        /**
	         * We're finishing up; let's trigger the last of the hooks.
	         */
	        await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));
	        await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));
	        await ((_f = (_e = this.state.hooks) === null || _e === void 0 ? void 0 : _e.afterExecution) === null || _f === void 0 ? void 0 : _f.call(_e));
	        const stepList = newSteps.map((step) => ({
	            displayName: step.displayName,
	            op: step.op,
	            id: step.hashedId,
	            name: step.name,
	            opts: step.opts,
	        }));
	        /**
	         * We also run `onSendEvent` middleware hooks against `step.invoke()` steps
	         * to ensure that their `data` is transformed correctly.
	         */
	        return await this.transformNewSteps(stepList);
	    }
	    /**
	     * Using middleware, transform any newly-found steps before returning them to
	     * an Inngest Server.
	     */
	    async transformNewSteps(steps) {
	        return Promise.all(steps.map(async (step) => {
	            var _a, _b, _c, _d, _e, _f, _g;
	            if (step.op !== types_js_1.StepOpCode.InvokeFunction) {
	                return step;
	            }
	            const onSendEventHooks = await (0, InngestMiddleware_js_1.getHookStack)(this.options.fn["middleware"], "onSendEvent", undefined, {
	                transformInput: (prev, output) => {
	                    return Object.assign(Object.assign({}, prev), output);
	                },
	                transformOutput: (prev, output) => {
	                    return {
	                        result: Object.assign(Object.assign({}, prev.result), output === null || output === void 0 ? void 0 : output.result),
	                    };
	                },
	            });
	            /**
	             * For each event being sent, create a new `onSendEvent` hook stack to
	             * process it. We do this as middleware hooks are intended to run once
	             * during each lifecycle (onFunctionRun or onSendEvent) and here, a hook
	             * is run for every single event.
	             *
	             * This is done because a developer can use this hook to filter out
	             * events entirely; if we batch all of the events together, we can't
	             * tell which ones were filtered out if we're processing >1 invocation
	             * here.
	             */
	            const transformedPayload = await ((_a = onSendEventHooks.transformInput) === null || _a === void 0 ? void 0 : _a.call(onSendEventHooks, {
	                payloads: [
	                    Object.assign(Object.assign({}, ((_c = (_b = step.opts) === null || _b === void 0 ? void 0 : _b.payload) !== null && _c !== void 0 ? _c : {})), { name: consts_js_1.internalEvents.FunctionInvoked }),
	                ],
	            }));
	            const newPayload = InngestStepTools_js_1.invokePayloadSchema.parse((_e = (_d = transformedPayload === null || transformedPayload === void 0 ? void 0 : transformedPayload.payloads) === null || _d === void 0 ? void 0 : _d[0]) !== null && _e !== void 0 ? _e : {});
	            return Object.assign(Object.assign({}, step), { opts: Object.assign(Object.assign({}, step.opts), { payload: Object.assign(Object.assign({}, ((_g = (_f = step.opts) === null || _f === void 0 ? void 0 : _f.payload) !== null && _g !== void 0 ? _g : {})), newPayload) }) });
	        }));
	    }
	    async executeStep({ id, name, opts, fn, displayName, }) {
	        var _a, _b, _c, _d, _e;
	        (_a = this.timeout) === null || _a === void 0 ? void 0 : _a.clear();
	        await ((_c = (_b = this.state.hooks) === null || _b === void 0 ? void 0 : _b.afterMemoization) === null || _c === void 0 ? void 0 : _c.call(_b));
	        await ((_e = (_d = this.state.hooks) === null || _d === void 0 ? void 0 : _d.beforeExecution) === null || _e === void 0 ? void 0 : _e.call(_d));
	        const outgoingOp = {
	            id,
	            op: types_js_1.StepOpCode.StepRun,
	            name,
	            opts,
	            displayName,
	        };
	        this.state.executingStep = outgoingOp;
	        const store = await (0, als_js_1.getAsyncCtx)();
	        if (store) {
	            store.executingStep = {
	                id,
	                name: displayName,
	            };
	        }
	        this.debug(`executing step "${id}"`);
	        return ((0, promises_js_1.runAsPromise)(fn)
	            // eslint-disable-next-line @typescript-eslint/no-misused-promises
	            .finally(async () => {
	            var _a, _b;
	            if (store) {
	                delete store.executingStep;
	            }
	            await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterExecution) === null || _b === void 0 ? void 0 : _b.call(_a));
	        })
	            .then((data) => {
	            return Object.assign(Object.assign({}, outgoingOp), { data });
	        })
	            .catch((error) => {
	            return Object.assign(Object.assign({}, outgoingOp), { op: types_js_1.StepOpCode.StepError, 
	                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
	                error });
	        }));
	    }
	    /**
	     * Starts execution of the user's function, including triggering checkpoints
	     * and middleware hooks where appropriate.
	     */
	    async startExecution() {
	        var _a, _b, _c, _d, _e, _f, _g;
	        /**
	         * Mutate input as neccessary based on middleware.
	         */
	        await this.transformInput();
	        /**
	         * Start the timer to time out the run if needed.
	         */
	        void ((_a = this.timeout) === null || _a === void 0 ? void 0 : _a.start());
	        await ((_c = (_b = this.state.hooks) === null || _b === void 0 ? void 0 : _b.beforeMemoization) === null || _c === void 0 ? void 0 : _c.call(_b));
	        /**
	         * If we had no state to begin with, immediately end the memoization phase.
	         */
	        if (this.state.allStateUsed()) {
	            await ((_e = (_d = this.state.hooks) === null || _d === void 0 ? void 0 : _d.afterMemoization) === null || _e === void 0 ? void 0 : _e.call(_d));
	            await ((_g = (_f = this.state.hooks) === null || _f === void 0 ? void 0 : _f.beforeExecution) === null || _g === void 0 ? void 0 : _g.call(_f));
	        }
	        /**
	         * Trigger the user's function.
	         */
	        (0, promises_js_1.runAsPromise)(() => this.userFnToRun(this.fnArg))
	            // eslint-disable-next-line @typescript-eslint/no-misused-promises
	            .finally(async () => {
	            var _a, _b, _c, _d, _e, _f;
	            await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));
	            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));
	            await ((_f = (_e = this.state.hooks) === null || _e === void 0 ? void 0 : _e.afterExecution) === null || _f === void 0 ? void 0 : _f.call(_e));
	        })
	            .then((data) => {
	            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
	            this.state.setCheckpoint({ type: "function-resolved", data });
	        })
	            .catch((error) => {
	            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
	            this.state.setCheckpoint({ type: "function-rejected", error });
	        });
	    }
	    /**
	     * Using middleware, transform input before running.
	     */
	    async transformInput() {
	        var _a, _b;
	        const inputMutations = await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.transformInput) === null || _b === void 0 ? void 0 : _b.call(_a, {
	            ctx: Object.assign({}, this.fnArg),
	            steps: Object.values(this.state.stepState),
	            fn: this.options.fn,
	            reqArgs: this.options.reqArgs,
	        }));
	        if (inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.ctx) {
	            this.fnArg = inputMutations.ctx;
	        }
	        if (inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.steps) {
	            this.state.stepState = Object.fromEntries(inputMutations.steps.map((step) => [step.id, step]));
	        }
	    }
	    /**
	     * Using middleware, transform output before returning.
	     */
	    async transformOutput(dataOrError) {
	        var _a, _b, _c, _d;
	        const output = Object.assign({}, dataOrError);
	        /**
	         * If we've been given an error and it's one that we just threw from a step,
	         * we should return a `NonRetriableError` to stop execution.
	         */
	        if (typeof output.error !== "undefined") {
	            output.data = (0, errors_js_1.serializeError)(output.error);
	        }
	        const isStepExecution = Boolean(this.state.executingStep);
	        const transformedOutput = await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.transformOutput) === null || _b === void 0 ? void 0 : _b.call(_a, {
	            result: Object.assign({}, output),
	            step: this.state.executingStep,
	        }));
	        const { data, error } = Object.assign(Object.assign({}, output), transformedOutput === null || transformedOutput === void 0 ? void 0 : transformedOutput.result);
	        if (!isStepExecution) {
	            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.finished) === null || _d === void 0 ? void 0 : _d.call(_c, {
	                result: Object.assign({}, (typeof error !== "undefined" ? { error } : { data })),
	            }));
	        }
	        if (typeof error !== "undefined") {
	            /**
	             * Ensure we give middleware the chance to decide on retriable behaviour
	             * by looking at the error returned from output transformation.
	             */
	            let retriable = !(error instanceof NonRetriableError_js_1.NonRetriableError || error instanceof StepError_js_1.StepError);
	            if (retriable && error instanceof RetryAfterError_js_1.RetryAfterError) {
	                retriable = error.retryAfter;
	            }
	            const serializedError = (0, errors_js_1.minifyPrettyError)((0, errors_js_1.serializeError)(error));
	            return {
	                type: "function-rejected",
	                ctx: this.fnArg,
	                ops: this.ops,
	                error: serializedError,
	                retriable,
	            };
	        }
	        return {
	            type: "function-resolved",
	            ctx: this.fnArg,
	            ops: this.ops,
	            data: (0, functions_js_1.undefinedToNull)(data),
	        };
	    }
	    createExecutionState() {
	        const d = (0, promises_js_1.createDeferredPromiseWithStack)();
	        let checkpointResolve = d.deferred.resolve;
	        const checkpointResults = d.results;
	        const loop = (function (cleanUp) {
	            return __asyncGenerator(this, arguments, function* () {
	                try {
	                    while (true) {
	                        const res = (yield __await(checkpointResults.next())).value;
	                        if (res) {
	                            yield yield __await(res);
	                        }
	                    }
	                }
	                finally {
	                    cleanUp === null || cleanUp === void 0 ? void 0 : cleanUp();
	                }
	            });
	        })(() => {
	            var _a;
	            (_a = this.timeout) === null || _a === void 0 ? void 0 : _a.clear();
	            void checkpointResults.return();
	        });
	        const stepsToFulfill = Object.keys(this.options.stepState).length;
	        const state = {
	            stepState: this.options.stepState,
	            stepsToFulfill,
	            steps: new Map(),
	            loop,
	            hasSteps: Boolean(stepsToFulfill),
	            stepCompletionOrder: [...this.options.stepCompletionOrder],
	            remainingStepsToBeSeen: new Set(this.options.stepCompletionOrder),
	            setCheckpoint: (checkpoint) => {
	                ({ resolve: checkpointResolve } = checkpointResolve(checkpoint));
	            },
	            allStateUsed: () => {
	                return this.state.remainingStepsToBeSeen.size === 0;
	            },
	        };
	        return state;
	    }
	    get ops() {
	        return Object.fromEntries(this.state.steps);
	    }
	    createFnArg() {
	        var _a, _b, _c, _d;
	        const step = this.createStepTools();
	        let fnArg = Object.assign(Object.assign({}, this.options.data), { step });
	        /**
	         * Handle use of the `onFailure` option by deserializing the error.
	         */
	        if (this.options.isFailureHandler) {
	            const eventData = zod_1.z
	                .object({ error: types_js_1.jsonErrorSchema })
	                .parse((_a = fnArg.event) === null || _a === void 0 ? void 0 : _a.data);
	            fnArg = Object.assign(Object.assign({}, fnArg), { error: (0, errors_js_1.deserializeError)(eventData.error) });
	        }
	        return (_d = (_c = (_b = this.options).transformCtx) === null || _c === void 0 ? void 0 : _c.call(_b, fnArg)) !== null && _d !== void 0 ? _d : fnArg;
	    }
	    createStepTools() {
	        /**
	         * A list of steps that have been found and are being rolled up before being
	         * reported to the core loop.
	         */
	        const foundStepsToReport = new Map();
	        /**
	         * A map of the subset of found steps to report that have not yet been
	         * handled. Used for fast access to steps that need to be handled in order.
	         */
	        const unhandledFoundStepsToReport = new Map();
	        /**
	         * A map of the latest sequential step indexes found for each step ID. Used
	         * to ensure that we don't index steps in parallel.
	         *
	         * Note that these must be sequential; if we've seen or assigned `a:1`,
	         * `a:2` and `a:4`, the latest sequential step index is `2`.
	         *
	         */
	        const expectedNextStepIndexes = new Map();
	        /**
	         * A promise that's used to ensure that step reporting cannot be run more than
	         * once in a given asynchronous time span.
	         */
	        let foundStepsReportPromise;
	        /**
	         * A promise that's used to represent middleware hooks running before
	         * execution.
	         */
	        let beforeExecHooksPromise;
	        /**
	         * A helper used to report steps to the core loop. Used after adding an item
	         * to `foundStepsToReport`.
	         */
	        const reportNextTick = () => {
	            // Being explicit instead of using `??=` to appease TypeScript.
	            if (foundStepsReportPromise) {
	                return;
	            }
	            foundStepsReportPromise = new Promise((resolve) => setImmediate(resolve))
	                /**
	                 * Ensure that we wait for this promise to resolve before continuing.
	                 *
	                 * The groups in which steps are reported can affect how we detect some
	                 * more complex determinism issues like parallel indexing. This promise
	                 * can represent middleware hooks being run early, in the middle of
	                 * ingesting steps to report.
	                 *
	                 * Because of this, it's important we wait for this middleware to resolve
	                 * before continuing to report steps to ensure that all steps have a
	                 * chance to be reported throughout this asynchronous action.
	                 */
	                .then(() => beforeExecHooksPromise)
	                .then(() => {
	                foundStepsReportPromise = undefined;
	                for (const [hashedId, step] of unhandledFoundStepsToReport) {
	                    if (step.handle()) {
	                        unhandledFoundStepsToReport.delete(hashedId);
	                        if (step.fulfilled) {
	                            foundStepsToReport.delete(step.id);
	                        }
	                    }
	                }
	                if (foundStepsToReport.size) {
	                    const steps = [...foundStepsToReport.values()];
	                    foundStepsToReport.clear();
	                    return void this.state.setCheckpoint({
	                        type: "steps-found",
	                        steps: steps,
	                    });
	                }
	            });
	        };
	        /**
	         * A helper used to push a step to the list of steps to report.
	         */
	        const pushStepToReport = (step) => {
	            foundStepsToReport.set(step.id, step);
	            unhandledFoundStepsToReport.set(step.hashedId, step);
	            reportNextTick();
	        };
	        const stepHandler = async ({ args, matchOp, opts, }) => {
	            var _a, _b, _c, _d;
	            await beforeExecHooksPromise;
	            const stepOptions = (0, InngestStepTools_js_1.getStepOptions)(args[0]);
	            const opId = matchOp(stepOptions, ...args.slice(1));
	            if (this.state.executingStep) {
	                /**
	                 * If a step is found after asynchronous actions during another step's
	                 * execution, everything is fine. The problem here is if we've found
	                 * that a step nested inside another a step, which is something we don't
	                 * support at the time of writing.
	                 *
	                 * In this case, we could use something like Async Hooks to understand
	                 * how the step is being triggered, though this isn't available in all
	                 * environments.
	                 *
	                 * Therefore, we'll only show a warning here to indicate that this is
	                 * potentially an issue.
	                 */
	                console.warn((0, errors_js_1.prettyError)({
	                    whatHappened: `We detected that you have nested \`step.*\` tooling in \`${(_a = opId.displayName) !== null && _a !== void 0 ? _a : opId.id}\``,
	                    consequences: "Nesting `step.*` tooling is not supported.",
	                    type: "warn",
	                    reassurance: "It's possible to see this warning if steps are separated by regular asynchronous calls, which is fine.",
	                    stack: true,
	                    toFixNow: "Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.",
	                    code: errors_js_1.ErrCode.NESTING_STEPS,
	                }));
	            }
	            if (this.state.steps.has(opId.id)) {
	                const originalId = opId.id;
	                const expectedNextIndex = (_b = expectedNextStepIndexes.get(originalId)) !== null && _b !== void 0 ? _b : 1;
	                for (let i = expectedNextIndex;; i++) {
	                    const newId = originalId + InngestStepTools_js_1.STEP_INDEXING_SUFFIX + i;
	                    if (!this.state.steps.has(newId)) {
	                        expectedNextStepIndexes.set(originalId, i + 1);
	                        opId.id = newId;
	                        break;
	                    }
	                }
	            }
	            const { promise, resolve, reject } = (0, promises_js_1.createDeferredPromise)();
	            const hashedId = exports._internals.hashId(opId.id);
	            const stepState = this.state.stepState[hashedId];
	            let isFulfilled = false;
	            if (stepState) {
	                stepState.seen = true;
	                this.state.remainingStepsToBeSeen.delete(hashedId);
	                if (typeof stepState.input === "undefined") {
	                    isFulfilled = true;
	                }
	            }
	            let extraOpts;
	            let fnArgs = [...args];
	            if (typeof (stepState === null || stepState === void 0 ? void 0 : stepState.input) !== "undefined" &&
	                Array.isArray(stepState.input)) {
	                switch (opId.op) {
	                    // `step.run()` has its function input affected
	                    case types_js_1.StepOpCode.StepPlanned: {
	                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
	                        fnArgs = [...args.slice(0, 2), ...stepState.input];
	                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
	                        extraOpts = { input: [...stepState.input] };
	                        break;
	                    }
	                    // `step.ai.infer()` has its body affected
	                    case types_js_1.StepOpCode.AiGateway: {
	                        extraOpts = {
	                            body: Object.assign(Object.assign({}, (typeof ((_c = opId.opts) === null || _c === void 0 ? void 0 : _c.body) === "object"
	                                ? Object.assign({}, opId.opts.body) : {})), stepState.input[0]),
	                        };
	                        break;
	                    }
	                }
	            }
	            const step = Object.assign(Object.assign({}, opId), { opts: Object.assign(Object.assign({}, opId.opts), extraOpts), rawArgs: fnArgs, // TODO What is the right value here? Should this be raw args without affected input?
	                hashedId, input: stepState === null || stepState === void 0 ? void 0 : stepState.input, 
	                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
	                fn: (opts === null || opts === void 0 ? void 0 : opts.fn) ? () => { var _a; return (_a = opts.fn) === null || _a === void 0 ? void 0 : _a.call(opts, ...fnArgs); } : undefined, promise, fulfilled: isFulfilled, hasStepState: Boolean(stepState), displayName: (_d = opId.displayName) !== null && _d !== void 0 ? _d : opId.id, handled: false, handle: () => {
	                    if (step.handled) {
	                        return false;
	                    }
	                    step.handled = true;
	                    if (isFulfilled && stepState) {
	                        stepState.fulfilled = true;
	                        // For some execution scenarios such as testing, `data`, `error`,
	                        // and `input` may be `Promises`. This could also be the case for
	                        // future middleware applications. For this reason, we'll make sure
	                        // the values are fully resolved before continuing.
	                        void Promise.all([
	                            stepState.data,
	                            stepState.error,
	                            stepState.input,
	                        ]).then(() => {
	                            if (typeof stepState.data !== "undefined") {
	                                resolve(stepState.data);
	                            }
	                            else {
	                                this.state.recentlyRejectedStepError = new StepError_js_1.StepError(opId.id, stepState.error);
	                                reject(this.state.recentlyRejectedStepError);
	                            }
	                        });
	                    }
	                    return true;
	                } });
	            this.state.steps.set(opId.id, step);
	            this.state.hasSteps = true;
	            pushStepToReport(step);
	            /**
	             * If this is the last piece of state we had, we've now finished
	             * memoizing.
	             */
	            if (!beforeExecHooksPromise && this.state.allStateUsed()) {
	                await (beforeExecHooksPromise = (async () => {
	                    var _a, _b, _c, _d;
	                    await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));
	                    await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));
	                })());
	            }
	            return promise;
	        };
	        return (0, InngestStepTools_js_1.createStepTools)(this.options.client, this, stepHandler);
	    }
	    getUserFnToRun() {
	        if (!this.options.isFailureHandler) {
	            return this.options.fn["fn"];
	        }
	        if (!this.options.fn["onFailureFn"]) {
	            /**
	             * Somehow, we've ended up detecting that this is a failure handler but
	             * doesn't have an `onFailure` function. This should never happen.
	             */
	            throw new Error("Cannot find function `onFailure` handler");
	        }
	        return this.options.fn["onFailureFn"];
	    }
	    initializeTimer(state) {
	        if (!this.options.requestedRunStep) {
	            return;
	        }
	        this.timeout = (0, promises_js_1.createTimeoutPromise)(this.timeoutDuration);
	        void this.timeout.then(async () => {
	            var _a, _b, _c, _d, _e, _f;
	            await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));
	            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));
	            await ((_f = (_e = this.state.hooks) === null || _e === void 0 ? void 0 : _e.afterExecution) === null || _f === void 0 ? void 0 : _f.call(_e));
	            state.setCheckpoint({
	                type: "step-not-found",
	                step: {
	                    id: this.options.requestedRunStep,
	                    op: types_js_1.StepOpCode.StepNotFound,
	                },
	            });
	        });
	    }
	    async initializeMiddleware() {
	        const ctx = this.options.data;
	        const hooks = await (0, InngestMiddleware_js_1.getHookStack)(this.options.fn["middleware"], "onFunctionRun", {
	            ctx,
	            fn: this.options.fn,
	            steps: Object.values(this.options.stepState),
	            reqArgs: this.options.reqArgs,
	        }, {
	            transformInput: (prev, output) => {
	                return {
	                    ctx: Object.assign(Object.assign({}, prev.ctx), output === null || output === void 0 ? void 0 : output.ctx),
	                    fn: this.options.fn,
	                    steps: prev.steps.map((step, i) => {
	                        var _a;
	                        return (Object.assign(Object.assign({}, step), (_a = output === null || output === void 0 ? void 0 : output.steps) === null || _a === void 0 ? void 0 : _a[i]));
	                    }),
	                    reqArgs: prev.reqArgs,
	                };
	            },
	            transformOutput: (prev, output) => {
	                return {
	                    result: Object.assign(Object.assign({}, prev.result), output === null || output === void 0 ? void 0 : output.result),
	                    step: prev.step,
	                };
	            },
	        });
	        return hooks;
	    }
	}
	const hashId = (id) => {
	    return (0, hash_js_1.sha1)().update(id).digest("hex");
	};
	const hashOp = (op) => {
	    return Object.assign(Object.assign({}, op), { id: hashId(op.id) });
	};
	/**
	 * Exported for testing.
	 */
	exports._internals = { hashOp, hashId };
	
} (v2));

Object.defineProperty(InngestFunction$1, "__esModule", { value: true });
InngestFunction$1.InngestFunction = void 0;
const consts_js_1$2 = consts;
const strings_js_1$3 = strings;
const InngestExecution_js_1$1 = InngestExecution$1;
const v0_js_1 = v0;
const v1_js_1 = v1;
const v2_js_1 = v2;
/**
 * A stateless Inngest function, wrapping up function configuration and any
 * in-memory steps to run when triggered.
 *
 * This function can be "registered" to create a handler that Inngest can
 * trigger remotely.
 *
 * @public
 */
class InngestFunction {
    /**
     * A stateless Inngest function, wrapping up function configuration and any
     * in-memory steps to run when triggered.
     *
     * This function can be "registered" to create a handler that Inngest can
     * trigger remotely.
     */
    constructor(client, 
    /**
     * Options
     */
    opts, fn) {
        this.client = client;
        this.opts = opts;
        this.fn = fn;
        this.onFailureFn = this.opts.onFailure;
        this.middleware = this.client["initializeMiddleware"](this.opts.middleware, { registerInput: { fn: this }, prefixStack: this.client["middleware"] });
    }
    /**
     * The generated or given ID for this function.
     */
    id(prefix) {
        return [prefix, this.opts.id].filter(Boolean).join("-");
    }
    /**
     * The generated or given ID for this function, prefixed with the app ID. This
     * is used for routing invokes and identifying the function across apps.
     */
    get absoluteId() {
        return this.id(this.client.id);
    }
    /**
     * The name of this function as it will appear in the Inngest Cloud UI.
     */
    get name() {
        return this.opts.name || this.id();
    }
    /**
     * The description of this function.
     */
    get description() {
        return this.opts.description;
    }
    /**
     * Retrieve the Inngest config for this function.
     */
    getConfig({ baseUrl, appPrefix, isConnect, }) {
        var _a, _b;
        const fnId = this.id(appPrefix);
        const stepUrl = new URL(baseUrl.href);
        stepUrl.searchParams.set(consts_js_1$2.queryKeys.FnId, fnId);
        stepUrl.searchParams.set(consts_js_1$2.queryKeys.StepId, InngestFunction.stepId);
        const { retries: attempts, cancelOn, idempotency, batchEvents, rateLimit, throttle, concurrency, debounce, timeouts, priority, } = this.opts;
        /**
         * Convert retries into the format required when defining function
         * configuration.
         */
        const retries = typeof attempts === "undefined" ? undefined : { attempts };
        const fn = {
            id: fnId,
            name: this.name,
            triggers: ((_a = this.opts.triggers) !== null && _a !== void 0 ? _a : []).map((trigger) => {
                if ("event" in trigger) {
                    return {
                        event: trigger.event,
                        expression: trigger.if,
                    };
                }
                return {
                    cron: trigger.cron,
                };
            }),
            steps: {
                [InngestFunction.stepId]: {
                    id: InngestFunction.stepId,
                    name: InngestFunction.stepId,
                    runtime: {
                        type: isConnect ? "ws" : "http",
                        url: stepUrl.href,
                    },
                    retries,
                },
            },
            idempotency,
            batchEvents,
            rateLimit,
            throttle,
            concurrency,
            debounce,
            priority,
            timeouts,
        };
        if (cancelOn) {
            fn.cancel = cancelOn.map(({ event, timeout, if: ifStr, match }) => {
                const ret = {
                    event,
                };
                if (timeout) {
                    ret.timeout = (0, strings_js_1$3.timeStr)(timeout);
                }
                if (match) {
                    ret.if = `event.${match} == async.${match}`;
                }
                else if (ifStr) {
                    ret.if = ifStr;
                }
                return ret;
            }, []);
        }
        const config = [fn];
        if (this.onFailureFn) {
            const id = `${fn.id}${InngestFunction.failureSuffix}`;
            const name = `${(_b = fn.name) !== null && _b !== void 0 ? _b : fn.id} (failure)`;
            const failureStepUrl = new URL(stepUrl.href);
            failureStepUrl.searchParams.set(consts_js_1$2.queryKeys.FnId, id);
            config.push({
                id,
                name,
                triggers: [
                    {
                        event: consts_js_1$2.internalEvents.FunctionFailed,
                        expression: `event.data.function_id == '${fnId}'`,
                    },
                ],
                steps: {
                    [InngestFunction.stepId]: {
                        id: InngestFunction.stepId,
                        name: InngestFunction.stepId,
                        runtime: {
                            type: "http",
                            url: failureStepUrl.href,
                        },
                        retries: { attempts: 1 },
                    },
                },
            });
        }
        return config;
    }
    createExecution(opts) {
        const options = Object.assign({ client: this.client, fn: this }, opts.partialOptions);
        const versionHandlers = {
            [InngestExecution_js_1$1.ExecutionVersion.V2]: () => (0, v2_js_1.createV2InngestExecution)(options),
            [InngestExecution_js_1$1.ExecutionVersion.V1]: () => (0, v1_js_1.createV1InngestExecution)(options),
            [InngestExecution_js_1$1.ExecutionVersion.V0]: () => (0, v0_js_1.createV0InngestExecution)(options),
        };
        return versionHandlers[opts.version]();
    }
    shouldOptimizeParallelism() {
        var _a, _b;
        // TODO We should check the commhandler's client instead of this one?
        return ((_b = (_a = this.opts.optimizeParallelism) !== null && _a !== void 0 ? _a : this.client["options"].optimizeParallelism) !== null && _b !== void 0 ? _b : false);
    }
}
InngestFunction$1.InngestFunction = InngestFunction;
InngestFunction.stepId = "step";
InngestFunction.failureSuffix = "-failure";

var InngestFunctionReference$1 = {};

Object.defineProperty(InngestFunctionReference$1, "__esModule", { value: true });
InngestFunctionReference$1.referenceFunction = InngestFunctionReference$1.InngestFunctionReference = void 0;
/**
 * A reference to an `InngestFunction` that can be used to represent both local
 * and remote functions without pulling in the full function definition (i.e.
 * dependencies).
 *
 * These references can be invoked in the same manner as a regular
 * `InngestFunction`.
 *
 * To create a reference function, use the {@link referenceFunction} helper.
 *
 * @public
 */
class InngestFunctionReference {
    constructor(opts) {
        this.opts = opts;
    }
}
InngestFunctionReference$1.InngestFunctionReference = InngestFunctionReference;
/**
 * Create a reference to an `InngestFunction` that can be used to represent both
 * local and remote functions without pulling in the full function definition
 * (i.e. dependencies).
 *
 * These references can be invoked in the same manner as a regular
 * `InngestFunction`.
 *
 * @public
 */
const referenceFunction = ({ functionId, appId, }) => {
    return new InngestFunctionReference({
        functionId,
        appId,
    });
};
InngestFunctionReference$1.referenceFunction = referenceFunction;

(function (exports) {
	var __createBinding = (InngestStepTools && InngestStepTools.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (InngestStepTools && InngestStepTools.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (InngestStepTools && InngestStepTools.__importStar) || (function () {
	    var ownKeys = function(o) {
	        ownKeys = Object.getOwnPropertyNames || function (o) {
	            var ar = [];
	            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
	            return ar;
	        };
	        return ownKeys(o);
	    };
	    return function (mod) {
	        if (mod && mod.__esModule) return mod;
	        var result = {};
	        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
	        __setModuleDefault(result, mod);
	        return result;
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.invokePayloadSchema = exports.gatewaySymbol = exports.createStepTools = exports.STEP_INDEXING_SUFFIX = exports.getStepOptions = void 0;
	const ai_1 = dist$1;
	const zod_1 = lib$2;
	const consts_js_1 = consts;
	const strings_js_1 = strings;
	const Temporal = __importStar(temporal);
	const types_js_1 = types$2;
	const Fetch_js_1 = Fetch;
	const InngestFunction_js_1 = InngestFunction$1;
	const InngestFunctionReference_js_1 = InngestFunctionReference$1;
	const getStepOptions = (options) => {
	    if (typeof options === "string") {
	        return { id: options };
	    }
	    return options;
	};
	exports.getStepOptions = getStepOptions;
	/**
	 * Suffix used to namespace steps that are automatically indexed.
	 */
	exports.STEP_INDEXING_SUFFIX = ":";
	/**
	 * Create a new set of step function tools ready to be used in a step function.
	 * This function should be run and a fresh set of tools provided every time a
	 * function is run.
	 *
	 * An op stack (function state) is passed in as well as some mutable properties
	 * that the tools can use to submit a new op.
	 */
	const createStepTools = (client, execution, stepHandler) => {
	    /**
	     * A local helper used to create tools that can be used to submit an op.
	     *
	     * When using this function, a generic type should be provided which is the
	     * function signature exposed to the user.
	     */
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    const createTool = (
	    /**
	     * A function that returns an ID for this op. This is used to ensure that
	     * the op stack is correctly filled, submitted, and retrieved with the same
	     * ID.
	     *
	     * It is passed the arguments passed by the user.
	     *
	     * Most simple tools will likely only need to define this.
	     */
	    matchOp, opts) => {
	        return (async (...args) => {
	            const parsedArgs = args;
	            return stepHandler({ args: parsedArgs, matchOp, opts });
	        });
	    };
	    /**
	     * Create a new step run tool that can be used to run a step function using
	     * `step.run()` as a shim.
	     */
	    const createStepRun = (
	    /**
	     * The sub-type of this step tool, exposed via `opts.type` when the op is
	     * reported.
	     */
	    type) => {
	        return createTool(({ id, name }, _fn, ...input) => {
	            const opts = Object.assign(Object.assign({}, (input.length ? { input } : {})), (type ? { type } : {}));
	            return Object.assign({ id, op: types_js_1.StepOpCode.StepPlanned, name: id, displayName: name !== null && name !== void 0 ? name : id }, (Object.keys(opts).length ? { opts } : {}));
	        }, {
	            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
	            fn: (_, fn, ...input) => fn(...input),
	        });
	    };
	    /**
	     * Define the set of tools the user has access to for their step functions.
	     *
	     * Each key is the function name and is expected to run `createTool` and pass
	     * a generic type for that function as it will appear in the user's code.
	     */
	    const tools = {
	        /**
	         * Send one or many events to Inngest. Should always be used in place of
	         * `inngest.send()` to ensure that the event send is successfully retried
	         * and not sent multiple times due to memoisation.
	         *
	         * @example
	         * ```ts
	         * await step.sendEvent("emit-user-creation", {
	         *   name: "app/user.created",
	         *   data: { id: 123 },
	         * });
	         *
	         * await step.sendEvent("emit-user-updates", [
	         *   {
	         *     name: "app/user.created",
	         *     data: { id: 123 },
	         *   },
	         *   {
	         *     name: "app/user.feed.created",
	         *     data: { id: 123 },
	         *   },
	         * ]);
	         * ```
	         *
	         * Returns a promise that will resolve once the event has been sent.
	         */
	        sendEvent: createTool(({ id, name }) => {
	            return {
	                id,
	                op: types_js_1.StepOpCode.StepPlanned,
	                name: "sendEvent",
	                displayName: name !== null && name !== void 0 ? name : id,
	            };
	        }, {
	            fn: (idOrOptions, payload) => {
	                return client["_send"]({
	                    payload,
	                    headers: execution["options"]["headers"],
	                });
	            },
	        }),
	        /**
	         * Wait for a particular event to be received before continuing. When the
	         * event is received, it will be returned.
	         *
	         * You can also provide options to control the particular event that is
	         * received, for example to ensure that a user ID matches between two
	         * events, or to only wait a maximum amount of time before giving up and
	         * returning `null` instead of any event data.
	         */
	        waitForEvent: createTool(({ id, name }, 
	        /**
	         * Options to control the event we're waiting for.
	         */
	        opts) => {
	            const matchOpts = {
	                timeout: (0, strings_js_1.timeStr)(typeof opts === "string" ? opts : opts.timeout),
	            };
	            if (typeof opts !== "string") {
	                if (opts === null || opts === void 0 ? void 0 : opts.match) {
	                    matchOpts.if = `event.${opts.match} == async.${opts.match}`;
	                }
	                else if (opts === null || opts === void 0 ? void 0 : opts.if) {
	                    matchOpts.if = opts.if;
	                }
	            }
	            return {
	                id,
	                op: types_js_1.StepOpCode.WaitForEvent,
	                name: opts.event,
	                opts: matchOpts,
	                displayName: name !== null && name !== void 0 ? name : id,
	            };
	        }),
	        /**
	         * Use this tool to run business logic. Each call to `run` will be retried
	         * individually, meaning you can compose complex workflows that safely
	         * retry dependent asynchronous actions.
	         *
	         * The function you pass to `run` will be called only when this "step" is to
	         * be executed and can be synchronous or asynchronous.
	         *
	         * In either case, the return value of the function will be the return value
	         * of the `run` tool, meaning you can return and reason about return data
	         * for next steps.
	         */
	        run: createStepRun(),
	        /**
	         * AI tooling for running AI models and other AI-related tasks.
	         */
	        ai: {
	            /**
	             * Use this tool to have Inngest make your AI calls. Useful for agentic workflows.
	             *
	             * Input is also tracked for this tool, meaning you can pass input to the
	             * function and it will be displayed and editable in the UI.
	             */
	            infer: createTool(({ id, name }, options) => {
	                var _a, _b;
	                const modelCopy = Object.assign({}, options.model);
	                // Allow the model to mutate options and body for this call
	                (_b = (_a = options.model).onCall) === null || _b === void 0 ? void 0 : _b.call(_a, modelCopy, options.body);
	                return {
	                    id,
	                    op: types_js_1.StepOpCode.AiGateway,
	                    displayName: name !== null && name !== void 0 ? name : id,
	                    opts: {
	                        type: "step.ai.infer",
	                        url: modelCopy.url,
	                        headers: modelCopy.headers,
	                        auth_key: modelCopy.authKey,
	                        format: modelCopy.format,
	                        body: options.body,
	                    },
	                };
	            }),
	            /**
	             * Use this tool to wrap AI models and other AI-related tasks. Each call
	             * to `wrap` will be retried individually, meaning you can compose complex
	             * workflows that safely retry dependent asynchronous actions.
	             *
	             * Input is also tracked for this tool, meaning you can pass input to the
	             * function and it will be displayed and editable in the UI.
	             */
	            wrap: createStepRun("step.ai.wrap"),
	            /**
	             * Models for AI inference and other AI-related tasks.
	             */
	            models: Object.assign({}, ai_1.models),
	        },
	        /**
	         * Wait a specified amount of time before continuing.
	         *
	         * The time to wait can be specified using a `number` of milliseconds or an
	         * `ms`-compatible time string like `"1 hour"`, `"30 mins"`, or `"2.5d"`.
	         *
	         * {@link https://npm.im/ms}
	         *
	         * To wait until a particular date, use `sleepUntil` instead.
	         */
	        sleep: createTool(({ id, name }, time) => {
	            /**
	             * The presence of this operation in the returned stack indicates that the
	             * sleep is over and we should continue execution.
	             */
	            const msTimeStr = (0, strings_js_1.timeStr)(Temporal.isTemporalDuration(time)
	                ? time.total({ unit: "milliseconds" })
	                : time);
	            return {
	                id,
	                op: types_js_1.StepOpCode.Sleep,
	                name: msTimeStr,
	                displayName: name !== null && name !== void 0 ? name : id,
	            };
	        }),
	        /**
	         * Wait until a particular date before continuing by passing a `Date`.
	         *
	         * To wait for a particular amount of time from now, always use `sleep`
	         * instead.
	         */
	        sleepUntil: createTool(({ id, name }, time) => {
	            try {
	                const iso = Temporal.getISOString(time);
	                /**
	                 * The presence of this operation in the returned stack indicates that the
	                 * sleep is over and we should continue execution.
	                 */
	                return {
	                    id,
	                    op: types_js_1.StepOpCode.Sleep,
	                    name: iso,
	                    displayName: name !== null && name !== void 0 ? name : id,
	                };
	            }
	            catch (err) {
	                /**
	                 * If we're here, it's because the date is invalid. We'll throw a custom
	                 * error here to standardise this response.
	                 */
	                // TODO PrettyError
	                console.warn("Invalid `Date`, date string, `Temporal.Instant`, or `Temporal.ZonedDateTime` passed to sleepUntil;", err);
	                // TODO PrettyError
	                throw new Error(`Invalid \`Date\`, date string, \`Temporal.Instant\`, or \`Temporal.ZonedDateTime\` passed to sleepUntil: ${
	                // eslint-disable-next-line @typescript-eslint/no-explicit-any
	                time}`);
	            }
	        }),
	        /**
	         * Invoke a passed Inngest `function` with the given `data`. Returns the
	         * result of the returned value of the function or `null` if the function
	         * does not return a value.
	         *
	         * A string ID can also be passed to reference functions outside of the
	         * current app.
	         */
	        invoke: createTool(({ id, name }, invokeOpts) => {
	            // Create a discriminated union to operate on based on the input types
	            // available for this tool.
	            const optsSchema = exports.invokePayloadSchema.extend({
	                timeout: zod_1.z.union([zod_1.z.number(), zod_1.z.string(), zod_1.z.date()]).optional(),
	            });
	            const parsedFnOpts = optsSchema
	                .extend({
	                _type: zod_1.z.literal("fullId").optional().default("fullId"),
	                function: zod_1.z.string().min(1),
	            })
	                .or(optsSchema.extend({
	                _type: zod_1.z.literal("fnInstance").optional().default("fnInstance"),
	                function: zod_1.z.instanceof(InngestFunction_js_1.InngestFunction),
	            }))
	                .or(optsSchema.extend({
	                _type: zod_1.z.literal("refInstance").optional().default("refInstance"),
	                function: zod_1.z.instanceof(InngestFunctionReference_js_1.InngestFunctionReference),
	            }))
	                .safeParse(invokeOpts);
	            if (!parsedFnOpts.success) {
	                throw new Error(`Invalid invocation options passed to invoke; must include either a function or functionId.`);
	            }
	            const { _type, function: fn, data, user, v, timeout } = parsedFnOpts.data;
	            const payload = { data, user, v };
	            const opts = {
	                payload,
	                function_id: "",
	                timeout: typeof timeout === "undefined" ? undefined : (0, strings_js_1.timeStr)(timeout),
	            };
	            switch (_type) {
	                case "fnInstance":
	                    opts.function_id = fn.id(fn["client"].id);
	                    break;
	                case "fullId":
	                    console.warn(`${consts_js_1.logPrefix} Invoking function with \`function: string\` is deprecated and will be removed in v4.0.0; use an imported function or \`referenceFunction()\` instead. See https://innge.st/ts-referencing-functions`);
	                    opts.function_id = fn;
	                    break;
	                case "refInstance":
	                    opts.function_id = [fn.opts.appId || client.id, fn.opts.functionId]
	                        .filter(Boolean)
	                        .join("-");
	                    break;
	            }
	            return {
	                id,
	                op: types_js_1.StepOpCode.InvokeFunction,
	                displayName: name !== null && name !== void 0 ? name : id,
	                opts,
	            };
	        }),
	        /**
	         * `step.fetch` is a Fetch-API-compatible function that can be used to make
	         * any HTTP code durable if it's called within an Inngest function.
	         *
	         * It will gracefully fall back to the global `fetch` if called outside of
	         * this context, and a custom fallback can be set using the `config` method.
	         */
	        fetch: Fetch_js_1.fetch,
	    };
	    // Add an uptyped gateway
	    tools[exports.gatewaySymbol] = createTool(({ id, name }, input, init) => {
	        var _a;
	        const url = input instanceof Request ? input.url : input.toString();
	        const headers = {};
	        if (input instanceof Request) {
	            input.headers.forEach((value, key) => (headers[key] = value));
	        }
	        else if (init === null || init === void 0 ? void 0 : init.headers) {
	            const h = new Headers(init.headers);
	            h.forEach((value, key) => (headers[key] = value));
	        }
	        return {
	            id,
	            op: types_js_1.StepOpCode.Gateway,
	            displayName: name !== null && name !== void 0 ? name : id,
	            opts: {
	                url,
	                method: (_a = init === null || init === void 0 ? void 0 : init.method) !== null && _a !== void 0 ? _a : "GET",
	                headers,
	                body: init === null || init === void 0 ? void 0 : init.body,
	            },
	        };
	    });
	    return tools;
	};
	exports.createStepTools = createStepTools;
	exports.gatewaySymbol = Symbol.for("inngest.step.gateway");
	/**
	 * The event payload portion of the options for `step.invoke()`. This does not
	 * include non-payload options like `timeout` or the function to invoke.
	 */
	exports.invokePayloadSchema = zod_1.z.object({
	    data: zod_1.z.record(zod_1.z.any()).optional(),
	    user: zod_1.z.record(zod_1.z.any()).optional(),
	    v: zod_1.z.string().optional(),
	});
	
} (InngestStepTools));

var __importDefault$2 = (Fetch && Fetch.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(Fetch, "__esModule", { value: true });
Fetch.fetch = void 0;
const debug_1$1 = __importDefault$2(srcExports);
const als_js_1 = als;
const InngestStepTools_js_1 = InngestStepTools;
const globalFetch = globalThis.fetch;
const debug = (0, debug_1$1.default)("inngest:fetch");
const createFetchShim = () => {
    // eslint-disable-next-line prefer-const
    let stepFetch;
    const fetch = async (input, init) => {
        const ctx = await (0, als_js_1.getAsyncCtx)();
        if (!ctx) {
            // Not in a function run
            if (!stepFetch.fallback) {
                // TODO Tell the user how to solve
                throw new Error("step.fetch() called outside of a function and had no fallback set");
            }
            debug("step.fetch() called outside of a function; falling back to global fetch");
            return stepFetch.fallback(input, init);
        }
        // In a function run
        if (ctx.executingStep) {
            // Inside a step
            if (!stepFetch.fallback) {
                // TODO Tell the user how to solve
                throw new Error(`step.fetch() called inside step "${ctx.executingStep.id}" and had no fallback set`);
            }
            debug(`step.fetch() called inside step "${ctx.executingStep.id}"; falling back to global fetch`);
            return stepFetch.fallback(input, init);
        }
        const targetUrl = new URL(input instanceof Request ? input.url : input.toString());
        debug("step.fetch() shimming request to", targetUrl.hostname);
        // Purposefully do not try/cacth this; if it throws then we treat that as a
        // regular `fetch()` throw, which also would not return a `Response`.
        const jsonRes = await ctx.ctx.step[InngestStepTools_js_1.gatewaySymbol](`step.fetch: ${targetUrl.hostname}`, input, init);
        return new Response(jsonRes.body, {
            headers: jsonRes.headers,
            status: jsonRes.status,
        });
    };
    const optionsRef = {
        fallback: globalFetch,
    };
    const extras = Object.assign({ config: (options) => {
            Object.assign(optionsRef, options);
            Object.assign(stepFetch, optionsRef);
            return stepFetch;
        } }, optionsRef);
    stepFetch = Object.assign(fetch, extras);
    return stepFetch;
};
/**
 * `fetch` is a Fetch API-compatible function that can be used to make any HTTP
 * code durable if it's called within an Inngest function.
 *
 * It will gracefully fall back to the global `fetch` if called outside of this
 * context, and a custom fallback can be set using the `config` method.
 *
 * @example Basic usage
 * ```ts
 * import { fetch } from "inngest";
 *
 * const api = new MyProductApi({ fetch });
 * ```
 *
 * @example Setting a custom fallback
 * ```ts
 * import { fetch } from "inngest";
 *
 * const api = new MyProductApi({
 *            fetch: fetch.config({ fallback: myCustomFetch }),
 * });
 * ```
 *
 * @example Do not allow fallback
 * ```ts
 * import { fetch } from "inngest";
 *
 * const api = new MyProductApi({
 *            fetch: fetch.config({ fallback: undefined }),
 * });
 * ```
 */
Fetch.fetch = createFetchShim();

var Inngest$1 = {};

var api$1 = {};

var devserver = {};

var env$3 = {};

var version = {};

Object.defineProperty(version, "__esModule", { value: true });
version.version = void 0;
// Generated by genversion.
version.version = "3.35.1";

var nodePonyfill = {exports: {}};

var publicApi = {};

var URL$2 = {exports: {}};

var conversions = {};
var lib$1 = conversions;

function sign(x) {
    return x < 0 ? -1 : 1;
}

function evenRound(x) {
    // Round x to the nearest integer, choosing the even integer if it lies halfway between two.
    if ((x % 1) === 0.5 && (x & 1) === 0) { // [even number].5; round down (i.e. floor)
        return Math.floor(x);
    } else {
        return Math.round(x);
    }
}

function createNumberConversion(bitLength, typeOpts) {
    if (!typeOpts.unsigned) {
        --bitLength;
    }
    const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
    const upperBound = Math.pow(2, bitLength) - 1;

    const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
    const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);

    return function(V, opts) {
        if (!opts) opts = {};

        let x = +V;

        if (opts.enforceRange) {
            if (!Number.isFinite(x)) {
                throw new TypeError("Argument is not a finite number");
            }

            x = sign(x) * Math.floor(Math.abs(x));
            if (x < lowerBound || x > upperBound) {
                throw new TypeError("Argument is not in byte range");
            }

            return x;
        }

        if (!isNaN(x) && opts.clamp) {
            x = evenRound(x);

            if (x < lowerBound) x = lowerBound;
            if (x > upperBound) x = upperBound;
            return x;
        }

        if (!Number.isFinite(x) || x === 0) {
            return 0;
        }

        x = sign(x) * Math.floor(Math.abs(x));
        x = x % moduloVal;

        if (!typeOpts.unsigned && x >= moduloBound) {
            return x - moduloVal;
        } else if (typeOpts.unsigned) {
            if (x < 0) {
              x += moduloVal;
            } else if (x === -0) { // don't return negative zero
              return 0;
            }
        }

        return x;
    }
}

conversions["void"] = function () {
    return undefined;
};

conversions["boolean"] = function (val) {
    return !!val;
};

conversions["byte"] = createNumberConversion(8, { unsigned: false });
conversions["octet"] = createNumberConversion(8, { unsigned: true });

conversions["short"] = createNumberConversion(16, { unsigned: false });
conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });

conversions["long"] = createNumberConversion(32, { unsigned: false });
conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });

conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });

conversions["double"] = function (V) {
    const x = +V;

    if (!Number.isFinite(x)) {
        throw new TypeError("Argument is not a finite floating-point value");
    }

    return x;
};

conversions["unrestricted double"] = function (V) {
    const x = +V;

    if (isNaN(x)) {
        throw new TypeError("Argument is NaN");
    }

    return x;
};

// not quite valid, but good enough for JS
conversions["float"] = conversions["double"];
conversions["unrestricted float"] = conversions["unrestricted double"];

conversions["DOMString"] = function (V, opts) {
    if (!opts) opts = {};

    if (opts.treatNullAsEmptyString && V === null) {
        return "";
    }

    return String(V);
};

conversions["ByteString"] = function (V, opts) {
    const x = String(V);
    let c = undefined;
    for (let i = 0; (c = x.codePointAt(i)) !== undefined; ++i) {
        if (c > 255) {
            throw new TypeError("Argument is not a valid bytestring");
        }
    }

    return x;
};

conversions["USVString"] = function (V) {
    const S = String(V);
    const n = S.length;
    const U = [];
    for (let i = 0; i < n; ++i) {
        const c = S.charCodeAt(i);
        if (c < 0xD800 || c > 0xDFFF) {
            U.push(String.fromCodePoint(c));
        } else if (0xDC00 <= c && c <= 0xDFFF) {
            U.push(String.fromCodePoint(0xFFFD));
        } else {
            if (i === n - 1) {
                U.push(String.fromCodePoint(0xFFFD));
            } else {
                const d = S.charCodeAt(i + 1);
                if (0xDC00 <= d && d <= 0xDFFF) {
                    const a = c & 0x3FF;
                    const b = d & 0x3FF;
                    U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
                    ++i;
                } else {
                    U.push(String.fromCodePoint(0xFFFD));
                }
            }
        }
    }

    return U.join('');
};

conversions["Date"] = function (V, opts) {
    if (!(V instanceof Date)) {
        throw new TypeError("Argument is not a Date object");
    }
    if (isNaN(V)) {
        return undefined;
    }

    return V;
};

conversions["RegExp"] = function (V, opts) {
    if (!(V instanceof RegExp)) {
        V = new RegExp(V);
    }

    return V;
};

var utils = {exports: {}};

(function (module) {

	module.exports.mixin = function mixin(target, source) {
	  const keys = Object.getOwnPropertyNames(source);
	  for (let i = 0; i < keys.length; ++i) {
	    Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
	  }
	};

	module.exports.wrapperSymbol = Symbol("wrapper");
	module.exports.implSymbol = Symbol("impl");

	module.exports.wrapperForImpl = function (impl) {
	  return impl[module.exports.wrapperSymbol];
	};

	module.exports.implForWrapper = function (wrapper) {
	  return wrapper[module.exports.implSymbol];
	}; 
} (utils));

var utilsExports = utils.exports;

var URLImpl = {};

var urlStateMachine = {exports: {}};

var tr46 = {};

var require$$1 = [
	[
		[
			0,
			44
		],
		"disallowed_STD3_valid"
	],
	[
		[
			45,
			46
		],
		"valid"
	],
	[
		[
			47,
			47
		],
		"disallowed_STD3_valid"
	],
	[
		[
			48,
			57
		],
		"valid"
	],
	[
		[
			58,
			64
		],
		"disallowed_STD3_valid"
	],
	[
		[
			65,
			65
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			66,
			66
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			67,
			67
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			68,
			68
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			69,
			69
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			70,
			70
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			71,
			71
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			72,
			72
		],
		"mapped",
		[
			104
		]
	],
	[
		[
			73,
			73
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			74,
			74
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			75,
			75
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			76,
			76
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			77,
			77
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			78,
			78
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			79,
			79
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			80,
			80
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			81,
			81
		],
		"mapped",
		[
			113
		]
	],
	[
		[
			82,
			82
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			83,
			83
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			84,
			84
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			85,
			85
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			86,
			86
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			87,
			87
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			88,
			88
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			89,
			89
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			90,
			90
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			91,
			96
		],
		"disallowed_STD3_valid"
	],
	[
		[
			97,
			122
		],
		"valid"
	],
	[
		[
			123,
			127
		],
		"disallowed_STD3_valid"
	],
	[
		[
			128,
			159
		],
		"disallowed"
	],
	[
		[
			160,
			160
		],
		"disallowed_STD3_mapped",
		[
			32
		]
	],
	[
		[
			161,
			167
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			168,
			168
		],
		"disallowed_STD3_mapped",
		[
			32,
			776
		]
	],
	[
		[
			169,
			169
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			170,
			170
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			171,
			172
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			173,
			173
		],
		"ignored"
	],
	[
		[
			174,
			174
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			175,
			175
		],
		"disallowed_STD3_mapped",
		[
			32,
			772
		]
	],
	[
		[
			176,
			177
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			178,
			178
		],
		"mapped",
		[
			50
		]
	],
	[
		[
			179,
			179
		],
		"mapped",
		[
			51
		]
	],
	[
		[
			180,
			180
		],
		"disallowed_STD3_mapped",
		[
			32,
			769
		]
	],
	[
		[
			181,
			181
		],
		"mapped",
		[
			956
		]
	],
	[
		[
			182,
			182
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			183,
			183
		],
		"valid"
	],
	[
		[
			184,
			184
		],
		"disallowed_STD3_mapped",
		[
			32,
			807
		]
	],
	[
		[
			185,
			185
		],
		"mapped",
		[
			49
		]
	],
	[
		[
			186,
			186
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			187,
			187
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			188,
			188
		],
		"mapped",
		[
			49,
			8260,
			52
		]
	],
	[
		[
			189,
			189
		],
		"mapped",
		[
			49,
			8260,
			50
		]
	],
	[
		[
			190,
			190
		],
		"mapped",
		[
			51,
			8260,
			52
		]
	],
	[
		[
			191,
			191
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			192,
			192
		],
		"mapped",
		[
			224
		]
	],
	[
		[
			193,
			193
		],
		"mapped",
		[
			225
		]
	],
	[
		[
			194,
			194
		],
		"mapped",
		[
			226
		]
	],
	[
		[
			195,
			195
		],
		"mapped",
		[
			227
		]
	],
	[
		[
			196,
			196
		],
		"mapped",
		[
			228
		]
	],
	[
		[
			197,
			197
		],
		"mapped",
		[
			229
		]
	],
	[
		[
			198,
			198
		],
		"mapped",
		[
			230
		]
	],
	[
		[
			199,
			199
		],
		"mapped",
		[
			231
		]
	],
	[
		[
			200,
			200
		],
		"mapped",
		[
			232
		]
	],
	[
		[
			201,
			201
		],
		"mapped",
		[
			233
		]
	],
	[
		[
			202,
			202
		],
		"mapped",
		[
			234
		]
	],
	[
		[
			203,
			203
		],
		"mapped",
		[
			235
		]
	],
	[
		[
			204,
			204
		],
		"mapped",
		[
			236
		]
	],
	[
		[
			205,
			205
		],
		"mapped",
		[
			237
		]
	],
	[
		[
			206,
			206
		],
		"mapped",
		[
			238
		]
	],
	[
		[
			207,
			207
		],
		"mapped",
		[
			239
		]
	],
	[
		[
			208,
			208
		],
		"mapped",
		[
			240
		]
	],
	[
		[
			209,
			209
		],
		"mapped",
		[
			241
		]
	],
	[
		[
			210,
			210
		],
		"mapped",
		[
			242
		]
	],
	[
		[
			211,
			211
		],
		"mapped",
		[
			243
		]
	],
	[
		[
			212,
			212
		],
		"mapped",
		[
			244
		]
	],
	[
		[
			213,
			213
		],
		"mapped",
		[
			245
		]
	],
	[
		[
			214,
			214
		],
		"mapped",
		[
			246
		]
	],
	[
		[
			215,
			215
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			216,
			216
		],
		"mapped",
		[
			248
		]
	],
	[
		[
			217,
			217
		],
		"mapped",
		[
			249
		]
	],
	[
		[
			218,
			218
		],
		"mapped",
		[
			250
		]
	],
	[
		[
			219,
			219
		],
		"mapped",
		[
			251
		]
	],
	[
		[
			220,
			220
		],
		"mapped",
		[
			252
		]
	],
	[
		[
			221,
			221
		],
		"mapped",
		[
			253
		]
	],
	[
		[
			222,
			222
		],
		"mapped",
		[
			254
		]
	],
	[
		[
			223,
			223
		],
		"deviation",
		[
			115,
			115
		]
	],
	[
		[
			224,
			246
		],
		"valid"
	],
	[
		[
			247,
			247
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			248,
			255
		],
		"valid"
	],
	[
		[
			256,
			256
		],
		"mapped",
		[
			257
		]
	],
	[
		[
			257,
			257
		],
		"valid"
	],
	[
		[
			258,
			258
		],
		"mapped",
		[
			259
		]
	],
	[
		[
			259,
			259
		],
		"valid"
	],
	[
		[
			260,
			260
		],
		"mapped",
		[
			261
		]
	],
	[
		[
			261,
			261
		],
		"valid"
	],
	[
		[
			262,
			262
		],
		"mapped",
		[
			263
		]
	],
	[
		[
			263,
			263
		],
		"valid"
	],
	[
		[
			264,
			264
		],
		"mapped",
		[
			265
		]
	],
	[
		[
			265,
			265
		],
		"valid"
	],
	[
		[
			266,
			266
		],
		"mapped",
		[
			267
		]
	],
	[
		[
			267,
			267
		],
		"valid"
	],
	[
		[
			268,
			268
		],
		"mapped",
		[
			269
		]
	],
	[
		[
			269,
			269
		],
		"valid"
	],
	[
		[
			270,
			270
		],
		"mapped",
		[
			271
		]
	],
	[
		[
			271,
			271
		],
		"valid"
	],
	[
		[
			272,
			272
		],
		"mapped",
		[
			273
		]
	],
	[
		[
			273,
			273
		],
		"valid"
	],
	[
		[
			274,
			274
		],
		"mapped",
		[
			275
		]
	],
	[
		[
			275,
			275
		],
		"valid"
	],
	[
		[
			276,
			276
		],
		"mapped",
		[
			277
		]
	],
	[
		[
			277,
			277
		],
		"valid"
	],
	[
		[
			278,
			278
		],
		"mapped",
		[
			279
		]
	],
	[
		[
			279,
			279
		],
		"valid"
	],
	[
		[
			280,
			280
		],
		"mapped",
		[
			281
		]
	],
	[
		[
			281,
			281
		],
		"valid"
	],
	[
		[
			282,
			282
		],
		"mapped",
		[
			283
		]
	],
	[
		[
			283,
			283
		],
		"valid"
	],
	[
		[
			284,
			284
		],
		"mapped",
		[
			285
		]
	],
	[
		[
			285,
			285
		],
		"valid"
	],
	[
		[
			286,
			286
		],
		"mapped",
		[
			287
		]
	],
	[
		[
			287,
			287
		],
		"valid"
	],
	[
		[
			288,
			288
		],
		"mapped",
		[
			289
		]
	],
	[
		[
			289,
			289
		],
		"valid"
	],
	[
		[
			290,
			290
		],
		"mapped",
		[
			291
		]
	],
	[
		[
			291,
			291
		],
		"valid"
	],
	[
		[
			292,
			292
		],
		"mapped",
		[
			293
		]
	],
	[
		[
			293,
			293
		],
		"valid"
	],
	[
		[
			294,
			294
		],
		"mapped",
		[
			295
		]
	],
	[
		[
			295,
			295
		],
		"valid"
	],
	[
		[
			296,
			296
		],
		"mapped",
		[
			297
		]
	],
	[
		[
			297,
			297
		],
		"valid"
	],
	[
		[
			298,
			298
		],
		"mapped",
		[
			299
		]
	],
	[
		[
			299,
			299
		],
		"valid"
	],
	[
		[
			300,
			300
		],
		"mapped",
		[
			301
		]
	],
	[
		[
			301,
			301
		],
		"valid"
	],
	[
		[
			302,
			302
		],
		"mapped",
		[
			303
		]
	],
	[
		[
			303,
			303
		],
		"valid"
	],
	[
		[
			304,
			304
		],
		"mapped",
		[
			105,
			775
		]
	],
	[
		[
			305,
			305
		],
		"valid"
	],
	[
		[
			306,
			307
		],
		"mapped",
		[
			105,
			106
		]
	],
	[
		[
			308,
			308
		],
		"mapped",
		[
			309
		]
	],
	[
		[
			309,
			309
		],
		"valid"
	],
	[
		[
			310,
			310
		],
		"mapped",
		[
			311
		]
	],
	[
		[
			311,
			312
		],
		"valid"
	],
	[
		[
			313,
			313
		],
		"mapped",
		[
			314
		]
	],
	[
		[
			314,
			314
		],
		"valid"
	],
	[
		[
			315,
			315
		],
		"mapped",
		[
			316
		]
	],
	[
		[
			316,
			316
		],
		"valid"
	],
	[
		[
			317,
			317
		],
		"mapped",
		[
			318
		]
	],
	[
		[
			318,
			318
		],
		"valid"
	],
	[
		[
			319,
			320
		],
		"mapped",
		[
			108,
			183
		]
	],
	[
		[
			321,
			321
		],
		"mapped",
		[
			322
		]
	],
	[
		[
			322,
			322
		],
		"valid"
	],
	[
		[
			323,
			323
		],
		"mapped",
		[
			324
		]
	],
	[
		[
			324,
			324
		],
		"valid"
	],
	[
		[
			325,
			325
		],
		"mapped",
		[
			326
		]
	],
	[
		[
			326,
			326
		],
		"valid"
	],
	[
		[
			327,
			327
		],
		"mapped",
		[
			328
		]
	],
	[
		[
			328,
			328
		],
		"valid"
	],
	[
		[
			329,
			329
		],
		"mapped",
		[
			700,
			110
		]
	],
	[
		[
			330,
			330
		],
		"mapped",
		[
			331
		]
	],
	[
		[
			331,
			331
		],
		"valid"
	],
	[
		[
			332,
			332
		],
		"mapped",
		[
			333
		]
	],
	[
		[
			333,
			333
		],
		"valid"
	],
	[
		[
			334,
			334
		],
		"mapped",
		[
			335
		]
	],
	[
		[
			335,
			335
		],
		"valid"
	],
	[
		[
			336,
			336
		],
		"mapped",
		[
			337
		]
	],
	[
		[
			337,
			337
		],
		"valid"
	],
	[
		[
			338,
			338
		],
		"mapped",
		[
			339
		]
	],
	[
		[
			339,
			339
		],
		"valid"
	],
	[
		[
			340,
			340
		],
		"mapped",
		[
			341
		]
	],
	[
		[
			341,
			341
		],
		"valid"
	],
	[
		[
			342,
			342
		],
		"mapped",
		[
			343
		]
	],
	[
		[
			343,
			343
		],
		"valid"
	],
	[
		[
			344,
			344
		],
		"mapped",
		[
			345
		]
	],
	[
		[
			345,
			345
		],
		"valid"
	],
	[
		[
			346,
			346
		],
		"mapped",
		[
			347
		]
	],
	[
		[
			347,
			347
		],
		"valid"
	],
	[
		[
			348,
			348
		],
		"mapped",
		[
			349
		]
	],
	[
		[
			349,
			349
		],
		"valid"
	],
	[
		[
			350,
			350
		],
		"mapped",
		[
			351
		]
	],
	[
		[
			351,
			351
		],
		"valid"
	],
	[
		[
			352,
			352
		],
		"mapped",
		[
			353
		]
	],
	[
		[
			353,
			353
		],
		"valid"
	],
	[
		[
			354,
			354
		],
		"mapped",
		[
			355
		]
	],
	[
		[
			355,
			355
		],
		"valid"
	],
	[
		[
			356,
			356
		],
		"mapped",
		[
			357
		]
	],
	[
		[
			357,
			357
		],
		"valid"
	],
	[
		[
			358,
			358
		],
		"mapped",
		[
			359
		]
	],
	[
		[
			359,
			359
		],
		"valid"
	],
	[
		[
			360,
			360
		],
		"mapped",
		[
			361
		]
	],
	[
		[
			361,
			361
		],
		"valid"
	],
	[
		[
			362,
			362
		],
		"mapped",
		[
			363
		]
	],
	[
		[
			363,
			363
		],
		"valid"
	],
	[
		[
			364,
			364
		],
		"mapped",
		[
			365
		]
	],
	[
		[
			365,
			365
		],
		"valid"
	],
	[
		[
			366,
			366
		],
		"mapped",
		[
			367
		]
	],
	[
		[
			367,
			367
		],
		"valid"
	],
	[
		[
			368,
			368
		],
		"mapped",
		[
			369
		]
	],
	[
		[
			369,
			369
		],
		"valid"
	],
	[
		[
			370,
			370
		],
		"mapped",
		[
			371
		]
	],
	[
		[
			371,
			371
		],
		"valid"
	],
	[
		[
			372,
			372
		],
		"mapped",
		[
			373
		]
	],
	[
		[
			373,
			373
		],
		"valid"
	],
	[
		[
			374,
			374
		],
		"mapped",
		[
			375
		]
	],
	[
		[
			375,
			375
		],
		"valid"
	],
	[
		[
			376,
			376
		],
		"mapped",
		[
			255
		]
	],
	[
		[
			377,
			377
		],
		"mapped",
		[
			378
		]
	],
	[
		[
			378,
			378
		],
		"valid"
	],
	[
		[
			379,
			379
		],
		"mapped",
		[
			380
		]
	],
	[
		[
			380,
			380
		],
		"valid"
	],
	[
		[
			381,
			381
		],
		"mapped",
		[
			382
		]
	],
	[
		[
			382,
			382
		],
		"valid"
	],
	[
		[
			383,
			383
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			384,
			384
		],
		"valid"
	],
	[
		[
			385,
			385
		],
		"mapped",
		[
			595
		]
	],
	[
		[
			386,
			386
		],
		"mapped",
		[
			387
		]
	],
	[
		[
			387,
			387
		],
		"valid"
	],
	[
		[
			388,
			388
		],
		"mapped",
		[
			389
		]
	],
	[
		[
			389,
			389
		],
		"valid"
	],
	[
		[
			390,
			390
		],
		"mapped",
		[
			596
		]
	],
	[
		[
			391,
			391
		],
		"mapped",
		[
			392
		]
	],
	[
		[
			392,
			392
		],
		"valid"
	],
	[
		[
			393,
			393
		],
		"mapped",
		[
			598
		]
	],
	[
		[
			394,
			394
		],
		"mapped",
		[
			599
		]
	],
	[
		[
			395,
			395
		],
		"mapped",
		[
			396
		]
	],
	[
		[
			396,
			397
		],
		"valid"
	],
	[
		[
			398,
			398
		],
		"mapped",
		[
			477
		]
	],
	[
		[
			399,
			399
		],
		"mapped",
		[
			601
		]
	],
	[
		[
			400,
			400
		],
		"mapped",
		[
			603
		]
	],
	[
		[
			401,
			401
		],
		"mapped",
		[
			402
		]
	],
	[
		[
			402,
			402
		],
		"valid"
	],
	[
		[
			403,
			403
		],
		"mapped",
		[
			608
		]
	],
	[
		[
			404,
			404
		],
		"mapped",
		[
			611
		]
	],
	[
		[
			405,
			405
		],
		"valid"
	],
	[
		[
			406,
			406
		],
		"mapped",
		[
			617
		]
	],
	[
		[
			407,
			407
		],
		"mapped",
		[
			616
		]
	],
	[
		[
			408,
			408
		],
		"mapped",
		[
			409
		]
	],
	[
		[
			409,
			411
		],
		"valid"
	],
	[
		[
			412,
			412
		],
		"mapped",
		[
			623
		]
	],
	[
		[
			413,
			413
		],
		"mapped",
		[
			626
		]
	],
	[
		[
			414,
			414
		],
		"valid"
	],
	[
		[
			415,
			415
		],
		"mapped",
		[
			629
		]
	],
	[
		[
			416,
			416
		],
		"mapped",
		[
			417
		]
	],
	[
		[
			417,
			417
		],
		"valid"
	],
	[
		[
			418,
			418
		],
		"mapped",
		[
			419
		]
	],
	[
		[
			419,
			419
		],
		"valid"
	],
	[
		[
			420,
			420
		],
		"mapped",
		[
			421
		]
	],
	[
		[
			421,
			421
		],
		"valid"
	],
	[
		[
			422,
			422
		],
		"mapped",
		[
			640
		]
	],
	[
		[
			423,
			423
		],
		"mapped",
		[
			424
		]
	],
	[
		[
			424,
			424
		],
		"valid"
	],
	[
		[
			425,
			425
		],
		"mapped",
		[
			643
		]
	],
	[
		[
			426,
			427
		],
		"valid"
	],
	[
		[
			428,
			428
		],
		"mapped",
		[
			429
		]
	],
	[
		[
			429,
			429
		],
		"valid"
	],
	[
		[
			430,
			430
		],
		"mapped",
		[
			648
		]
	],
	[
		[
			431,
			431
		],
		"mapped",
		[
			432
		]
	],
	[
		[
			432,
			432
		],
		"valid"
	],
	[
		[
			433,
			433
		],
		"mapped",
		[
			650
		]
	],
	[
		[
			434,
			434
		],
		"mapped",
		[
			651
		]
	],
	[
		[
			435,
			435
		],
		"mapped",
		[
			436
		]
	],
	[
		[
			436,
			436
		],
		"valid"
	],
	[
		[
			437,
			437
		],
		"mapped",
		[
			438
		]
	],
	[
		[
			438,
			438
		],
		"valid"
	],
	[
		[
			439,
			439
		],
		"mapped",
		[
			658
		]
	],
	[
		[
			440,
			440
		],
		"mapped",
		[
			441
		]
	],
	[
		[
			441,
			443
		],
		"valid"
	],
	[
		[
			444,
			444
		],
		"mapped",
		[
			445
		]
	],
	[
		[
			445,
			451
		],
		"valid"
	],
	[
		[
			452,
			454
		],
		"mapped",
		[
			100,
			382
		]
	],
	[
		[
			455,
			457
		],
		"mapped",
		[
			108,
			106
		]
	],
	[
		[
			458,
			460
		],
		"mapped",
		[
			110,
			106
		]
	],
	[
		[
			461,
			461
		],
		"mapped",
		[
			462
		]
	],
	[
		[
			462,
			462
		],
		"valid"
	],
	[
		[
			463,
			463
		],
		"mapped",
		[
			464
		]
	],
	[
		[
			464,
			464
		],
		"valid"
	],
	[
		[
			465,
			465
		],
		"mapped",
		[
			466
		]
	],
	[
		[
			466,
			466
		],
		"valid"
	],
	[
		[
			467,
			467
		],
		"mapped",
		[
			468
		]
	],
	[
		[
			468,
			468
		],
		"valid"
	],
	[
		[
			469,
			469
		],
		"mapped",
		[
			470
		]
	],
	[
		[
			470,
			470
		],
		"valid"
	],
	[
		[
			471,
			471
		],
		"mapped",
		[
			472
		]
	],
	[
		[
			472,
			472
		],
		"valid"
	],
	[
		[
			473,
			473
		],
		"mapped",
		[
			474
		]
	],
	[
		[
			474,
			474
		],
		"valid"
	],
	[
		[
			475,
			475
		],
		"mapped",
		[
			476
		]
	],
	[
		[
			476,
			477
		],
		"valid"
	],
	[
		[
			478,
			478
		],
		"mapped",
		[
			479
		]
	],
	[
		[
			479,
			479
		],
		"valid"
	],
	[
		[
			480,
			480
		],
		"mapped",
		[
			481
		]
	],
	[
		[
			481,
			481
		],
		"valid"
	],
	[
		[
			482,
			482
		],
		"mapped",
		[
			483
		]
	],
	[
		[
			483,
			483
		],
		"valid"
	],
	[
		[
			484,
			484
		],
		"mapped",
		[
			485
		]
	],
	[
		[
			485,
			485
		],
		"valid"
	],
	[
		[
			486,
			486
		],
		"mapped",
		[
			487
		]
	],
	[
		[
			487,
			487
		],
		"valid"
	],
	[
		[
			488,
			488
		],
		"mapped",
		[
			489
		]
	],
	[
		[
			489,
			489
		],
		"valid"
	],
	[
		[
			490,
			490
		],
		"mapped",
		[
			491
		]
	],
	[
		[
			491,
			491
		],
		"valid"
	],
	[
		[
			492,
			492
		],
		"mapped",
		[
			493
		]
	],
	[
		[
			493,
			493
		],
		"valid"
	],
	[
		[
			494,
			494
		],
		"mapped",
		[
			495
		]
	],
	[
		[
			495,
			496
		],
		"valid"
	],
	[
		[
			497,
			499
		],
		"mapped",
		[
			100,
			122
		]
	],
	[
		[
			500,
			500
		],
		"mapped",
		[
			501
		]
	],
	[
		[
			501,
			501
		],
		"valid"
	],
	[
		[
			502,
			502
		],
		"mapped",
		[
			405
		]
	],
	[
		[
			503,
			503
		],
		"mapped",
		[
			447
		]
	],
	[
		[
			504,
			504
		],
		"mapped",
		[
			505
		]
	],
	[
		[
			505,
			505
		],
		"valid"
	],
	[
		[
			506,
			506
		],
		"mapped",
		[
			507
		]
	],
	[
		[
			507,
			507
		],
		"valid"
	],
	[
		[
			508,
			508
		],
		"mapped",
		[
			509
		]
	],
	[
		[
			509,
			509
		],
		"valid"
	],
	[
		[
			510,
			510
		],
		"mapped",
		[
			511
		]
	],
	[
		[
			511,
			511
		],
		"valid"
	],
	[
		[
			512,
			512
		],
		"mapped",
		[
			513
		]
	],
	[
		[
			513,
			513
		],
		"valid"
	],
	[
		[
			514,
			514
		],
		"mapped",
		[
			515
		]
	],
	[
		[
			515,
			515
		],
		"valid"
	],
	[
		[
			516,
			516
		],
		"mapped",
		[
			517
		]
	],
	[
		[
			517,
			517
		],
		"valid"
	],
	[
		[
			518,
			518
		],
		"mapped",
		[
			519
		]
	],
	[
		[
			519,
			519
		],
		"valid"
	],
	[
		[
			520,
			520
		],
		"mapped",
		[
			521
		]
	],
	[
		[
			521,
			521
		],
		"valid"
	],
	[
		[
			522,
			522
		],
		"mapped",
		[
			523
		]
	],
	[
		[
			523,
			523
		],
		"valid"
	],
	[
		[
			524,
			524
		],
		"mapped",
		[
			525
		]
	],
	[
		[
			525,
			525
		],
		"valid"
	],
	[
		[
			526,
			526
		],
		"mapped",
		[
			527
		]
	],
	[
		[
			527,
			527
		],
		"valid"
	],
	[
		[
			528,
			528
		],
		"mapped",
		[
			529
		]
	],
	[
		[
			529,
			529
		],
		"valid"
	],
	[
		[
			530,
			530
		],
		"mapped",
		[
			531
		]
	],
	[
		[
			531,
			531
		],
		"valid"
	],
	[
		[
			532,
			532
		],
		"mapped",
		[
			533
		]
	],
	[
		[
			533,
			533
		],
		"valid"
	],
	[
		[
			534,
			534
		],
		"mapped",
		[
			535
		]
	],
	[
		[
			535,
			535
		],
		"valid"
	],
	[
		[
			536,
			536
		],
		"mapped",
		[
			537
		]
	],
	[
		[
			537,
			537
		],
		"valid"
	],
	[
		[
			538,
			538
		],
		"mapped",
		[
			539
		]
	],
	[
		[
			539,
			539
		],
		"valid"
	],
	[
		[
			540,
			540
		],
		"mapped",
		[
			541
		]
	],
	[
		[
			541,
			541
		],
		"valid"
	],
	[
		[
			542,
			542
		],
		"mapped",
		[
			543
		]
	],
	[
		[
			543,
			543
		],
		"valid"
	],
	[
		[
			544,
			544
		],
		"mapped",
		[
			414
		]
	],
	[
		[
			545,
			545
		],
		"valid"
	],
	[
		[
			546,
			546
		],
		"mapped",
		[
			547
		]
	],
	[
		[
			547,
			547
		],
		"valid"
	],
	[
		[
			548,
			548
		],
		"mapped",
		[
			549
		]
	],
	[
		[
			549,
			549
		],
		"valid"
	],
	[
		[
			550,
			550
		],
		"mapped",
		[
			551
		]
	],
	[
		[
			551,
			551
		],
		"valid"
	],
	[
		[
			552,
			552
		],
		"mapped",
		[
			553
		]
	],
	[
		[
			553,
			553
		],
		"valid"
	],
	[
		[
			554,
			554
		],
		"mapped",
		[
			555
		]
	],
	[
		[
			555,
			555
		],
		"valid"
	],
	[
		[
			556,
			556
		],
		"mapped",
		[
			557
		]
	],
	[
		[
			557,
			557
		],
		"valid"
	],
	[
		[
			558,
			558
		],
		"mapped",
		[
			559
		]
	],
	[
		[
			559,
			559
		],
		"valid"
	],
	[
		[
			560,
			560
		],
		"mapped",
		[
			561
		]
	],
	[
		[
			561,
			561
		],
		"valid"
	],
	[
		[
			562,
			562
		],
		"mapped",
		[
			563
		]
	],
	[
		[
			563,
			563
		],
		"valid"
	],
	[
		[
			564,
			566
		],
		"valid"
	],
	[
		[
			567,
			569
		],
		"valid"
	],
	[
		[
			570,
			570
		],
		"mapped",
		[
			11365
		]
	],
	[
		[
			571,
			571
		],
		"mapped",
		[
			572
		]
	],
	[
		[
			572,
			572
		],
		"valid"
	],
	[
		[
			573,
			573
		],
		"mapped",
		[
			410
		]
	],
	[
		[
			574,
			574
		],
		"mapped",
		[
			11366
		]
	],
	[
		[
			575,
			576
		],
		"valid"
	],
	[
		[
			577,
			577
		],
		"mapped",
		[
			578
		]
	],
	[
		[
			578,
			578
		],
		"valid"
	],
	[
		[
			579,
			579
		],
		"mapped",
		[
			384
		]
	],
	[
		[
			580,
			580
		],
		"mapped",
		[
			649
		]
	],
	[
		[
			581,
			581
		],
		"mapped",
		[
			652
		]
	],
	[
		[
			582,
			582
		],
		"mapped",
		[
			583
		]
	],
	[
		[
			583,
			583
		],
		"valid"
	],
	[
		[
			584,
			584
		],
		"mapped",
		[
			585
		]
	],
	[
		[
			585,
			585
		],
		"valid"
	],
	[
		[
			586,
			586
		],
		"mapped",
		[
			587
		]
	],
	[
		[
			587,
			587
		],
		"valid"
	],
	[
		[
			588,
			588
		],
		"mapped",
		[
			589
		]
	],
	[
		[
			589,
			589
		],
		"valid"
	],
	[
		[
			590,
			590
		],
		"mapped",
		[
			591
		]
	],
	[
		[
			591,
			591
		],
		"valid"
	],
	[
		[
			592,
			680
		],
		"valid"
	],
	[
		[
			681,
			685
		],
		"valid"
	],
	[
		[
			686,
			687
		],
		"valid"
	],
	[
		[
			688,
			688
		],
		"mapped",
		[
			104
		]
	],
	[
		[
			689,
			689
		],
		"mapped",
		[
			614
		]
	],
	[
		[
			690,
			690
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			691,
			691
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			692,
			692
		],
		"mapped",
		[
			633
		]
	],
	[
		[
			693,
			693
		],
		"mapped",
		[
			635
		]
	],
	[
		[
			694,
			694
		],
		"mapped",
		[
			641
		]
	],
	[
		[
			695,
			695
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			696,
			696
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			697,
			705
		],
		"valid"
	],
	[
		[
			706,
			709
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			710,
			721
		],
		"valid"
	],
	[
		[
			722,
			727
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			728,
			728
		],
		"disallowed_STD3_mapped",
		[
			32,
			774
		]
	],
	[
		[
			729,
			729
		],
		"disallowed_STD3_mapped",
		[
			32,
			775
		]
	],
	[
		[
			730,
			730
		],
		"disallowed_STD3_mapped",
		[
			32,
			778
		]
	],
	[
		[
			731,
			731
		],
		"disallowed_STD3_mapped",
		[
			32,
			808
		]
	],
	[
		[
			732,
			732
		],
		"disallowed_STD3_mapped",
		[
			32,
			771
		]
	],
	[
		[
			733,
			733
		],
		"disallowed_STD3_mapped",
		[
			32,
			779
		]
	],
	[
		[
			734,
			734
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			735,
			735
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			736,
			736
		],
		"mapped",
		[
			611
		]
	],
	[
		[
			737,
			737
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			738,
			738
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			739,
			739
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			740,
			740
		],
		"mapped",
		[
			661
		]
	],
	[
		[
			741,
			745
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			746,
			747
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			748,
			748
		],
		"valid"
	],
	[
		[
			749,
			749
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			750,
			750
		],
		"valid"
	],
	[
		[
			751,
			767
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			768,
			831
		],
		"valid"
	],
	[
		[
			832,
			832
		],
		"mapped",
		[
			768
		]
	],
	[
		[
			833,
			833
		],
		"mapped",
		[
			769
		]
	],
	[
		[
			834,
			834
		],
		"valid"
	],
	[
		[
			835,
			835
		],
		"mapped",
		[
			787
		]
	],
	[
		[
			836,
			836
		],
		"mapped",
		[
			776,
			769
		]
	],
	[
		[
			837,
			837
		],
		"mapped",
		[
			953
		]
	],
	[
		[
			838,
			846
		],
		"valid"
	],
	[
		[
			847,
			847
		],
		"ignored"
	],
	[
		[
			848,
			855
		],
		"valid"
	],
	[
		[
			856,
			860
		],
		"valid"
	],
	[
		[
			861,
			863
		],
		"valid"
	],
	[
		[
			864,
			865
		],
		"valid"
	],
	[
		[
			866,
			866
		],
		"valid"
	],
	[
		[
			867,
			879
		],
		"valid"
	],
	[
		[
			880,
			880
		],
		"mapped",
		[
			881
		]
	],
	[
		[
			881,
			881
		],
		"valid"
	],
	[
		[
			882,
			882
		],
		"mapped",
		[
			883
		]
	],
	[
		[
			883,
			883
		],
		"valid"
	],
	[
		[
			884,
			884
		],
		"mapped",
		[
			697
		]
	],
	[
		[
			885,
			885
		],
		"valid"
	],
	[
		[
			886,
			886
		],
		"mapped",
		[
			887
		]
	],
	[
		[
			887,
			887
		],
		"valid"
	],
	[
		[
			888,
			889
		],
		"disallowed"
	],
	[
		[
			890,
			890
		],
		"disallowed_STD3_mapped",
		[
			32,
			953
		]
	],
	[
		[
			891,
			893
		],
		"valid"
	],
	[
		[
			894,
			894
		],
		"disallowed_STD3_mapped",
		[
			59
		]
	],
	[
		[
			895,
			895
		],
		"mapped",
		[
			1011
		]
	],
	[
		[
			896,
			899
		],
		"disallowed"
	],
	[
		[
			900,
			900
		],
		"disallowed_STD3_mapped",
		[
			32,
			769
		]
	],
	[
		[
			901,
			901
		],
		"disallowed_STD3_mapped",
		[
			32,
			776,
			769
		]
	],
	[
		[
			902,
			902
		],
		"mapped",
		[
			940
		]
	],
	[
		[
			903,
			903
		],
		"mapped",
		[
			183
		]
	],
	[
		[
			904,
			904
		],
		"mapped",
		[
			941
		]
	],
	[
		[
			905,
			905
		],
		"mapped",
		[
			942
		]
	],
	[
		[
			906,
			906
		],
		"mapped",
		[
			943
		]
	],
	[
		[
			907,
			907
		],
		"disallowed"
	],
	[
		[
			908,
			908
		],
		"mapped",
		[
			972
		]
	],
	[
		[
			909,
			909
		],
		"disallowed"
	],
	[
		[
			910,
			910
		],
		"mapped",
		[
			973
		]
	],
	[
		[
			911,
			911
		],
		"mapped",
		[
			974
		]
	],
	[
		[
			912,
			912
		],
		"valid"
	],
	[
		[
			913,
			913
		],
		"mapped",
		[
			945
		]
	],
	[
		[
			914,
			914
		],
		"mapped",
		[
			946
		]
	],
	[
		[
			915,
			915
		],
		"mapped",
		[
			947
		]
	],
	[
		[
			916,
			916
		],
		"mapped",
		[
			948
		]
	],
	[
		[
			917,
			917
		],
		"mapped",
		[
			949
		]
	],
	[
		[
			918,
			918
		],
		"mapped",
		[
			950
		]
	],
	[
		[
			919,
			919
		],
		"mapped",
		[
			951
		]
	],
	[
		[
			920,
			920
		],
		"mapped",
		[
			952
		]
	],
	[
		[
			921,
			921
		],
		"mapped",
		[
			953
		]
	],
	[
		[
			922,
			922
		],
		"mapped",
		[
			954
		]
	],
	[
		[
			923,
			923
		],
		"mapped",
		[
			955
		]
	],
	[
		[
			924,
			924
		],
		"mapped",
		[
			956
		]
	],
	[
		[
			925,
			925
		],
		"mapped",
		[
			957
		]
	],
	[
		[
			926,
			926
		],
		"mapped",
		[
			958
		]
	],
	[
		[
			927,
			927
		],
		"mapped",
		[
			959
		]
	],
	[
		[
			928,
			928
		],
		"mapped",
		[
			960
		]
	],
	[
		[
			929,
			929
		],
		"mapped",
		[
			961
		]
	],
	[
		[
			930,
			930
		],
		"disallowed"
	],
	[
		[
			931,
			931
		],
		"mapped",
		[
			963
		]
	],
	[
		[
			932,
			932
		],
		"mapped",
		[
			964
		]
	],
	[
		[
			933,
			933
		],
		"mapped",
		[
			965
		]
	],
	[
		[
			934,
			934
		],
		"mapped",
		[
			966
		]
	],
	[
		[
			935,
			935
		],
		"mapped",
		[
			967
		]
	],
	[
		[
			936,
			936
		],
		"mapped",
		[
			968
		]
	],
	[
		[
			937,
			937
		],
		"mapped",
		[
			969
		]
	],
	[
		[
			938,
			938
		],
		"mapped",
		[
			970
		]
	],
	[
		[
			939,
			939
		],
		"mapped",
		[
			971
		]
	],
	[
		[
			940,
			961
		],
		"valid"
	],
	[
		[
			962,
			962
		],
		"deviation",
		[
			963
		]
	],
	[
		[
			963,
			974
		],
		"valid"
	],
	[
		[
			975,
			975
		],
		"mapped",
		[
			983
		]
	],
	[
		[
			976,
			976
		],
		"mapped",
		[
			946
		]
	],
	[
		[
			977,
			977
		],
		"mapped",
		[
			952
		]
	],
	[
		[
			978,
			978
		],
		"mapped",
		[
			965
		]
	],
	[
		[
			979,
			979
		],
		"mapped",
		[
			973
		]
	],
	[
		[
			980,
			980
		],
		"mapped",
		[
			971
		]
	],
	[
		[
			981,
			981
		],
		"mapped",
		[
			966
		]
	],
	[
		[
			982,
			982
		],
		"mapped",
		[
			960
		]
	],
	[
		[
			983,
			983
		],
		"valid"
	],
	[
		[
			984,
			984
		],
		"mapped",
		[
			985
		]
	],
	[
		[
			985,
			985
		],
		"valid"
	],
	[
		[
			986,
			986
		],
		"mapped",
		[
			987
		]
	],
	[
		[
			987,
			987
		],
		"valid"
	],
	[
		[
			988,
			988
		],
		"mapped",
		[
			989
		]
	],
	[
		[
			989,
			989
		],
		"valid"
	],
	[
		[
			990,
			990
		],
		"mapped",
		[
			991
		]
	],
	[
		[
			991,
			991
		],
		"valid"
	],
	[
		[
			992,
			992
		],
		"mapped",
		[
			993
		]
	],
	[
		[
			993,
			993
		],
		"valid"
	],
	[
		[
			994,
			994
		],
		"mapped",
		[
			995
		]
	],
	[
		[
			995,
			995
		],
		"valid"
	],
	[
		[
			996,
			996
		],
		"mapped",
		[
			997
		]
	],
	[
		[
			997,
			997
		],
		"valid"
	],
	[
		[
			998,
			998
		],
		"mapped",
		[
			999
		]
	],
	[
		[
			999,
			999
		],
		"valid"
	],
	[
		[
			1000,
			1000
		],
		"mapped",
		[
			1001
		]
	],
	[
		[
			1001,
			1001
		],
		"valid"
	],
	[
		[
			1002,
			1002
		],
		"mapped",
		[
			1003
		]
	],
	[
		[
			1003,
			1003
		],
		"valid"
	],
	[
		[
			1004,
			1004
		],
		"mapped",
		[
			1005
		]
	],
	[
		[
			1005,
			1005
		],
		"valid"
	],
	[
		[
			1006,
			1006
		],
		"mapped",
		[
			1007
		]
	],
	[
		[
			1007,
			1007
		],
		"valid"
	],
	[
		[
			1008,
			1008
		],
		"mapped",
		[
			954
		]
	],
	[
		[
			1009,
			1009
		],
		"mapped",
		[
			961
		]
	],
	[
		[
			1010,
			1010
		],
		"mapped",
		[
			963
		]
	],
	[
		[
			1011,
			1011
		],
		"valid"
	],
	[
		[
			1012,
			1012
		],
		"mapped",
		[
			952
		]
	],
	[
		[
			1013,
			1013
		],
		"mapped",
		[
			949
		]
	],
	[
		[
			1014,
			1014
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			1015,
			1015
		],
		"mapped",
		[
			1016
		]
	],
	[
		[
			1016,
			1016
		],
		"valid"
	],
	[
		[
			1017,
			1017
		],
		"mapped",
		[
			963
		]
	],
	[
		[
			1018,
			1018
		],
		"mapped",
		[
			1019
		]
	],
	[
		[
			1019,
			1019
		],
		"valid"
	],
	[
		[
			1020,
			1020
		],
		"valid"
	],
	[
		[
			1021,
			1021
		],
		"mapped",
		[
			891
		]
	],
	[
		[
			1022,
			1022
		],
		"mapped",
		[
			892
		]
	],
	[
		[
			1023,
			1023
		],
		"mapped",
		[
			893
		]
	],
	[
		[
			1024,
			1024
		],
		"mapped",
		[
			1104
		]
	],
	[
		[
			1025,
			1025
		],
		"mapped",
		[
			1105
		]
	],
	[
		[
			1026,
			1026
		],
		"mapped",
		[
			1106
		]
	],
	[
		[
			1027,
			1027
		],
		"mapped",
		[
			1107
		]
	],
	[
		[
			1028,
			1028
		],
		"mapped",
		[
			1108
		]
	],
	[
		[
			1029,
			1029
		],
		"mapped",
		[
			1109
		]
	],
	[
		[
			1030,
			1030
		],
		"mapped",
		[
			1110
		]
	],
	[
		[
			1031,
			1031
		],
		"mapped",
		[
			1111
		]
	],
	[
		[
			1032,
			1032
		],
		"mapped",
		[
			1112
		]
	],
	[
		[
			1033,
			1033
		],
		"mapped",
		[
			1113
		]
	],
	[
		[
			1034,
			1034
		],
		"mapped",
		[
			1114
		]
	],
	[
		[
			1035,
			1035
		],
		"mapped",
		[
			1115
		]
	],
	[
		[
			1036,
			1036
		],
		"mapped",
		[
			1116
		]
	],
	[
		[
			1037,
			1037
		],
		"mapped",
		[
			1117
		]
	],
	[
		[
			1038,
			1038
		],
		"mapped",
		[
			1118
		]
	],
	[
		[
			1039,
			1039
		],
		"mapped",
		[
			1119
		]
	],
	[
		[
			1040,
			1040
		],
		"mapped",
		[
			1072
		]
	],
	[
		[
			1041,
			1041
		],
		"mapped",
		[
			1073
		]
	],
	[
		[
			1042,
			1042
		],
		"mapped",
		[
			1074
		]
	],
	[
		[
			1043,
			1043
		],
		"mapped",
		[
			1075
		]
	],
	[
		[
			1044,
			1044
		],
		"mapped",
		[
			1076
		]
	],
	[
		[
			1045,
			1045
		],
		"mapped",
		[
			1077
		]
	],
	[
		[
			1046,
			1046
		],
		"mapped",
		[
			1078
		]
	],
	[
		[
			1047,
			1047
		],
		"mapped",
		[
			1079
		]
	],
	[
		[
			1048,
			1048
		],
		"mapped",
		[
			1080
		]
	],
	[
		[
			1049,
			1049
		],
		"mapped",
		[
			1081
		]
	],
	[
		[
			1050,
			1050
		],
		"mapped",
		[
			1082
		]
	],
	[
		[
			1051,
			1051
		],
		"mapped",
		[
			1083
		]
	],
	[
		[
			1052,
			1052
		],
		"mapped",
		[
			1084
		]
	],
	[
		[
			1053,
			1053
		],
		"mapped",
		[
			1085
		]
	],
	[
		[
			1054,
			1054
		],
		"mapped",
		[
			1086
		]
	],
	[
		[
			1055,
			1055
		],
		"mapped",
		[
			1087
		]
	],
	[
		[
			1056,
			1056
		],
		"mapped",
		[
			1088
		]
	],
	[
		[
			1057,
			1057
		],
		"mapped",
		[
			1089
		]
	],
	[
		[
			1058,
			1058
		],
		"mapped",
		[
			1090
		]
	],
	[
		[
			1059,
			1059
		],
		"mapped",
		[
			1091
		]
	],
	[
		[
			1060,
			1060
		],
		"mapped",
		[
			1092
		]
	],
	[
		[
			1061,
			1061
		],
		"mapped",
		[
			1093
		]
	],
	[
		[
			1062,
			1062
		],
		"mapped",
		[
			1094
		]
	],
	[
		[
			1063,
			1063
		],
		"mapped",
		[
			1095
		]
	],
	[
		[
			1064,
			1064
		],
		"mapped",
		[
			1096
		]
	],
	[
		[
			1065,
			1065
		],
		"mapped",
		[
			1097
		]
	],
	[
		[
			1066,
			1066
		],
		"mapped",
		[
			1098
		]
	],
	[
		[
			1067,
			1067
		],
		"mapped",
		[
			1099
		]
	],
	[
		[
			1068,
			1068
		],
		"mapped",
		[
			1100
		]
	],
	[
		[
			1069,
			1069
		],
		"mapped",
		[
			1101
		]
	],
	[
		[
			1070,
			1070
		],
		"mapped",
		[
			1102
		]
	],
	[
		[
			1071,
			1071
		],
		"mapped",
		[
			1103
		]
	],
	[
		[
			1072,
			1103
		],
		"valid"
	],
	[
		[
			1104,
			1104
		],
		"valid"
	],
	[
		[
			1105,
			1116
		],
		"valid"
	],
	[
		[
			1117,
			1117
		],
		"valid"
	],
	[
		[
			1118,
			1119
		],
		"valid"
	],
	[
		[
			1120,
			1120
		],
		"mapped",
		[
			1121
		]
	],
	[
		[
			1121,
			1121
		],
		"valid"
	],
	[
		[
			1122,
			1122
		],
		"mapped",
		[
			1123
		]
	],
	[
		[
			1123,
			1123
		],
		"valid"
	],
	[
		[
			1124,
			1124
		],
		"mapped",
		[
			1125
		]
	],
	[
		[
			1125,
			1125
		],
		"valid"
	],
	[
		[
			1126,
			1126
		],
		"mapped",
		[
			1127
		]
	],
	[
		[
			1127,
			1127
		],
		"valid"
	],
	[
		[
			1128,
			1128
		],
		"mapped",
		[
			1129
		]
	],
	[
		[
			1129,
			1129
		],
		"valid"
	],
	[
		[
			1130,
			1130
		],
		"mapped",
		[
			1131
		]
	],
	[
		[
			1131,
			1131
		],
		"valid"
	],
	[
		[
			1132,
			1132
		],
		"mapped",
		[
			1133
		]
	],
	[
		[
			1133,
			1133
		],
		"valid"
	],
	[
		[
			1134,
			1134
		],
		"mapped",
		[
			1135
		]
	],
	[
		[
			1135,
			1135
		],
		"valid"
	],
	[
		[
			1136,
			1136
		],
		"mapped",
		[
			1137
		]
	],
	[
		[
			1137,
			1137
		],
		"valid"
	],
	[
		[
			1138,
			1138
		],
		"mapped",
		[
			1139
		]
	],
	[
		[
			1139,
			1139
		],
		"valid"
	],
	[
		[
			1140,
			1140
		],
		"mapped",
		[
			1141
		]
	],
	[
		[
			1141,
			1141
		],
		"valid"
	],
	[
		[
			1142,
			1142
		],
		"mapped",
		[
			1143
		]
	],
	[
		[
			1143,
			1143
		],
		"valid"
	],
	[
		[
			1144,
			1144
		],
		"mapped",
		[
			1145
		]
	],
	[
		[
			1145,
			1145
		],
		"valid"
	],
	[
		[
			1146,
			1146
		],
		"mapped",
		[
			1147
		]
	],
	[
		[
			1147,
			1147
		],
		"valid"
	],
	[
		[
			1148,
			1148
		],
		"mapped",
		[
			1149
		]
	],
	[
		[
			1149,
			1149
		],
		"valid"
	],
	[
		[
			1150,
			1150
		],
		"mapped",
		[
			1151
		]
	],
	[
		[
			1151,
			1151
		],
		"valid"
	],
	[
		[
			1152,
			1152
		],
		"mapped",
		[
			1153
		]
	],
	[
		[
			1153,
			1153
		],
		"valid"
	],
	[
		[
			1154,
			1154
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			1155,
			1158
		],
		"valid"
	],
	[
		[
			1159,
			1159
		],
		"valid"
	],
	[
		[
			1160,
			1161
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			1162,
			1162
		],
		"mapped",
		[
			1163
		]
	],
	[
		[
			1163,
			1163
		],
		"valid"
	],
	[
		[
			1164,
			1164
		],
		"mapped",
		[
			1165
		]
	],
	[
		[
			1165,
			1165
		],
		"valid"
	],
	[
		[
			1166,
			1166
		],
		"mapped",
		[
			1167
		]
	],
	[
		[
			1167,
			1167
		],
		"valid"
	],
	[
		[
			1168,
			1168
		],
		"mapped",
		[
			1169
		]
	],
	[
		[
			1169,
			1169
		],
		"valid"
	],
	[
		[
			1170,
			1170
		],
		"mapped",
		[
			1171
		]
	],
	[
		[
			1171,
			1171
		],
		"valid"
	],
	[
		[
			1172,
			1172
		],
		"mapped",
		[
			1173
		]
	],
	[
		[
			1173,
			1173
		],
		"valid"
	],
	[
		[
			1174,
			1174
		],
		"mapped",
		[
			1175
		]
	],
	[
		[
			1175,
			1175
		],
		"valid"
	],
	[
		[
			1176,
			1176
		],
		"mapped",
		[
			1177
		]
	],
	[
		[
			1177,
			1177
		],
		"valid"
	],
	[
		[
			1178,
			1178
		],
		"mapped",
		[
			1179
		]
	],
	[
		[
			1179,
			1179
		],
		"valid"
	],
	[
		[
			1180,
			1180
		],
		"mapped",
		[
			1181
		]
	],
	[
		[
			1181,
			1181
		],
		"valid"
	],
	[
		[
			1182,
			1182
		],
		"mapped",
		[
			1183
		]
	],
	[
		[
			1183,
			1183
		],
		"valid"
	],
	[
		[
			1184,
			1184
		],
		"mapped",
		[
			1185
		]
	],
	[
		[
			1185,
			1185
		],
		"valid"
	],
	[
		[
			1186,
			1186
		],
		"mapped",
		[
			1187
		]
	],
	[
		[
			1187,
			1187
		],
		"valid"
	],
	[
		[
			1188,
			1188
		],
		"mapped",
		[
			1189
		]
	],
	[
		[
			1189,
			1189
		],
		"valid"
	],
	[
		[
			1190,
			1190
		],
		"mapped",
		[
			1191
		]
	],
	[
		[
			1191,
			1191
		],
		"valid"
	],
	[
		[
			1192,
			1192
		],
		"mapped",
		[
			1193
		]
	],
	[
		[
			1193,
			1193
		],
		"valid"
	],
	[
		[
			1194,
			1194
		],
		"mapped",
		[
			1195
		]
	],
	[
		[
			1195,
			1195
		],
		"valid"
	],
	[
		[
			1196,
			1196
		],
		"mapped",
		[
			1197
		]
	],
	[
		[
			1197,
			1197
		],
		"valid"
	],
	[
		[
			1198,
			1198
		],
		"mapped",
		[
			1199
		]
	],
	[
		[
			1199,
			1199
		],
		"valid"
	],
	[
		[
			1200,
			1200
		],
		"mapped",
		[
			1201
		]
	],
	[
		[
			1201,
			1201
		],
		"valid"
	],
	[
		[
			1202,
			1202
		],
		"mapped",
		[
			1203
		]
	],
	[
		[
			1203,
			1203
		],
		"valid"
	],
	[
		[
			1204,
			1204
		],
		"mapped",
		[
			1205
		]
	],
	[
		[
			1205,
			1205
		],
		"valid"
	],
	[
		[
			1206,
			1206
		],
		"mapped",
		[
			1207
		]
	],
	[
		[
			1207,
			1207
		],
		"valid"
	],
	[
		[
			1208,
			1208
		],
		"mapped",
		[
			1209
		]
	],
	[
		[
			1209,
			1209
		],
		"valid"
	],
	[
		[
			1210,
			1210
		],
		"mapped",
		[
			1211
		]
	],
	[
		[
			1211,
			1211
		],
		"valid"
	],
	[
		[
			1212,
			1212
		],
		"mapped",
		[
			1213
		]
	],
	[
		[
			1213,
			1213
		],
		"valid"
	],
	[
		[
			1214,
			1214
		],
		"mapped",
		[
			1215
		]
	],
	[
		[
			1215,
			1215
		],
		"valid"
	],
	[
		[
			1216,
			1216
		],
		"disallowed"
	],
	[
		[
			1217,
			1217
		],
		"mapped",
		[
			1218
		]
	],
	[
		[
			1218,
			1218
		],
		"valid"
	],
	[
		[
			1219,
			1219
		],
		"mapped",
		[
			1220
		]
	],
	[
		[
			1220,
			1220
		],
		"valid"
	],
	[
		[
			1221,
			1221
		],
		"mapped",
		[
			1222
		]
	],
	[
		[
			1222,
			1222
		],
		"valid"
	],
	[
		[
			1223,
			1223
		],
		"mapped",
		[
			1224
		]
	],
	[
		[
			1224,
			1224
		],
		"valid"
	],
	[
		[
			1225,
			1225
		],
		"mapped",
		[
			1226
		]
	],
	[
		[
			1226,
			1226
		],
		"valid"
	],
	[
		[
			1227,
			1227
		],
		"mapped",
		[
			1228
		]
	],
	[
		[
			1228,
			1228
		],
		"valid"
	],
	[
		[
			1229,
			1229
		],
		"mapped",
		[
			1230
		]
	],
	[
		[
			1230,
			1230
		],
		"valid"
	],
	[
		[
			1231,
			1231
		],
		"valid"
	],
	[
		[
			1232,
			1232
		],
		"mapped",
		[
			1233
		]
	],
	[
		[
			1233,
			1233
		],
		"valid"
	],
	[
		[
			1234,
			1234
		],
		"mapped",
		[
			1235
		]
	],
	[
		[
			1235,
			1235
		],
		"valid"
	],
	[
		[
			1236,
			1236
		],
		"mapped",
		[
			1237
		]
	],
	[
		[
			1237,
			1237
		],
		"valid"
	],
	[
		[
			1238,
			1238
		],
		"mapped",
		[
			1239
		]
	],
	[
		[
			1239,
			1239
		],
		"valid"
	],
	[
		[
			1240,
			1240
		],
		"mapped",
		[
			1241
		]
	],
	[
		[
			1241,
			1241
		],
		"valid"
	],
	[
		[
			1242,
			1242
		],
		"mapped",
		[
			1243
		]
	],
	[
		[
			1243,
			1243
		],
		"valid"
	],
	[
		[
			1244,
			1244
		],
		"mapped",
		[
			1245
		]
	],
	[
		[
			1245,
			1245
		],
		"valid"
	],
	[
		[
			1246,
			1246
		],
		"mapped",
		[
			1247
		]
	],
	[
		[
			1247,
			1247
		],
		"valid"
	],
	[
		[
			1248,
			1248
		],
		"mapped",
		[
			1249
		]
	],
	[
		[
			1249,
			1249
		],
		"valid"
	],
	[
		[
			1250,
			1250
		],
		"mapped",
		[
			1251
		]
	],
	[
		[
			1251,
			1251
		],
		"valid"
	],
	[
		[
			1252,
			1252
		],
		"mapped",
		[
			1253
		]
	],
	[
		[
			1253,
			1253
		],
		"valid"
	],
	[
		[
			1254,
			1254
		],
		"mapped",
		[
			1255
		]
	],
	[
		[
			1255,
			1255
		],
		"valid"
	],
	[
		[
			1256,
			1256
		],
		"mapped",
		[
			1257
		]
	],
	[
		[
			1257,
			1257
		],
		"valid"
	],
	[
		[
			1258,
			1258
		],
		"mapped",
		[
			1259
		]
	],
	[
		[
			1259,
			1259
		],
		"valid"
	],
	[
		[
			1260,
			1260
		],
		"mapped",
		[
			1261
		]
	],
	[
		[
			1261,
			1261
		],
		"valid"
	],
	[
		[
			1262,
			1262
		],
		"mapped",
		[
			1263
		]
	],
	[
		[
			1263,
			1263
		],
		"valid"
	],
	[
		[
			1264,
			1264
		],
		"mapped",
		[
			1265
		]
	],
	[
		[
			1265,
			1265
		],
		"valid"
	],
	[
		[
			1266,
			1266
		],
		"mapped",
		[
			1267
		]
	],
	[
		[
			1267,
			1267
		],
		"valid"
	],
	[
		[
			1268,
			1268
		],
		"mapped",
		[
			1269
		]
	],
	[
		[
			1269,
			1269
		],
		"valid"
	],
	[
		[
			1270,
			1270
		],
		"mapped",
		[
			1271
		]
	],
	[
		[
			1271,
			1271
		],
		"valid"
	],
	[
		[
			1272,
			1272
		],
		"mapped",
		[
			1273
		]
	],
	[
		[
			1273,
			1273
		],
		"valid"
	],
	[
		[
			1274,
			1274
		],
		"mapped",
		[
			1275
		]
	],
	[
		[
			1275,
			1275
		],
		"valid"
	],
	[
		[
			1276,
			1276
		],
		"mapped",
		[
			1277
		]
	],
	[
		[
			1277,
			1277
		],
		"valid"
	],
	[
		[
			1278,
			1278
		],
		"mapped",
		[
			1279
		]
	],
	[
		[
			1279,
			1279
		],
		"valid"
	],
	[
		[
			1280,
			1280
		],
		"mapped",
		[
			1281
		]
	],
	[
		[
			1281,
			1281
		],
		"valid"
	],
	[
		[
			1282,
			1282
		],
		"mapped",
		[
			1283
		]
	],
	[
		[
			1283,
			1283
		],
		"valid"
	],
	[
		[
			1284,
			1284
		],
		"mapped",
		[
			1285
		]
	],
	[
		[
			1285,
			1285
		],
		"valid"
	],
	[
		[
			1286,
			1286
		],
		"mapped",
		[
			1287
		]
	],
	[
		[
			1287,
			1287
		],
		"valid"
	],
	[
		[
			1288,
			1288
		],
		"mapped",
		[
			1289
		]
	],
	[
		[
			1289,
			1289
		],
		"valid"
	],
	[
		[
			1290,
			1290
		],
		"mapped",
		[
			1291
		]
	],
	[
		[
			1291,
			1291
		],
		"valid"
	],
	[
		[
			1292,
			1292
		],
		"mapped",
		[
			1293
		]
	],
	[
		[
			1293,
			1293
		],
		"valid"
	],
	[
		[
			1294,
			1294
		],
		"mapped",
		[
			1295
		]
	],
	[
		[
			1295,
			1295
		],
		"valid"
	],
	[
		[
			1296,
			1296
		],
		"mapped",
		[
			1297
		]
	],
	[
		[
			1297,
			1297
		],
		"valid"
	],
	[
		[
			1298,
			1298
		],
		"mapped",
		[
			1299
		]
	],
	[
		[
			1299,
			1299
		],
		"valid"
	],
	[
		[
			1300,
			1300
		],
		"mapped",
		[
			1301
		]
	],
	[
		[
			1301,
			1301
		],
		"valid"
	],
	[
		[
			1302,
			1302
		],
		"mapped",
		[
			1303
		]
	],
	[
		[
			1303,
			1303
		],
		"valid"
	],
	[
		[
			1304,
			1304
		],
		"mapped",
		[
			1305
		]
	],
	[
		[
			1305,
			1305
		],
		"valid"
	],
	[
		[
			1306,
			1306
		],
		"mapped",
		[
			1307
		]
	],
	[
		[
			1307,
			1307
		],
		"valid"
	],
	[
		[
			1308,
			1308
		],
		"mapped",
		[
			1309
		]
	],
	[
		[
			1309,
			1309
		],
		"valid"
	],
	[
		[
			1310,
			1310
		],
		"mapped",
		[
			1311
		]
	],
	[
		[
			1311,
			1311
		],
		"valid"
	],
	[
		[
			1312,
			1312
		],
		"mapped",
		[
			1313
		]
	],
	[
		[
			1313,
			1313
		],
		"valid"
	],
	[
		[
			1314,
			1314
		],
		"mapped",
		[
			1315
		]
	],
	[
		[
			1315,
			1315
		],
		"valid"
	],
	[
		[
			1316,
			1316
		],
		"mapped",
		[
			1317
		]
	],
	[
		[
			1317,
			1317
		],
		"valid"
	],
	[
		[
			1318,
			1318
		],
		"mapped",
		[
			1319
		]
	],
	[
		[
			1319,
			1319
		],
		"valid"
	],
	[
		[
			1320,
			1320
		],
		"mapped",
		[
			1321
		]
	],
	[
		[
			1321,
			1321
		],
		"valid"
	],
	[
		[
			1322,
			1322
		],
		"mapped",
		[
			1323
		]
	],
	[
		[
			1323,
			1323
		],
		"valid"
	],
	[
		[
			1324,
			1324
		],
		"mapped",
		[
			1325
		]
	],
	[
		[
			1325,
			1325
		],
		"valid"
	],
	[
		[
			1326,
			1326
		],
		"mapped",
		[
			1327
		]
	],
	[
		[
			1327,
			1327
		],
		"valid"
	],
	[
		[
			1328,
			1328
		],
		"disallowed"
	],
	[
		[
			1329,
			1329
		],
		"mapped",
		[
			1377
		]
	],
	[
		[
			1330,
			1330
		],
		"mapped",
		[
			1378
		]
	],
	[
		[
			1331,
			1331
		],
		"mapped",
		[
			1379
		]
	],
	[
		[
			1332,
			1332
		],
		"mapped",
		[
			1380
		]
	],
	[
		[
			1333,
			1333
		],
		"mapped",
		[
			1381
		]
	],
	[
		[
			1334,
			1334
		],
		"mapped",
		[
			1382
		]
	],
	[
		[
			1335,
			1335
		],
		"mapped",
		[
			1383
		]
	],
	[
		[
			1336,
			1336
		],
		"mapped",
		[
			1384
		]
	],
	[
		[
			1337,
			1337
		],
		"mapped",
		[
			1385
		]
	],
	[
		[
			1338,
			1338
		],
		"mapped",
		[
			1386
		]
	],
	[
		[
			1339,
			1339
		],
		"mapped",
		[
			1387
		]
	],
	[
		[
			1340,
			1340
		],
		"mapped",
		[
			1388
		]
	],
	[
		[
			1341,
			1341
		],
		"mapped",
		[
			1389
		]
	],
	[
		[
			1342,
			1342
		],
		"mapped",
		[
			1390
		]
	],
	[
		[
			1343,
			1343
		],
		"mapped",
		[
			1391
		]
	],
	[
		[
			1344,
			1344
		],
		"mapped",
		[
			1392
		]
	],
	[
		[
			1345,
			1345
		],
		"mapped",
		[
			1393
		]
	],
	[
		[
			1346,
			1346
		],
		"mapped",
		[
			1394
		]
	],
	[
		[
			1347,
			1347
		],
		"mapped",
		[
			1395
		]
	],
	[
		[
			1348,
			1348
		],
		"mapped",
		[
			1396
		]
	],
	[
		[
			1349,
			1349
		],
		"mapped",
		[
			1397
		]
	],
	[
		[
			1350,
			1350
		],
		"mapped",
		[
			1398
		]
	],
	[
		[
			1351,
			1351
		],
		"mapped",
		[
			1399
		]
	],
	[
		[
			1352,
			1352
		],
		"mapped",
		[
			1400
		]
	],
	[
		[
			1353,
			1353
		],
		"mapped",
		[
			1401
		]
	],
	[
		[
			1354,
			1354
		],
		"mapped",
		[
			1402
		]
	],
	[
		[
			1355,
			1355
		],
		"mapped",
		[
			1403
		]
	],
	[
		[
			1356,
			1356
		],
		"mapped",
		[
			1404
		]
	],
	[
		[
			1357,
			1357
		],
		"mapped",
		[
			1405
		]
	],
	[
		[
			1358,
			1358
		],
		"mapped",
		[
			1406
		]
	],
	[
		[
			1359,
			1359
		],
		"mapped",
		[
			1407
		]
	],
	[
		[
			1360,
			1360
		],
		"mapped",
		[
			1408
		]
	],
	[
		[
			1361,
			1361
		],
		"mapped",
		[
			1409
		]
	],
	[
		[
			1362,
			1362
		],
		"mapped",
		[
			1410
		]
	],
	[
		[
			1363,
			1363
		],
		"mapped",
		[
			1411
		]
	],
	[
		[
			1364,
			1364
		],
		"mapped",
		[
			1412
		]
	],
	[
		[
			1365,
			1365
		],
		"mapped",
		[
			1413
		]
	],
	[
		[
			1366,
			1366
		],
		"mapped",
		[
			1414
		]
	],
	[
		[
			1367,
			1368
		],
		"disallowed"
	],
	[
		[
			1369,
			1369
		],
		"valid"
	],
	[
		[
			1370,
			1375
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			1376,
			1376
		],
		"disallowed"
	],
	[
		[
			1377,
			1414
		],
		"valid"
	],
	[
		[
			1415,
			1415
		],
		"mapped",
		[
			1381,
			1410
		]
	],
	[
		[
			1416,
			1416
		],
		"disallowed"
	],
	[
		[
			1417,
			1417
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			1418,
			1418
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			1419,
			1420
		],
		"disallowed"
	],
	[
		[
			1421,
			1422
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			1423,
			1423
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			1424,
			1424
		],
		"disallowed"
	],
	[
		[
			1425,
			1441
		],
		"valid"
	],
	[
		[
			1442,
			1442
		],
		"valid"
	],
	[
		[
			1443,
			1455
		],
		"valid"
	],
	[
		[
			1456,
			1465
		],
		"valid"
	],
	[
		[
			1466,
			1466
		],
		"valid"
	],
	[
		[
			1467,
			1469
		],
		"valid"
	],
	[
		[
			1470,
			1470
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			1471,
			1471
		],
		"valid"
	],
	[
		[
			1472,
			1472
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			1473,
			1474
		],
		"valid"
	],
	[
		[
			1475,
			1475
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			1476,
			1476
		],
		"valid"
	],
	[
		[
			1477,
			1477
		],
		"valid"
	],
	[
		[
			1478,
			1478
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			1479,
			1479
		],
		"valid"
	],
	[
		[
			1480,
			1487
		],
		"disallowed"
	],
	[
		[
			1488,
			1514
		],
		"valid"
	],
	[
		[
			1515,
			1519
		],
		"disallowed"
	],
	[
		[
			1520,
			1524
		],
		"valid"
	],
	[
		[
			1525,
			1535
		],
		"disallowed"
	],
	[
		[
			1536,
			1539
		],
		"disallowed"
	],
	[
		[
			1540,
			1540
		],
		"disallowed"
	],
	[
		[
			1541,
			1541
		],
		"disallowed"
	],
	[
		[
			1542,
			1546
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			1547,
			1547
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			1548,
			1548
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			1549,
			1551
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			1552,
			1557
		],
		"valid"
	],
	[
		[
			1558,
			1562
		],
		"valid"
	],
	[
		[
			1563,
			1563
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			1564,
			1564
		],
		"disallowed"
	],
	[
		[
			1565,
			1565
		],
		"disallowed"
	],
	[
		[
			1566,
			1566
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			1567,
			1567
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			1568,
			1568
		],
		"valid"
	],
	[
		[
			1569,
			1594
		],
		"valid"
	],
	[
		[
			1595,
			1599
		],
		"valid"
	],
	[
		[
			1600,
			1600
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			1601,
			1618
		],
		"valid"
	],
	[
		[
			1619,
			1621
		],
		"valid"
	],
	[
		[
			1622,
			1624
		],
		"valid"
	],
	[
		[
			1625,
			1630
		],
		"valid"
	],
	[
		[
			1631,
			1631
		],
		"valid"
	],
	[
		[
			1632,
			1641
		],
		"valid"
	],
	[
		[
			1642,
			1645
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			1646,
			1647
		],
		"valid"
	],
	[
		[
			1648,
			1652
		],
		"valid"
	],
	[
		[
			1653,
			1653
		],
		"mapped",
		[
			1575,
			1652
		]
	],
	[
		[
			1654,
			1654
		],
		"mapped",
		[
			1608,
			1652
		]
	],
	[
		[
			1655,
			1655
		],
		"mapped",
		[
			1735,
			1652
		]
	],
	[
		[
			1656,
			1656
		],
		"mapped",
		[
			1610,
			1652
		]
	],
	[
		[
			1657,
			1719
		],
		"valid"
	],
	[
		[
			1720,
			1721
		],
		"valid"
	],
	[
		[
			1722,
			1726
		],
		"valid"
	],
	[
		[
			1727,
			1727
		],
		"valid"
	],
	[
		[
			1728,
			1742
		],
		"valid"
	],
	[
		[
			1743,
			1743
		],
		"valid"
	],
	[
		[
			1744,
			1747
		],
		"valid"
	],
	[
		[
			1748,
			1748
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			1749,
			1756
		],
		"valid"
	],
	[
		[
			1757,
			1757
		],
		"disallowed"
	],
	[
		[
			1758,
			1758
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			1759,
			1768
		],
		"valid"
	],
	[
		[
			1769,
			1769
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			1770,
			1773
		],
		"valid"
	],
	[
		[
			1774,
			1775
		],
		"valid"
	],
	[
		[
			1776,
			1785
		],
		"valid"
	],
	[
		[
			1786,
			1790
		],
		"valid"
	],
	[
		[
			1791,
			1791
		],
		"valid"
	],
	[
		[
			1792,
			1805
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			1806,
			1806
		],
		"disallowed"
	],
	[
		[
			1807,
			1807
		],
		"disallowed"
	],
	[
		[
			1808,
			1836
		],
		"valid"
	],
	[
		[
			1837,
			1839
		],
		"valid"
	],
	[
		[
			1840,
			1866
		],
		"valid"
	],
	[
		[
			1867,
			1868
		],
		"disallowed"
	],
	[
		[
			1869,
			1871
		],
		"valid"
	],
	[
		[
			1872,
			1901
		],
		"valid"
	],
	[
		[
			1902,
			1919
		],
		"valid"
	],
	[
		[
			1920,
			1968
		],
		"valid"
	],
	[
		[
			1969,
			1969
		],
		"valid"
	],
	[
		[
			1970,
			1983
		],
		"disallowed"
	],
	[
		[
			1984,
			2037
		],
		"valid"
	],
	[
		[
			2038,
			2042
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			2043,
			2047
		],
		"disallowed"
	],
	[
		[
			2048,
			2093
		],
		"valid"
	],
	[
		[
			2094,
			2095
		],
		"disallowed"
	],
	[
		[
			2096,
			2110
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			2111,
			2111
		],
		"disallowed"
	],
	[
		[
			2112,
			2139
		],
		"valid"
	],
	[
		[
			2140,
			2141
		],
		"disallowed"
	],
	[
		[
			2142,
			2142
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			2143,
			2207
		],
		"disallowed"
	],
	[
		[
			2208,
			2208
		],
		"valid"
	],
	[
		[
			2209,
			2209
		],
		"valid"
	],
	[
		[
			2210,
			2220
		],
		"valid"
	],
	[
		[
			2221,
			2226
		],
		"valid"
	],
	[
		[
			2227,
			2228
		],
		"valid"
	],
	[
		[
			2229,
			2274
		],
		"disallowed"
	],
	[
		[
			2275,
			2275
		],
		"valid"
	],
	[
		[
			2276,
			2302
		],
		"valid"
	],
	[
		[
			2303,
			2303
		],
		"valid"
	],
	[
		[
			2304,
			2304
		],
		"valid"
	],
	[
		[
			2305,
			2307
		],
		"valid"
	],
	[
		[
			2308,
			2308
		],
		"valid"
	],
	[
		[
			2309,
			2361
		],
		"valid"
	],
	[
		[
			2362,
			2363
		],
		"valid"
	],
	[
		[
			2364,
			2381
		],
		"valid"
	],
	[
		[
			2382,
			2382
		],
		"valid"
	],
	[
		[
			2383,
			2383
		],
		"valid"
	],
	[
		[
			2384,
			2388
		],
		"valid"
	],
	[
		[
			2389,
			2389
		],
		"valid"
	],
	[
		[
			2390,
			2391
		],
		"valid"
	],
	[
		[
			2392,
			2392
		],
		"mapped",
		[
			2325,
			2364
		]
	],
	[
		[
			2393,
			2393
		],
		"mapped",
		[
			2326,
			2364
		]
	],
	[
		[
			2394,
			2394
		],
		"mapped",
		[
			2327,
			2364
		]
	],
	[
		[
			2395,
			2395
		],
		"mapped",
		[
			2332,
			2364
		]
	],
	[
		[
			2396,
			2396
		],
		"mapped",
		[
			2337,
			2364
		]
	],
	[
		[
			2397,
			2397
		],
		"mapped",
		[
			2338,
			2364
		]
	],
	[
		[
			2398,
			2398
		],
		"mapped",
		[
			2347,
			2364
		]
	],
	[
		[
			2399,
			2399
		],
		"mapped",
		[
			2351,
			2364
		]
	],
	[
		[
			2400,
			2403
		],
		"valid"
	],
	[
		[
			2404,
			2405
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			2406,
			2415
		],
		"valid"
	],
	[
		[
			2416,
			2416
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			2417,
			2418
		],
		"valid"
	],
	[
		[
			2419,
			2423
		],
		"valid"
	],
	[
		[
			2424,
			2424
		],
		"valid"
	],
	[
		[
			2425,
			2426
		],
		"valid"
	],
	[
		[
			2427,
			2428
		],
		"valid"
	],
	[
		[
			2429,
			2429
		],
		"valid"
	],
	[
		[
			2430,
			2431
		],
		"valid"
	],
	[
		[
			2432,
			2432
		],
		"valid"
	],
	[
		[
			2433,
			2435
		],
		"valid"
	],
	[
		[
			2436,
			2436
		],
		"disallowed"
	],
	[
		[
			2437,
			2444
		],
		"valid"
	],
	[
		[
			2445,
			2446
		],
		"disallowed"
	],
	[
		[
			2447,
			2448
		],
		"valid"
	],
	[
		[
			2449,
			2450
		],
		"disallowed"
	],
	[
		[
			2451,
			2472
		],
		"valid"
	],
	[
		[
			2473,
			2473
		],
		"disallowed"
	],
	[
		[
			2474,
			2480
		],
		"valid"
	],
	[
		[
			2481,
			2481
		],
		"disallowed"
	],
	[
		[
			2482,
			2482
		],
		"valid"
	],
	[
		[
			2483,
			2485
		],
		"disallowed"
	],
	[
		[
			2486,
			2489
		],
		"valid"
	],
	[
		[
			2490,
			2491
		],
		"disallowed"
	],
	[
		[
			2492,
			2492
		],
		"valid"
	],
	[
		[
			2493,
			2493
		],
		"valid"
	],
	[
		[
			2494,
			2500
		],
		"valid"
	],
	[
		[
			2501,
			2502
		],
		"disallowed"
	],
	[
		[
			2503,
			2504
		],
		"valid"
	],
	[
		[
			2505,
			2506
		],
		"disallowed"
	],
	[
		[
			2507,
			2509
		],
		"valid"
	],
	[
		[
			2510,
			2510
		],
		"valid"
	],
	[
		[
			2511,
			2518
		],
		"disallowed"
	],
	[
		[
			2519,
			2519
		],
		"valid"
	],
	[
		[
			2520,
			2523
		],
		"disallowed"
	],
	[
		[
			2524,
			2524
		],
		"mapped",
		[
			2465,
			2492
		]
	],
	[
		[
			2525,
			2525
		],
		"mapped",
		[
			2466,
			2492
		]
	],
	[
		[
			2526,
			2526
		],
		"disallowed"
	],
	[
		[
			2527,
			2527
		],
		"mapped",
		[
			2479,
			2492
		]
	],
	[
		[
			2528,
			2531
		],
		"valid"
	],
	[
		[
			2532,
			2533
		],
		"disallowed"
	],
	[
		[
			2534,
			2545
		],
		"valid"
	],
	[
		[
			2546,
			2554
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			2555,
			2555
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			2556,
			2560
		],
		"disallowed"
	],
	[
		[
			2561,
			2561
		],
		"valid"
	],
	[
		[
			2562,
			2562
		],
		"valid"
	],
	[
		[
			2563,
			2563
		],
		"valid"
	],
	[
		[
			2564,
			2564
		],
		"disallowed"
	],
	[
		[
			2565,
			2570
		],
		"valid"
	],
	[
		[
			2571,
			2574
		],
		"disallowed"
	],
	[
		[
			2575,
			2576
		],
		"valid"
	],
	[
		[
			2577,
			2578
		],
		"disallowed"
	],
	[
		[
			2579,
			2600
		],
		"valid"
	],
	[
		[
			2601,
			2601
		],
		"disallowed"
	],
	[
		[
			2602,
			2608
		],
		"valid"
	],
	[
		[
			2609,
			2609
		],
		"disallowed"
	],
	[
		[
			2610,
			2610
		],
		"valid"
	],
	[
		[
			2611,
			2611
		],
		"mapped",
		[
			2610,
			2620
		]
	],
	[
		[
			2612,
			2612
		],
		"disallowed"
	],
	[
		[
			2613,
			2613
		],
		"valid"
	],
	[
		[
			2614,
			2614
		],
		"mapped",
		[
			2616,
			2620
		]
	],
	[
		[
			2615,
			2615
		],
		"disallowed"
	],
	[
		[
			2616,
			2617
		],
		"valid"
	],
	[
		[
			2618,
			2619
		],
		"disallowed"
	],
	[
		[
			2620,
			2620
		],
		"valid"
	],
	[
		[
			2621,
			2621
		],
		"disallowed"
	],
	[
		[
			2622,
			2626
		],
		"valid"
	],
	[
		[
			2627,
			2630
		],
		"disallowed"
	],
	[
		[
			2631,
			2632
		],
		"valid"
	],
	[
		[
			2633,
			2634
		],
		"disallowed"
	],
	[
		[
			2635,
			2637
		],
		"valid"
	],
	[
		[
			2638,
			2640
		],
		"disallowed"
	],
	[
		[
			2641,
			2641
		],
		"valid"
	],
	[
		[
			2642,
			2648
		],
		"disallowed"
	],
	[
		[
			2649,
			2649
		],
		"mapped",
		[
			2582,
			2620
		]
	],
	[
		[
			2650,
			2650
		],
		"mapped",
		[
			2583,
			2620
		]
	],
	[
		[
			2651,
			2651
		],
		"mapped",
		[
			2588,
			2620
		]
	],
	[
		[
			2652,
			2652
		],
		"valid"
	],
	[
		[
			2653,
			2653
		],
		"disallowed"
	],
	[
		[
			2654,
			2654
		],
		"mapped",
		[
			2603,
			2620
		]
	],
	[
		[
			2655,
			2661
		],
		"disallowed"
	],
	[
		[
			2662,
			2676
		],
		"valid"
	],
	[
		[
			2677,
			2677
		],
		"valid"
	],
	[
		[
			2678,
			2688
		],
		"disallowed"
	],
	[
		[
			2689,
			2691
		],
		"valid"
	],
	[
		[
			2692,
			2692
		],
		"disallowed"
	],
	[
		[
			2693,
			2699
		],
		"valid"
	],
	[
		[
			2700,
			2700
		],
		"valid"
	],
	[
		[
			2701,
			2701
		],
		"valid"
	],
	[
		[
			2702,
			2702
		],
		"disallowed"
	],
	[
		[
			2703,
			2705
		],
		"valid"
	],
	[
		[
			2706,
			2706
		],
		"disallowed"
	],
	[
		[
			2707,
			2728
		],
		"valid"
	],
	[
		[
			2729,
			2729
		],
		"disallowed"
	],
	[
		[
			2730,
			2736
		],
		"valid"
	],
	[
		[
			2737,
			2737
		],
		"disallowed"
	],
	[
		[
			2738,
			2739
		],
		"valid"
	],
	[
		[
			2740,
			2740
		],
		"disallowed"
	],
	[
		[
			2741,
			2745
		],
		"valid"
	],
	[
		[
			2746,
			2747
		],
		"disallowed"
	],
	[
		[
			2748,
			2757
		],
		"valid"
	],
	[
		[
			2758,
			2758
		],
		"disallowed"
	],
	[
		[
			2759,
			2761
		],
		"valid"
	],
	[
		[
			2762,
			2762
		],
		"disallowed"
	],
	[
		[
			2763,
			2765
		],
		"valid"
	],
	[
		[
			2766,
			2767
		],
		"disallowed"
	],
	[
		[
			2768,
			2768
		],
		"valid"
	],
	[
		[
			2769,
			2783
		],
		"disallowed"
	],
	[
		[
			2784,
			2784
		],
		"valid"
	],
	[
		[
			2785,
			2787
		],
		"valid"
	],
	[
		[
			2788,
			2789
		],
		"disallowed"
	],
	[
		[
			2790,
			2799
		],
		"valid"
	],
	[
		[
			2800,
			2800
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			2801,
			2801
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			2802,
			2808
		],
		"disallowed"
	],
	[
		[
			2809,
			2809
		],
		"valid"
	],
	[
		[
			2810,
			2816
		],
		"disallowed"
	],
	[
		[
			2817,
			2819
		],
		"valid"
	],
	[
		[
			2820,
			2820
		],
		"disallowed"
	],
	[
		[
			2821,
			2828
		],
		"valid"
	],
	[
		[
			2829,
			2830
		],
		"disallowed"
	],
	[
		[
			2831,
			2832
		],
		"valid"
	],
	[
		[
			2833,
			2834
		],
		"disallowed"
	],
	[
		[
			2835,
			2856
		],
		"valid"
	],
	[
		[
			2857,
			2857
		],
		"disallowed"
	],
	[
		[
			2858,
			2864
		],
		"valid"
	],
	[
		[
			2865,
			2865
		],
		"disallowed"
	],
	[
		[
			2866,
			2867
		],
		"valid"
	],
	[
		[
			2868,
			2868
		],
		"disallowed"
	],
	[
		[
			2869,
			2869
		],
		"valid"
	],
	[
		[
			2870,
			2873
		],
		"valid"
	],
	[
		[
			2874,
			2875
		],
		"disallowed"
	],
	[
		[
			2876,
			2883
		],
		"valid"
	],
	[
		[
			2884,
			2884
		],
		"valid"
	],
	[
		[
			2885,
			2886
		],
		"disallowed"
	],
	[
		[
			2887,
			2888
		],
		"valid"
	],
	[
		[
			2889,
			2890
		],
		"disallowed"
	],
	[
		[
			2891,
			2893
		],
		"valid"
	],
	[
		[
			2894,
			2901
		],
		"disallowed"
	],
	[
		[
			2902,
			2903
		],
		"valid"
	],
	[
		[
			2904,
			2907
		],
		"disallowed"
	],
	[
		[
			2908,
			2908
		],
		"mapped",
		[
			2849,
			2876
		]
	],
	[
		[
			2909,
			2909
		],
		"mapped",
		[
			2850,
			2876
		]
	],
	[
		[
			2910,
			2910
		],
		"disallowed"
	],
	[
		[
			2911,
			2913
		],
		"valid"
	],
	[
		[
			2914,
			2915
		],
		"valid"
	],
	[
		[
			2916,
			2917
		],
		"disallowed"
	],
	[
		[
			2918,
			2927
		],
		"valid"
	],
	[
		[
			2928,
			2928
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			2929,
			2929
		],
		"valid"
	],
	[
		[
			2930,
			2935
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			2936,
			2945
		],
		"disallowed"
	],
	[
		[
			2946,
			2947
		],
		"valid"
	],
	[
		[
			2948,
			2948
		],
		"disallowed"
	],
	[
		[
			2949,
			2954
		],
		"valid"
	],
	[
		[
			2955,
			2957
		],
		"disallowed"
	],
	[
		[
			2958,
			2960
		],
		"valid"
	],
	[
		[
			2961,
			2961
		],
		"disallowed"
	],
	[
		[
			2962,
			2965
		],
		"valid"
	],
	[
		[
			2966,
			2968
		],
		"disallowed"
	],
	[
		[
			2969,
			2970
		],
		"valid"
	],
	[
		[
			2971,
			2971
		],
		"disallowed"
	],
	[
		[
			2972,
			2972
		],
		"valid"
	],
	[
		[
			2973,
			2973
		],
		"disallowed"
	],
	[
		[
			2974,
			2975
		],
		"valid"
	],
	[
		[
			2976,
			2978
		],
		"disallowed"
	],
	[
		[
			2979,
			2980
		],
		"valid"
	],
	[
		[
			2981,
			2983
		],
		"disallowed"
	],
	[
		[
			2984,
			2986
		],
		"valid"
	],
	[
		[
			2987,
			2989
		],
		"disallowed"
	],
	[
		[
			2990,
			2997
		],
		"valid"
	],
	[
		[
			2998,
			2998
		],
		"valid"
	],
	[
		[
			2999,
			3001
		],
		"valid"
	],
	[
		[
			3002,
			3005
		],
		"disallowed"
	],
	[
		[
			3006,
			3010
		],
		"valid"
	],
	[
		[
			3011,
			3013
		],
		"disallowed"
	],
	[
		[
			3014,
			3016
		],
		"valid"
	],
	[
		[
			3017,
			3017
		],
		"disallowed"
	],
	[
		[
			3018,
			3021
		],
		"valid"
	],
	[
		[
			3022,
			3023
		],
		"disallowed"
	],
	[
		[
			3024,
			3024
		],
		"valid"
	],
	[
		[
			3025,
			3030
		],
		"disallowed"
	],
	[
		[
			3031,
			3031
		],
		"valid"
	],
	[
		[
			3032,
			3045
		],
		"disallowed"
	],
	[
		[
			3046,
			3046
		],
		"valid"
	],
	[
		[
			3047,
			3055
		],
		"valid"
	],
	[
		[
			3056,
			3058
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			3059,
			3066
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			3067,
			3071
		],
		"disallowed"
	],
	[
		[
			3072,
			3072
		],
		"valid"
	],
	[
		[
			3073,
			3075
		],
		"valid"
	],
	[
		[
			3076,
			3076
		],
		"disallowed"
	],
	[
		[
			3077,
			3084
		],
		"valid"
	],
	[
		[
			3085,
			3085
		],
		"disallowed"
	],
	[
		[
			3086,
			3088
		],
		"valid"
	],
	[
		[
			3089,
			3089
		],
		"disallowed"
	],
	[
		[
			3090,
			3112
		],
		"valid"
	],
	[
		[
			3113,
			3113
		],
		"disallowed"
	],
	[
		[
			3114,
			3123
		],
		"valid"
	],
	[
		[
			3124,
			3124
		],
		"valid"
	],
	[
		[
			3125,
			3129
		],
		"valid"
	],
	[
		[
			3130,
			3132
		],
		"disallowed"
	],
	[
		[
			3133,
			3133
		],
		"valid"
	],
	[
		[
			3134,
			3140
		],
		"valid"
	],
	[
		[
			3141,
			3141
		],
		"disallowed"
	],
	[
		[
			3142,
			3144
		],
		"valid"
	],
	[
		[
			3145,
			3145
		],
		"disallowed"
	],
	[
		[
			3146,
			3149
		],
		"valid"
	],
	[
		[
			3150,
			3156
		],
		"disallowed"
	],
	[
		[
			3157,
			3158
		],
		"valid"
	],
	[
		[
			3159,
			3159
		],
		"disallowed"
	],
	[
		[
			3160,
			3161
		],
		"valid"
	],
	[
		[
			3162,
			3162
		],
		"valid"
	],
	[
		[
			3163,
			3167
		],
		"disallowed"
	],
	[
		[
			3168,
			3169
		],
		"valid"
	],
	[
		[
			3170,
			3171
		],
		"valid"
	],
	[
		[
			3172,
			3173
		],
		"disallowed"
	],
	[
		[
			3174,
			3183
		],
		"valid"
	],
	[
		[
			3184,
			3191
		],
		"disallowed"
	],
	[
		[
			3192,
			3199
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			3200,
			3200
		],
		"disallowed"
	],
	[
		[
			3201,
			3201
		],
		"valid"
	],
	[
		[
			3202,
			3203
		],
		"valid"
	],
	[
		[
			3204,
			3204
		],
		"disallowed"
	],
	[
		[
			3205,
			3212
		],
		"valid"
	],
	[
		[
			3213,
			3213
		],
		"disallowed"
	],
	[
		[
			3214,
			3216
		],
		"valid"
	],
	[
		[
			3217,
			3217
		],
		"disallowed"
	],
	[
		[
			3218,
			3240
		],
		"valid"
	],
	[
		[
			3241,
			3241
		],
		"disallowed"
	],
	[
		[
			3242,
			3251
		],
		"valid"
	],
	[
		[
			3252,
			3252
		],
		"disallowed"
	],
	[
		[
			3253,
			3257
		],
		"valid"
	],
	[
		[
			3258,
			3259
		],
		"disallowed"
	],
	[
		[
			3260,
			3261
		],
		"valid"
	],
	[
		[
			3262,
			3268
		],
		"valid"
	],
	[
		[
			3269,
			3269
		],
		"disallowed"
	],
	[
		[
			3270,
			3272
		],
		"valid"
	],
	[
		[
			3273,
			3273
		],
		"disallowed"
	],
	[
		[
			3274,
			3277
		],
		"valid"
	],
	[
		[
			3278,
			3284
		],
		"disallowed"
	],
	[
		[
			3285,
			3286
		],
		"valid"
	],
	[
		[
			3287,
			3293
		],
		"disallowed"
	],
	[
		[
			3294,
			3294
		],
		"valid"
	],
	[
		[
			3295,
			3295
		],
		"disallowed"
	],
	[
		[
			3296,
			3297
		],
		"valid"
	],
	[
		[
			3298,
			3299
		],
		"valid"
	],
	[
		[
			3300,
			3301
		],
		"disallowed"
	],
	[
		[
			3302,
			3311
		],
		"valid"
	],
	[
		[
			3312,
			3312
		],
		"disallowed"
	],
	[
		[
			3313,
			3314
		],
		"valid"
	],
	[
		[
			3315,
			3328
		],
		"disallowed"
	],
	[
		[
			3329,
			3329
		],
		"valid"
	],
	[
		[
			3330,
			3331
		],
		"valid"
	],
	[
		[
			3332,
			3332
		],
		"disallowed"
	],
	[
		[
			3333,
			3340
		],
		"valid"
	],
	[
		[
			3341,
			3341
		],
		"disallowed"
	],
	[
		[
			3342,
			3344
		],
		"valid"
	],
	[
		[
			3345,
			3345
		],
		"disallowed"
	],
	[
		[
			3346,
			3368
		],
		"valid"
	],
	[
		[
			3369,
			3369
		],
		"valid"
	],
	[
		[
			3370,
			3385
		],
		"valid"
	],
	[
		[
			3386,
			3386
		],
		"valid"
	],
	[
		[
			3387,
			3388
		],
		"disallowed"
	],
	[
		[
			3389,
			3389
		],
		"valid"
	],
	[
		[
			3390,
			3395
		],
		"valid"
	],
	[
		[
			3396,
			3396
		],
		"valid"
	],
	[
		[
			3397,
			3397
		],
		"disallowed"
	],
	[
		[
			3398,
			3400
		],
		"valid"
	],
	[
		[
			3401,
			3401
		],
		"disallowed"
	],
	[
		[
			3402,
			3405
		],
		"valid"
	],
	[
		[
			3406,
			3406
		],
		"valid"
	],
	[
		[
			3407,
			3414
		],
		"disallowed"
	],
	[
		[
			3415,
			3415
		],
		"valid"
	],
	[
		[
			3416,
			3422
		],
		"disallowed"
	],
	[
		[
			3423,
			3423
		],
		"valid"
	],
	[
		[
			3424,
			3425
		],
		"valid"
	],
	[
		[
			3426,
			3427
		],
		"valid"
	],
	[
		[
			3428,
			3429
		],
		"disallowed"
	],
	[
		[
			3430,
			3439
		],
		"valid"
	],
	[
		[
			3440,
			3445
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			3446,
			3448
		],
		"disallowed"
	],
	[
		[
			3449,
			3449
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			3450,
			3455
		],
		"valid"
	],
	[
		[
			3456,
			3457
		],
		"disallowed"
	],
	[
		[
			3458,
			3459
		],
		"valid"
	],
	[
		[
			3460,
			3460
		],
		"disallowed"
	],
	[
		[
			3461,
			3478
		],
		"valid"
	],
	[
		[
			3479,
			3481
		],
		"disallowed"
	],
	[
		[
			3482,
			3505
		],
		"valid"
	],
	[
		[
			3506,
			3506
		],
		"disallowed"
	],
	[
		[
			3507,
			3515
		],
		"valid"
	],
	[
		[
			3516,
			3516
		],
		"disallowed"
	],
	[
		[
			3517,
			3517
		],
		"valid"
	],
	[
		[
			3518,
			3519
		],
		"disallowed"
	],
	[
		[
			3520,
			3526
		],
		"valid"
	],
	[
		[
			3527,
			3529
		],
		"disallowed"
	],
	[
		[
			3530,
			3530
		],
		"valid"
	],
	[
		[
			3531,
			3534
		],
		"disallowed"
	],
	[
		[
			3535,
			3540
		],
		"valid"
	],
	[
		[
			3541,
			3541
		],
		"disallowed"
	],
	[
		[
			3542,
			3542
		],
		"valid"
	],
	[
		[
			3543,
			3543
		],
		"disallowed"
	],
	[
		[
			3544,
			3551
		],
		"valid"
	],
	[
		[
			3552,
			3557
		],
		"disallowed"
	],
	[
		[
			3558,
			3567
		],
		"valid"
	],
	[
		[
			3568,
			3569
		],
		"disallowed"
	],
	[
		[
			3570,
			3571
		],
		"valid"
	],
	[
		[
			3572,
			3572
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			3573,
			3584
		],
		"disallowed"
	],
	[
		[
			3585,
			3634
		],
		"valid"
	],
	[
		[
			3635,
			3635
		],
		"mapped",
		[
			3661,
			3634
		]
	],
	[
		[
			3636,
			3642
		],
		"valid"
	],
	[
		[
			3643,
			3646
		],
		"disallowed"
	],
	[
		[
			3647,
			3647
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			3648,
			3662
		],
		"valid"
	],
	[
		[
			3663,
			3663
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			3664,
			3673
		],
		"valid"
	],
	[
		[
			3674,
			3675
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			3676,
			3712
		],
		"disallowed"
	],
	[
		[
			3713,
			3714
		],
		"valid"
	],
	[
		[
			3715,
			3715
		],
		"disallowed"
	],
	[
		[
			3716,
			3716
		],
		"valid"
	],
	[
		[
			3717,
			3718
		],
		"disallowed"
	],
	[
		[
			3719,
			3720
		],
		"valid"
	],
	[
		[
			3721,
			3721
		],
		"disallowed"
	],
	[
		[
			3722,
			3722
		],
		"valid"
	],
	[
		[
			3723,
			3724
		],
		"disallowed"
	],
	[
		[
			3725,
			3725
		],
		"valid"
	],
	[
		[
			3726,
			3731
		],
		"disallowed"
	],
	[
		[
			3732,
			3735
		],
		"valid"
	],
	[
		[
			3736,
			3736
		],
		"disallowed"
	],
	[
		[
			3737,
			3743
		],
		"valid"
	],
	[
		[
			3744,
			3744
		],
		"disallowed"
	],
	[
		[
			3745,
			3747
		],
		"valid"
	],
	[
		[
			3748,
			3748
		],
		"disallowed"
	],
	[
		[
			3749,
			3749
		],
		"valid"
	],
	[
		[
			3750,
			3750
		],
		"disallowed"
	],
	[
		[
			3751,
			3751
		],
		"valid"
	],
	[
		[
			3752,
			3753
		],
		"disallowed"
	],
	[
		[
			3754,
			3755
		],
		"valid"
	],
	[
		[
			3756,
			3756
		],
		"disallowed"
	],
	[
		[
			3757,
			3762
		],
		"valid"
	],
	[
		[
			3763,
			3763
		],
		"mapped",
		[
			3789,
			3762
		]
	],
	[
		[
			3764,
			3769
		],
		"valid"
	],
	[
		[
			3770,
			3770
		],
		"disallowed"
	],
	[
		[
			3771,
			3773
		],
		"valid"
	],
	[
		[
			3774,
			3775
		],
		"disallowed"
	],
	[
		[
			3776,
			3780
		],
		"valid"
	],
	[
		[
			3781,
			3781
		],
		"disallowed"
	],
	[
		[
			3782,
			3782
		],
		"valid"
	],
	[
		[
			3783,
			3783
		],
		"disallowed"
	],
	[
		[
			3784,
			3789
		],
		"valid"
	],
	[
		[
			3790,
			3791
		],
		"disallowed"
	],
	[
		[
			3792,
			3801
		],
		"valid"
	],
	[
		[
			3802,
			3803
		],
		"disallowed"
	],
	[
		[
			3804,
			3804
		],
		"mapped",
		[
			3755,
			3737
		]
	],
	[
		[
			3805,
			3805
		],
		"mapped",
		[
			3755,
			3745
		]
	],
	[
		[
			3806,
			3807
		],
		"valid"
	],
	[
		[
			3808,
			3839
		],
		"disallowed"
	],
	[
		[
			3840,
			3840
		],
		"valid"
	],
	[
		[
			3841,
			3850
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			3851,
			3851
		],
		"valid"
	],
	[
		[
			3852,
			3852
		],
		"mapped",
		[
			3851
		]
	],
	[
		[
			3853,
			3863
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			3864,
			3865
		],
		"valid"
	],
	[
		[
			3866,
			3871
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			3872,
			3881
		],
		"valid"
	],
	[
		[
			3882,
			3892
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			3893,
			3893
		],
		"valid"
	],
	[
		[
			3894,
			3894
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			3895,
			3895
		],
		"valid"
	],
	[
		[
			3896,
			3896
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			3897,
			3897
		],
		"valid"
	],
	[
		[
			3898,
			3901
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			3902,
			3906
		],
		"valid"
	],
	[
		[
			3907,
			3907
		],
		"mapped",
		[
			3906,
			4023
		]
	],
	[
		[
			3908,
			3911
		],
		"valid"
	],
	[
		[
			3912,
			3912
		],
		"disallowed"
	],
	[
		[
			3913,
			3916
		],
		"valid"
	],
	[
		[
			3917,
			3917
		],
		"mapped",
		[
			3916,
			4023
		]
	],
	[
		[
			3918,
			3921
		],
		"valid"
	],
	[
		[
			3922,
			3922
		],
		"mapped",
		[
			3921,
			4023
		]
	],
	[
		[
			3923,
			3926
		],
		"valid"
	],
	[
		[
			3927,
			3927
		],
		"mapped",
		[
			3926,
			4023
		]
	],
	[
		[
			3928,
			3931
		],
		"valid"
	],
	[
		[
			3932,
			3932
		],
		"mapped",
		[
			3931,
			4023
		]
	],
	[
		[
			3933,
			3944
		],
		"valid"
	],
	[
		[
			3945,
			3945
		],
		"mapped",
		[
			3904,
			4021
		]
	],
	[
		[
			3946,
			3946
		],
		"valid"
	],
	[
		[
			3947,
			3948
		],
		"valid"
	],
	[
		[
			3949,
			3952
		],
		"disallowed"
	],
	[
		[
			3953,
			3954
		],
		"valid"
	],
	[
		[
			3955,
			3955
		],
		"mapped",
		[
			3953,
			3954
		]
	],
	[
		[
			3956,
			3956
		],
		"valid"
	],
	[
		[
			3957,
			3957
		],
		"mapped",
		[
			3953,
			3956
		]
	],
	[
		[
			3958,
			3958
		],
		"mapped",
		[
			4018,
			3968
		]
	],
	[
		[
			3959,
			3959
		],
		"mapped",
		[
			4018,
			3953,
			3968
		]
	],
	[
		[
			3960,
			3960
		],
		"mapped",
		[
			4019,
			3968
		]
	],
	[
		[
			3961,
			3961
		],
		"mapped",
		[
			4019,
			3953,
			3968
		]
	],
	[
		[
			3962,
			3968
		],
		"valid"
	],
	[
		[
			3969,
			3969
		],
		"mapped",
		[
			3953,
			3968
		]
	],
	[
		[
			3970,
			3972
		],
		"valid"
	],
	[
		[
			3973,
			3973
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			3974,
			3979
		],
		"valid"
	],
	[
		[
			3980,
			3983
		],
		"valid"
	],
	[
		[
			3984,
			3986
		],
		"valid"
	],
	[
		[
			3987,
			3987
		],
		"mapped",
		[
			3986,
			4023
		]
	],
	[
		[
			3988,
			3989
		],
		"valid"
	],
	[
		[
			3990,
			3990
		],
		"valid"
	],
	[
		[
			3991,
			3991
		],
		"valid"
	],
	[
		[
			3992,
			3992
		],
		"disallowed"
	],
	[
		[
			3993,
			3996
		],
		"valid"
	],
	[
		[
			3997,
			3997
		],
		"mapped",
		[
			3996,
			4023
		]
	],
	[
		[
			3998,
			4001
		],
		"valid"
	],
	[
		[
			4002,
			4002
		],
		"mapped",
		[
			4001,
			4023
		]
	],
	[
		[
			4003,
			4006
		],
		"valid"
	],
	[
		[
			4007,
			4007
		],
		"mapped",
		[
			4006,
			4023
		]
	],
	[
		[
			4008,
			4011
		],
		"valid"
	],
	[
		[
			4012,
			4012
		],
		"mapped",
		[
			4011,
			4023
		]
	],
	[
		[
			4013,
			4013
		],
		"valid"
	],
	[
		[
			4014,
			4016
		],
		"valid"
	],
	[
		[
			4017,
			4023
		],
		"valid"
	],
	[
		[
			4024,
			4024
		],
		"valid"
	],
	[
		[
			4025,
			4025
		],
		"mapped",
		[
			3984,
			4021
		]
	],
	[
		[
			4026,
			4028
		],
		"valid"
	],
	[
		[
			4029,
			4029
		],
		"disallowed"
	],
	[
		[
			4030,
			4037
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			4038,
			4038
		],
		"valid"
	],
	[
		[
			4039,
			4044
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			4045,
			4045
		],
		"disallowed"
	],
	[
		[
			4046,
			4046
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			4047,
			4047
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			4048,
			4049
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			4050,
			4052
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			4053,
			4056
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			4057,
			4058
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			4059,
			4095
		],
		"disallowed"
	],
	[
		[
			4096,
			4129
		],
		"valid"
	],
	[
		[
			4130,
			4130
		],
		"valid"
	],
	[
		[
			4131,
			4135
		],
		"valid"
	],
	[
		[
			4136,
			4136
		],
		"valid"
	],
	[
		[
			4137,
			4138
		],
		"valid"
	],
	[
		[
			4139,
			4139
		],
		"valid"
	],
	[
		[
			4140,
			4146
		],
		"valid"
	],
	[
		[
			4147,
			4149
		],
		"valid"
	],
	[
		[
			4150,
			4153
		],
		"valid"
	],
	[
		[
			4154,
			4159
		],
		"valid"
	],
	[
		[
			4160,
			4169
		],
		"valid"
	],
	[
		[
			4170,
			4175
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			4176,
			4185
		],
		"valid"
	],
	[
		[
			4186,
			4249
		],
		"valid"
	],
	[
		[
			4250,
			4253
		],
		"valid"
	],
	[
		[
			4254,
			4255
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			4256,
			4293
		],
		"disallowed"
	],
	[
		[
			4294,
			4294
		],
		"disallowed"
	],
	[
		[
			4295,
			4295
		],
		"mapped",
		[
			11559
		]
	],
	[
		[
			4296,
			4300
		],
		"disallowed"
	],
	[
		[
			4301,
			4301
		],
		"mapped",
		[
			11565
		]
	],
	[
		[
			4302,
			4303
		],
		"disallowed"
	],
	[
		[
			4304,
			4342
		],
		"valid"
	],
	[
		[
			4343,
			4344
		],
		"valid"
	],
	[
		[
			4345,
			4346
		],
		"valid"
	],
	[
		[
			4347,
			4347
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			4348,
			4348
		],
		"mapped",
		[
			4316
		]
	],
	[
		[
			4349,
			4351
		],
		"valid"
	],
	[
		[
			4352,
			4441
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			4442,
			4446
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			4447,
			4448
		],
		"disallowed"
	],
	[
		[
			4449,
			4514
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			4515,
			4519
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			4520,
			4601
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			4602,
			4607
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			4608,
			4614
		],
		"valid"
	],
	[
		[
			4615,
			4615
		],
		"valid"
	],
	[
		[
			4616,
			4678
		],
		"valid"
	],
	[
		[
			4679,
			4679
		],
		"valid"
	],
	[
		[
			4680,
			4680
		],
		"valid"
	],
	[
		[
			4681,
			4681
		],
		"disallowed"
	],
	[
		[
			4682,
			4685
		],
		"valid"
	],
	[
		[
			4686,
			4687
		],
		"disallowed"
	],
	[
		[
			4688,
			4694
		],
		"valid"
	],
	[
		[
			4695,
			4695
		],
		"disallowed"
	],
	[
		[
			4696,
			4696
		],
		"valid"
	],
	[
		[
			4697,
			4697
		],
		"disallowed"
	],
	[
		[
			4698,
			4701
		],
		"valid"
	],
	[
		[
			4702,
			4703
		],
		"disallowed"
	],
	[
		[
			4704,
			4742
		],
		"valid"
	],
	[
		[
			4743,
			4743
		],
		"valid"
	],
	[
		[
			4744,
			4744
		],
		"valid"
	],
	[
		[
			4745,
			4745
		],
		"disallowed"
	],
	[
		[
			4746,
			4749
		],
		"valid"
	],
	[
		[
			4750,
			4751
		],
		"disallowed"
	],
	[
		[
			4752,
			4782
		],
		"valid"
	],
	[
		[
			4783,
			4783
		],
		"valid"
	],
	[
		[
			4784,
			4784
		],
		"valid"
	],
	[
		[
			4785,
			4785
		],
		"disallowed"
	],
	[
		[
			4786,
			4789
		],
		"valid"
	],
	[
		[
			4790,
			4791
		],
		"disallowed"
	],
	[
		[
			4792,
			4798
		],
		"valid"
	],
	[
		[
			4799,
			4799
		],
		"disallowed"
	],
	[
		[
			4800,
			4800
		],
		"valid"
	],
	[
		[
			4801,
			4801
		],
		"disallowed"
	],
	[
		[
			4802,
			4805
		],
		"valid"
	],
	[
		[
			4806,
			4807
		],
		"disallowed"
	],
	[
		[
			4808,
			4814
		],
		"valid"
	],
	[
		[
			4815,
			4815
		],
		"valid"
	],
	[
		[
			4816,
			4822
		],
		"valid"
	],
	[
		[
			4823,
			4823
		],
		"disallowed"
	],
	[
		[
			4824,
			4846
		],
		"valid"
	],
	[
		[
			4847,
			4847
		],
		"valid"
	],
	[
		[
			4848,
			4878
		],
		"valid"
	],
	[
		[
			4879,
			4879
		],
		"valid"
	],
	[
		[
			4880,
			4880
		],
		"valid"
	],
	[
		[
			4881,
			4881
		],
		"disallowed"
	],
	[
		[
			4882,
			4885
		],
		"valid"
	],
	[
		[
			4886,
			4887
		],
		"disallowed"
	],
	[
		[
			4888,
			4894
		],
		"valid"
	],
	[
		[
			4895,
			4895
		],
		"valid"
	],
	[
		[
			4896,
			4934
		],
		"valid"
	],
	[
		[
			4935,
			4935
		],
		"valid"
	],
	[
		[
			4936,
			4954
		],
		"valid"
	],
	[
		[
			4955,
			4956
		],
		"disallowed"
	],
	[
		[
			4957,
			4958
		],
		"valid"
	],
	[
		[
			4959,
			4959
		],
		"valid"
	],
	[
		[
			4960,
			4960
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			4961,
			4988
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			4989,
			4991
		],
		"disallowed"
	],
	[
		[
			4992,
			5007
		],
		"valid"
	],
	[
		[
			5008,
			5017
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			5018,
			5023
		],
		"disallowed"
	],
	[
		[
			5024,
			5108
		],
		"valid"
	],
	[
		[
			5109,
			5109
		],
		"valid"
	],
	[
		[
			5110,
			5111
		],
		"disallowed"
	],
	[
		[
			5112,
			5112
		],
		"mapped",
		[
			5104
		]
	],
	[
		[
			5113,
			5113
		],
		"mapped",
		[
			5105
		]
	],
	[
		[
			5114,
			5114
		],
		"mapped",
		[
			5106
		]
	],
	[
		[
			5115,
			5115
		],
		"mapped",
		[
			5107
		]
	],
	[
		[
			5116,
			5116
		],
		"mapped",
		[
			5108
		]
	],
	[
		[
			5117,
			5117
		],
		"mapped",
		[
			5109
		]
	],
	[
		[
			5118,
			5119
		],
		"disallowed"
	],
	[
		[
			5120,
			5120
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			5121,
			5740
		],
		"valid"
	],
	[
		[
			5741,
			5742
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			5743,
			5750
		],
		"valid"
	],
	[
		[
			5751,
			5759
		],
		"valid"
	],
	[
		[
			5760,
			5760
		],
		"disallowed"
	],
	[
		[
			5761,
			5786
		],
		"valid"
	],
	[
		[
			5787,
			5788
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			5789,
			5791
		],
		"disallowed"
	],
	[
		[
			5792,
			5866
		],
		"valid"
	],
	[
		[
			5867,
			5872
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			5873,
			5880
		],
		"valid"
	],
	[
		[
			5881,
			5887
		],
		"disallowed"
	],
	[
		[
			5888,
			5900
		],
		"valid"
	],
	[
		[
			5901,
			5901
		],
		"disallowed"
	],
	[
		[
			5902,
			5908
		],
		"valid"
	],
	[
		[
			5909,
			5919
		],
		"disallowed"
	],
	[
		[
			5920,
			5940
		],
		"valid"
	],
	[
		[
			5941,
			5942
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			5943,
			5951
		],
		"disallowed"
	],
	[
		[
			5952,
			5971
		],
		"valid"
	],
	[
		[
			5972,
			5983
		],
		"disallowed"
	],
	[
		[
			5984,
			5996
		],
		"valid"
	],
	[
		[
			5997,
			5997
		],
		"disallowed"
	],
	[
		[
			5998,
			6000
		],
		"valid"
	],
	[
		[
			6001,
			6001
		],
		"disallowed"
	],
	[
		[
			6002,
			6003
		],
		"valid"
	],
	[
		[
			6004,
			6015
		],
		"disallowed"
	],
	[
		[
			6016,
			6067
		],
		"valid"
	],
	[
		[
			6068,
			6069
		],
		"disallowed"
	],
	[
		[
			6070,
			6099
		],
		"valid"
	],
	[
		[
			6100,
			6102
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			6103,
			6103
		],
		"valid"
	],
	[
		[
			6104,
			6107
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			6108,
			6108
		],
		"valid"
	],
	[
		[
			6109,
			6109
		],
		"valid"
	],
	[
		[
			6110,
			6111
		],
		"disallowed"
	],
	[
		[
			6112,
			6121
		],
		"valid"
	],
	[
		[
			6122,
			6127
		],
		"disallowed"
	],
	[
		[
			6128,
			6137
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			6138,
			6143
		],
		"disallowed"
	],
	[
		[
			6144,
			6149
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			6150,
			6150
		],
		"disallowed"
	],
	[
		[
			6151,
			6154
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			6155,
			6157
		],
		"ignored"
	],
	[
		[
			6158,
			6158
		],
		"disallowed"
	],
	[
		[
			6159,
			6159
		],
		"disallowed"
	],
	[
		[
			6160,
			6169
		],
		"valid"
	],
	[
		[
			6170,
			6175
		],
		"disallowed"
	],
	[
		[
			6176,
			6263
		],
		"valid"
	],
	[
		[
			6264,
			6271
		],
		"disallowed"
	],
	[
		[
			6272,
			6313
		],
		"valid"
	],
	[
		[
			6314,
			6314
		],
		"valid"
	],
	[
		[
			6315,
			6319
		],
		"disallowed"
	],
	[
		[
			6320,
			6389
		],
		"valid"
	],
	[
		[
			6390,
			6399
		],
		"disallowed"
	],
	[
		[
			6400,
			6428
		],
		"valid"
	],
	[
		[
			6429,
			6430
		],
		"valid"
	],
	[
		[
			6431,
			6431
		],
		"disallowed"
	],
	[
		[
			6432,
			6443
		],
		"valid"
	],
	[
		[
			6444,
			6447
		],
		"disallowed"
	],
	[
		[
			6448,
			6459
		],
		"valid"
	],
	[
		[
			6460,
			6463
		],
		"disallowed"
	],
	[
		[
			6464,
			6464
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			6465,
			6467
		],
		"disallowed"
	],
	[
		[
			6468,
			6469
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			6470,
			6509
		],
		"valid"
	],
	[
		[
			6510,
			6511
		],
		"disallowed"
	],
	[
		[
			6512,
			6516
		],
		"valid"
	],
	[
		[
			6517,
			6527
		],
		"disallowed"
	],
	[
		[
			6528,
			6569
		],
		"valid"
	],
	[
		[
			6570,
			6571
		],
		"valid"
	],
	[
		[
			6572,
			6575
		],
		"disallowed"
	],
	[
		[
			6576,
			6601
		],
		"valid"
	],
	[
		[
			6602,
			6607
		],
		"disallowed"
	],
	[
		[
			6608,
			6617
		],
		"valid"
	],
	[
		[
			6618,
			6618
		],
		"valid",
		[
		],
		"XV8"
	],
	[
		[
			6619,
			6621
		],
		"disallowed"
	],
	[
		[
			6622,
			6623
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			6624,
			6655
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			6656,
			6683
		],
		"valid"
	],
	[
		[
			6684,
			6685
		],
		"disallowed"
	],
	[
		[
			6686,
			6687
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			6688,
			6750
		],
		"valid"
	],
	[
		[
			6751,
			6751
		],
		"disallowed"
	],
	[
		[
			6752,
			6780
		],
		"valid"
	],
	[
		[
			6781,
			6782
		],
		"disallowed"
	],
	[
		[
			6783,
			6793
		],
		"valid"
	],
	[
		[
			6794,
			6799
		],
		"disallowed"
	],
	[
		[
			6800,
			6809
		],
		"valid"
	],
	[
		[
			6810,
			6815
		],
		"disallowed"
	],
	[
		[
			6816,
			6822
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			6823,
			6823
		],
		"valid"
	],
	[
		[
			6824,
			6829
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			6830,
			6831
		],
		"disallowed"
	],
	[
		[
			6832,
			6845
		],
		"valid"
	],
	[
		[
			6846,
			6846
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			6847,
			6911
		],
		"disallowed"
	],
	[
		[
			6912,
			6987
		],
		"valid"
	],
	[
		[
			6988,
			6991
		],
		"disallowed"
	],
	[
		[
			6992,
			7001
		],
		"valid"
	],
	[
		[
			7002,
			7018
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			7019,
			7027
		],
		"valid"
	],
	[
		[
			7028,
			7036
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			7037,
			7039
		],
		"disallowed"
	],
	[
		[
			7040,
			7082
		],
		"valid"
	],
	[
		[
			7083,
			7085
		],
		"valid"
	],
	[
		[
			7086,
			7097
		],
		"valid"
	],
	[
		[
			7098,
			7103
		],
		"valid"
	],
	[
		[
			7104,
			7155
		],
		"valid"
	],
	[
		[
			7156,
			7163
		],
		"disallowed"
	],
	[
		[
			7164,
			7167
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			7168,
			7223
		],
		"valid"
	],
	[
		[
			7224,
			7226
		],
		"disallowed"
	],
	[
		[
			7227,
			7231
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			7232,
			7241
		],
		"valid"
	],
	[
		[
			7242,
			7244
		],
		"disallowed"
	],
	[
		[
			7245,
			7293
		],
		"valid"
	],
	[
		[
			7294,
			7295
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			7296,
			7359
		],
		"disallowed"
	],
	[
		[
			7360,
			7367
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			7368,
			7375
		],
		"disallowed"
	],
	[
		[
			7376,
			7378
		],
		"valid"
	],
	[
		[
			7379,
			7379
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			7380,
			7410
		],
		"valid"
	],
	[
		[
			7411,
			7414
		],
		"valid"
	],
	[
		[
			7415,
			7415
		],
		"disallowed"
	],
	[
		[
			7416,
			7417
		],
		"valid"
	],
	[
		[
			7418,
			7423
		],
		"disallowed"
	],
	[
		[
			7424,
			7467
		],
		"valid"
	],
	[
		[
			7468,
			7468
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			7469,
			7469
		],
		"mapped",
		[
			230
		]
	],
	[
		[
			7470,
			7470
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			7471,
			7471
		],
		"valid"
	],
	[
		[
			7472,
			7472
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			7473,
			7473
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			7474,
			7474
		],
		"mapped",
		[
			477
		]
	],
	[
		[
			7475,
			7475
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			7476,
			7476
		],
		"mapped",
		[
			104
		]
	],
	[
		[
			7477,
			7477
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			7478,
			7478
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			7479,
			7479
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			7480,
			7480
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			7481,
			7481
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			7482,
			7482
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			7483,
			7483
		],
		"valid"
	],
	[
		[
			7484,
			7484
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			7485,
			7485
		],
		"mapped",
		[
			547
		]
	],
	[
		[
			7486,
			7486
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			7487,
			7487
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			7488,
			7488
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			7489,
			7489
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			7490,
			7490
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			7491,
			7491
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			7492,
			7492
		],
		"mapped",
		[
			592
		]
	],
	[
		[
			7493,
			7493
		],
		"mapped",
		[
			593
		]
	],
	[
		[
			7494,
			7494
		],
		"mapped",
		[
			7426
		]
	],
	[
		[
			7495,
			7495
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			7496,
			7496
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			7497,
			7497
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			7498,
			7498
		],
		"mapped",
		[
			601
		]
	],
	[
		[
			7499,
			7499
		],
		"mapped",
		[
			603
		]
	],
	[
		[
			7500,
			7500
		],
		"mapped",
		[
			604
		]
	],
	[
		[
			7501,
			7501
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			7502,
			7502
		],
		"valid"
	],
	[
		[
			7503,
			7503
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			7504,
			7504
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			7505,
			7505
		],
		"mapped",
		[
			331
		]
	],
	[
		[
			7506,
			7506
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			7507,
			7507
		],
		"mapped",
		[
			596
		]
	],
	[
		[
			7508,
			7508
		],
		"mapped",
		[
			7446
		]
	],
	[
		[
			7509,
			7509
		],
		"mapped",
		[
			7447
		]
	],
	[
		[
			7510,
			7510
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			7511,
			7511
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			7512,
			7512
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			7513,
			7513
		],
		"mapped",
		[
			7453
		]
	],
	[
		[
			7514,
			7514
		],
		"mapped",
		[
			623
		]
	],
	[
		[
			7515,
			7515
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			7516,
			7516
		],
		"mapped",
		[
			7461
		]
	],
	[
		[
			7517,
			7517
		],
		"mapped",
		[
			946
		]
	],
	[
		[
			7518,
			7518
		],
		"mapped",
		[
			947
		]
	],
	[
		[
			7519,
			7519
		],
		"mapped",
		[
			948
		]
	],
	[
		[
			7520,
			7520
		],
		"mapped",
		[
			966
		]
	],
	[
		[
			7521,
			7521
		],
		"mapped",
		[
			967
		]
	],
	[
		[
			7522,
			7522
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			7523,
			7523
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			7524,
			7524
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			7525,
			7525
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			7526,
			7526
		],
		"mapped",
		[
			946
		]
	],
	[
		[
			7527,
			7527
		],
		"mapped",
		[
			947
		]
	],
	[
		[
			7528,
			7528
		],
		"mapped",
		[
			961
		]
	],
	[
		[
			7529,
			7529
		],
		"mapped",
		[
			966
		]
	],
	[
		[
			7530,
			7530
		],
		"mapped",
		[
			967
		]
	],
	[
		[
			7531,
			7531
		],
		"valid"
	],
	[
		[
			7532,
			7543
		],
		"valid"
	],
	[
		[
			7544,
			7544
		],
		"mapped",
		[
			1085
		]
	],
	[
		[
			7545,
			7578
		],
		"valid"
	],
	[
		[
			7579,
			7579
		],
		"mapped",
		[
			594
		]
	],
	[
		[
			7580,
			7580
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			7581,
			7581
		],
		"mapped",
		[
			597
		]
	],
	[
		[
			7582,
			7582
		],
		"mapped",
		[
			240
		]
	],
	[
		[
			7583,
			7583
		],
		"mapped",
		[
			604
		]
	],
	[
		[
			7584,
			7584
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			7585,
			7585
		],
		"mapped",
		[
			607
		]
	],
	[
		[
			7586,
			7586
		],
		"mapped",
		[
			609
		]
	],
	[
		[
			7587,
			7587
		],
		"mapped",
		[
			613
		]
	],
	[
		[
			7588,
			7588
		],
		"mapped",
		[
			616
		]
	],
	[
		[
			7589,
			7589
		],
		"mapped",
		[
			617
		]
	],
	[
		[
			7590,
			7590
		],
		"mapped",
		[
			618
		]
	],
	[
		[
			7591,
			7591
		],
		"mapped",
		[
			7547
		]
	],
	[
		[
			7592,
			7592
		],
		"mapped",
		[
			669
		]
	],
	[
		[
			7593,
			7593
		],
		"mapped",
		[
			621
		]
	],
	[
		[
			7594,
			7594
		],
		"mapped",
		[
			7557
		]
	],
	[
		[
			7595,
			7595
		],
		"mapped",
		[
			671
		]
	],
	[
		[
			7596,
			7596
		],
		"mapped",
		[
			625
		]
	],
	[
		[
			7597,
			7597
		],
		"mapped",
		[
			624
		]
	],
	[
		[
			7598,
			7598
		],
		"mapped",
		[
			626
		]
	],
	[
		[
			7599,
			7599
		],
		"mapped",
		[
			627
		]
	],
	[
		[
			7600,
			7600
		],
		"mapped",
		[
			628
		]
	],
	[
		[
			7601,
			7601
		],
		"mapped",
		[
			629
		]
	],
	[
		[
			7602,
			7602
		],
		"mapped",
		[
			632
		]
	],
	[
		[
			7603,
			7603
		],
		"mapped",
		[
			642
		]
	],
	[
		[
			7604,
			7604
		],
		"mapped",
		[
			643
		]
	],
	[
		[
			7605,
			7605
		],
		"mapped",
		[
			427
		]
	],
	[
		[
			7606,
			7606
		],
		"mapped",
		[
			649
		]
	],
	[
		[
			7607,
			7607
		],
		"mapped",
		[
			650
		]
	],
	[
		[
			7608,
			7608
		],
		"mapped",
		[
			7452
		]
	],
	[
		[
			7609,
			7609
		],
		"mapped",
		[
			651
		]
	],
	[
		[
			7610,
			7610
		],
		"mapped",
		[
			652
		]
	],
	[
		[
			7611,
			7611
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			7612,
			7612
		],
		"mapped",
		[
			656
		]
	],
	[
		[
			7613,
			7613
		],
		"mapped",
		[
			657
		]
	],
	[
		[
			7614,
			7614
		],
		"mapped",
		[
			658
		]
	],
	[
		[
			7615,
			7615
		],
		"mapped",
		[
			952
		]
	],
	[
		[
			7616,
			7619
		],
		"valid"
	],
	[
		[
			7620,
			7626
		],
		"valid"
	],
	[
		[
			7627,
			7654
		],
		"valid"
	],
	[
		[
			7655,
			7669
		],
		"valid"
	],
	[
		[
			7670,
			7675
		],
		"disallowed"
	],
	[
		[
			7676,
			7676
		],
		"valid"
	],
	[
		[
			7677,
			7677
		],
		"valid"
	],
	[
		[
			7678,
			7679
		],
		"valid"
	],
	[
		[
			7680,
			7680
		],
		"mapped",
		[
			7681
		]
	],
	[
		[
			7681,
			7681
		],
		"valid"
	],
	[
		[
			7682,
			7682
		],
		"mapped",
		[
			7683
		]
	],
	[
		[
			7683,
			7683
		],
		"valid"
	],
	[
		[
			7684,
			7684
		],
		"mapped",
		[
			7685
		]
	],
	[
		[
			7685,
			7685
		],
		"valid"
	],
	[
		[
			7686,
			7686
		],
		"mapped",
		[
			7687
		]
	],
	[
		[
			7687,
			7687
		],
		"valid"
	],
	[
		[
			7688,
			7688
		],
		"mapped",
		[
			7689
		]
	],
	[
		[
			7689,
			7689
		],
		"valid"
	],
	[
		[
			7690,
			7690
		],
		"mapped",
		[
			7691
		]
	],
	[
		[
			7691,
			7691
		],
		"valid"
	],
	[
		[
			7692,
			7692
		],
		"mapped",
		[
			7693
		]
	],
	[
		[
			7693,
			7693
		],
		"valid"
	],
	[
		[
			7694,
			7694
		],
		"mapped",
		[
			7695
		]
	],
	[
		[
			7695,
			7695
		],
		"valid"
	],
	[
		[
			7696,
			7696
		],
		"mapped",
		[
			7697
		]
	],
	[
		[
			7697,
			7697
		],
		"valid"
	],
	[
		[
			7698,
			7698
		],
		"mapped",
		[
			7699
		]
	],
	[
		[
			7699,
			7699
		],
		"valid"
	],
	[
		[
			7700,
			7700
		],
		"mapped",
		[
			7701
		]
	],
	[
		[
			7701,
			7701
		],
		"valid"
	],
	[
		[
			7702,
			7702
		],
		"mapped",
		[
			7703
		]
	],
	[
		[
			7703,
			7703
		],
		"valid"
	],
	[
		[
			7704,
			7704
		],
		"mapped",
		[
			7705
		]
	],
	[
		[
			7705,
			7705
		],
		"valid"
	],
	[
		[
			7706,
			7706
		],
		"mapped",
		[
			7707
		]
	],
	[
		[
			7707,
			7707
		],
		"valid"
	],
	[
		[
			7708,
			7708
		],
		"mapped",
		[
			7709
		]
	],
	[
		[
			7709,
			7709
		],
		"valid"
	],
	[
		[
			7710,
			7710
		],
		"mapped",
		[
			7711
		]
	],
	[
		[
			7711,
			7711
		],
		"valid"
	],
	[
		[
			7712,
			7712
		],
		"mapped",
		[
			7713
		]
	],
	[
		[
			7713,
			7713
		],
		"valid"
	],
	[
		[
			7714,
			7714
		],
		"mapped",
		[
			7715
		]
	],
	[
		[
			7715,
			7715
		],
		"valid"
	],
	[
		[
			7716,
			7716
		],
		"mapped",
		[
			7717
		]
	],
	[
		[
			7717,
			7717
		],
		"valid"
	],
	[
		[
			7718,
			7718
		],
		"mapped",
		[
			7719
		]
	],
	[
		[
			7719,
			7719
		],
		"valid"
	],
	[
		[
			7720,
			7720
		],
		"mapped",
		[
			7721
		]
	],
	[
		[
			7721,
			7721
		],
		"valid"
	],
	[
		[
			7722,
			7722
		],
		"mapped",
		[
			7723
		]
	],
	[
		[
			7723,
			7723
		],
		"valid"
	],
	[
		[
			7724,
			7724
		],
		"mapped",
		[
			7725
		]
	],
	[
		[
			7725,
			7725
		],
		"valid"
	],
	[
		[
			7726,
			7726
		],
		"mapped",
		[
			7727
		]
	],
	[
		[
			7727,
			7727
		],
		"valid"
	],
	[
		[
			7728,
			7728
		],
		"mapped",
		[
			7729
		]
	],
	[
		[
			7729,
			7729
		],
		"valid"
	],
	[
		[
			7730,
			7730
		],
		"mapped",
		[
			7731
		]
	],
	[
		[
			7731,
			7731
		],
		"valid"
	],
	[
		[
			7732,
			7732
		],
		"mapped",
		[
			7733
		]
	],
	[
		[
			7733,
			7733
		],
		"valid"
	],
	[
		[
			7734,
			7734
		],
		"mapped",
		[
			7735
		]
	],
	[
		[
			7735,
			7735
		],
		"valid"
	],
	[
		[
			7736,
			7736
		],
		"mapped",
		[
			7737
		]
	],
	[
		[
			7737,
			7737
		],
		"valid"
	],
	[
		[
			7738,
			7738
		],
		"mapped",
		[
			7739
		]
	],
	[
		[
			7739,
			7739
		],
		"valid"
	],
	[
		[
			7740,
			7740
		],
		"mapped",
		[
			7741
		]
	],
	[
		[
			7741,
			7741
		],
		"valid"
	],
	[
		[
			7742,
			7742
		],
		"mapped",
		[
			7743
		]
	],
	[
		[
			7743,
			7743
		],
		"valid"
	],
	[
		[
			7744,
			7744
		],
		"mapped",
		[
			7745
		]
	],
	[
		[
			7745,
			7745
		],
		"valid"
	],
	[
		[
			7746,
			7746
		],
		"mapped",
		[
			7747
		]
	],
	[
		[
			7747,
			7747
		],
		"valid"
	],
	[
		[
			7748,
			7748
		],
		"mapped",
		[
			7749
		]
	],
	[
		[
			7749,
			7749
		],
		"valid"
	],
	[
		[
			7750,
			7750
		],
		"mapped",
		[
			7751
		]
	],
	[
		[
			7751,
			7751
		],
		"valid"
	],
	[
		[
			7752,
			7752
		],
		"mapped",
		[
			7753
		]
	],
	[
		[
			7753,
			7753
		],
		"valid"
	],
	[
		[
			7754,
			7754
		],
		"mapped",
		[
			7755
		]
	],
	[
		[
			7755,
			7755
		],
		"valid"
	],
	[
		[
			7756,
			7756
		],
		"mapped",
		[
			7757
		]
	],
	[
		[
			7757,
			7757
		],
		"valid"
	],
	[
		[
			7758,
			7758
		],
		"mapped",
		[
			7759
		]
	],
	[
		[
			7759,
			7759
		],
		"valid"
	],
	[
		[
			7760,
			7760
		],
		"mapped",
		[
			7761
		]
	],
	[
		[
			7761,
			7761
		],
		"valid"
	],
	[
		[
			7762,
			7762
		],
		"mapped",
		[
			7763
		]
	],
	[
		[
			7763,
			7763
		],
		"valid"
	],
	[
		[
			7764,
			7764
		],
		"mapped",
		[
			7765
		]
	],
	[
		[
			7765,
			7765
		],
		"valid"
	],
	[
		[
			7766,
			7766
		],
		"mapped",
		[
			7767
		]
	],
	[
		[
			7767,
			7767
		],
		"valid"
	],
	[
		[
			7768,
			7768
		],
		"mapped",
		[
			7769
		]
	],
	[
		[
			7769,
			7769
		],
		"valid"
	],
	[
		[
			7770,
			7770
		],
		"mapped",
		[
			7771
		]
	],
	[
		[
			7771,
			7771
		],
		"valid"
	],
	[
		[
			7772,
			7772
		],
		"mapped",
		[
			7773
		]
	],
	[
		[
			7773,
			7773
		],
		"valid"
	],
	[
		[
			7774,
			7774
		],
		"mapped",
		[
			7775
		]
	],
	[
		[
			7775,
			7775
		],
		"valid"
	],
	[
		[
			7776,
			7776
		],
		"mapped",
		[
			7777
		]
	],
	[
		[
			7777,
			7777
		],
		"valid"
	],
	[
		[
			7778,
			7778
		],
		"mapped",
		[
			7779
		]
	],
	[
		[
			7779,
			7779
		],
		"valid"
	],
	[
		[
			7780,
			7780
		],
		"mapped",
		[
			7781
		]
	],
	[
		[
			7781,
			7781
		],
		"valid"
	],
	[
		[
			7782,
			7782
		],
		"mapped",
		[
			7783
		]
	],
	[
		[
			7783,
			7783
		],
		"valid"
	],
	[
		[
			7784,
			7784
		],
		"mapped",
		[
			7785
		]
	],
	[
		[
			7785,
			7785
		],
		"valid"
	],
	[
		[
			7786,
			7786
		],
		"mapped",
		[
			7787
		]
	],
	[
		[
			7787,
			7787
		],
		"valid"
	],
	[
		[
			7788,
			7788
		],
		"mapped",
		[
			7789
		]
	],
	[
		[
			7789,
			7789
		],
		"valid"
	],
	[
		[
			7790,
			7790
		],
		"mapped",
		[
			7791
		]
	],
	[
		[
			7791,
			7791
		],
		"valid"
	],
	[
		[
			7792,
			7792
		],
		"mapped",
		[
			7793
		]
	],
	[
		[
			7793,
			7793
		],
		"valid"
	],
	[
		[
			7794,
			7794
		],
		"mapped",
		[
			7795
		]
	],
	[
		[
			7795,
			7795
		],
		"valid"
	],
	[
		[
			7796,
			7796
		],
		"mapped",
		[
			7797
		]
	],
	[
		[
			7797,
			7797
		],
		"valid"
	],
	[
		[
			7798,
			7798
		],
		"mapped",
		[
			7799
		]
	],
	[
		[
			7799,
			7799
		],
		"valid"
	],
	[
		[
			7800,
			7800
		],
		"mapped",
		[
			7801
		]
	],
	[
		[
			7801,
			7801
		],
		"valid"
	],
	[
		[
			7802,
			7802
		],
		"mapped",
		[
			7803
		]
	],
	[
		[
			7803,
			7803
		],
		"valid"
	],
	[
		[
			7804,
			7804
		],
		"mapped",
		[
			7805
		]
	],
	[
		[
			7805,
			7805
		],
		"valid"
	],
	[
		[
			7806,
			7806
		],
		"mapped",
		[
			7807
		]
	],
	[
		[
			7807,
			7807
		],
		"valid"
	],
	[
		[
			7808,
			7808
		],
		"mapped",
		[
			7809
		]
	],
	[
		[
			7809,
			7809
		],
		"valid"
	],
	[
		[
			7810,
			7810
		],
		"mapped",
		[
			7811
		]
	],
	[
		[
			7811,
			7811
		],
		"valid"
	],
	[
		[
			7812,
			7812
		],
		"mapped",
		[
			7813
		]
	],
	[
		[
			7813,
			7813
		],
		"valid"
	],
	[
		[
			7814,
			7814
		],
		"mapped",
		[
			7815
		]
	],
	[
		[
			7815,
			7815
		],
		"valid"
	],
	[
		[
			7816,
			7816
		],
		"mapped",
		[
			7817
		]
	],
	[
		[
			7817,
			7817
		],
		"valid"
	],
	[
		[
			7818,
			7818
		],
		"mapped",
		[
			7819
		]
	],
	[
		[
			7819,
			7819
		],
		"valid"
	],
	[
		[
			7820,
			7820
		],
		"mapped",
		[
			7821
		]
	],
	[
		[
			7821,
			7821
		],
		"valid"
	],
	[
		[
			7822,
			7822
		],
		"mapped",
		[
			7823
		]
	],
	[
		[
			7823,
			7823
		],
		"valid"
	],
	[
		[
			7824,
			7824
		],
		"mapped",
		[
			7825
		]
	],
	[
		[
			7825,
			7825
		],
		"valid"
	],
	[
		[
			7826,
			7826
		],
		"mapped",
		[
			7827
		]
	],
	[
		[
			7827,
			7827
		],
		"valid"
	],
	[
		[
			7828,
			7828
		],
		"mapped",
		[
			7829
		]
	],
	[
		[
			7829,
			7833
		],
		"valid"
	],
	[
		[
			7834,
			7834
		],
		"mapped",
		[
			97,
			702
		]
	],
	[
		[
			7835,
			7835
		],
		"mapped",
		[
			7777
		]
	],
	[
		[
			7836,
			7837
		],
		"valid"
	],
	[
		[
			7838,
			7838
		],
		"mapped",
		[
			115,
			115
		]
	],
	[
		[
			7839,
			7839
		],
		"valid"
	],
	[
		[
			7840,
			7840
		],
		"mapped",
		[
			7841
		]
	],
	[
		[
			7841,
			7841
		],
		"valid"
	],
	[
		[
			7842,
			7842
		],
		"mapped",
		[
			7843
		]
	],
	[
		[
			7843,
			7843
		],
		"valid"
	],
	[
		[
			7844,
			7844
		],
		"mapped",
		[
			7845
		]
	],
	[
		[
			7845,
			7845
		],
		"valid"
	],
	[
		[
			7846,
			7846
		],
		"mapped",
		[
			7847
		]
	],
	[
		[
			7847,
			7847
		],
		"valid"
	],
	[
		[
			7848,
			7848
		],
		"mapped",
		[
			7849
		]
	],
	[
		[
			7849,
			7849
		],
		"valid"
	],
	[
		[
			7850,
			7850
		],
		"mapped",
		[
			7851
		]
	],
	[
		[
			7851,
			7851
		],
		"valid"
	],
	[
		[
			7852,
			7852
		],
		"mapped",
		[
			7853
		]
	],
	[
		[
			7853,
			7853
		],
		"valid"
	],
	[
		[
			7854,
			7854
		],
		"mapped",
		[
			7855
		]
	],
	[
		[
			7855,
			7855
		],
		"valid"
	],
	[
		[
			7856,
			7856
		],
		"mapped",
		[
			7857
		]
	],
	[
		[
			7857,
			7857
		],
		"valid"
	],
	[
		[
			7858,
			7858
		],
		"mapped",
		[
			7859
		]
	],
	[
		[
			7859,
			7859
		],
		"valid"
	],
	[
		[
			7860,
			7860
		],
		"mapped",
		[
			7861
		]
	],
	[
		[
			7861,
			7861
		],
		"valid"
	],
	[
		[
			7862,
			7862
		],
		"mapped",
		[
			7863
		]
	],
	[
		[
			7863,
			7863
		],
		"valid"
	],
	[
		[
			7864,
			7864
		],
		"mapped",
		[
			7865
		]
	],
	[
		[
			7865,
			7865
		],
		"valid"
	],
	[
		[
			7866,
			7866
		],
		"mapped",
		[
			7867
		]
	],
	[
		[
			7867,
			7867
		],
		"valid"
	],
	[
		[
			7868,
			7868
		],
		"mapped",
		[
			7869
		]
	],
	[
		[
			7869,
			7869
		],
		"valid"
	],
	[
		[
			7870,
			7870
		],
		"mapped",
		[
			7871
		]
	],
	[
		[
			7871,
			7871
		],
		"valid"
	],
	[
		[
			7872,
			7872
		],
		"mapped",
		[
			7873
		]
	],
	[
		[
			7873,
			7873
		],
		"valid"
	],
	[
		[
			7874,
			7874
		],
		"mapped",
		[
			7875
		]
	],
	[
		[
			7875,
			7875
		],
		"valid"
	],
	[
		[
			7876,
			7876
		],
		"mapped",
		[
			7877
		]
	],
	[
		[
			7877,
			7877
		],
		"valid"
	],
	[
		[
			7878,
			7878
		],
		"mapped",
		[
			7879
		]
	],
	[
		[
			7879,
			7879
		],
		"valid"
	],
	[
		[
			7880,
			7880
		],
		"mapped",
		[
			7881
		]
	],
	[
		[
			7881,
			7881
		],
		"valid"
	],
	[
		[
			7882,
			7882
		],
		"mapped",
		[
			7883
		]
	],
	[
		[
			7883,
			7883
		],
		"valid"
	],
	[
		[
			7884,
			7884
		],
		"mapped",
		[
			7885
		]
	],
	[
		[
			7885,
			7885
		],
		"valid"
	],
	[
		[
			7886,
			7886
		],
		"mapped",
		[
			7887
		]
	],
	[
		[
			7887,
			7887
		],
		"valid"
	],
	[
		[
			7888,
			7888
		],
		"mapped",
		[
			7889
		]
	],
	[
		[
			7889,
			7889
		],
		"valid"
	],
	[
		[
			7890,
			7890
		],
		"mapped",
		[
			7891
		]
	],
	[
		[
			7891,
			7891
		],
		"valid"
	],
	[
		[
			7892,
			7892
		],
		"mapped",
		[
			7893
		]
	],
	[
		[
			7893,
			7893
		],
		"valid"
	],
	[
		[
			7894,
			7894
		],
		"mapped",
		[
			7895
		]
	],
	[
		[
			7895,
			7895
		],
		"valid"
	],
	[
		[
			7896,
			7896
		],
		"mapped",
		[
			7897
		]
	],
	[
		[
			7897,
			7897
		],
		"valid"
	],
	[
		[
			7898,
			7898
		],
		"mapped",
		[
			7899
		]
	],
	[
		[
			7899,
			7899
		],
		"valid"
	],
	[
		[
			7900,
			7900
		],
		"mapped",
		[
			7901
		]
	],
	[
		[
			7901,
			7901
		],
		"valid"
	],
	[
		[
			7902,
			7902
		],
		"mapped",
		[
			7903
		]
	],
	[
		[
			7903,
			7903
		],
		"valid"
	],
	[
		[
			7904,
			7904
		],
		"mapped",
		[
			7905
		]
	],
	[
		[
			7905,
			7905
		],
		"valid"
	],
	[
		[
			7906,
			7906
		],
		"mapped",
		[
			7907
		]
	],
	[
		[
			7907,
			7907
		],
		"valid"
	],
	[
		[
			7908,
			7908
		],
		"mapped",
		[
			7909
		]
	],
	[
		[
			7909,
			7909
		],
		"valid"
	],
	[
		[
			7910,
			7910
		],
		"mapped",
		[
			7911
		]
	],
	[
		[
			7911,
			7911
		],
		"valid"
	],
	[
		[
			7912,
			7912
		],
		"mapped",
		[
			7913
		]
	],
	[
		[
			7913,
			7913
		],
		"valid"
	],
	[
		[
			7914,
			7914
		],
		"mapped",
		[
			7915
		]
	],
	[
		[
			7915,
			7915
		],
		"valid"
	],
	[
		[
			7916,
			7916
		],
		"mapped",
		[
			7917
		]
	],
	[
		[
			7917,
			7917
		],
		"valid"
	],
	[
		[
			7918,
			7918
		],
		"mapped",
		[
			7919
		]
	],
	[
		[
			7919,
			7919
		],
		"valid"
	],
	[
		[
			7920,
			7920
		],
		"mapped",
		[
			7921
		]
	],
	[
		[
			7921,
			7921
		],
		"valid"
	],
	[
		[
			7922,
			7922
		],
		"mapped",
		[
			7923
		]
	],
	[
		[
			7923,
			7923
		],
		"valid"
	],
	[
		[
			7924,
			7924
		],
		"mapped",
		[
			7925
		]
	],
	[
		[
			7925,
			7925
		],
		"valid"
	],
	[
		[
			7926,
			7926
		],
		"mapped",
		[
			7927
		]
	],
	[
		[
			7927,
			7927
		],
		"valid"
	],
	[
		[
			7928,
			7928
		],
		"mapped",
		[
			7929
		]
	],
	[
		[
			7929,
			7929
		],
		"valid"
	],
	[
		[
			7930,
			7930
		],
		"mapped",
		[
			7931
		]
	],
	[
		[
			7931,
			7931
		],
		"valid"
	],
	[
		[
			7932,
			7932
		],
		"mapped",
		[
			7933
		]
	],
	[
		[
			7933,
			7933
		],
		"valid"
	],
	[
		[
			7934,
			7934
		],
		"mapped",
		[
			7935
		]
	],
	[
		[
			7935,
			7935
		],
		"valid"
	],
	[
		[
			7936,
			7943
		],
		"valid"
	],
	[
		[
			7944,
			7944
		],
		"mapped",
		[
			7936
		]
	],
	[
		[
			7945,
			7945
		],
		"mapped",
		[
			7937
		]
	],
	[
		[
			7946,
			7946
		],
		"mapped",
		[
			7938
		]
	],
	[
		[
			7947,
			7947
		],
		"mapped",
		[
			7939
		]
	],
	[
		[
			7948,
			7948
		],
		"mapped",
		[
			7940
		]
	],
	[
		[
			7949,
			7949
		],
		"mapped",
		[
			7941
		]
	],
	[
		[
			7950,
			7950
		],
		"mapped",
		[
			7942
		]
	],
	[
		[
			7951,
			7951
		],
		"mapped",
		[
			7943
		]
	],
	[
		[
			7952,
			7957
		],
		"valid"
	],
	[
		[
			7958,
			7959
		],
		"disallowed"
	],
	[
		[
			7960,
			7960
		],
		"mapped",
		[
			7952
		]
	],
	[
		[
			7961,
			7961
		],
		"mapped",
		[
			7953
		]
	],
	[
		[
			7962,
			7962
		],
		"mapped",
		[
			7954
		]
	],
	[
		[
			7963,
			7963
		],
		"mapped",
		[
			7955
		]
	],
	[
		[
			7964,
			7964
		],
		"mapped",
		[
			7956
		]
	],
	[
		[
			7965,
			7965
		],
		"mapped",
		[
			7957
		]
	],
	[
		[
			7966,
			7967
		],
		"disallowed"
	],
	[
		[
			7968,
			7975
		],
		"valid"
	],
	[
		[
			7976,
			7976
		],
		"mapped",
		[
			7968
		]
	],
	[
		[
			7977,
			7977
		],
		"mapped",
		[
			7969
		]
	],
	[
		[
			7978,
			7978
		],
		"mapped",
		[
			7970
		]
	],
	[
		[
			7979,
			7979
		],
		"mapped",
		[
			7971
		]
	],
	[
		[
			7980,
			7980
		],
		"mapped",
		[
			7972
		]
	],
	[
		[
			7981,
			7981
		],
		"mapped",
		[
			7973
		]
	],
	[
		[
			7982,
			7982
		],
		"mapped",
		[
			7974
		]
	],
	[
		[
			7983,
			7983
		],
		"mapped",
		[
			7975
		]
	],
	[
		[
			7984,
			7991
		],
		"valid"
	],
	[
		[
			7992,
			7992
		],
		"mapped",
		[
			7984
		]
	],
	[
		[
			7993,
			7993
		],
		"mapped",
		[
			7985
		]
	],
	[
		[
			7994,
			7994
		],
		"mapped",
		[
			7986
		]
	],
	[
		[
			7995,
			7995
		],
		"mapped",
		[
			7987
		]
	],
	[
		[
			7996,
			7996
		],
		"mapped",
		[
			7988
		]
	],
	[
		[
			7997,
			7997
		],
		"mapped",
		[
			7989
		]
	],
	[
		[
			7998,
			7998
		],
		"mapped",
		[
			7990
		]
	],
	[
		[
			7999,
			7999
		],
		"mapped",
		[
			7991
		]
	],
	[
		[
			8000,
			8005
		],
		"valid"
	],
	[
		[
			8006,
			8007
		],
		"disallowed"
	],
	[
		[
			8008,
			8008
		],
		"mapped",
		[
			8000
		]
	],
	[
		[
			8009,
			8009
		],
		"mapped",
		[
			8001
		]
	],
	[
		[
			8010,
			8010
		],
		"mapped",
		[
			8002
		]
	],
	[
		[
			8011,
			8011
		],
		"mapped",
		[
			8003
		]
	],
	[
		[
			8012,
			8012
		],
		"mapped",
		[
			8004
		]
	],
	[
		[
			8013,
			8013
		],
		"mapped",
		[
			8005
		]
	],
	[
		[
			8014,
			8015
		],
		"disallowed"
	],
	[
		[
			8016,
			8023
		],
		"valid"
	],
	[
		[
			8024,
			8024
		],
		"disallowed"
	],
	[
		[
			8025,
			8025
		],
		"mapped",
		[
			8017
		]
	],
	[
		[
			8026,
			8026
		],
		"disallowed"
	],
	[
		[
			8027,
			8027
		],
		"mapped",
		[
			8019
		]
	],
	[
		[
			8028,
			8028
		],
		"disallowed"
	],
	[
		[
			8029,
			8029
		],
		"mapped",
		[
			8021
		]
	],
	[
		[
			8030,
			8030
		],
		"disallowed"
	],
	[
		[
			8031,
			8031
		],
		"mapped",
		[
			8023
		]
	],
	[
		[
			8032,
			8039
		],
		"valid"
	],
	[
		[
			8040,
			8040
		],
		"mapped",
		[
			8032
		]
	],
	[
		[
			8041,
			8041
		],
		"mapped",
		[
			8033
		]
	],
	[
		[
			8042,
			8042
		],
		"mapped",
		[
			8034
		]
	],
	[
		[
			8043,
			8043
		],
		"mapped",
		[
			8035
		]
	],
	[
		[
			8044,
			8044
		],
		"mapped",
		[
			8036
		]
	],
	[
		[
			8045,
			8045
		],
		"mapped",
		[
			8037
		]
	],
	[
		[
			8046,
			8046
		],
		"mapped",
		[
			8038
		]
	],
	[
		[
			8047,
			8047
		],
		"mapped",
		[
			8039
		]
	],
	[
		[
			8048,
			8048
		],
		"valid"
	],
	[
		[
			8049,
			8049
		],
		"mapped",
		[
			940
		]
	],
	[
		[
			8050,
			8050
		],
		"valid"
	],
	[
		[
			8051,
			8051
		],
		"mapped",
		[
			941
		]
	],
	[
		[
			8052,
			8052
		],
		"valid"
	],
	[
		[
			8053,
			8053
		],
		"mapped",
		[
			942
		]
	],
	[
		[
			8054,
			8054
		],
		"valid"
	],
	[
		[
			8055,
			8055
		],
		"mapped",
		[
			943
		]
	],
	[
		[
			8056,
			8056
		],
		"valid"
	],
	[
		[
			8057,
			8057
		],
		"mapped",
		[
			972
		]
	],
	[
		[
			8058,
			8058
		],
		"valid"
	],
	[
		[
			8059,
			8059
		],
		"mapped",
		[
			973
		]
	],
	[
		[
			8060,
			8060
		],
		"valid"
	],
	[
		[
			8061,
			8061
		],
		"mapped",
		[
			974
		]
	],
	[
		[
			8062,
			8063
		],
		"disallowed"
	],
	[
		[
			8064,
			8064
		],
		"mapped",
		[
			7936,
			953
		]
	],
	[
		[
			8065,
			8065
		],
		"mapped",
		[
			7937,
			953
		]
	],
	[
		[
			8066,
			8066
		],
		"mapped",
		[
			7938,
			953
		]
	],
	[
		[
			8067,
			8067
		],
		"mapped",
		[
			7939,
			953
		]
	],
	[
		[
			8068,
			8068
		],
		"mapped",
		[
			7940,
			953
		]
	],
	[
		[
			8069,
			8069
		],
		"mapped",
		[
			7941,
			953
		]
	],
	[
		[
			8070,
			8070
		],
		"mapped",
		[
			7942,
			953
		]
	],
	[
		[
			8071,
			8071
		],
		"mapped",
		[
			7943,
			953
		]
	],
	[
		[
			8072,
			8072
		],
		"mapped",
		[
			7936,
			953
		]
	],
	[
		[
			8073,
			8073
		],
		"mapped",
		[
			7937,
			953
		]
	],
	[
		[
			8074,
			8074
		],
		"mapped",
		[
			7938,
			953
		]
	],
	[
		[
			8075,
			8075
		],
		"mapped",
		[
			7939,
			953
		]
	],
	[
		[
			8076,
			8076
		],
		"mapped",
		[
			7940,
			953
		]
	],
	[
		[
			8077,
			8077
		],
		"mapped",
		[
			7941,
			953
		]
	],
	[
		[
			8078,
			8078
		],
		"mapped",
		[
			7942,
			953
		]
	],
	[
		[
			8079,
			8079
		],
		"mapped",
		[
			7943,
			953
		]
	],
	[
		[
			8080,
			8080
		],
		"mapped",
		[
			7968,
			953
		]
	],
	[
		[
			8081,
			8081
		],
		"mapped",
		[
			7969,
			953
		]
	],
	[
		[
			8082,
			8082
		],
		"mapped",
		[
			7970,
			953
		]
	],
	[
		[
			8083,
			8083
		],
		"mapped",
		[
			7971,
			953
		]
	],
	[
		[
			8084,
			8084
		],
		"mapped",
		[
			7972,
			953
		]
	],
	[
		[
			8085,
			8085
		],
		"mapped",
		[
			7973,
			953
		]
	],
	[
		[
			8086,
			8086
		],
		"mapped",
		[
			7974,
			953
		]
	],
	[
		[
			8087,
			8087
		],
		"mapped",
		[
			7975,
			953
		]
	],
	[
		[
			8088,
			8088
		],
		"mapped",
		[
			7968,
			953
		]
	],
	[
		[
			8089,
			8089
		],
		"mapped",
		[
			7969,
			953
		]
	],
	[
		[
			8090,
			8090
		],
		"mapped",
		[
			7970,
			953
		]
	],
	[
		[
			8091,
			8091
		],
		"mapped",
		[
			7971,
			953
		]
	],
	[
		[
			8092,
			8092
		],
		"mapped",
		[
			7972,
			953
		]
	],
	[
		[
			8093,
			8093
		],
		"mapped",
		[
			7973,
			953
		]
	],
	[
		[
			8094,
			8094
		],
		"mapped",
		[
			7974,
			953
		]
	],
	[
		[
			8095,
			8095
		],
		"mapped",
		[
			7975,
			953
		]
	],
	[
		[
			8096,
			8096
		],
		"mapped",
		[
			8032,
			953
		]
	],
	[
		[
			8097,
			8097
		],
		"mapped",
		[
			8033,
			953
		]
	],
	[
		[
			8098,
			8098
		],
		"mapped",
		[
			8034,
			953
		]
	],
	[
		[
			8099,
			8099
		],
		"mapped",
		[
			8035,
			953
		]
	],
	[
		[
			8100,
			8100
		],
		"mapped",
		[
			8036,
			953
		]
	],
	[
		[
			8101,
			8101
		],
		"mapped",
		[
			8037,
			953
		]
	],
	[
		[
			8102,
			8102
		],
		"mapped",
		[
			8038,
			953
		]
	],
	[
		[
			8103,
			8103
		],
		"mapped",
		[
			8039,
			953
		]
	],
	[
		[
			8104,
			8104
		],
		"mapped",
		[
			8032,
			953
		]
	],
	[
		[
			8105,
			8105
		],
		"mapped",
		[
			8033,
			953
		]
	],
	[
		[
			8106,
			8106
		],
		"mapped",
		[
			8034,
			953
		]
	],
	[
		[
			8107,
			8107
		],
		"mapped",
		[
			8035,
			953
		]
	],
	[
		[
			8108,
			8108
		],
		"mapped",
		[
			8036,
			953
		]
	],
	[
		[
			8109,
			8109
		],
		"mapped",
		[
			8037,
			953
		]
	],
	[
		[
			8110,
			8110
		],
		"mapped",
		[
			8038,
			953
		]
	],
	[
		[
			8111,
			8111
		],
		"mapped",
		[
			8039,
			953
		]
	],
	[
		[
			8112,
			8113
		],
		"valid"
	],
	[
		[
			8114,
			8114
		],
		"mapped",
		[
			8048,
			953
		]
	],
	[
		[
			8115,
			8115
		],
		"mapped",
		[
			945,
			953
		]
	],
	[
		[
			8116,
			8116
		],
		"mapped",
		[
			940,
			953
		]
	],
	[
		[
			8117,
			8117
		],
		"disallowed"
	],
	[
		[
			8118,
			8118
		],
		"valid"
	],
	[
		[
			8119,
			8119
		],
		"mapped",
		[
			8118,
			953
		]
	],
	[
		[
			8120,
			8120
		],
		"mapped",
		[
			8112
		]
	],
	[
		[
			8121,
			8121
		],
		"mapped",
		[
			8113
		]
	],
	[
		[
			8122,
			8122
		],
		"mapped",
		[
			8048
		]
	],
	[
		[
			8123,
			8123
		],
		"mapped",
		[
			940
		]
	],
	[
		[
			8124,
			8124
		],
		"mapped",
		[
			945,
			953
		]
	],
	[
		[
			8125,
			8125
		],
		"disallowed_STD3_mapped",
		[
			32,
			787
		]
	],
	[
		[
			8126,
			8126
		],
		"mapped",
		[
			953
		]
	],
	[
		[
			8127,
			8127
		],
		"disallowed_STD3_mapped",
		[
			32,
			787
		]
	],
	[
		[
			8128,
			8128
		],
		"disallowed_STD3_mapped",
		[
			32,
			834
		]
	],
	[
		[
			8129,
			8129
		],
		"disallowed_STD3_mapped",
		[
			32,
			776,
			834
		]
	],
	[
		[
			8130,
			8130
		],
		"mapped",
		[
			8052,
			953
		]
	],
	[
		[
			8131,
			8131
		],
		"mapped",
		[
			951,
			953
		]
	],
	[
		[
			8132,
			8132
		],
		"mapped",
		[
			942,
			953
		]
	],
	[
		[
			8133,
			8133
		],
		"disallowed"
	],
	[
		[
			8134,
			8134
		],
		"valid"
	],
	[
		[
			8135,
			8135
		],
		"mapped",
		[
			8134,
			953
		]
	],
	[
		[
			8136,
			8136
		],
		"mapped",
		[
			8050
		]
	],
	[
		[
			8137,
			8137
		],
		"mapped",
		[
			941
		]
	],
	[
		[
			8138,
			8138
		],
		"mapped",
		[
			8052
		]
	],
	[
		[
			8139,
			8139
		],
		"mapped",
		[
			942
		]
	],
	[
		[
			8140,
			8140
		],
		"mapped",
		[
			951,
			953
		]
	],
	[
		[
			8141,
			8141
		],
		"disallowed_STD3_mapped",
		[
			32,
			787,
			768
		]
	],
	[
		[
			8142,
			8142
		],
		"disallowed_STD3_mapped",
		[
			32,
			787,
			769
		]
	],
	[
		[
			8143,
			8143
		],
		"disallowed_STD3_mapped",
		[
			32,
			787,
			834
		]
	],
	[
		[
			8144,
			8146
		],
		"valid"
	],
	[
		[
			8147,
			8147
		],
		"mapped",
		[
			912
		]
	],
	[
		[
			8148,
			8149
		],
		"disallowed"
	],
	[
		[
			8150,
			8151
		],
		"valid"
	],
	[
		[
			8152,
			8152
		],
		"mapped",
		[
			8144
		]
	],
	[
		[
			8153,
			8153
		],
		"mapped",
		[
			8145
		]
	],
	[
		[
			8154,
			8154
		],
		"mapped",
		[
			8054
		]
	],
	[
		[
			8155,
			8155
		],
		"mapped",
		[
			943
		]
	],
	[
		[
			8156,
			8156
		],
		"disallowed"
	],
	[
		[
			8157,
			8157
		],
		"disallowed_STD3_mapped",
		[
			32,
			788,
			768
		]
	],
	[
		[
			8158,
			8158
		],
		"disallowed_STD3_mapped",
		[
			32,
			788,
			769
		]
	],
	[
		[
			8159,
			8159
		],
		"disallowed_STD3_mapped",
		[
			32,
			788,
			834
		]
	],
	[
		[
			8160,
			8162
		],
		"valid"
	],
	[
		[
			8163,
			8163
		],
		"mapped",
		[
			944
		]
	],
	[
		[
			8164,
			8167
		],
		"valid"
	],
	[
		[
			8168,
			8168
		],
		"mapped",
		[
			8160
		]
	],
	[
		[
			8169,
			8169
		],
		"mapped",
		[
			8161
		]
	],
	[
		[
			8170,
			8170
		],
		"mapped",
		[
			8058
		]
	],
	[
		[
			8171,
			8171
		],
		"mapped",
		[
			973
		]
	],
	[
		[
			8172,
			8172
		],
		"mapped",
		[
			8165
		]
	],
	[
		[
			8173,
			8173
		],
		"disallowed_STD3_mapped",
		[
			32,
			776,
			768
		]
	],
	[
		[
			8174,
			8174
		],
		"disallowed_STD3_mapped",
		[
			32,
			776,
			769
		]
	],
	[
		[
			8175,
			8175
		],
		"disallowed_STD3_mapped",
		[
			96
		]
	],
	[
		[
			8176,
			8177
		],
		"disallowed"
	],
	[
		[
			8178,
			8178
		],
		"mapped",
		[
			8060,
			953
		]
	],
	[
		[
			8179,
			8179
		],
		"mapped",
		[
			969,
			953
		]
	],
	[
		[
			8180,
			8180
		],
		"mapped",
		[
			974,
			953
		]
	],
	[
		[
			8181,
			8181
		],
		"disallowed"
	],
	[
		[
			8182,
			8182
		],
		"valid"
	],
	[
		[
			8183,
			8183
		],
		"mapped",
		[
			8182,
			953
		]
	],
	[
		[
			8184,
			8184
		],
		"mapped",
		[
			8056
		]
	],
	[
		[
			8185,
			8185
		],
		"mapped",
		[
			972
		]
	],
	[
		[
			8186,
			8186
		],
		"mapped",
		[
			8060
		]
	],
	[
		[
			8187,
			8187
		],
		"mapped",
		[
			974
		]
	],
	[
		[
			8188,
			8188
		],
		"mapped",
		[
			969,
			953
		]
	],
	[
		[
			8189,
			8189
		],
		"disallowed_STD3_mapped",
		[
			32,
			769
		]
	],
	[
		[
			8190,
			8190
		],
		"disallowed_STD3_mapped",
		[
			32,
			788
		]
	],
	[
		[
			8191,
			8191
		],
		"disallowed"
	],
	[
		[
			8192,
			8202
		],
		"disallowed_STD3_mapped",
		[
			32
		]
	],
	[
		[
			8203,
			8203
		],
		"ignored"
	],
	[
		[
			8204,
			8205
		],
		"deviation",
		[
		]
	],
	[
		[
			8206,
			8207
		],
		"disallowed"
	],
	[
		[
			8208,
			8208
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8209,
			8209
		],
		"mapped",
		[
			8208
		]
	],
	[
		[
			8210,
			8214
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8215,
			8215
		],
		"disallowed_STD3_mapped",
		[
			32,
			819
		]
	],
	[
		[
			8216,
			8227
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8228,
			8230
		],
		"disallowed"
	],
	[
		[
			8231,
			8231
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8232,
			8238
		],
		"disallowed"
	],
	[
		[
			8239,
			8239
		],
		"disallowed_STD3_mapped",
		[
			32
		]
	],
	[
		[
			8240,
			8242
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8243,
			8243
		],
		"mapped",
		[
			8242,
			8242
		]
	],
	[
		[
			8244,
			8244
		],
		"mapped",
		[
			8242,
			8242,
			8242
		]
	],
	[
		[
			8245,
			8245
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8246,
			8246
		],
		"mapped",
		[
			8245,
			8245
		]
	],
	[
		[
			8247,
			8247
		],
		"mapped",
		[
			8245,
			8245,
			8245
		]
	],
	[
		[
			8248,
			8251
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8252,
			8252
		],
		"disallowed_STD3_mapped",
		[
			33,
			33
		]
	],
	[
		[
			8253,
			8253
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8254,
			8254
		],
		"disallowed_STD3_mapped",
		[
			32,
			773
		]
	],
	[
		[
			8255,
			8262
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8263,
			8263
		],
		"disallowed_STD3_mapped",
		[
			63,
			63
		]
	],
	[
		[
			8264,
			8264
		],
		"disallowed_STD3_mapped",
		[
			63,
			33
		]
	],
	[
		[
			8265,
			8265
		],
		"disallowed_STD3_mapped",
		[
			33,
			63
		]
	],
	[
		[
			8266,
			8269
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8270,
			8274
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8275,
			8276
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8277,
			8278
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8279,
			8279
		],
		"mapped",
		[
			8242,
			8242,
			8242,
			8242
		]
	],
	[
		[
			8280,
			8286
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8287,
			8287
		],
		"disallowed_STD3_mapped",
		[
			32
		]
	],
	[
		[
			8288,
			8288
		],
		"ignored"
	],
	[
		[
			8289,
			8291
		],
		"disallowed"
	],
	[
		[
			8292,
			8292
		],
		"ignored"
	],
	[
		[
			8293,
			8293
		],
		"disallowed"
	],
	[
		[
			8294,
			8297
		],
		"disallowed"
	],
	[
		[
			8298,
			8303
		],
		"disallowed"
	],
	[
		[
			8304,
			8304
		],
		"mapped",
		[
			48
		]
	],
	[
		[
			8305,
			8305
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			8306,
			8307
		],
		"disallowed"
	],
	[
		[
			8308,
			8308
		],
		"mapped",
		[
			52
		]
	],
	[
		[
			8309,
			8309
		],
		"mapped",
		[
			53
		]
	],
	[
		[
			8310,
			8310
		],
		"mapped",
		[
			54
		]
	],
	[
		[
			8311,
			8311
		],
		"mapped",
		[
			55
		]
	],
	[
		[
			8312,
			8312
		],
		"mapped",
		[
			56
		]
	],
	[
		[
			8313,
			8313
		],
		"mapped",
		[
			57
		]
	],
	[
		[
			8314,
			8314
		],
		"disallowed_STD3_mapped",
		[
			43
		]
	],
	[
		[
			8315,
			8315
		],
		"mapped",
		[
			8722
		]
	],
	[
		[
			8316,
			8316
		],
		"disallowed_STD3_mapped",
		[
			61
		]
	],
	[
		[
			8317,
			8317
		],
		"disallowed_STD3_mapped",
		[
			40
		]
	],
	[
		[
			8318,
			8318
		],
		"disallowed_STD3_mapped",
		[
			41
		]
	],
	[
		[
			8319,
			8319
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			8320,
			8320
		],
		"mapped",
		[
			48
		]
	],
	[
		[
			8321,
			8321
		],
		"mapped",
		[
			49
		]
	],
	[
		[
			8322,
			8322
		],
		"mapped",
		[
			50
		]
	],
	[
		[
			8323,
			8323
		],
		"mapped",
		[
			51
		]
	],
	[
		[
			8324,
			8324
		],
		"mapped",
		[
			52
		]
	],
	[
		[
			8325,
			8325
		],
		"mapped",
		[
			53
		]
	],
	[
		[
			8326,
			8326
		],
		"mapped",
		[
			54
		]
	],
	[
		[
			8327,
			8327
		],
		"mapped",
		[
			55
		]
	],
	[
		[
			8328,
			8328
		],
		"mapped",
		[
			56
		]
	],
	[
		[
			8329,
			8329
		],
		"mapped",
		[
			57
		]
	],
	[
		[
			8330,
			8330
		],
		"disallowed_STD3_mapped",
		[
			43
		]
	],
	[
		[
			8331,
			8331
		],
		"mapped",
		[
			8722
		]
	],
	[
		[
			8332,
			8332
		],
		"disallowed_STD3_mapped",
		[
			61
		]
	],
	[
		[
			8333,
			8333
		],
		"disallowed_STD3_mapped",
		[
			40
		]
	],
	[
		[
			8334,
			8334
		],
		"disallowed_STD3_mapped",
		[
			41
		]
	],
	[
		[
			8335,
			8335
		],
		"disallowed"
	],
	[
		[
			8336,
			8336
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			8337,
			8337
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			8338,
			8338
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			8339,
			8339
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			8340,
			8340
		],
		"mapped",
		[
			601
		]
	],
	[
		[
			8341,
			8341
		],
		"mapped",
		[
			104
		]
	],
	[
		[
			8342,
			8342
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			8343,
			8343
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			8344,
			8344
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			8345,
			8345
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			8346,
			8346
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			8347,
			8347
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			8348,
			8348
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			8349,
			8351
		],
		"disallowed"
	],
	[
		[
			8352,
			8359
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8360,
			8360
		],
		"mapped",
		[
			114,
			115
		]
	],
	[
		[
			8361,
			8362
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8363,
			8363
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8364,
			8364
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8365,
			8367
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8368,
			8369
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8370,
			8373
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8374,
			8376
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8377,
			8377
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8378,
			8378
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8379,
			8381
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8382,
			8382
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8383,
			8399
		],
		"disallowed"
	],
	[
		[
			8400,
			8417
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8418,
			8419
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8420,
			8426
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8427,
			8427
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8428,
			8431
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8432,
			8432
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8433,
			8447
		],
		"disallowed"
	],
	[
		[
			8448,
			8448
		],
		"disallowed_STD3_mapped",
		[
			97,
			47,
			99
		]
	],
	[
		[
			8449,
			8449
		],
		"disallowed_STD3_mapped",
		[
			97,
			47,
			115
		]
	],
	[
		[
			8450,
			8450
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			8451,
			8451
		],
		"mapped",
		[
			176,
			99
		]
	],
	[
		[
			8452,
			8452
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8453,
			8453
		],
		"disallowed_STD3_mapped",
		[
			99,
			47,
			111
		]
	],
	[
		[
			8454,
			8454
		],
		"disallowed_STD3_mapped",
		[
			99,
			47,
			117
		]
	],
	[
		[
			8455,
			8455
		],
		"mapped",
		[
			603
		]
	],
	[
		[
			8456,
			8456
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8457,
			8457
		],
		"mapped",
		[
			176,
			102
		]
	],
	[
		[
			8458,
			8458
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			8459,
			8462
		],
		"mapped",
		[
			104
		]
	],
	[
		[
			8463,
			8463
		],
		"mapped",
		[
			295
		]
	],
	[
		[
			8464,
			8465
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			8466,
			8467
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			8468,
			8468
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8469,
			8469
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			8470,
			8470
		],
		"mapped",
		[
			110,
			111
		]
	],
	[
		[
			8471,
			8472
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8473,
			8473
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			8474,
			8474
		],
		"mapped",
		[
			113
		]
	],
	[
		[
			8475,
			8477
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			8478,
			8479
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8480,
			8480
		],
		"mapped",
		[
			115,
			109
		]
	],
	[
		[
			8481,
			8481
		],
		"mapped",
		[
			116,
			101,
			108
		]
	],
	[
		[
			8482,
			8482
		],
		"mapped",
		[
			116,
			109
		]
	],
	[
		[
			8483,
			8483
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8484,
			8484
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			8485,
			8485
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8486,
			8486
		],
		"mapped",
		[
			969
		]
	],
	[
		[
			8487,
			8487
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8488,
			8488
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			8489,
			8489
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8490,
			8490
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			8491,
			8491
		],
		"mapped",
		[
			229
		]
	],
	[
		[
			8492,
			8492
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			8493,
			8493
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			8494,
			8494
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8495,
			8496
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			8497,
			8497
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			8498,
			8498
		],
		"disallowed"
	],
	[
		[
			8499,
			8499
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			8500,
			8500
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			8501,
			8501
		],
		"mapped",
		[
			1488
		]
	],
	[
		[
			8502,
			8502
		],
		"mapped",
		[
			1489
		]
	],
	[
		[
			8503,
			8503
		],
		"mapped",
		[
			1490
		]
	],
	[
		[
			8504,
			8504
		],
		"mapped",
		[
			1491
		]
	],
	[
		[
			8505,
			8505
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			8506,
			8506
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8507,
			8507
		],
		"mapped",
		[
			102,
			97,
			120
		]
	],
	[
		[
			8508,
			8508
		],
		"mapped",
		[
			960
		]
	],
	[
		[
			8509,
			8510
		],
		"mapped",
		[
			947
		]
	],
	[
		[
			8511,
			8511
		],
		"mapped",
		[
			960
		]
	],
	[
		[
			8512,
			8512
		],
		"mapped",
		[
			8721
		]
	],
	[
		[
			8513,
			8516
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8517,
			8518
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			8519,
			8519
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			8520,
			8520
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			8521,
			8521
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			8522,
			8523
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8524,
			8524
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8525,
			8525
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8526,
			8526
		],
		"valid"
	],
	[
		[
			8527,
			8527
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8528,
			8528
		],
		"mapped",
		[
			49,
			8260,
			55
		]
	],
	[
		[
			8529,
			8529
		],
		"mapped",
		[
			49,
			8260,
			57
		]
	],
	[
		[
			8530,
			8530
		],
		"mapped",
		[
			49,
			8260,
			49,
			48
		]
	],
	[
		[
			8531,
			8531
		],
		"mapped",
		[
			49,
			8260,
			51
		]
	],
	[
		[
			8532,
			8532
		],
		"mapped",
		[
			50,
			8260,
			51
		]
	],
	[
		[
			8533,
			8533
		],
		"mapped",
		[
			49,
			8260,
			53
		]
	],
	[
		[
			8534,
			8534
		],
		"mapped",
		[
			50,
			8260,
			53
		]
	],
	[
		[
			8535,
			8535
		],
		"mapped",
		[
			51,
			8260,
			53
		]
	],
	[
		[
			8536,
			8536
		],
		"mapped",
		[
			52,
			8260,
			53
		]
	],
	[
		[
			8537,
			8537
		],
		"mapped",
		[
			49,
			8260,
			54
		]
	],
	[
		[
			8538,
			8538
		],
		"mapped",
		[
			53,
			8260,
			54
		]
	],
	[
		[
			8539,
			8539
		],
		"mapped",
		[
			49,
			8260,
			56
		]
	],
	[
		[
			8540,
			8540
		],
		"mapped",
		[
			51,
			8260,
			56
		]
	],
	[
		[
			8541,
			8541
		],
		"mapped",
		[
			53,
			8260,
			56
		]
	],
	[
		[
			8542,
			8542
		],
		"mapped",
		[
			55,
			8260,
			56
		]
	],
	[
		[
			8543,
			8543
		],
		"mapped",
		[
			49,
			8260
		]
	],
	[
		[
			8544,
			8544
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			8545,
			8545
		],
		"mapped",
		[
			105,
			105
		]
	],
	[
		[
			8546,
			8546
		],
		"mapped",
		[
			105,
			105,
			105
		]
	],
	[
		[
			8547,
			8547
		],
		"mapped",
		[
			105,
			118
		]
	],
	[
		[
			8548,
			8548
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			8549,
			8549
		],
		"mapped",
		[
			118,
			105
		]
	],
	[
		[
			8550,
			8550
		],
		"mapped",
		[
			118,
			105,
			105
		]
	],
	[
		[
			8551,
			8551
		],
		"mapped",
		[
			118,
			105,
			105,
			105
		]
	],
	[
		[
			8552,
			8552
		],
		"mapped",
		[
			105,
			120
		]
	],
	[
		[
			8553,
			8553
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			8554,
			8554
		],
		"mapped",
		[
			120,
			105
		]
	],
	[
		[
			8555,
			8555
		],
		"mapped",
		[
			120,
			105,
			105
		]
	],
	[
		[
			8556,
			8556
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			8557,
			8557
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			8558,
			8558
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			8559,
			8559
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			8560,
			8560
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			8561,
			8561
		],
		"mapped",
		[
			105,
			105
		]
	],
	[
		[
			8562,
			8562
		],
		"mapped",
		[
			105,
			105,
			105
		]
	],
	[
		[
			8563,
			8563
		],
		"mapped",
		[
			105,
			118
		]
	],
	[
		[
			8564,
			8564
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			8565,
			8565
		],
		"mapped",
		[
			118,
			105
		]
	],
	[
		[
			8566,
			8566
		],
		"mapped",
		[
			118,
			105,
			105
		]
	],
	[
		[
			8567,
			8567
		],
		"mapped",
		[
			118,
			105,
			105,
			105
		]
	],
	[
		[
			8568,
			8568
		],
		"mapped",
		[
			105,
			120
		]
	],
	[
		[
			8569,
			8569
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			8570,
			8570
		],
		"mapped",
		[
			120,
			105
		]
	],
	[
		[
			8571,
			8571
		],
		"mapped",
		[
			120,
			105,
			105
		]
	],
	[
		[
			8572,
			8572
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			8573,
			8573
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			8574,
			8574
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			8575,
			8575
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			8576,
			8578
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8579,
			8579
		],
		"disallowed"
	],
	[
		[
			8580,
			8580
		],
		"valid"
	],
	[
		[
			8581,
			8584
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8585,
			8585
		],
		"mapped",
		[
			48,
			8260,
			51
		]
	],
	[
		[
			8586,
			8587
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8588,
			8591
		],
		"disallowed"
	],
	[
		[
			8592,
			8682
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8683,
			8691
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8692,
			8703
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8704,
			8747
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8748,
			8748
		],
		"mapped",
		[
			8747,
			8747
		]
	],
	[
		[
			8749,
			8749
		],
		"mapped",
		[
			8747,
			8747,
			8747
		]
	],
	[
		[
			8750,
			8750
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8751,
			8751
		],
		"mapped",
		[
			8750,
			8750
		]
	],
	[
		[
			8752,
			8752
		],
		"mapped",
		[
			8750,
			8750,
			8750
		]
	],
	[
		[
			8753,
			8799
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8800,
			8800
		],
		"disallowed_STD3_valid"
	],
	[
		[
			8801,
			8813
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8814,
			8815
		],
		"disallowed_STD3_valid"
	],
	[
		[
			8816,
			8945
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8946,
			8959
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8960,
			8960
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8961,
			8961
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			8962,
			9000
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9001,
			9001
		],
		"mapped",
		[
			12296
		]
	],
	[
		[
			9002,
			9002
		],
		"mapped",
		[
			12297
		]
	],
	[
		[
			9003,
			9082
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9083,
			9083
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9084,
			9084
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9085,
			9114
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9115,
			9166
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9167,
			9168
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9169,
			9179
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9180,
			9191
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9192,
			9192
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9193,
			9203
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9204,
			9210
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9211,
			9215
		],
		"disallowed"
	],
	[
		[
			9216,
			9252
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9253,
			9254
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9255,
			9279
		],
		"disallowed"
	],
	[
		[
			9280,
			9290
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9291,
			9311
		],
		"disallowed"
	],
	[
		[
			9312,
			9312
		],
		"mapped",
		[
			49
		]
	],
	[
		[
			9313,
			9313
		],
		"mapped",
		[
			50
		]
	],
	[
		[
			9314,
			9314
		],
		"mapped",
		[
			51
		]
	],
	[
		[
			9315,
			9315
		],
		"mapped",
		[
			52
		]
	],
	[
		[
			9316,
			9316
		],
		"mapped",
		[
			53
		]
	],
	[
		[
			9317,
			9317
		],
		"mapped",
		[
			54
		]
	],
	[
		[
			9318,
			9318
		],
		"mapped",
		[
			55
		]
	],
	[
		[
			9319,
			9319
		],
		"mapped",
		[
			56
		]
	],
	[
		[
			9320,
			9320
		],
		"mapped",
		[
			57
		]
	],
	[
		[
			9321,
			9321
		],
		"mapped",
		[
			49,
			48
		]
	],
	[
		[
			9322,
			9322
		],
		"mapped",
		[
			49,
			49
		]
	],
	[
		[
			9323,
			9323
		],
		"mapped",
		[
			49,
			50
		]
	],
	[
		[
			9324,
			9324
		],
		"mapped",
		[
			49,
			51
		]
	],
	[
		[
			9325,
			9325
		],
		"mapped",
		[
			49,
			52
		]
	],
	[
		[
			9326,
			9326
		],
		"mapped",
		[
			49,
			53
		]
	],
	[
		[
			9327,
			9327
		],
		"mapped",
		[
			49,
			54
		]
	],
	[
		[
			9328,
			9328
		],
		"mapped",
		[
			49,
			55
		]
	],
	[
		[
			9329,
			9329
		],
		"mapped",
		[
			49,
			56
		]
	],
	[
		[
			9330,
			9330
		],
		"mapped",
		[
			49,
			57
		]
	],
	[
		[
			9331,
			9331
		],
		"mapped",
		[
			50,
			48
		]
	],
	[
		[
			9332,
			9332
		],
		"disallowed_STD3_mapped",
		[
			40,
			49,
			41
		]
	],
	[
		[
			9333,
			9333
		],
		"disallowed_STD3_mapped",
		[
			40,
			50,
			41
		]
	],
	[
		[
			9334,
			9334
		],
		"disallowed_STD3_mapped",
		[
			40,
			51,
			41
		]
	],
	[
		[
			9335,
			9335
		],
		"disallowed_STD3_mapped",
		[
			40,
			52,
			41
		]
	],
	[
		[
			9336,
			9336
		],
		"disallowed_STD3_mapped",
		[
			40,
			53,
			41
		]
	],
	[
		[
			9337,
			9337
		],
		"disallowed_STD3_mapped",
		[
			40,
			54,
			41
		]
	],
	[
		[
			9338,
			9338
		],
		"disallowed_STD3_mapped",
		[
			40,
			55,
			41
		]
	],
	[
		[
			9339,
			9339
		],
		"disallowed_STD3_mapped",
		[
			40,
			56,
			41
		]
	],
	[
		[
			9340,
			9340
		],
		"disallowed_STD3_mapped",
		[
			40,
			57,
			41
		]
	],
	[
		[
			9341,
			9341
		],
		"disallowed_STD3_mapped",
		[
			40,
			49,
			48,
			41
		]
	],
	[
		[
			9342,
			9342
		],
		"disallowed_STD3_mapped",
		[
			40,
			49,
			49,
			41
		]
	],
	[
		[
			9343,
			9343
		],
		"disallowed_STD3_mapped",
		[
			40,
			49,
			50,
			41
		]
	],
	[
		[
			9344,
			9344
		],
		"disallowed_STD3_mapped",
		[
			40,
			49,
			51,
			41
		]
	],
	[
		[
			9345,
			9345
		],
		"disallowed_STD3_mapped",
		[
			40,
			49,
			52,
			41
		]
	],
	[
		[
			9346,
			9346
		],
		"disallowed_STD3_mapped",
		[
			40,
			49,
			53,
			41
		]
	],
	[
		[
			9347,
			9347
		],
		"disallowed_STD3_mapped",
		[
			40,
			49,
			54,
			41
		]
	],
	[
		[
			9348,
			9348
		],
		"disallowed_STD3_mapped",
		[
			40,
			49,
			55,
			41
		]
	],
	[
		[
			9349,
			9349
		],
		"disallowed_STD3_mapped",
		[
			40,
			49,
			56,
			41
		]
	],
	[
		[
			9350,
			9350
		],
		"disallowed_STD3_mapped",
		[
			40,
			49,
			57,
			41
		]
	],
	[
		[
			9351,
			9351
		],
		"disallowed_STD3_mapped",
		[
			40,
			50,
			48,
			41
		]
	],
	[
		[
			9352,
			9371
		],
		"disallowed"
	],
	[
		[
			9372,
			9372
		],
		"disallowed_STD3_mapped",
		[
			40,
			97,
			41
		]
	],
	[
		[
			9373,
			9373
		],
		"disallowed_STD3_mapped",
		[
			40,
			98,
			41
		]
	],
	[
		[
			9374,
			9374
		],
		"disallowed_STD3_mapped",
		[
			40,
			99,
			41
		]
	],
	[
		[
			9375,
			9375
		],
		"disallowed_STD3_mapped",
		[
			40,
			100,
			41
		]
	],
	[
		[
			9376,
			9376
		],
		"disallowed_STD3_mapped",
		[
			40,
			101,
			41
		]
	],
	[
		[
			9377,
			9377
		],
		"disallowed_STD3_mapped",
		[
			40,
			102,
			41
		]
	],
	[
		[
			9378,
			9378
		],
		"disallowed_STD3_mapped",
		[
			40,
			103,
			41
		]
	],
	[
		[
			9379,
			9379
		],
		"disallowed_STD3_mapped",
		[
			40,
			104,
			41
		]
	],
	[
		[
			9380,
			9380
		],
		"disallowed_STD3_mapped",
		[
			40,
			105,
			41
		]
	],
	[
		[
			9381,
			9381
		],
		"disallowed_STD3_mapped",
		[
			40,
			106,
			41
		]
	],
	[
		[
			9382,
			9382
		],
		"disallowed_STD3_mapped",
		[
			40,
			107,
			41
		]
	],
	[
		[
			9383,
			9383
		],
		"disallowed_STD3_mapped",
		[
			40,
			108,
			41
		]
	],
	[
		[
			9384,
			9384
		],
		"disallowed_STD3_mapped",
		[
			40,
			109,
			41
		]
	],
	[
		[
			9385,
			9385
		],
		"disallowed_STD3_mapped",
		[
			40,
			110,
			41
		]
	],
	[
		[
			9386,
			9386
		],
		"disallowed_STD3_mapped",
		[
			40,
			111,
			41
		]
	],
	[
		[
			9387,
			9387
		],
		"disallowed_STD3_mapped",
		[
			40,
			112,
			41
		]
	],
	[
		[
			9388,
			9388
		],
		"disallowed_STD3_mapped",
		[
			40,
			113,
			41
		]
	],
	[
		[
			9389,
			9389
		],
		"disallowed_STD3_mapped",
		[
			40,
			114,
			41
		]
	],
	[
		[
			9390,
			9390
		],
		"disallowed_STD3_mapped",
		[
			40,
			115,
			41
		]
	],
	[
		[
			9391,
			9391
		],
		"disallowed_STD3_mapped",
		[
			40,
			116,
			41
		]
	],
	[
		[
			9392,
			9392
		],
		"disallowed_STD3_mapped",
		[
			40,
			117,
			41
		]
	],
	[
		[
			9393,
			9393
		],
		"disallowed_STD3_mapped",
		[
			40,
			118,
			41
		]
	],
	[
		[
			9394,
			9394
		],
		"disallowed_STD3_mapped",
		[
			40,
			119,
			41
		]
	],
	[
		[
			9395,
			9395
		],
		"disallowed_STD3_mapped",
		[
			40,
			120,
			41
		]
	],
	[
		[
			9396,
			9396
		],
		"disallowed_STD3_mapped",
		[
			40,
			121,
			41
		]
	],
	[
		[
			9397,
			9397
		],
		"disallowed_STD3_mapped",
		[
			40,
			122,
			41
		]
	],
	[
		[
			9398,
			9398
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			9399,
			9399
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			9400,
			9400
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			9401,
			9401
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			9402,
			9402
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			9403,
			9403
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			9404,
			9404
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			9405,
			9405
		],
		"mapped",
		[
			104
		]
	],
	[
		[
			9406,
			9406
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			9407,
			9407
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			9408,
			9408
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			9409,
			9409
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			9410,
			9410
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			9411,
			9411
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			9412,
			9412
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			9413,
			9413
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			9414,
			9414
		],
		"mapped",
		[
			113
		]
	],
	[
		[
			9415,
			9415
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			9416,
			9416
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			9417,
			9417
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			9418,
			9418
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			9419,
			9419
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			9420,
			9420
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			9421,
			9421
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			9422,
			9422
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			9423,
			9423
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			9424,
			9424
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			9425,
			9425
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			9426,
			9426
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			9427,
			9427
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			9428,
			9428
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			9429,
			9429
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			9430,
			9430
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			9431,
			9431
		],
		"mapped",
		[
			104
		]
	],
	[
		[
			9432,
			9432
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			9433,
			9433
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			9434,
			9434
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			9435,
			9435
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			9436,
			9436
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			9437,
			9437
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			9438,
			9438
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			9439,
			9439
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			9440,
			9440
		],
		"mapped",
		[
			113
		]
	],
	[
		[
			9441,
			9441
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			9442,
			9442
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			9443,
			9443
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			9444,
			9444
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			9445,
			9445
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			9446,
			9446
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			9447,
			9447
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			9448,
			9448
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			9449,
			9449
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			9450,
			9450
		],
		"mapped",
		[
			48
		]
	],
	[
		[
			9451,
			9470
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9471,
			9471
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9472,
			9621
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9622,
			9631
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9632,
			9711
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9712,
			9719
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9720,
			9727
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9728,
			9747
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9748,
			9749
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9750,
			9751
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9752,
			9752
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9753,
			9753
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9754,
			9839
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9840,
			9841
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9842,
			9853
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9854,
			9855
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9856,
			9865
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9866,
			9873
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9874,
			9884
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9885,
			9885
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9886,
			9887
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9888,
			9889
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9890,
			9905
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9906,
			9906
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9907,
			9916
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9917,
			9919
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9920,
			9923
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9924,
			9933
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9934,
			9934
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9935,
			9953
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9954,
			9954
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9955,
			9955
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9956,
			9959
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9960,
			9983
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9984,
			9984
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9985,
			9988
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9989,
			9989
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9990,
			9993
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9994,
			9995
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			9996,
			10023
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10024,
			10024
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10025,
			10059
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10060,
			10060
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10061,
			10061
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10062,
			10062
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10063,
			10066
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10067,
			10069
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10070,
			10070
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10071,
			10071
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10072,
			10078
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10079,
			10080
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10081,
			10087
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10088,
			10101
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10102,
			10132
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10133,
			10135
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10136,
			10159
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10160,
			10160
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10161,
			10174
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10175,
			10175
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10176,
			10182
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10183,
			10186
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10187,
			10187
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10188,
			10188
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10189,
			10189
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10190,
			10191
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10192,
			10219
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10220,
			10223
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10224,
			10239
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10240,
			10495
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10496,
			10763
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10764,
			10764
		],
		"mapped",
		[
			8747,
			8747,
			8747,
			8747
		]
	],
	[
		[
			10765,
			10867
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10868,
			10868
		],
		"disallowed_STD3_mapped",
		[
			58,
			58,
			61
		]
	],
	[
		[
			10869,
			10869
		],
		"disallowed_STD3_mapped",
		[
			61,
			61
		]
	],
	[
		[
			10870,
			10870
		],
		"disallowed_STD3_mapped",
		[
			61,
			61,
			61
		]
	],
	[
		[
			10871,
			10971
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			10972,
			10972
		],
		"mapped",
		[
			10973,
			824
		]
	],
	[
		[
			10973,
			11007
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			11008,
			11021
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			11022,
			11027
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			11028,
			11034
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			11035,
			11039
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			11040,
			11043
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			11044,
			11084
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			11085,
			11087
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			11088,
			11092
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			11093,
			11097
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			11098,
			11123
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			11124,
			11125
		],
		"disallowed"
	],
	[
		[
			11126,
			11157
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			11158,
			11159
		],
		"disallowed"
	],
	[
		[
			11160,
			11193
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			11194,
			11196
		],
		"disallowed"
	],
	[
		[
			11197,
			11208
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			11209,
			11209
		],
		"disallowed"
	],
	[
		[
			11210,
			11217
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			11218,
			11243
		],
		"disallowed"
	],
	[
		[
			11244,
			11247
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			11248,
			11263
		],
		"disallowed"
	],
	[
		[
			11264,
			11264
		],
		"mapped",
		[
			11312
		]
	],
	[
		[
			11265,
			11265
		],
		"mapped",
		[
			11313
		]
	],
	[
		[
			11266,
			11266
		],
		"mapped",
		[
			11314
		]
	],
	[
		[
			11267,
			11267
		],
		"mapped",
		[
			11315
		]
	],
	[
		[
			11268,
			11268
		],
		"mapped",
		[
			11316
		]
	],
	[
		[
			11269,
			11269
		],
		"mapped",
		[
			11317
		]
	],
	[
		[
			11270,
			11270
		],
		"mapped",
		[
			11318
		]
	],
	[
		[
			11271,
			11271
		],
		"mapped",
		[
			11319
		]
	],
	[
		[
			11272,
			11272
		],
		"mapped",
		[
			11320
		]
	],
	[
		[
			11273,
			11273
		],
		"mapped",
		[
			11321
		]
	],
	[
		[
			11274,
			11274
		],
		"mapped",
		[
			11322
		]
	],
	[
		[
			11275,
			11275
		],
		"mapped",
		[
			11323
		]
	],
	[
		[
			11276,
			11276
		],
		"mapped",
		[
			11324
		]
	],
	[
		[
			11277,
			11277
		],
		"mapped",
		[
			11325
		]
	],
	[
		[
			11278,
			11278
		],
		"mapped",
		[
			11326
		]
	],
	[
		[
			11279,
			11279
		],
		"mapped",
		[
			11327
		]
	],
	[
		[
			11280,
			11280
		],
		"mapped",
		[
			11328
		]
	],
	[
		[
			11281,
			11281
		],
		"mapped",
		[
			11329
		]
	],
	[
		[
			11282,
			11282
		],
		"mapped",
		[
			11330
		]
	],
	[
		[
			11283,
			11283
		],
		"mapped",
		[
			11331
		]
	],
	[
		[
			11284,
			11284
		],
		"mapped",
		[
			11332
		]
	],
	[
		[
			11285,
			11285
		],
		"mapped",
		[
			11333
		]
	],
	[
		[
			11286,
			11286
		],
		"mapped",
		[
			11334
		]
	],
	[
		[
			11287,
			11287
		],
		"mapped",
		[
			11335
		]
	],
	[
		[
			11288,
			11288
		],
		"mapped",
		[
			11336
		]
	],
	[
		[
			11289,
			11289
		],
		"mapped",
		[
			11337
		]
	],
	[
		[
			11290,
			11290
		],
		"mapped",
		[
			11338
		]
	],
	[
		[
			11291,
			11291
		],
		"mapped",
		[
			11339
		]
	],
	[
		[
			11292,
			11292
		],
		"mapped",
		[
			11340
		]
	],
	[
		[
			11293,
			11293
		],
		"mapped",
		[
			11341
		]
	],
	[
		[
			11294,
			11294
		],
		"mapped",
		[
			11342
		]
	],
	[
		[
			11295,
			11295
		],
		"mapped",
		[
			11343
		]
	],
	[
		[
			11296,
			11296
		],
		"mapped",
		[
			11344
		]
	],
	[
		[
			11297,
			11297
		],
		"mapped",
		[
			11345
		]
	],
	[
		[
			11298,
			11298
		],
		"mapped",
		[
			11346
		]
	],
	[
		[
			11299,
			11299
		],
		"mapped",
		[
			11347
		]
	],
	[
		[
			11300,
			11300
		],
		"mapped",
		[
			11348
		]
	],
	[
		[
			11301,
			11301
		],
		"mapped",
		[
			11349
		]
	],
	[
		[
			11302,
			11302
		],
		"mapped",
		[
			11350
		]
	],
	[
		[
			11303,
			11303
		],
		"mapped",
		[
			11351
		]
	],
	[
		[
			11304,
			11304
		],
		"mapped",
		[
			11352
		]
	],
	[
		[
			11305,
			11305
		],
		"mapped",
		[
			11353
		]
	],
	[
		[
			11306,
			11306
		],
		"mapped",
		[
			11354
		]
	],
	[
		[
			11307,
			11307
		],
		"mapped",
		[
			11355
		]
	],
	[
		[
			11308,
			11308
		],
		"mapped",
		[
			11356
		]
	],
	[
		[
			11309,
			11309
		],
		"mapped",
		[
			11357
		]
	],
	[
		[
			11310,
			11310
		],
		"mapped",
		[
			11358
		]
	],
	[
		[
			11311,
			11311
		],
		"disallowed"
	],
	[
		[
			11312,
			11358
		],
		"valid"
	],
	[
		[
			11359,
			11359
		],
		"disallowed"
	],
	[
		[
			11360,
			11360
		],
		"mapped",
		[
			11361
		]
	],
	[
		[
			11361,
			11361
		],
		"valid"
	],
	[
		[
			11362,
			11362
		],
		"mapped",
		[
			619
		]
	],
	[
		[
			11363,
			11363
		],
		"mapped",
		[
			7549
		]
	],
	[
		[
			11364,
			11364
		],
		"mapped",
		[
			637
		]
	],
	[
		[
			11365,
			11366
		],
		"valid"
	],
	[
		[
			11367,
			11367
		],
		"mapped",
		[
			11368
		]
	],
	[
		[
			11368,
			11368
		],
		"valid"
	],
	[
		[
			11369,
			11369
		],
		"mapped",
		[
			11370
		]
	],
	[
		[
			11370,
			11370
		],
		"valid"
	],
	[
		[
			11371,
			11371
		],
		"mapped",
		[
			11372
		]
	],
	[
		[
			11372,
			11372
		],
		"valid"
	],
	[
		[
			11373,
			11373
		],
		"mapped",
		[
			593
		]
	],
	[
		[
			11374,
			11374
		],
		"mapped",
		[
			625
		]
	],
	[
		[
			11375,
			11375
		],
		"mapped",
		[
			592
		]
	],
	[
		[
			11376,
			11376
		],
		"mapped",
		[
			594
		]
	],
	[
		[
			11377,
			11377
		],
		"valid"
	],
	[
		[
			11378,
			11378
		],
		"mapped",
		[
			11379
		]
	],
	[
		[
			11379,
			11379
		],
		"valid"
	],
	[
		[
			11380,
			11380
		],
		"valid"
	],
	[
		[
			11381,
			11381
		],
		"mapped",
		[
			11382
		]
	],
	[
		[
			11382,
			11383
		],
		"valid"
	],
	[
		[
			11384,
			11387
		],
		"valid"
	],
	[
		[
			11388,
			11388
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			11389,
			11389
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			11390,
			11390
		],
		"mapped",
		[
			575
		]
	],
	[
		[
			11391,
			11391
		],
		"mapped",
		[
			576
		]
	],
	[
		[
			11392,
			11392
		],
		"mapped",
		[
			11393
		]
	],
	[
		[
			11393,
			11393
		],
		"valid"
	],
	[
		[
			11394,
			11394
		],
		"mapped",
		[
			11395
		]
	],
	[
		[
			11395,
			11395
		],
		"valid"
	],
	[
		[
			11396,
			11396
		],
		"mapped",
		[
			11397
		]
	],
	[
		[
			11397,
			11397
		],
		"valid"
	],
	[
		[
			11398,
			11398
		],
		"mapped",
		[
			11399
		]
	],
	[
		[
			11399,
			11399
		],
		"valid"
	],
	[
		[
			11400,
			11400
		],
		"mapped",
		[
			11401
		]
	],
	[
		[
			11401,
			11401
		],
		"valid"
	],
	[
		[
			11402,
			11402
		],
		"mapped",
		[
			11403
		]
	],
	[
		[
			11403,
			11403
		],
		"valid"
	],
	[
		[
			11404,
			11404
		],
		"mapped",
		[
			11405
		]
	],
	[
		[
			11405,
			11405
		],
		"valid"
	],
	[
		[
			11406,
			11406
		],
		"mapped",
		[
			11407
		]
	],
	[
		[
			11407,
			11407
		],
		"valid"
	],
	[
		[
			11408,
			11408
		],
		"mapped",
		[
			11409
		]
	],
	[
		[
			11409,
			11409
		],
		"valid"
	],
	[
		[
			11410,
			11410
		],
		"mapped",
		[
			11411
		]
	],
	[
		[
			11411,
			11411
		],
		"valid"
	],
	[
		[
			11412,
			11412
		],
		"mapped",
		[
			11413
		]
	],
	[
		[
			11413,
			11413
		],
		"valid"
	],
	[
		[
			11414,
			11414
		],
		"mapped",
		[
			11415
		]
	],
	[
		[
			11415,
			11415
		],
		"valid"
	],
	[
		[
			11416,
			11416
		],
		"mapped",
		[
			11417
		]
	],
	[
		[
			11417,
			11417
		],
		"valid"
	],
	[
		[
			11418,
			11418
		],
		"mapped",
		[
			11419
		]
	],
	[
		[
			11419,
			11419
		],
		"valid"
	],
	[
		[
			11420,
			11420
		],
		"mapped",
		[
			11421
		]
	],
	[
		[
			11421,
			11421
		],
		"valid"
	],
	[
		[
			11422,
			11422
		],
		"mapped",
		[
			11423
		]
	],
	[
		[
			11423,
			11423
		],
		"valid"
	],
	[
		[
			11424,
			11424
		],
		"mapped",
		[
			11425
		]
	],
	[
		[
			11425,
			11425
		],
		"valid"
	],
	[
		[
			11426,
			11426
		],
		"mapped",
		[
			11427
		]
	],
	[
		[
			11427,
			11427
		],
		"valid"
	],
	[
		[
			11428,
			11428
		],
		"mapped",
		[
			11429
		]
	],
	[
		[
			11429,
			11429
		],
		"valid"
	],
	[
		[
			11430,
			11430
		],
		"mapped",
		[
			11431
		]
	],
	[
		[
			11431,
			11431
		],
		"valid"
	],
	[
		[
			11432,
			11432
		],
		"mapped",
		[
			11433
		]
	],
	[
		[
			11433,
			11433
		],
		"valid"
	],
	[
		[
			11434,
			11434
		],
		"mapped",
		[
			11435
		]
	],
	[
		[
			11435,
			11435
		],
		"valid"
	],
	[
		[
			11436,
			11436
		],
		"mapped",
		[
			11437
		]
	],
	[
		[
			11437,
			11437
		],
		"valid"
	],
	[
		[
			11438,
			11438
		],
		"mapped",
		[
			11439
		]
	],
	[
		[
			11439,
			11439
		],
		"valid"
	],
	[
		[
			11440,
			11440
		],
		"mapped",
		[
			11441
		]
	],
	[
		[
			11441,
			11441
		],
		"valid"
	],
	[
		[
			11442,
			11442
		],
		"mapped",
		[
			11443
		]
	],
	[
		[
			11443,
			11443
		],
		"valid"
	],
	[
		[
			11444,
			11444
		],
		"mapped",
		[
			11445
		]
	],
	[
		[
			11445,
			11445
		],
		"valid"
	],
	[
		[
			11446,
			11446
		],
		"mapped",
		[
			11447
		]
	],
	[
		[
			11447,
			11447
		],
		"valid"
	],
	[
		[
			11448,
			11448
		],
		"mapped",
		[
			11449
		]
	],
	[
		[
			11449,
			11449
		],
		"valid"
	],
	[
		[
			11450,
			11450
		],
		"mapped",
		[
			11451
		]
	],
	[
		[
			11451,
			11451
		],
		"valid"
	],
	[
		[
			11452,
			11452
		],
		"mapped",
		[
			11453
		]
	],
	[
		[
			11453,
			11453
		],
		"valid"
	],
	[
		[
			11454,
			11454
		],
		"mapped",
		[
			11455
		]
	],
	[
		[
			11455,
			11455
		],
		"valid"
	],
	[
		[
			11456,
			11456
		],
		"mapped",
		[
			11457
		]
	],
	[
		[
			11457,
			11457
		],
		"valid"
	],
	[
		[
			11458,
			11458
		],
		"mapped",
		[
			11459
		]
	],
	[
		[
			11459,
			11459
		],
		"valid"
	],
	[
		[
			11460,
			11460
		],
		"mapped",
		[
			11461
		]
	],
	[
		[
			11461,
			11461
		],
		"valid"
	],
	[
		[
			11462,
			11462
		],
		"mapped",
		[
			11463
		]
	],
	[
		[
			11463,
			11463
		],
		"valid"
	],
	[
		[
			11464,
			11464
		],
		"mapped",
		[
			11465
		]
	],
	[
		[
			11465,
			11465
		],
		"valid"
	],
	[
		[
			11466,
			11466
		],
		"mapped",
		[
			11467
		]
	],
	[
		[
			11467,
			11467
		],
		"valid"
	],
	[
		[
			11468,
			11468
		],
		"mapped",
		[
			11469
		]
	],
	[
		[
			11469,
			11469
		],
		"valid"
	],
	[
		[
			11470,
			11470
		],
		"mapped",
		[
			11471
		]
	],
	[
		[
			11471,
			11471
		],
		"valid"
	],
	[
		[
			11472,
			11472
		],
		"mapped",
		[
			11473
		]
	],
	[
		[
			11473,
			11473
		],
		"valid"
	],
	[
		[
			11474,
			11474
		],
		"mapped",
		[
			11475
		]
	],
	[
		[
			11475,
			11475
		],
		"valid"
	],
	[
		[
			11476,
			11476
		],
		"mapped",
		[
			11477
		]
	],
	[
		[
			11477,
			11477
		],
		"valid"
	],
	[
		[
			11478,
			11478
		],
		"mapped",
		[
			11479
		]
	],
	[
		[
			11479,
			11479
		],
		"valid"
	],
	[
		[
			11480,
			11480
		],
		"mapped",
		[
			11481
		]
	],
	[
		[
			11481,
			11481
		],
		"valid"
	],
	[
		[
			11482,
			11482
		],
		"mapped",
		[
			11483
		]
	],
	[
		[
			11483,
			11483
		],
		"valid"
	],
	[
		[
			11484,
			11484
		],
		"mapped",
		[
			11485
		]
	],
	[
		[
			11485,
			11485
		],
		"valid"
	],
	[
		[
			11486,
			11486
		],
		"mapped",
		[
			11487
		]
	],
	[
		[
			11487,
			11487
		],
		"valid"
	],
	[
		[
			11488,
			11488
		],
		"mapped",
		[
			11489
		]
	],
	[
		[
			11489,
			11489
		],
		"valid"
	],
	[
		[
			11490,
			11490
		],
		"mapped",
		[
			11491
		]
	],
	[
		[
			11491,
			11492
		],
		"valid"
	],
	[
		[
			11493,
			11498
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			11499,
			11499
		],
		"mapped",
		[
			11500
		]
	],
	[
		[
			11500,
			11500
		],
		"valid"
	],
	[
		[
			11501,
			11501
		],
		"mapped",
		[
			11502
		]
	],
	[
		[
			11502,
			11505
		],
		"valid"
	],
	[
		[
			11506,
			11506
		],
		"mapped",
		[
			11507
		]
	],
	[
		[
			11507,
			11507
		],
		"valid"
	],
	[
		[
			11508,
			11512
		],
		"disallowed"
	],
	[
		[
			11513,
			11519
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			11520,
			11557
		],
		"valid"
	],
	[
		[
			11558,
			11558
		],
		"disallowed"
	],
	[
		[
			11559,
			11559
		],
		"valid"
	],
	[
		[
			11560,
			11564
		],
		"disallowed"
	],
	[
		[
			11565,
			11565
		],
		"valid"
	],
	[
		[
			11566,
			11567
		],
		"disallowed"
	],
	[
		[
			11568,
			11621
		],
		"valid"
	],
	[
		[
			11622,
			11623
		],
		"valid"
	],
	[
		[
			11624,
			11630
		],
		"disallowed"
	],
	[
		[
			11631,
			11631
		],
		"mapped",
		[
			11617
		]
	],
	[
		[
			11632,
			11632
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			11633,
			11646
		],
		"disallowed"
	],
	[
		[
			11647,
			11647
		],
		"valid"
	],
	[
		[
			11648,
			11670
		],
		"valid"
	],
	[
		[
			11671,
			11679
		],
		"disallowed"
	],
	[
		[
			11680,
			11686
		],
		"valid"
	],
	[
		[
			11687,
			11687
		],
		"disallowed"
	],
	[
		[
			11688,
			11694
		],
		"valid"
	],
	[
		[
			11695,
			11695
		],
		"disallowed"
	],
	[
		[
			11696,
			11702
		],
		"valid"
	],
	[
		[
			11703,
			11703
		],
		"disallowed"
	],
	[
		[
			11704,
			11710
		],
		"valid"
	],
	[
		[
			11711,
			11711
		],
		"disallowed"
	],
	[
		[
			11712,
			11718
		],
		"valid"
	],
	[
		[
			11719,
			11719
		],
		"disallowed"
	],
	[
		[
			11720,
			11726
		],
		"valid"
	],
	[
		[
			11727,
			11727
		],
		"disallowed"
	],
	[
		[
			11728,
			11734
		],
		"valid"
	],
	[
		[
			11735,
			11735
		],
		"disallowed"
	],
	[
		[
			11736,
			11742
		],
		"valid"
	],
	[
		[
			11743,
			11743
		],
		"disallowed"
	],
	[
		[
			11744,
			11775
		],
		"valid"
	],
	[
		[
			11776,
			11799
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			11800,
			11803
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			11804,
			11805
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			11806,
			11822
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			11823,
			11823
		],
		"valid"
	],
	[
		[
			11824,
			11824
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			11825,
			11825
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			11826,
			11835
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			11836,
			11842
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			11843,
			11903
		],
		"disallowed"
	],
	[
		[
			11904,
			11929
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			11930,
			11930
		],
		"disallowed"
	],
	[
		[
			11931,
			11934
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			11935,
			11935
		],
		"mapped",
		[
			27597
		]
	],
	[
		[
			11936,
			12018
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			12019,
			12019
		],
		"mapped",
		[
			40863
		]
	],
	[
		[
			12020,
			12031
		],
		"disallowed"
	],
	[
		[
			12032,
			12032
		],
		"mapped",
		[
			19968
		]
	],
	[
		[
			12033,
			12033
		],
		"mapped",
		[
			20008
		]
	],
	[
		[
			12034,
			12034
		],
		"mapped",
		[
			20022
		]
	],
	[
		[
			12035,
			12035
		],
		"mapped",
		[
			20031
		]
	],
	[
		[
			12036,
			12036
		],
		"mapped",
		[
			20057
		]
	],
	[
		[
			12037,
			12037
		],
		"mapped",
		[
			20101
		]
	],
	[
		[
			12038,
			12038
		],
		"mapped",
		[
			20108
		]
	],
	[
		[
			12039,
			12039
		],
		"mapped",
		[
			20128
		]
	],
	[
		[
			12040,
			12040
		],
		"mapped",
		[
			20154
		]
	],
	[
		[
			12041,
			12041
		],
		"mapped",
		[
			20799
		]
	],
	[
		[
			12042,
			12042
		],
		"mapped",
		[
			20837
		]
	],
	[
		[
			12043,
			12043
		],
		"mapped",
		[
			20843
		]
	],
	[
		[
			12044,
			12044
		],
		"mapped",
		[
			20866
		]
	],
	[
		[
			12045,
			12045
		],
		"mapped",
		[
			20886
		]
	],
	[
		[
			12046,
			12046
		],
		"mapped",
		[
			20907
		]
	],
	[
		[
			12047,
			12047
		],
		"mapped",
		[
			20960
		]
	],
	[
		[
			12048,
			12048
		],
		"mapped",
		[
			20981
		]
	],
	[
		[
			12049,
			12049
		],
		"mapped",
		[
			20992
		]
	],
	[
		[
			12050,
			12050
		],
		"mapped",
		[
			21147
		]
	],
	[
		[
			12051,
			12051
		],
		"mapped",
		[
			21241
		]
	],
	[
		[
			12052,
			12052
		],
		"mapped",
		[
			21269
		]
	],
	[
		[
			12053,
			12053
		],
		"mapped",
		[
			21274
		]
	],
	[
		[
			12054,
			12054
		],
		"mapped",
		[
			21304
		]
	],
	[
		[
			12055,
			12055
		],
		"mapped",
		[
			21313
		]
	],
	[
		[
			12056,
			12056
		],
		"mapped",
		[
			21340
		]
	],
	[
		[
			12057,
			12057
		],
		"mapped",
		[
			21353
		]
	],
	[
		[
			12058,
			12058
		],
		"mapped",
		[
			21378
		]
	],
	[
		[
			12059,
			12059
		],
		"mapped",
		[
			21430
		]
	],
	[
		[
			12060,
			12060
		],
		"mapped",
		[
			21448
		]
	],
	[
		[
			12061,
			12061
		],
		"mapped",
		[
			21475
		]
	],
	[
		[
			12062,
			12062
		],
		"mapped",
		[
			22231
		]
	],
	[
		[
			12063,
			12063
		],
		"mapped",
		[
			22303
		]
	],
	[
		[
			12064,
			12064
		],
		"mapped",
		[
			22763
		]
	],
	[
		[
			12065,
			12065
		],
		"mapped",
		[
			22786
		]
	],
	[
		[
			12066,
			12066
		],
		"mapped",
		[
			22794
		]
	],
	[
		[
			12067,
			12067
		],
		"mapped",
		[
			22805
		]
	],
	[
		[
			12068,
			12068
		],
		"mapped",
		[
			22823
		]
	],
	[
		[
			12069,
			12069
		],
		"mapped",
		[
			22899
		]
	],
	[
		[
			12070,
			12070
		],
		"mapped",
		[
			23376
		]
	],
	[
		[
			12071,
			12071
		],
		"mapped",
		[
			23424
		]
	],
	[
		[
			12072,
			12072
		],
		"mapped",
		[
			23544
		]
	],
	[
		[
			12073,
			12073
		],
		"mapped",
		[
			23567
		]
	],
	[
		[
			12074,
			12074
		],
		"mapped",
		[
			23586
		]
	],
	[
		[
			12075,
			12075
		],
		"mapped",
		[
			23608
		]
	],
	[
		[
			12076,
			12076
		],
		"mapped",
		[
			23662
		]
	],
	[
		[
			12077,
			12077
		],
		"mapped",
		[
			23665
		]
	],
	[
		[
			12078,
			12078
		],
		"mapped",
		[
			24027
		]
	],
	[
		[
			12079,
			12079
		],
		"mapped",
		[
			24037
		]
	],
	[
		[
			12080,
			12080
		],
		"mapped",
		[
			24049
		]
	],
	[
		[
			12081,
			12081
		],
		"mapped",
		[
			24062
		]
	],
	[
		[
			12082,
			12082
		],
		"mapped",
		[
			24178
		]
	],
	[
		[
			12083,
			12083
		],
		"mapped",
		[
			24186
		]
	],
	[
		[
			12084,
			12084
		],
		"mapped",
		[
			24191
		]
	],
	[
		[
			12085,
			12085
		],
		"mapped",
		[
			24308
		]
	],
	[
		[
			12086,
			12086
		],
		"mapped",
		[
			24318
		]
	],
	[
		[
			12087,
			12087
		],
		"mapped",
		[
			24331
		]
	],
	[
		[
			12088,
			12088
		],
		"mapped",
		[
			24339
		]
	],
	[
		[
			12089,
			12089
		],
		"mapped",
		[
			24400
		]
	],
	[
		[
			12090,
			12090
		],
		"mapped",
		[
			24417
		]
	],
	[
		[
			12091,
			12091
		],
		"mapped",
		[
			24435
		]
	],
	[
		[
			12092,
			12092
		],
		"mapped",
		[
			24515
		]
	],
	[
		[
			12093,
			12093
		],
		"mapped",
		[
			25096
		]
	],
	[
		[
			12094,
			12094
		],
		"mapped",
		[
			25142
		]
	],
	[
		[
			12095,
			12095
		],
		"mapped",
		[
			25163
		]
	],
	[
		[
			12096,
			12096
		],
		"mapped",
		[
			25903
		]
	],
	[
		[
			12097,
			12097
		],
		"mapped",
		[
			25908
		]
	],
	[
		[
			12098,
			12098
		],
		"mapped",
		[
			25991
		]
	],
	[
		[
			12099,
			12099
		],
		"mapped",
		[
			26007
		]
	],
	[
		[
			12100,
			12100
		],
		"mapped",
		[
			26020
		]
	],
	[
		[
			12101,
			12101
		],
		"mapped",
		[
			26041
		]
	],
	[
		[
			12102,
			12102
		],
		"mapped",
		[
			26080
		]
	],
	[
		[
			12103,
			12103
		],
		"mapped",
		[
			26085
		]
	],
	[
		[
			12104,
			12104
		],
		"mapped",
		[
			26352
		]
	],
	[
		[
			12105,
			12105
		],
		"mapped",
		[
			26376
		]
	],
	[
		[
			12106,
			12106
		],
		"mapped",
		[
			26408
		]
	],
	[
		[
			12107,
			12107
		],
		"mapped",
		[
			27424
		]
	],
	[
		[
			12108,
			12108
		],
		"mapped",
		[
			27490
		]
	],
	[
		[
			12109,
			12109
		],
		"mapped",
		[
			27513
		]
	],
	[
		[
			12110,
			12110
		],
		"mapped",
		[
			27571
		]
	],
	[
		[
			12111,
			12111
		],
		"mapped",
		[
			27595
		]
	],
	[
		[
			12112,
			12112
		],
		"mapped",
		[
			27604
		]
	],
	[
		[
			12113,
			12113
		],
		"mapped",
		[
			27611
		]
	],
	[
		[
			12114,
			12114
		],
		"mapped",
		[
			27663
		]
	],
	[
		[
			12115,
			12115
		],
		"mapped",
		[
			27668
		]
	],
	[
		[
			12116,
			12116
		],
		"mapped",
		[
			27700
		]
	],
	[
		[
			12117,
			12117
		],
		"mapped",
		[
			28779
		]
	],
	[
		[
			12118,
			12118
		],
		"mapped",
		[
			29226
		]
	],
	[
		[
			12119,
			12119
		],
		"mapped",
		[
			29238
		]
	],
	[
		[
			12120,
			12120
		],
		"mapped",
		[
			29243
		]
	],
	[
		[
			12121,
			12121
		],
		"mapped",
		[
			29247
		]
	],
	[
		[
			12122,
			12122
		],
		"mapped",
		[
			29255
		]
	],
	[
		[
			12123,
			12123
		],
		"mapped",
		[
			29273
		]
	],
	[
		[
			12124,
			12124
		],
		"mapped",
		[
			29275
		]
	],
	[
		[
			12125,
			12125
		],
		"mapped",
		[
			29356
		]
	],
	[
		[
			12126,
			12126
		],
		"mapped",
		[
			29572
		]
	],
	[
		[
			12127,
			12127
		],
		"mapped",
		[
			29577
		]
	],
	[
		[
			12128,
			12128
		],
		"mapped",
		[
			29916
		]
	],
	[
		[
			12129,
			12129
		],
		"mapped",
		[
			29926
		]
	],
	[
		[
			12130,
			12130
		],
		"mapped",
		[
			29976
		]
	],
	[
		[
			12131,
			12131
		],
		"mapped",
		[
			29983
		]
	],
	[
		[
			12132,
			12132
		],
		"mapped",
		[
			29992
		]
	],
	[
		[
			12133,
			12133
		],
		"mapped",
		[
			30000
		]
	],
	[
		[
			12134,
			12134
		],
		"mapped",
		[
			30091
		]
	],
	[
		[
			12135,
			12135
		],
		"mapped",
		[
			30098
		]
	],
	[
		[
			12136,
			12136
		],
		"mapped",
		[
			30326
		]
	],
	[
		[
			12137,
			12137
		],
		"mapped",
		[
			30333
		]
	],
	[
		[
			12138,
			12138
		],
		"mapped",
		[
			30382
		]
	],
	[
		[
			12139,
			12139
		],
		"mapped",
		[
			30399
		]
	],
	[
		[
			12140,
			12140
		],
		"mapped",
		[
			30446
		]
	],
	[
		[
			12141,
			12141
		],
		"mapped",
		[
			30683
		]
	],
	[
		[
			12142,
			12142
		],
		"mapped",
		[
			30690
		]
	],
	[
		[
			12143,
			12143
		],
		"mapped",
		[
			30707
		]
	],
	[
		[
			12144,
			12144
		],
		"mapped",
		[
			31034
		]
	],
	[
		[
			12145,
			12145
		],
		"mapped",
		[
			31160
		]
	],
	[
		[
			12146,
			12146
		],
		"mapped",
		[
			31166
		]
	],
	[
		[
			12147,
			12147
		],
		"mapped",
		[
			31348
		]
	],
	[
		[
			12148,
			12148
		],
		"mapped",
		[
			31435
		]
	],
	[
		[
			12149,
			12149
		],
		"mapped",
		[
			31481
		]
	],
	[
		[
			12150,
			12150
		],
		"mapped",
		[
			31859
		]
	],
	[
		[
			12151,
			12151
		],
		"mapped",
		[
			31992
		]
	],
	[
		[
			12152,
			12152
		],
		"mapped",
		[
			32566
		]
	],
	[
		[
			12153,
			12153
		],
		"mapped",
		[
			32593
		]
	],
	[
		[
			12154,
			12154
		],
		"mapped",
		[
			32650
		]
	],
	[
		[
			12155,
			12155
		],
		"mapped",
		[
			32701
		]
	],
	[
		[
			12156,
			12156
		],
		"mapped",
		[
			32769
		]
	],
	[
		[
			12157,
			12157
		],
		"mapped",
		[
			32780
		]
	],
	[
		[
			12158,
			12158
		],
		"mapped",
		[
			32786
		]
	],
	[
		[
			12159,
			12159
		],
		"mapped",
		[
			32819
		]
	],
	[
		[
			12160,
			12160
		],
		"mapped",
		[
			32895
		]
	],
	[
		[
			12161,
			12161
		],
		"mapped",
		[
			32905
		]
	],
	[
		[
			12162,
			12162
		],
		"mapped",
		[
			33251
		]
	],
	[
		[
			12163,
			12163
		],
		"mapped",
		[
			33258
		]
	],
	[
		[
			12164,
			12164
		],
		"mapped",
		[
			33267
		]
	],
	[
		[
			12165,
			12165
		],
		"mapped",
		[
			33276
		]
	],
	[
		[
			12166,
			12166
		],
		"mapped",
		[
			33292
		]
	],
	[
		[
			12167,
			12167
		],
		"mapped",
		[
			33307
		]
	],
	[
		[
			12168,
			12168
		],
		"mapped",
		[
			33311
		]
	],
	[
		[
			12169,
			12169
		],
		"mapped",
		[
			33390
		]
	],
	[
		[
			12170,
			12170
		],
		"mapped",
		[
			33394
		]
	],
	[
		[
			12171,
			12171
		],
		"mapped",
		[
			33400
		]
	],
	[
		[
			12172,
			12172
		],
		"mapped",
		[
			34381
		]
	],
	[
		[
			12173,
			12173
		],
		"mapped",
		[
			34411
		]
	],
	[
		[
			12174,
			12174
		],
		"mapped",
		[
			34880
		]
	],
	[
		[
			12175,
			12175
		],
		"mapped",
		[
			34892
		]
	],
	[
		[
			12176,
			12176
		],
		"mapped",
		[
			34915
		]
	],
	[
		[
			12177,
			12177
		],
		"mapped",
		[
			35198
		]
	],
	[
		[
			12178,
			12178
		],
		"mapped",
		[
			35211
		]
	],
	[
		[
			12179,
			12179
		],
		"mapped",
		[
			35282
		]
	],
	[
		[
			12180,
			12180
		],
		"mapped",
		[
			35328
		]
	],
	[
		[
			12181,
			12181
		],
		"mapped",
		[
			35895
		]
	],
	[
		[
			12182,
			12182
		],
		"mapped",
		[
			35910
		]
	],
	[
		[
			12183,
			12183
		],
		"mapped",
		[
			35925
		]
	],
	[
		[
			12184,
			12184
		],
		"mapped",
		[
			35960
		]
	],
	[
		[
			12185,
			12185
		],
		"mapped",
		[
			35997
		]
	],
	[
		[
			12186,
			12186
		],
		"mapped",
		[
			36196
		]
	],
	[
		[
			12187,
			12187
		],
		"mapped",
		[
			36208
		]
	],
	[
		[
			12188,
			12188
		],
		"mapped",
		[
			36275
		]
	],
	[
		[
			12189,
			12189
		],
		"mapped",
		[
			36523
		]
	],
	[
		[
			12190,
			12190
		],
		"mapped",
		[
			36554
		]
	],
	[
		[
			12191,
			12191
		],
		"mapped",
		[
			36763
		]
	],
	[
		[
			12192,
			12192
		],
		"mapped",
		[
			36784
		]
	],
	[
		[
			12193,
			12193
		],
		"mapped",
		[
			36789
		]
	],
	[
		[
			12194,
			12194
		],
		"mapped",
		[
			37009
		]
	],
	[
		[
			12195,
			12195
		],
		"mapped",
		[
			37193
		]
	],
	[
		[
			12196,
			12196
		],
		"mapped",
		[
			37318
		]
	],
	[
		[
			12197,
			12197
		],
		"mapped",
		[
			37324
		]
	],
	[
		[
			12198,
			12198
		],
		"mapped",
		[
			37329
		]
	],
	[
		[
			12199,
			12199
		],
		"mapped",
		[
			38263
		]
	],
	[
		[
			12200,
			12200
		],
		"mapped",
		[
			38272
		]
	],
	[
		[
			12201,
			12201
		],
		"mapped",
		[
			38428
		]
	],
	[
		[
			12202,
			12202
		],
		"mapped",
		[
			38582
		]
	],
	[
		[
			12203,
			12203
		],
		"mapped",
		[
			38585
		]
	],
	[
		[
			12204,
			12204
		],
		"mapped",
		[
			38632
		]
	],
	[
		[
			12205,
			12205
		],
		"mapped",
		[
			38737
		]
	],
	[
		[
			12206,
			12206
		],
		"mapped",
		[
			38750
		]
	],
	[
		[
			12207,
			12207
		],
		"mapped",
		[
			38754
		]
	],
	[
		[
			12208,
			12208
		],
		"mapped",
		[
			38761
		]
	],
	[
		[
			12209,
			12209
		],
		"mapped",
		[
			38859
		]
	],
	[
		[
			12210,
			12210
		],
		"mapped",
		[
			38893
		]
	],
	[
		[
			12211,
			12211
		],
		"mapped",
		[
			38899
		]
	],
	[
		[
			12212,
			12212
		],
		"mapped",
		[
			38913
		]
	],
	[
		[
			12213,
			12213
		],
		"mapped",
		[
			39080
		]
	],
	[
		[
			12214,
			12214
		],
		"mapped",
		[
			39131
		]
	],
	[
		[
			12215,
			12215
		],
		"mapped",
		[
			39135
		]
	],
	[
		[
			12216,
			12216
		],
		"mapped",
		[
			39318
		]
	],
	[
		[
			12217,
			12217
		],
		"mapped",
		[
			39321
		]
	],
	[
		[
			12218,
			12218
		],
		"mapped",
		[
			39340
		]
	],
	[
		[
			12219,
			12219
		],
		"mapped",
		[
			39592
		]
	],
	[
		[
			12220,
			12220
		],
		"mapped",
		[
			39640
		]
	],
	[
		[
			12221,
			12221
		],
		"mapped",
		[
			39647
		]
	],
	[
		[
			12222,
			12222
		],
		"mapped",
		[
			39717
		]
	],
	[
		[
			12223,
			12223
		],
		"mapped",
		[
			39727
		]
	],
	[
		[
			12224,
			12224
		],
		"mapped",
		[
			39730
		]
	],
	[
		[
			12225,
			12225
		],
		"mapped",
		[
			39740
		]
	],
	[
		[
			12226,
			12226
		],
		"mapped",
		[
			39770
		]
	],
	[
		[
			12227,
			12227
		],
		"mapped",
		[
			40165
		]
	],
	[
		[
			12228,
			12228
		],
		"mapped",
		[
			40565
		]
	],
	[
		[
			12229,
			12229
		],
		"mapped",
		[
			40575
		]
	],
	[
		[
			12230,
			12230
		],
		"mapped",
		[
			40613
		]
	],
	[
		[
			12231,
			12231
		],
		"mapped",
		[
			40635
		]
	],
	[
		[
			12232,
			12232
		],
		"mapped",
		[
			40643
		]
	],
	[
		[
			12233,
			12233
		],
		"mapped",
		[
			40653
		]
	],
	[
		[
			12234,
			12234
		],
		"mapped",
		[
			40657
		]
	],
	[
		[
			12235,
			12235
		],
		"mapped",
		[
			40697
		]
	],
	[
		[
			12236,
			12236
		],
		"mapped",
		[
			40701
		]
	],
	[
		[
			12237,
			12237
		],
		"mapped",
		[
			40718
		]
	],
	[
		[
			12238,
			12238
		],
		"mapped",
		[
			40723
		]
	],
	[
		[
			12239,
			12239
		],
		"mapped",
		[
			40736
		]
	],
	[
		[
			12240,
			12240
		],
		"mapped",
		[
			40763
		]
	],
	[
		[
			12241,
			12241
		],
		"mapped",
		[
			40778
		]
	],
	[
		[
			12242,
			12242
		],
		"mapped",
		[
			40786
		]
	],
	[
		[
			12243,
			12243
		],
		"mapped",
		[
			40845
		]
	],
	[
		[
			12244,
			12244
		],
		"mapped",
		[
			40860
		]
	],
	[
		[
			12245,
			12245
		],
		"mapped",
		[
			40864
		]
	],
	[
		[
			12246,
			12271
		],
		"disallowed"
	],
	[
		[
			12272,
			12283
		],
		"disallowed"
	],
	[
		[
			12284,
			12287
		],
		"disallowed"
	],
	[
		[
			12288,
			12288
		],
		"disallowed_STD3_mapped",
		[
			32
		]
	],
	[
		[
			12289,
			12289
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			12290,
			12290
		],
		"mapped",
		[
			46
		]
	],
	[
		[
			12291,
			12292
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			12293,
			12295
		],
		"valid"
	],
	[
		[
			12296,
			12329
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			12330,
			12333
		],
		"valid"
	],
	[
		[
			12334,
			12341
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			12342,
			12342
		],
		"mapped",
		[
			12306
		]
	],
	[
		[
			12343,
			12343
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			12344,
			12344
		],
		"mapped",
		[
			21313
		]
	],
	[
		[
			12345,
			12345
		],
		"mapped",
		[
			21316
		]
	],
	[
		[
			12346,
			12346
		],
		"mapped",
		[
			21317
		]
	],
	[
		[
			12347,
			12347
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			12348,
			12348
		],
		"valid"
	],
	[
		[
			12349,
			12349
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			12350,
			12350
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			12351,
			12351
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			12352,
			12352
		],
		"disallowed"
	],
	[
		[
			12353,
			12436
		],
		"valid"
	],
	[
		[
			12437,
			12438
		],
		"valid"
	],
	[
		[
			12439,
			12440
		],
		"disallowed"
	],
	[
		[
			12441,
			12442
		],
		"valid"
	],
	[
		[
			12443,
			12443
		],
		"disallowed_STD3_mapped",
		[
			32,
			12441
		]
	],
	[
		[
			12444,
			12444
		],
		"disallowed_STD3_mapped",
		[
			32,
			12442
		]
	],
	[
		[
			12445,
			12446
		],
		"valid"
	],
	[
		[
			12447,
			12447
		],
		"mapped",
		[
			12424,
			12426
		]
	],
	[
		[
			12448,
			12448
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			12449,
			12542
		],
		"valid"
	],
	[
		[
			12543,
			12543
		],
		"mapped",
		[
			12467,
			12488
		]
	],
	[
		[
			12544,
			12548
		],
		"disallowed"
	],
	[
		[
			12549,
			12588
		],
		"valid"
	],
	[
		[
			12589,
			12589
		],
		"valid"
	],
	[
		[
			12590,
			12592
		],
		"disallowed"
	],
	[
		[
			12593,
			12593
		],
		"mapped",
		[
			4352
		]
	],
	[
		[
			12594,
			12594
		],
		"mapped",
		[
			4353
		]
	],
	[
		[
			12595,
			12595
		],
		"mapped",
		[
			4522
		]
	],
	[
		[
			12596,
			12596
		],
		"mapped",
		[
			4354
		]
	],
	[
		[
			12597,
			12597
		],
		"mapped",
		[
			4524
		]
	],
	[
		[
			12598,
			12598
		],
		"mapped",
		[
			4525
		]
	],
	[
		[
			12599,
			12599
		],
		"mapped",
		[
			4355
		]
	],
	[
		[
			12600,
			12600
		],
		"mapped",
		[
			4356
		]
	],
	[
		[
			12601,
			12601
		],
		"mapped",
		[
			4357
		]
	],
	[
		[
			12602,
			12602
		],
		"mapped",
		[
			4528
		]
	],
	[
		[
			12603,
			12603
		],
		"mapped",
		[
			4529
		]
	],
	[
		[
			12604,
			12604
		],
		"mapped",
		[
			4530
		]
	],
	[
		[
			12605,
			12605
		],
		"mapped",
		[
			4531
		]
	],
	[
		[
			12606,
			12606
		],
		"mapped",
		[
			4532
		]
	],
	[
		[
			12607,
			12607
		],
		"mapped",
		[
			4533
		]
	],
	[
		[
			12608,
			12608
		],
		"mapped",
		[
			4378
		]
	],
	[
		[
			12609,
			12609
		],
		"mapped",
		[
			4358
		]
	],
	[
		[
			12610,
			12610
		],
		"mapped",
		[
			4359
		]
	],
	[
		[
			12611,
			12611
		],
		"mapped",
		[
			4360
		]
	],
	[
		[
			12612,
			12612
		],
		"mapped",
		[
			4385
		]
	],
	[
		[
			12613,
			12613
		],
		"mapped",
		[
			4361
		]
	],
	[
		[
			12614,
			12614
		],
		"mapped",
		[
			4362
		]
	],
	[
		[
			12615,
			12615
		],
		"mapped",
		[
			4363
		]
	],
	[
		[
			12616,
			12616
		],
		"mapped",
		[
			4364
		]
	],
	[
		[
			12617,
			12617
		],
		"mapped",
		[
			4365
		]
	],
	[
		[
			12618,
			12618
		],
		"mapped",
		[
			4366
		]
	],
	[
		[
			12619,
			12619
		],
		"mapped",
		[
			4367
		]
	],
	[
		[
			12620,
			12620
		],
		"mapped",
		[
			4368
		]
	],
	[
		[
			12621,
			12621
		],
		"mapped",
		[
			4369
		]
	],
	[
		[
			12622,
			12622
		],
		"mapped",
		[
			4370
		]
	],
	[
		[
			12623,
			12623
		],
		"mapped",
		[
			4449
		]
	],
	[
		[
			12624,
			12624
		],
		"mapped",
		[
			4450
		]
	],
	[
		[
			12625,
			12625
		],
		"mapped",
		[
			4451
		]
	],
	[
		[
			12626,
			12626
		],
		"mapped",
		[
			4452
		]
	],
	[
		[
			12627,
			12627
		],
		"mapped",
		[
			4453
		]
	],
	[
		[
			12628,
			12628
		],
		"mapped",
		[
			4454
		]
	],
	[
		[
			12629,
			12629
		],
		"mapped",
		[
			4455
		]
	],
	[
		[
			12630,
			12630
		],
		"mapped",
		[
			4456
		]
	],
	[
		[
			12631,
			12631
		],
		"mapped",
		[
			4457
		]
	],
	[
		[
			12632,
			12632
		],
		"mapped",
		[
			4458
		]
	],
	[
		[
			12633,
			12633
		],
		"mapped",
		[
			4459
		]
	],
	[
		[
			12634,
			12634
		],
		"mapped",
		[
			4460
		]
	],
	[
		[
			12635,
			12635
		],
		"mapped",
		[
			4461
		]
	],
	[
		[
			12636,
			12636
		],
		"mapped",
		[
			4462
		]
	],
	[
		[
			12637,
			12637
		],
		"mapped",
		[
			4463
		]
	],
	[
		[
			12638,
			12638
		],
		"mapped",
		[
			4464
		]
	],
	[
		[
			12639,
			12639
		],
		"mapped",
		[
			4465
		]
	],
	[
		[
			12640,
			12640
		],
		"mapped",
		[
			4466
		]
	],
	[
		[
			12641,
			12641
		],
		"mapped",
		[
			4467
		]
	],
	[
		[
			12642,
			12642
		],
		"mapped",
		[
			4468
		]
	],
	[
		[
			12643,
			12643
		],
		"mapped",
		[
			4469
		]
	],
	[
		[
			12644,
			12644
		],
		"disallowed"
	],
	[
		[
			12645,
			12645
		],
		"mapped",
		[
			4372
		]
	],
	[
		[
			12646,
			12646
		],
		"mapped",
		[
			4373
		]
	],
	[
		[
			12647,
			12647
		],
		"mapped",
		[
			4551
		]
	],
	[
		[
			12648,
			12648
		],
		"mapped",
		[
			4552
		]
	],
	[
		[
			12649,
			12649
		],
		"mapped",
		[
			4556
		]
	],
	[
		[
			12650,
			12650
		],
		"mapped",
		[
			4558
		]
	],
	[
		[
			12651,
			12651
		],
		"mapped",
		[
			4563
		]
	],
	[
		[
			12652,
			12652
		],
		"mapped",
		[
			4567
		]
	],
	[
		[
			12653,
			12653
		],
		"mapped",
		[
			4569
		]
	],
	[
		[
			12654,
			12654
		],
		"mapped",
		[
			4380
		]
	],
	[
		[
			12655,
			12655
		],
		"mapped",
		[
			4573
		]
	],
	[
		[
			12656,
			12656
		],
		"mapped",
		[
			4575
		]
	],
	[
		[
			12657,
			12657
		],
		"mapped",
		[
			4381
		]
	],
	[
		[
			12658,
			12658
		],
		"mapped",
		[
			4382
		]
	],
	[
		[
			12659,
			12659
		],
		"mapped",
		[
			4384
		]
	],
	[
		[
			12660,
			12660
		],
		"mapped",
		[
			4386
		]
	],
	[
		[
			12661,
			12661
		],
		"mapped",
		[
			4387
		]
	],
	[
		[
			12662,
			12662
		],
		"mapped",
		[
			4391
		]
	],
	[
		[
			12663,
			12663
		],
		"mapped",
		[
			4393
		]
	],
	[
		[
			12664,
			12664
		],
		"mapped",
		[
			4395
		]
	],
	[
		[
			12665,
			12665
		],
		"mapped",
		[
			4396
		]
	],
	[
		[
			12666,
			12666
		],
		"mapped",
		[
			4397
		]
	],
	[
		[
			12667,
			12667
		],
		"mapped",
		[
			4398
		]
	],
	[
		[
			12668,
			12668
		],
		"mapped",
		[
			4399
		]
	],
	[
		[
			12669,
			12669
		],
		"mapped",
		[
			4402
		]
	],
	[
		[
			12670,
			12670
		],
		"mapped",
		[
			4406
		]
	],
	[
		[
			12671,
			12671
		],
		"mapped",
		[
			4416
		]
	],
	[
		[
			12672,
			12672
		],
		"mapped",
		[
			4423
		]
	],
	[
		[
			12673,
			12673
		],
		"mapped",
		[
			4428
		]
	],
	[
		[
			12674,
			12674
		],
		"mapped",
		[
			4593
		]
	],
	[
		[
			12675,
			12675
		],
		"mapped",
		[
			4594
		]
	],
	[
		[
			12676,
			12676
		],
		"mapped",
		[
			4439
		]
	],
	[
		[
			12677,
			12677
		],
		"mapped",
		[
			4440
		]
	],
	[
		[
			12678,
			12678
		],
		"mapped",
		[
			4441
		]
	],
	[
		[
			12679,
			12679
		],
		"mapped",
		[
			4484
		]
	],
	[
		[
			12680,
			12680
		],
		"mapped",
		[
			4485
		]
	],
	[
		[
			12681,
			12681
		],
		"mapped",
		[
			4488
		]
	],
	[
		[
			12682,
			12682
		],
		"mapped",
		[
			4497
		]
	],
	[
		[
			12683,
			12683
		],
		"mapped",
		[
			4498
		]
	],
	[
		[
			12684,
			12684
		],
		"mapped",
		[
			4500
		]
	],
	[
		[
			12685,
			12685
		],
		"mapped",
		[
			4510
		]
	],
	[
		[
			12686,
			12686
		],
		"mapped",
		[
			4513
		]
	],
	[
		[
			12687,
			12687
		],
		"disallowed"
	],
	[
		[
			12688,
			12689
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			12690,
			12690
		],
		"mapped",
		[
			19968
		]
	],
	[
		[
			12691,
			12691
		],
		"mapped",
		[
			20108
		]
	],
	[
		[
			12692,
			12692
		],
		"mapped",
		[
			19977
		]
	],
	[
		[
			12693,
			12693
		],
		"mapped",
		[
			22235
		]
	],
	[
		[
			12694,
			12694
		],
		"mapped",
		[
			19978
		]
	],
	[
		[
			12695,
			12695
		],
		"mapped",
		[
			20013
		]
	],
	[
		[
			12696,
			12696
		],
		"mapped",
		[
			19979
		]
	],
	[
		[
			12697,
			12697
		],
		"mapped",
		[
			30002
		]
	],
	[
		[
			12698,
			12698
		],
		"mapped",
		[
			20057
		]
	],
	[
		[
			12699,
			12699
		],
		"mapped",
		[
			19993
		]
	],
	[
		[
			12700,
			12700
		],
		"mapped",
		[
			19969
		]
	],
	[
		[
			12701,
			12701
		],
		"mapped",
		[
			22825
		]
	],
	[
		[
			12702,
			12702
		],
		"mapped",
		[
			22320
		]
	],
	[
		[
			12703,
			12703
		],
		"mapped",
		[
			20154
		]
	],
	[
		[
			12704,
			12727
		],
		"valid"
	],
	[
		[
			12728,
			12730
		],
		"valid"
	],
	[
		[
			12731,
			12735
		],
		"disallowed"
	],
	[
		[
			12736,
			12751
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			12752,
			12771
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			12772,
			12783
		],
		"disallowed"
	],
	[
		[
			12784,
			12799
		],
		"valid"
	],
	[
		[
			12800,
			12800
		],
		"disallowed_STD3_mapped",
		[
			40,
			4352,
			41
		]
	],
	[
		[
			12801,
			12801
		],
		"disallowed_STD3_mapped",
		[
			40,
			4354,
			41
		]
	],
	[
		[
			12802,
			12802
		],
		"disallowed_STD3_mapped",
		[
			40,
			4355,
			41
		]
	],
	[
		[
			12803,
			12803
		],
		"disallowed_STD3_mapped",
		[
			40,
			4357,
			41
		]
	],
	[
		[
			12804,
			12804
		],
		"disallowed_STD3_mapped",
		[
			40,
			4358,
			41
		]
	],
	[
		[
			12805,
			12805
		],
		"disallowed_STD3_mapped",
		[
			40,
			4359,
			41
		]
	],
	[
		[
			12806,
			12806
		],
		"disallowed_STD3_mapped",
		[
			40,
			4361,
			41
		]
	],
	[
		[
			12807,
			12807
		],
		"disallowed_STD3_mapped",
		[
			40,
			4363,
			41
		]
	],
	[
		[
			12808,
			12808
		],
		"disallowed_STD3_mapped",
		[
			40,
			4364,
			41
		]
	],
	[
		[
			12809,
			12809
		],
		"disallowed_STD3_mapped",
		[
			40,
			4366,
			41
		]
	],
	[
		[
			12810,
			12810
		],
		"disallowed_STD3_mapped",
		[
			40,
			4367,
			41
		]
	],
	[
		[
			12811,
			12811
		],
		"disallowed_STD3_mapped",
		[
			40,
			4368,
			41
		]
	],
	[
		[
			12812,
			12812
		],
		"disallowed_STD3_mapped",
		[
			40,
			4369,
			41
		]
	],
	[
		[
			12813,
			12813
		],
		"disallowed_STD3_mapped",
		[
			40,
			4370,
			41
		]
	],
	[
		[
			12814,
			12814
		],
		"disallowed_STD3_mapped",
		[
			40,
			44032,
			41
		]
	],
	[
		[
			12815,
			12815
		],
		"disallowed_STD3_mapped",
		[
			40,
			45208,
			41
		]
	],
	[
		[
			12816,
			12816
		],
		"disallowed_STD3_mapped",
		[
			40,
			45796,
			41
		]
	],
	[
		[
			12817,
			12817
		],
		"disallowed_STD3_mapped",
		[
			40,
			46972,
			41
		]
	],
	[
		[
			12818,
			12818
		],
		"disallowed_STD3_mapped",
		[
			40,
			47560,
			41
		]
	],
	[
		[
			12819,
			12819
		],
		"disallowed_STD3_mapped",
		[
			40,
			48148,
			41
		]
	],
	[
		[
			12820,
			12820
		],
		"disallowed_STD3_mapped",
		[
			40,
			49324,
			41
		]
	],
	[
		[
			12821,
			12821
		],
		"disallowed_STD3_mapped",
		[
			40,
			50500,
			41
		]
	],
	[
		[
			12822,
			12822
		],
		"disallowed_STD3_mapped",
		[
			40,
			51088,
			41
		]
	],
	[
		[
			12823,
			12823
		],
		"disallowed_STD3_mapped",
		[
			40,
			52264,
			41
		]
	],
	[
		[
			12824,
			12824
		],
		"disallowed_STD3_mapped",
		[
			40,
			52852,
			41
		]
	],
	[
		[
			12825,
			12825
		],
		"disallowed_STD3_mapped",
		[
			40,
			53440,
			41
		]
	],
	[
		[
			12826,
			12826
		],
		"disallowed_STD3_mapped",
		[
			40,
			54028,
			41
		]
	],
	[
		[
			12827,
			12827
		],
		"disallowed_STD3_mapped",
		[
			40,
			54616,
			41
		]
	],
	[
		[
			12828,
			12828
		],
		"disallowed_STD3_mapped",
		[
			40,
			51452,
			41
		]
	],
	[
		[
			12829,
			12829
		],
		"disallowed_STD3_mapped",
		[
			40,
			50724,
			51204,
			41
		]
	],
	[
		[
			12830,
			12830
		],
		"disallowed_STD3_mapped",
		[
			40,
			50724,
			54980,
			41
		]
	],
	[
		[
			12831,
			12831
		],
		"disallowed"
	],
	[
		[
			12832,
			12832
		],
		"disallowed_STD3_mapped",
		[
			40,
			19968,
			41
		]
	],
	[
		[
			12833,
			12833
		],
		"disallowed_STD3_mapped",
		[
			40,
			20108,
			41
		]
	],
	[
		[
			12834,
			12834
		],
		"disallowed_STD3_mapped",
		[
			40,
			19977,
			41
		]
	],
	[
		[
			12835,
			12835
		],
		"disallowed_STD3_mapped",
		[
			40,
			22235,
			41
		]
	],
	[
		[
			12836,
			12836
		],
		"disallowed_STD3_mapped",
		[
			40,
			20116,
			41
		]
	],
	[
		[
			12837,
			12837
		],
		"disallowed_STD3_mapped",
		[
			40,
			20845,
			41
		]
	],
	[
		[
			12838,
			12838
		],
		"disallowed_STD3_mapped",
		[
			40,
			19971,
			41
		]
	],
	[
		[
			12839,
			12839
		],
		"disallowed_STD3_mapped",
		[
			40,
			20843,
			41
		]
	],
	[
		[
			12840,
			12840
		],
		"disallowed_STD3_mapped",
		[
			40,
			20061,
			41
		]
	],
	[
		[
			12841,
			12841
		],
		"disallowed_STD3_mapped",
		[
			40,
			21313,
			41
		]
	],
	[
		[
			12842,
			12842
		],
		"disallowed_STD3_mapped",
		[
			40,
			26376,
			41
		]
	],
	[
		[
			12843,
			12843
		],
		"disallowed_STD3_mapped",
		[
			40,
			28779,
			41
		]
	],
	[
		[
			12844,
			12844
		],
		"disallowed_STD3_mapped",
		[
			40,
			27700,
			41
		]
	],
	[
		[
			12845,
			12845
		],
		"disallowed_STD3_mapped",
		[
			40,
			26408,
			41
		]
	],
	[
		[
			12846,
			12846
		],
		"disallowed_STD3_mapped",
		[
			40,
			37329,
			41
		]
	],
	[
		[
			12847,
			12847
		],
		"disallowed_STD3_mapped",
		[
			40,
			22303,
			41
		]
	],
	[
		[
			12848,
			12848
		],
		"disallowed_STD3_mapped",
		[
			40,
			26085,
			41
		]
	],
	[
		[
			12849,
			12849
		],
		"disallowed_STD3_mapped",
		[
			40,
			26666,
			41
		]
	],
	[
		[
			12850,
			12850
		],
		"disallowed_STD3_mapped",
		[
			40,
			26377,
			41
		]
	],
	[
		[
			12851,
			12851
		],
		"disallowed_STD3_mapped",
		[
			40,
			31038,
			41
		]
	],
	[
		[
			12852,
			12852
		],
		"disallowed_STD3_mapped",
		[
			40,
			21517,
			41
		]
	],
	[
		[
			12853,
			12853
		],
		"disallowed_STD3_mapped",
		[
			40,
			29305,
			41
		]
	],
	[
		[
			12854,
			12854
		],
		"disallowed_STD3_mapped",
		[
			40,
			36001,
			41
		]
	],
	[
		[
			12855,
			12855
		],
		"disallowed_STD3_mapped",
		[
			40,
			31069,
			41
		]
	],
	[
		[
			12856,
			12856
		],
		"disallowed_STD3_mapped",
		[
			40,
			21172,
			41
		]
	],
	[
		[
			12857,
			12857
		],
		"disallowed_STD3_mapped",
		[
			40,
			20195,
			41
		]
	],
	[
		[
			12858,
			12858
		],
		"disallowed_STD3_mapped",
		[
			40,
			21628,
			41
		]
	],
	[
		[
			12859,
			12859
		],
		"disallowed_STD3_mapped",
		[
			40,
			23398,
			41
		]
	],
	[
		[
			12860,
			12860
		],
		"disallowed_STD3_mapped",
		[
			40,
			30435,
			41
		]
	],
	[
		[
			12861,
			12861
		],
		"disallowed_STD3_mapped",
		[
			40,
			20225,
			41
		]
	],
	[
		[
			12862,
			12862
		],
		"disallowed_STD3_mapped",
		[
			40,
			36039,
			41
		]
	],
	[
		[
			12863,
			12863
		],
		"disallowed_STD3_mapped",
		[
			40,
			21332,
			41
		]
	],
	[
		[
			12864,
			12864
		],
		"disallowed_STD3_mapped",
		[
			40,
			31085,
			41
		]
	],
	[
		[
			12865,
			12865
		],
		"disallowed_STD3_mapped",
		[
			40,
			20241,
			41
		]
	],
	[
		[
			12866,
			12866
		],
		"disallowed_STD3_mapped",
		[
			40,
			33258,
			41
		]
	],
	[
		[
			12867,
			12867
		],
		"disallowed_STD3_mapped",
		[
			40,
			33267,
			41
		]
	],
	[
		[
			12868,
			12868
		],
		"mapped",
		[
			21839
		]
	],
	[
		[
			12869,
			12869
		],
		"mapped",
		[
			24188
		]
	],
	[
		[
			12870,
			12870
		],
		"mapped",
		[
			25991
		]
	],
	[
		[
			12871,
			12871
		],
		"mapped",
		[
			31631
		]
	],
	[
		[
			12872,
			12879
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			12880,
			12880
		],
		"mapped",
		[
			112,
			116,
			101
		]
	],
	[
		[
			12881,
			12881
		],
		"mapped",
		[
			50,
			49
		]
	],
	[
		[
			12882,
			12882
		],
		"mapped",
		[
			50,
			50
		]
	],
	[
		[
			12883,
			12883
		],
		"mapped",
		[
			50,
			51
		]
	],
	[
		[
			12884,
			12884
		],
		"mapped",
		[
			50,
			52
		]
	],
	[
		[
			12885,
			12885
		],
		"mapped",
		[
			50,
			53
		]
	],
	[
		[
			12886,
			12886
		],
		"mapped",
		[
			50,
			54
		]
	],
	[
		[
			12887,
			12887
		],
		"mapped",
		[
			50,
			55
		]
	],
	[
		[
			12888,
			12888
		],
		"mapped",
		[
			50,
			56
		]
	],
	[
		[
			12889,
			12889
		],
		"mapped",
		[
			50,
			57
		]
	],
	[
		[
			12890,
			12890
		],
		"mapped",
		[
			51,
			48
		]
	],
	[
		[
			12891,
			12891
		],
		"mapped",
		[
			51,
			49
		]
	],
	[
		[
			12892,
			12892
		],
		"mapped",
		[
			51,
			50
		]
	],
	[
		[
			12893,
			12893
		],
		"mapped",
		[
			51,
			51
		]
	],
	[
		[
			12894,
			12894
		],
		"mapped",
		[
			51,
			52
		]
	],
	[
		[
			12895,
			12895
		],
		"mapped",
		[
			51,
			53
		]
	],
	[
		[
			12896,
			12896
		],
		"mapped",
		[
			4352
		]
	],
	[
		[
			12897,
			12897
		],
		"mapped",
		[
			4354
		]
	],
	[
		[
			12898,
			12898
		],
		"mapped",
		[
			4355
		]
	],
	[
		[
			12899,
			12899
		],
		"mapped",
		[
			4357
		]
	],
	[
		[
			12900,
			12900
		],
		"mapped",
		[
			4358
		]
	],
	[
		[
			12901,
			12901
		],
		"mapped",
		[
			4359
		]
	],
	[
		[
			12902,
			12902
		],
		"mapped",
		[
			4361
		]
	],
	[
		[
			12903,
			12903
		],
		"mapped",
		[
			4363
		]
	],
	[
		[
			12904,
			12904
		],
		"mapped",
		[
			4364
		]
	],
	[
		[
			12905,
			12905
		],
		"mapped",
		[
			4366
		]
	],
	[
		[
			12906,
			12906
		],
		"mapped",
		[
			4367
		]
	],
	[
		[
			12907,
			12907
		],
		"mapped",
		[
			4368
		]
	],
	[
		[
			12908,
			12908
		],
		"mapped",
		[
			4369
		]
	],
	[
		[
			12909,
			12909
		],
		"mapped",
		[
			4370
		]
	],
	[
		[
			12910,
			12910
		],
		"mapped",
		[
			44032
		]
	],
	[
		[
			12911,
			12911
		],
		"mapped",
		[
			45208
		]
	],
	[
		[
			12912,
			12912
		],
		"mapped",
		[
			45796
		]
	],
	[
		[
			12913,
			12913
		],
		"mapped",
		[
			46972
		]
	],
	[
		[
			12914,
			12914
		],
		"mapped",
		[
			47560
		]
	],
	[
		[
			12915,
			12915
		],
		"mapped",
		[
			48148
		]
	],
	[
		[
			12916,
			12916
		],
		"mapped",
		[
			49324
		]
	],
	[
		[
			12917,
			12917
		],
		"mapped",
		[
			50500
		]
	],
	[
		[
			12918,
			12918
		],
		"mapped",
		[
			51088
		]
	],
	[
		[
			12919,
			12919
		],
		"mapped",
		[
			52264
		]
	],
	[
		[
			12920,
			12920
		],
		"mapped",
		[
			52852
		]
	],
	[
		[
			12921,
			12921
		],
		"mapped",
		[
			53440
		]
	],
	[
		[
			12922,
			12922
		],
		"mapped",
		[
			54028
		]
	],
	[
		[
			12923,
			12923
		],
		"mapped",
		[
			54616
		]
	],
	[
		[
			12924,
			12924
		],
		"mapped",
		[
			52280,
			44256
		]
	],
	[
		[
			12925,
			12925
		],
		"mapped",
		[
			51452,
			51032
		]
	],
	[
		[
			12926,
			12926
		],
		"mapped",
		[
			50864
		]
	],
	[
		[
			12927,
			12927
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			12928,
			12928
		],
		"mapped",
		[
			19968
		]
	],
	[
		[
			12929,
			12929
		],
		"mapped",
		[
			20108
		]
	],
	[
		[
			12930,
			12930
		],
		"mapped",
		[
			19977
		]
	],
	[
		[
			12931,
			12931
		],
		"mapped",
		[
			22235
		]
	],
	[
		[
			12932,
			12932
		],
		"mapped",
		[
			20116
		]
	],
	[
		[
			12933,
			12933
		],
		"mapped",
		[
			20845
		]
	],
	[
		[
			12934,
			12934
		],
		"mapped",
		[
			19971
		]
	],
	[
		[
			12935,
			12935
		],
		"mapped",
		[
			20843
		]
	],
	[
		[
			12936,
			12936
		],
		"mapped",
		[
			20061
		]
	],
	[
		[
			12937,
			12937
		],
		"mapped",
		[
			21313
		]
	],
	[
		[
			12938,
			12938
		],
		"mapped",
		[
			26376
		]
	],
	[
		[
			12939,
			12939
		],
		"mapped",
		[
			28779
		]
	],
	[
		[
			12940,
			12940
		],
		"mapped",
		[
			27700
		]
	],
	[
		[
			12941,
			12941
		],
		"mapped",
		[
			26408
		]
	],
	[
		[
			12942,
			12942
		],
		"mapped",
		[
			37329
		]
	],
	[
		[
			12943,
			12943
		],
		"mapped",
		[
			22303
		]
	],
	[
		[
			12944,
			12944
		],
		"mapped",
		[
			26085
		]
	],
	[
		[
			12945,
			12945
		],
		"mapped",
		[
			26666
		]
	],
	[
		[
			12946,
			12946
		],
		"mapped",
		[
			26377
		]
	],
	[
		[
			12947,
			12947
		],
		"mapped",
		[
			31038
		]
	],
	[
		[
			12948,
			12948
		],
		"mapped",
		[
			21517
		]
	],
	[
		[
			12949,
			12949
		],
		"mapped",
		[
			29305
		]
	],
	[
		[
			12950,
			12950
		],
		"mapped",
		[
			36001
		]
	],
	[
		[
			12951,
			12951
		],
		"mapped",
		[
			31069
		]
	],
	[
		[
			12952,
			12952
		],
		"mapped",
		[
			21172
		]
	],
	[
		[
			12953,
			12953
		],
		"mapped",
		[
			31192
		]
	],
	[
		[
			12954,
			12954
		],
		"mapped",
		[
			30007
		]
	],
	[
		[
			12955,
			12955
		],
		"mapped",
		[
			22899
		]
	],
	[
		[
			12956,
			12956
		],
		"mapped",
		[
			36969
		]
	],
	[
		[
			12957,
			12957
		],
		"mapped",
		[
			20778
		]
	],
	[
		[
			12958,
			12958
		],
		"mapped",
		[
			21360
		]
	],
	[
		[
			12959,
			12959
		],
		"mapped",
		[
			27880
		]
	],
	[
		[
			12960,
			12960
		],
		"mapped",
		[
			38917
		]
	],
	[
		[
			12961,
			12961
		],
		"mapped",
		[
			20241
		]
	],
	[
		[
			12962,
			12962
		],
		"mapped",
		[
			20889
		]
	],
	[
		[
			12963,
			12963
		],
		"mapped",
		[
			27491
		]
	],
	[
		[
			12964,
			12964
		],
		"mapped",
		[
			19978
		]
	],
	[
		[
			12965,
			12965
		],
		"mapped",
		[
			20013
		]
	],
	[
		[
			12966,
			12966
		],
		"mapped",
		[
			19979
		]
	],
	[
		[
			12967,
			12967
		],
		"mapped",
		[
			24038
		]
	],
	[
		[
			12968,
			12968
		],
		"mapped",
		[
			21491
		]
	],
	[
		[
			12969,
			12969
		],
		"mapped",
		[
			21307
		]
	],
	[
		[
			12970,
			12970
		],
		"mapped",
		[
			23447
		]
	],
	[
		[
			12971,
			12971
		],
		"mapped",
		[
			23398
		]
	],
	[
		[
			12972,
			12972
		],
		"mapped",
		[
			30435
		]
	],
	[
		[
			12973,
			12973
		],
		"mapped",
		[
			20225
		]
	],
	[
		[
			12974,
			12974
		],
		"mapped",
		[
			36039
		]
	],
	[
		[
			12975,
			12975
		],
		"mapped",
		[
			21332
		]
	],
	[
		[
			12976,
			12976
		],
		"mapped",
		[
			22812
		]
	],
	[
		[
			12977,
			12977
		],
		"mapped",
		[
			51,
			54
		]
	],
	[
		[
			12978,
			12978
		],
		"mapped",
		[
			51,
			55
		]
	],
	[
		[
			12979,
			12979
		],
		"mapped",
		[
			51,
			56
		]
	],
	[
		[
			12980,
			12980
		],
		"mapped",
		[
			51,
			57
		]
	],
	[
		[
			12981,
			12981
		],
		"mapped",
		[
			52,
			48
		]
	],
	[
		[
			12982,
			12982
		],
		"mapped",
		[
			52,
			49
		]
	],
	[
		[
			12983,
			12983
		],
		"mapped",
		[
			52,
			50
		]
	],
	[
		[
			12984,
			12984
		],
		"mapped",
		[
			52,
			51
		]
	],
	[
		[
			12985,
			12985
		],
		"mapped",
		[
			52,
			52
		]
	],
	[
		[
			12986,
			12986
		],
		"mapped",
		[
			52,
			53
		]
	],
	[
		[
			12987,
			12987
		],
		"mapped",
		[
			52,
			54
		]
	],
	[
		[
			12988,
			12988
		],
		"mapped",
		[
			52,
			55
		]
	],
	[
		[
			12989,
			12989
		],
		"mapped",
		[
			52,
			56
		]
	],
	[
		[
			12990,
			12990
		],
		"mapped",
		[
			52,
			57
		]
	],
	[
		[
			12991,
			12991
		],
		"mapped",
		[
			53,
			48
		]
	],
	[
		[
			12992,
			12992
		],
		"mapped",
		[
			49,
			26376
		]
	],
	[
		[
			12993,
			12993
		],
		"mapped",
		[
			50,
			26376
		]
	],
	[
		[
			12994,
			12994
		],
		"mapped",
		[
			51,
			26376
		]
	],
	[
		[
			12995,
			12995
		],
		"mapped",
		[
			52,
			26376
		]
	],
	[
		[
			12996,
			12996
		],
		"mapped",
		[
			53,
			26376
		]
	],
	[
		[
			12997,
			12997
		],
		"mapped",
		[
			54,
			26376
		]
	],
	[
		[
			12998,
			12998
		],
		"mapped",
		[
			55,
			26376
		]
	],
	[
		[
			12999,
			12999
		],
		"mapped",
		[
			56,
			26376
		]
	],
	[
		[
			13000,
			13000
		],
		"mapped",
		[
			57,
			26376
		]
	],
	[
		[
			13001,
			13001
		],
		"mapped",
		[
			49,
			48,
			26376
		]
	],
	[
		[
			13002,
			13002
		],
		"mapped",
		[
			49,
			49,
			26376
		]
	],
	[
		[
			13003,
			13003
		],
		"mapped",
		[
			49,
			50,
			26376
		]
	],
	[
		[
			13004,
			13004
		],
		"mapped",
		[
			104,
			103
		]
	],
	[
		[
			13005,
			13005
		],
		"mapped",
		[
			101,
			114,
			103
		]
	],
	[
		[
			13006,
			13006
		],
		"mapped",
		[
			101,
			118
		]
	],
	[
		[
			13007,
			13007
		],
		"mapped",
		[
			108,
			116,
			100
		]
	],
	[
		[
			13008,
			13008
		],
		"mapped",
		[
			12450
		]
	],
	[
		[
			13009,
			13009
		],
		"mapped",
		[
			12452
		]
	],
	[
		[
			13010,
			13010
		],
		"mapped",
		[
			12454
		]
	],
	[
		[
			13011,
			13011
		],
		"mapped",
		[
			12456
		]
	],
	[
		[
			13012,
			13012
		],
		"mapped",
		[
			12458
		]
	],
	[
		[
			13013,
			13013
		],
		"mapped",
		[
			12459
		]
	],
	[
		[
			13014,
			13014
		],
		"mapped",
		[
			12461
		]
	],
	[
		[
			13015,
			13015
		],
		"mapped",
		[
			12463
		]
	],
	[
		[
			13016,
			13016
		],
		"mapped",
		[
			12465
		]
	],
	[
		[
			13017,
			13017
		],
		"mapped",
		[
			12467
		]
	],
	[
		[
			13018,
			13018
		],
		"mapped",
		[
			12469
		]
	],
	[
		[
			13019,
			13019
		],
		"mapped",
		[
			12471
		]
	],
	[
		[
			13020,
			13020
		],
		"mapped",
		[
			12473
		]
	],
	[
		[
			13021,
			13021
		],
		"mapped",
		[
			12475
		]
	],
	[
		[
			13022,
			13022
		],
		"mapped",
		[
			12477
		]
	],
	[
		[
			13023,
			13023
		],
		"mapped",
		[
			12479
		]
	],
	[
		[
			13024,
			13024
		],
		"mapped",
		[
			12481
		]
	],
	[
		[
			13025,
			13025
		],
		"mapped",
		[
			12484
		]
	],
	[
		[
			13026,
			13026
		],
		"mapped",
		[
			12486
		]
	],
	[
		[
			13027,
			13027
		],
		"mapped",
		[
			12488
		]
	],
	[
		[
			13028,
			13028
		],
		"mapped",
		[
			12490
		]
	],
	[
		[
			13029,
			13029
		],
		"mapped",
		[
			12491
		]
	],
	[
		[
			13030,
			13030
		],
		"mapped",
		[
			12492
		]
	],
	[
		[
			13031,
			13031
		],
		"mapped",
		[
			12493
		]
	],
	[
		[
			13032,
			13032
		],
		"mapped",
		[
			12494
		]
	],
	[
		[
			13033,
			13033
		],
		"mapped",
		[
			12495
		]
	],
	[
		[
			13034,
			13034
		],
		"mapped",
		[
			12498
		]
	],
	[
		[
			13035,
			13035
		],
		"mapped",
		[
			12501
		]
	],
	[
		[
			13036,
			13036
		],
		"mapped",
		[
			12504
		]
	],
	[
		[
			13037,
			13037
		],
		"mapped",
		[
			12507
		]
	],
	[
		[
			13038,
			13038
		],
		"mapped",
		[
			12510
		]
	],
	[
		[
			13039,
			13039
		],
		"mapped",
		[
			12511
		]
	],
	[
		[
			13040,
			13040
		],
		"mapped",
		[
			12512
		]
	],
	[
		[
			13041,
			13041
		],
		"mapped",
		[
			12513
		]
	],
	[
		[
			13042,
			13042
		],
		"mapped",
		[
			12514
		]
	],
	[
		[
			13043,
			13043
		],
		"mapped",
		[
			12516
		]
	],
	[
		[
			13044,
			13044
		],
		"mapped",
		[
			12518
		]
	],
	[
		[
			13045,
			13045
		],
		"mapped",
		[
			12520
		]
	],
	[
		[
			13046,
			13046
		],
		"mapped",
		[
			12521
		]
	],
	[
		[
			13047,
			13047
		],
		"mapped",
		[
			12522
		]
	],
	[
		[
			13048,
			13048
		],
		"mapped",
		[
			12523
		]
	],
	[
		[
			13049,
			13049
		],
		"mapped",
		[
			12524
		]
	],
	[
		[
			13050,
			13050
		],
		"mapped",
		[
			12525
		]
	],
	[
		[
			13051,
			13051
		],
		"mapped",
		[
			12527
		]
	],
	[
		[
			13052,
			13052
		],
		"mapped",
		[
			12528
		]
	],
	[
		[
			13053,
			13053
		],
		"mapped",
		[
			12529
		]
	],
	[
		[
			13054,
			13054
		],
		"mapped",
		[
			12530
		]
	],
	[
		[
			13055,
			13055
		],
		"disallowed"
	],
	[
		[
			13056,
			13056
		],
		"mapped",
		[
			12450,
			12497,
			12540,
			12488
		]
	],
	[
		[
			13057,
			13057
		],
		"mapped",
		[
			12450,
			12523,
			12501,
			12449
		]
	],
	[
		[
			13058,
			13058
		],
		"mapped",
		[
			12450,
			12531,
			12506,
			12450
		]
	],
	[
		[
			13059,
			13059
		],
		"mapped",
		[
			12450,
			12540,
			12523
		]
	],
	[
		[
			13060,
			13060
		],
		"mapped",
		[
			12452,
			12491,
			12531,
			12464
		]
	],
	[
		[
			13061,
			13061
		],
		"mapped",
		[
			12452,
			12531,
			12481
		]
	],
	[
		[
			13062,
			13062
		],
		"mapped",
		[
			12454,
			12457,
			12531
		]
	],
	[
		[
			13063,
			13063
		],
		"mapped",
		[
			12456,
			12473,
			12463,
			12540,
			12489
		]
	],
	[
		[
			13064,
			13064
		],
		"mapped",
		[
			12456,
			12540,
			12459,
			12540
		]
	],
	[
		[
			13065,
			13065
		],
		"mapped",
		[
			12458,
			12531,
			12473
		]
	],
	[
		[
			13066,
			13066
		],
		"mapped",
		[
			12458,
			12540,
			12512
		]
	],
	[
		[
			13067,
			13067
		],
		"mapped",
		[
			12459,
			12452,
			12522
		]
	],
	[
		[
			13068,
			13068
		],
		"mapped",
		[
			12459,
			12521,
			12483,
			12488
		]
	],
	[
		[
			13069,
			13069
		],
		"mapped",
		[
			12459,
			12525,
			12522,
			12540
		]
	],
	[
		[
			13070,
			13070
		],
		"mapped",
		[
			12460,
			12525,
			12531
		]
	],
	[
		[
			13071,
			13071
		],
		"mapped",
		[
			12460,
			12531,
			12510
		]
	],
	[
		[
			13072,
			13072
		],
		"mapped",
		[
			12462,
			12460
		]
	],
	[
		[
			13073,
			13073
		],
		"mapped",
		[
			12462,
			12491,
			12540
		]
	],
	[
		[
			13074,
			13074
		],
		"mapped",
		[
			12461,
			12517,
			12522,
			12540
		]
	],
	[
		[
			13075,
			13075
		],
		"mapped",
		[
			12462,
			12523,
			12480,
			12540
		]
	],
	[
		[
			13076,
			13076
		],
		"mapped",
		[
			12461,
			12525
		]
	],
	[
		[
			13077,
			13077
		],
		"mapped",
		[
			12461,
			12525,
			12464,
			12521,
			12512
		]
	],
	[
		[
			13078,
			13078
		],
		"mapped",
		[
			12461,
			12525,
			12513,
			12540,
			12488,
			12523
		]
	],
	[
		[
			13079,
			13079
		],
		"mapped",
		[
			12461,
			12525,
			12527,
			12483,
			12488
		]
	],
	[
		[
			13080,
			13080
		],
		"mapped",
		[
			12464,
			12521,
			12512
		]
	],
	[
		[
			13081,
			13081
		],
		"mapped",
		[
			12464,
			12521,
			12512,
			12488,
			12531
		]
	],
	[
		[
			13082,
			13082
		],
		"mapped",
		[
			12463,
			12523,
			12476,
			12452,
			12525
		]
	],
	[
		[
			13083,
			13083
		],
		"mapped",
		[
			12463,
			12525,
			12540,
			12493
		]
	],
	[
		[
			13084,
			13084
		],
		"mapped",
		[
			12465,
			12540,
			12473
		]
	],
	[
		[
			13085,
			13085
		],
		"mapped",
		[
			12467,
			12523,
			12490
		]
	],
	[
		[
			13086,
			13086
		],
		"mapped",
		[
			12467,
			12540,
			12509
		]
	],
	[
		[
			13087,
			13087
		],
		"mapped",
		[
			12469,
			12452,
			12463,
			12523
		]
	],
	[
		[
			13088,
			13088
		],
		"mapped",
		[
			12469,
			12531,
			12481,
			12540,
			12512
		]
	],
	[
		[
			13089,
			13089
		],
		"mapped",
		[
			12471,
			12522,
			12531,
			12464
		]
	],
	[
		[
			13090,
			13090
		],
		"mapped",
		[
			12475,
			12531,
			12481
		]
	],
	[
		[
			13091,
			13091
		],
		"mapped",
		[
			12475,
			12531,
			12488
		]
	],
	[
		[
			13092,
			13092
		],
		"mapped",
		[
			12480,
			12540,
			12473
		]
	],
	[
		[
			13093,
			13093
		],
		"mapped",
		[
			12487,
			12471
		]
	],
	[
		[
			13094,
			13094
		],
		"mapped",
		[
			12489,
			12523
		]
	],
	[
		[
			13095,
			13095
		],
		"mapped",
		[
			12488,
			12531
		]
	],
	[
		[
			13096,
			13096
		],
		"mapped",
		[
			12490,
			12494
		]
	],
	[
		[
			13097,
			13097
		],
		"mapped",
		[
			12494,
			12483,
			12488
		]
	],
	[
		[
			13098,
			13098
		],
		"mapped",
		[
			12495,
			12452,
			12484
		]
	],
	[
		[
			13099,
			13099
		],
		"mapped",
		[
			12497,
			12540,
			12475,
			12531,
			12488
		]
	],
	[
		[
			13100,
			13100
		],
		"mapped",
		[
			12497,
			12540,
			12484
		]
	],
	[
		[
			13101,
			13101
		],
		"mapped",
		[
			12496,
			12540,
			12524,
			12523
		]
	],
	[
		[
			13102,
			13102
		],
		"mapped",
		[
			12500,
			12450,
			12473,
			12488,
			12523
		]
	],
	[
		[
			13103,
			13103
		],
		"mapped",
		[
			12500,
			12463,
			12523
		]
	],
	[
		[
			13104,
			13104
		],
		"mapped",
		[
			12500,
			12467
		]
	],
	[
		[
			13105,
			13105
		],
		"mapped",
		[
			12499,
			12523
		]
	],
	[
		[
			13106,
			13106
		],
		"mapped",
		[
			12501,
			12449,
			12521,
			12483,
			12489
		]
	],
	[
		[
			13107,
			13107
		],
		"mapped",
		[
			12501,
			12451,
			12540,
			12488
		]
	],
	[
		[
			13108,
			13108
		],
		"mapped",
		[
			12502,
			12483,
			12471,
			12455,
			12523
		]
	],
	[
		[
			13109,
			13109
		],
		"mapped",
		[
			12501,
			12521,
			12531
		]
	],
	[
		[
			13110,
			13110
		],
		"mapped",
		[
			12504,
			12463,
			12479,
			12540,
			12523
		]
	],
	[
		[
			13111,
			13111
		],
		"mapped",
		[
			12506,
			12477
		]
	],
	[
		[
			13112,
			13112
		],
		"mapped",
		[
			12506,
			12491,
			12498
		]
	],
	[
		[
			13113,
			13113
		],
		"mapped",
		[
			12504,
			12523,
			12484
		]
	],
	[
		[
			13114,
			13114
		],
		"mapped",
		[
			12506,
			12531,
			12473
		]
	],
	[
		[
			13115,
			13115
		],
		"mapped",
		[
			12506,
			12540,
			12472
		]
	],
	[
		[
			13116,
			13116
		],
		"mapped",
		[
			12505,
			12540,
			12479
		]
	],
	[
		[
			13117,
			13117
		],
		"mapped",
		[
			12509,
			12452,
			12531,
			12488
		]
	],
	[
		[
			13118,
			13118
		],
		"mapped",
		[
			12508,
			12523,
			12488
		]
	],
	[
		[
			13119,
			13119
		],
		"mapped",
		[
			12507,
			12531
		]
	],
	[
		[
			13120,
			13120
		],
		"mapped",
		[
			12509,
			12531,
			12489
		]
	],
	[
		[
			13121,
			13121
		],
		"mapped",
		[
			12507,
			12540,
			12523
		]
	],
	[
		[
			13122,
			13122
		],
		"mapped",
		[
			12507,
			12540,
			12531
		]
	],
	[
		[
			13123,
			13123
		],
		"mapped",
		[
			12510,
			12452,
			12463,
			12525
		]
	],
	[
		[
			13124,
			13124
		],
		"mapped",
		[
			12510,
			12452,
			12523
		]
	],
	[
		[
			13125,
			13125
		],
		"mapped",
		[
			12510,
			12483,
			12495
		]
	],
	[
		[
			13126,
			13126
		],
		"mapped",
		[
			12510,
			12523,
			12463
		]
	],
	[
		[
			13127,
			13127
		],
		"mapped",
		[
			12510,
			12531,
			12471,
			12519,
			12531
		]
	],
	[
		[
			13128,
			13128
		],
		"mapped",
		[
			12511,
			12463,
			12525,
			12531
		]
	],
	[
		[
			13129,
			13129
		],
		"mapped",
		[
			12511,
			12522
		]
	],
	[
		[
			13130,
			13130
		],
		"mapped",
		[
			12511,
			12522,
			12496,
			12540,
			12523
		]
	],
	[
		[
			13131,
			13131
		],
		"mapped",
		[
			12513,
			12460
		]
	],
	[
		[
			13132,
			13132
		],
		"mapped",
		[
			12513,
			12460,
			12488,
			12531
		]
	],
	[
		[
			13133,
			13133
		],
		"mapped",
		[
			12513,
			12540,
			12488,
			12523
		]
	],
	[
		[
			13134,
			13134
		],
		"mapped",
		[
			12516,
			12540,
			12489
		]
	],
	[
		[
			13135,
			13135
		],
		"mapped",
		[
			12516,
			12540,
			12523
		]
	],
	[
		[
			13136,
			13136
		],
		"mapped",
		[
			12518,
			12450,
			12531
		]
	],
	[
		[
			13137,
			13137
		],
		"mapped",
		[
			12522,
			12483,
			12488,
			12523
		]
	],
	[
		[
			13138,
			13138
		],
		"mapped",
		[
			12522,
			12521
		]
	],
	[
		[
			13139,
			13139
		],
		"mapped",
		[
			12523,
			12500,
			12540
		]
	],
	[
		[
			13140,
			13140
		],
		"mapped",
		[
			12523,
			12540,
			12502,
			12523
		]
	],
	[
		[
			13141,
			13141
		],
		"mapped",
		[
			12524,
			12512
		]
	],
	[
		[
			13142,
			13142
		],
		"mapped",
		[
			12524,
			12531,
			12488,
			12466,
			12531
		]
	],
	[
		[
			13143,
			13143
		],
		"mapped",
		[
			12527,
			12483,
			12488
		]
	],
	[
		[
			13144,
			13144
		],
		"mapped",
		[
			48,
			28857
		]
	],
	[
		[
			13145,
			13145
		],
		"mapped",
		[
			49,
			28857
		]
	],
	[
		[
			13146,
			13146
		],
		"mapped",
		[
			50,
			28857
		]
	],
	[
		[
			13147,
			13147
		],
		"mapped",
		[
			51,
			28857
		]
	],
	[
		[
			13148,
			13148
		],
		"mapped",
		[
			52,
			28857
		]
	],
	[
		[
			13149,
			13149
		],
		"mapped",
		[
			53,
			28857
		]
	],
	[
		[
			13150,
			13150
		],
		"mapped",
		[
			54,
			28857
		]
	],
	[
		[
			13151,
			13151
		],
		"mapped",
		[
			55,
			28857
		]
	],
	[
		[
			13152,
			13152
		],
		"mapped",
		[
			56,
			28857
		]
	],
	[
		[
			13153,
			13153
		],
		"mapped",
		[
			57,
			28857
		]
	],
	[
		[
			13154,
			13154
		],
		"mapped",
		[
			49,
			48,
			28857
		]
	],
	[
		[
			13155,
			13155
		],
		"mapped",
		[
			49,
			49,
			28857
		]
	],
	[
		[
			13156,
			13156
		],
		"mapped",
		[
			49,
			50,
			28857
		]
	],
	[
		[
			13157,
			13157
		],
		"mapped",
		[
			49,
			51,
			28857
		]
	],
	[
		[
			13158,
			13158
		],
		"mapped",
		[
			49,
			52,
			28857
		]
	],
	[
		[
			13159,
			13159
		],
		"mapped",
		[
			49,
			53,
			28857
		]
	],
	[
		[
			13160,
			13160
		],
		"mapped",
		[
			49,
			54,
			28857
		]
	],
	[
		[
			13161,
			13161
		],
		"mapped",
		[
			49,
			55,
			28857
		]
	],
	[
		[
			13162,
			13162
		],
		"mapped",
		[
			49,
			56,
			28857
		]
	],
	[
		[
			13163,
			13163
		],
		"mapped",
		[
			49,
			57,
			28857
		]
	],
	[
		[
			13164,
			13164
		],
		"mapped",
		[
			50,
			48,
			28857
		]
	],
	[
		[
			13165,
			13165
		],
		"mapped",
		[
			50,
			49,
			28857
		]
	],
	[
		[
			13166,
			13166
		],
		"mapped",
		[
			50,
			50,
			28857
		]
	],
	[
		[
			13167,
			13167
		],
		"mapped",
		[
			50,
			51,
			28857
		]
	],
	[
		[
			13168,
			13168
		],
		"mapped",
		[
			50,
			52,
			28857
		]
	],
	[
		[
			13169,
			13169
		],
		"mapped",
		[
			104,
			112,
			97
		]
	],
	[
		[
			13170,
			13170
		],
		"mapped",
		[
			100,
			97
		]
	],
	[
		[
			13171,
			13171
		],
		"mapped",
		[
			97,
			117
		]
	],
	[
		[
			13172,
			13172
		],
		"mapped",
		[
			98,
			97,
			114
		]
	],
	[
		[
			13173,
			13173
		],
		"mapped",
		[
			111,
			118
		]
	],
	[
		[
			13174,
			13174
		],
		"mapped",
		[
			112,
			99
		]
	],
	[
		[
			13175,
			13175
		],
		"mapped",
		[
			100,
			109
		]
	],
	[
		[
			13176,
			13176
		],
		"mapped",
		[
			100,
			109,
			50
		]
	],
	[
		[
			13177,
			13177
		],
		"mapped",
		[
			100,
			109,
			51
		]
	],
	[
		[
			13178,
			13178
		],
		"mapped",
		[
			105,
			117
		]
	],
	[
		[
			13179,
			13179
		],
		"mapped",
		[
			24179,
			25104
		]
	],
	[
		[
			13180,
			13180
		],
		"mapped",
		[
			26157,
			21644
		]
	],
	[
		[
			13181,
			13181
		],
		"mapped",
		[
			22823,
			27491
		]
	],
	[
		[
			13182,
			13182
		],
		"mapped",
		[
			26126,
			27835
		]
	],
	[
		[
			13183,
			13183
		],
		"mapped",
		[
			26666,
			24335,
			20250,
			31038
		]
	],
	[
		[
			13184,
			13184
		],
		"mapped",
		[
			112,
			97
		]
	],
	[
		[
			13185,
			13185
		],
		"mapped",
		[
			110,
			97
		]
	],
	[
		[
			13186,
			13186
		],
		"mapped",
		[
			956,
			97
		]
	],
	[
		[
			13187,
			13187
		],
		"mapped",
		[
			109,
			97
		]
	],
	[
		[
			13188,
			13188
		],
		"mapped",
		[
			107,
			97
		]
	],
	[
		[
			13189,
			13189
		],
		"mapped",
		[
			107,
			98
		]
	],
	[
		[
			13190,
			13190
		],
		"mapped",
		[
			109,
			98
		]
	],
	[
		[
			13191,
			13191
		],
		"mapped",
		[
			103,
			98
		]
	],
	[
		[
			13192,
			13192
		],
		"mapped",
		[
			99,
			97,
			108
		]
	],
	[
		[
			13193,
			13193
		],
		"mapped",
		[
			107,
			99,
			97,
			108
		]
	],
	[
		[
			13194,
			13194
		],
		"mapped",
		[
			112,
			102
		]
	],
	[
		[
			13195,
			13195
		],
		"mapped",
		[
			110,
			102
		]
	],
	[
		[
			13196,
			13196
		],
		"mapped",
		[
			956,
			102
		]
	],
	[
		[
			13197,
			13197
		],
		"mapped",
		[
			956,
			103
		]
	],
	[
		[
			13198,
			13198
		],
		"mapped",
		[
			109,
			103
		]
	],
	[
		[
			13199,
			13199
		],
		"mapped",
		[
			107,
			103
		]
	],
	[
		[
			13200,
			13200
		],
		"mapped",
		[
			104,
			122
		]
	],
	[
		[
			13201,
			13201
		],
		"mapped",
		[
			107,
			104,
			122
		]
	],
	[
		[
			13202,
			13202
		],
		"mapped",
		[
			109,
			104,
			122
		]
	],
	[
		[
			13203,
			13203
		],
		"mapped",
		[
			103,
			104,
			122
		]
	],
	[
		[
			13204,
			13204
		],
		"mapped",
		[
			116,
			104,
			122
		]
	],
	[
		[
			13205,
			13205
		],
		"mapped",
		[
			956,
			108
		]
	],
	[
		[
			13206,
			13206
		],
		"mapped",
		[
			109,
			108
		]
	],
	[
		[
			13207,
			13207
		],
		"mapped",
		[
			100,
			108
		]
	],
	[
		[
			13208,
			13208
		],
		"mapped",
		[
			107,
			108
		]
	],
	[
		[
			13209,
			13209
		],
		"mapped",
		[
			102,
			109
		]
	],
	[
		[
			13210,
			13210
		],
		"mapped",
		[
			110,
			109
		]
	],
	[
		[
			13211,
			13211
		],
		"mapped",
		[
			956,
			109
		]
	],
	[
		[
			13212,
			13212
		],
		"mapped",
		[
			109,
			109
		]
	],
	[
		[
			13213,
			13213
		],
		"mapped",
		[
			99,
			109
		]
	],
	[
		[
			13214,
			13214
		],
		"mapped",
		[
			107,
			109
		]
	],
	[
		[
			13215,
			13215
		],
		"mapped",
		[
			109,
			109,
			50
		]
	],
	[
		[
			13216,
			13216
		],
		"mapped",
		[
			99,
			109,
			50
		]
	],
	[
		[
			13217,
			13217
		],
		"mapped",
		[
			109,
			50
		]
	],
	[
		[
			13218,
			13218
		],
		"mapped",
		[
			107,
			109,
			50
		]
	],
	[
		[
			13219,
			13219
		],
		"mapped",
		[
			109,
			109,
			51
		]
	],
	[
		[
			13220,
			13220
		],
		"mapped",
		[
			99,
			109,
			51
		]
	],
	[
		[
			13221,
			13221
		],
		"mapped",
		[
			109,
			51
		]
	],
	[
		[
			13222,
			13222
		],
		"mapped",
		[
			107,
			109,
			51
		]
	],
	[
		[
			13223,
			13223
		],
		"mapped",
		[
			109,
			8725,
			115
		]
	],
	[
		[
			13224,
			13224
		],
		"mapped",
		[
			109,
			8725,
			115,
			50
		]
	],
	[
		[
			13225,
			13225
		],
		"mapped",
		[
			112,
			97
		]
	],
	[
		[
			13226,
			13226
		],
		"mapped",
		[
			107,
			112,
			97
		]
	],
	[
		[
			13227,
			13227
		],
		"mapped",
		[
			109,
			112,
			97
		]
	],
	[
		[
			13228,
			13228
		],
		"mapped",
		[
			103,
			112,
			97
		]
	],
	[
		[
			13229,
			13229
		],
		"mapped",
		[
			114,
			97,
			100
		]
	],
	[
		[
			13230,
			13230
		],
		"mapped",
		[
			114,
			97,
			100,
			8725,
			115
		]
	],
	[
		[
			13231,
			13231
		],
		"mapped",
		[
			114,
			97,
			100,
			8725,
			115,
			50
		]
	],
	[
		[
			13232,
			13232
		],
		"mapped",
		[
			112,
			115
		]
	],
	[
		[
			13233,
			13233
		],
		"mapped",
		[
			110,
			115
		]
	],
	[
		[
			13234,
			13234
		],
		"mapped",
		[
			956,
			115
		]
	],
	[
		[
			13235,
			13235
		],
		"mapped",
		[
			109,
			115
		]
	],
	[
		[
			13236,
			13236
		],
		"mapped",
		[
			112,
			118
		]
	],
	[
		[
			13237,
			13237
		],
		"mapped",
		[
			110,
			118
		]
	],
	[
		[
			13238,
			13238
		],
		"mapped",
		[
			956,
			118
		]
	],
	[
		[
			13239,
			13239
		],
		"mapped",
		[
			109,
			118
		]
	],
	[
		[
			13240,
			13240
		],
		"mapped",
		[
			107,
			118
		]
	],
	[
		[
			13241,
			13241
		],
		"mapped",
		[
			109,
			118
		]
	],
	[
		[
			13242,
			13242
		],
		"mapped",
		[
			112,
			119
		]
	],
	[
		[
			13243,
			13243
		],
		"mapped",
		[
			110,
			119
		]
	],
	[
		[
			13244,
			13244
		],
		"mapped",
		[
			956,
			119
		]
	],
	[
		[
			13245,
			13245
		],
		"mapped",
		[
			109,
			119
		]
	],
	[
		[
			13246,
			13246
		],
		"mapped",
		[
			107,
			119
		]
	],
	[
		[
			13247,
			13247
		],
		"mapped",
		[
			109,
			119
		]
	],
	[
		[
			13248,
			13248
		],
		"mapped",
		[
			107,
			969
		]
	],
	[
		[
			13249,
			13249
		],
		"mapped",
		[
			109,
			969
		]
	],
	[
		[
			13250,
			13250
		],
		"disallowed"
	],
	[
		[
			13251,
			13251
		],
		"mapped",
		[
			98,
			113
		]
	],
	[
		[
			13252,
			13252
		],
		"mapped",
		[
			99,
			99
		]
	],
	[
		[
			13253,
			13253
		],
		"mapped",
		[
			99,
			100
		]
	],
	[
		[
			13254,
			13254
		],
		"mapped",
		[
			99,
			8725,
			107,
			103
		]
	],
	[
		[
			13255,
			13255
		],
		"disallowed"
	],
	[
		[
			13256,
			13256
		],
		"mapped",
		[
			100,
			98
		]
	],
	[
		[
			13257,
			13257
		],
		"mapped",
		[
			103,
			121
		]
	],
	[
		[
			13258,
			13258
		],
		"mapped",
		[
			104,
			97
		]
	],
	[
		[
			13259,
			13259
		],
		"mapped",
		[
			104,
			112
		]
	],
	[
		[
			13260,
			13260
		],
		"mapped",
		[
			105,
			110
		]
	],
	[
		[
			13261,
			13261
		],
		"mapped",
		[
			107,
			107
		]
	],
	[
		[
			13262,
			13262
		],
		"mapped",
		[
			107,
			109
		]
	],
	[
		[
			13263,
			13263
		],
		"mapped",
		[
			107,
			116
		]
	],
	[
		[
			13264,
			13264
		],
		"mapped",
		[
			108,
			109
		]
	],
	[
		[
			13265,
			13265
		],
		"mapped",
		[
			108,
			110
		]
	],
	[
		[
			13266,
			13266
		],
		"mapped",
		[
			108,
			111,
			103
		]
	],
	[
		[
			13267,
			13267
		],
		"mapped",
		[
			108,
			120
		]
	],
	[
		[
			13268,
			13268
		],
		"mapped",
		[
			109,
			98
		]
	],
	[
		[
			13269,
			13269
		],
		"mapped",
		[
			109,
			105,
			108
		]
	],
	[
		[
			13270,
			13270
		],
		"mapped",
		[
			109,
			111,
			108
		]
	],
	[
		[
			13271,
			13271
		],
		"mapped",
		[
			112,
			104
		]
	],
	[
		[
			13272,
			13272
		],
		"disallowed"
	],
	[
		[
			13273,
			13273
		],
		"mapped",
		[
			112,
			112,
			109
		]
	],
	[
		[
			13274,
			13274
		],
		"mapped",
		[
			112,
			114
		]
	],
	[
		[
			13275,
			13275
		],
		"mapped",
		[
			115,
			114
		]
	],
	[
		[
			13276,
			13276
		],
		"mapped",
		[
			115,
			118
		]
	],
	[
		[
			13277,
			13277
		],
		"mapped",
		[
			119,
			98
		]
	],
	[
		[
			13278,
			13278
		],
		"mapped",
		[
			118,
			8725,
			109
		]
	],
	[
		[
			13279,
			13279
		],
		"mapped",
		[
			97,
			8725,
			109
		]
	],
	[
		[
			13280,
			13280
		],
		"mapped",
		[
			49,
			26085
		]
	],
	[
		[
			13281,
			13281
		],
		"mapped",
		[
			50,
			26085
		]
	],
	[
		[
			13282,
			13282
		],
		"mapped",
		[
			51,
			26085
		]
	],
	[
		[
			13283,
			13283
		],
		"mapped",
		[
			52,
			26085
		]
	],
	[
		[
			13284,
			13284
		],
		"mapped",
		[
			53,
			26085
		]
	],
	[
		[
			13285,
			13285
		],
		"mapped",
		[
			54,
			26085
		]
	],
	[
		[
			13286,
			13286
		],
		"mapped",
		[
			55,
			26085
		]
	],
	[
		[
			13287,
			13287
		],
		"mapped",
		[
			56,
			26085
		]
	],
	[
		[
			13288,
			13288
		],
		"mapped",
		[
			57,
			26085
		]
	],
	[
		[
			13289,
			13289
		],
		"mapped",
		[
			49,
			48,
			26085
		]
	],
	[
		[
			13290,
			13290
		],
		"mapped",
		[
			49,
			49,
			26085
		]
	],
	[
		[
			13291,
			13291
		],
		"mapped",
		[
			49,
			50,
			26085
		]
	],
	[
		[
			13292,
			13292
		],
		"mapped",
		[
			49,
			51,
			26085
		]
	],
	[
		[
			13293,
			13293
		],
		"mapped",
		[
			49,
			52,
			26085
		]
	],
	[
		[
			13294,
			13294
		],
		"mapped",
		[
			49,
			53,
			26085
		]
	],
	[
		[
			13295,
			13295
		],
		"mapped",
		[
			49,
			54,
			26085
		]
	],
	[
		[
			13296,
			13296
		],
		"mapped",
		[
			49,
			55,
			26085
		]
	],
	[
		[
			13297,
			13297
		],
		"mapped",
		[
			49,
			56,
			26085
		]
	],
	[
		[
			13298,
			13298
		],
		"mapped",
		[
			49,
			57,
			26085
		]
	],
	[
		[
			13299,
			13299
		],
		"mapped",
		[
			50,
			48,
			26085
		]
	],
	[
		[
			13300,
			13300
		],
		"mapped",
		[
			50,
			49,
			26085
		]
	],
	[
		[
			13301,
			13301
		],
		"mapped",
		[
			50,
			50,
			26085
		]
	],
	[
		[
			13302,
			13302
		],
		"mapped",
		[
			50,
			51,
			26085
		]
	],
	[
		[
			13303,
			13303
		],
		"mapped",
		[
			50,
			52,
			26085
		]
	],
	[
		[
			13304,
			13304
		],
		"mapped",
		[
			50,
			53,
			26085
		]
	],
	[
		[
			13305,
			13305
		],
		"mapped",
		[
			50,
			54,
			26085
		]
	],
	[
		[
			13306,
			13306
		],
		"mapped",
		[
			50,
			55,
			26085
		]
	],
	[
		[
			13307,
			13307
		],
		"mapped",
		[
			50,
			56,
			26085
		]
	],
	[
		[
			13308,
			13308
		],
		"mapped",
		[
			50,
			57,
			26085
		]
	],
	[
		[
			13309,
			13309
		],
		"mapped",
		[
			51,
			48,
			26085
		]
	],
	[
		[
			13310,
			13310
		],
		"mapped",
		[
			51,
			49,
			26085
		]
	],
	[
		[
			13311,
			13311
		],
		"mapped",
		[
			103,
			97,
			108
		]
	],
	[
		[
			13312,
			19893
		],
		"valid"
	],
	[
		[
			19894,
			19903
		],
		"disallowed"
	],
	[
		[
			19904,
			19967
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			19968,
			40869
		],
		"valid"
	],
	[
		[
			40870,
			40891
		],
		"valid"
	],
	[
		[
			40892,
			40899
		],
		"valid"
	],
	[
		[
			40900,
			40907
		],
		"valid"
	],
	[
		[
			40908,
			40908
		],
		"valid"
	],
	[
		[
			40909,
			40917
		],
		"valid"
	],
	[
		[
			40918,
			40959
		],
		"disallowed"
	],
	[
		[
			40960,
			42124
		],
		"valid"
	],
	[
		[
			42125,
			42127
		],
		"disallowed"
	],
	[
		[
			42128,
			42145
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			42146,
			42147
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			42148,
			42163
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			42164,
			42164
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			42165,
			42176
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			42177,
			42177
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			42178,
			42180
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			42181,
			42181
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			42182,
			42182
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			42183,
			42191
		],
		"disallowed"
	],
	[
		[
			42192,
			42237
		],
		"valid"
	],
	[
		[
			42238,
			42239
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			42240,
			42508
		],
		"valid"
	],
	[
		[
			42509,
			42511
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			42512,
			42539
		],
		"valid"
	],
	[
		[
			42540,
			42559
		],
		"disallowed"
	],
	[
		[
			42560,
			42560
		],
		"mapped",
		[
			42561
		]
	],
	[
		[
			42561,
			42561
		],
		"valid"
	],
	[
		[
			42562,
			42562
		],
		"mapped",
		[
			42563
		]
	],
	[
		[
			42563,
			42563
		],
		"valid"
	],
	[
		[
			42564,
			42564
		],
		"mapped",
		[
			42565
		]
	],
	[
		[
			42565,
			42565
		],
		"valid"
	],
	[
		[
			42566,
			42566
		],
		"mapped",
		[
			42567
		]
	],
	[
		[
			42567,
			42567
		],
		"valid"
	],
	[
		[
			42568,
			42568
		],
		"mapped",
		[
			42569
		]
	],
	[
		[
			42569,
			42569
		],
		"valid"
	],
	[
		[
			42570,
			42570
		],
		"mapped",
		[
			42571
		]
	],
	[
		[
			42571,
			42571
		],
		"valid"
	],
	[
		[
			42572,
			42572
		],
		"mapped",
		[
			42573
		]
	],
	[
		[
			42573,
			42573
		],
		"valid"
	],
	[
		[
			42574,
			42574
		],
		"mapped",
		[
			42575
		]
	],
	[
		[
			42575,
			42575
		],
		"valid"
	],
	[
		[
			42576,
			42576
		],
		"mapped",
		[
			42577
		]
	],
	[
		[
			42577,
			42577
		],
		"valid"
	],
	[
		[
			42578,
			42578
		],
		"mapped",
		[
			42579
		]
	],
	[
		[
			42579,
			42579
		],
		"valid"
	],
	[
		[
			42580,
			42580
		],
		"mapped",
		[
			42581
		]
	],
	[
		[
			42581,
			42581
		],
		"valid"
	],
	[
		[
			42582,
			42582
		],
		"mapped",
		[
			42583
		]
	],
	[
		[
			42583,
			42583
		],
		"valid"
	],
	[
		[
			42584,
			42584
		],
		"mapped",
		[
			42585
		]
	],
	[
		[
			42585,
			42585
		],
		"valid"
	],
	[
		[
			42586,
			42586
		],
		"mapped",
		[
			42587
		]
	],
	[
		[
			42587,
			42587
		],
		"valid"
	],
	[
		[
			42588,
			42588
		],
		"mapped",
		[
			42589
		]
	],
	[
		[
			42589,
			42589
		],
		"valid"
	],
	[
		[
			42590,
			42590
		],
		"mapped",
		[
			42591
		]
	],
	[
		[
			42591,
			42591
		],
		"valid"
	],
	[
		[
			42592,
			42592
		],
		"mapped",
		[
			42593
		]
	],
	[
		[
			42593,
			42593
		],
		"valid"
	],
	[
		[
			42594,
			42594
		],
		"mapped",
		[
			42595
		]
	],
	[
		[
			42595,
			42595
		],
		"valid"
	],
	[
		[
			42596,
			42596
		],
		"mapped",
		[
			42597
		]
	],
	[
		[
			42597,
			42597
		],
		"valid"
	],
	[
		[
			42598,
			42598
		],
		"mapped",
		[
			42599
		]
	],
	[
		[
			42599,
			42599
		],
		"valid"
	],
	[
		[
			42600,
			42600
		],
		"mapped",
		[
			42601
		]
	],
	[
		[
			42601,
			42601
		],
		"valid"
	],
	[
		[
			42602,
			42602
		],
		"mapped",
		[
			42603
		]
	],
	[
		[
			42603,
			42603
		],
		"valid"
	],
	[
		[
			42604,
			42604
		],
		"mapped",
		[
			42605
		]
	],
	[
		[
			42605,
			42607
		],
		"valid"
	],
	[
		[
			42608,
			42611
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			42612,
			42619
		],
		"valid"
	],
	[
		[
			42620,
			42621
		],
		"valid"
	],
	[
		[
			42622,
			42622
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			42623,
			42623
		],
		"valid"
	],
	[
		[
			42624,
			42624
		],
		"mapped",
		[
			42625
		]
	],
	[
		[
			42625,
			42625
		],
		"valid"
	],
	[
		[
			42626,
			42626
		],
		"mapped",
		[
			42627
		]
	],
	[
		[
			42627,
			42627
		],
		"valid"
	],
	[
		[
			42628,
			42628
		],
		"mapped",
		[
			42629
		]
	],
	[
		[
			42629,
			42629
		],
		"valid"
	],
	[
		[
			42630,
			42630
		],
		"mapped",
		[
			42631
		]
	],
	[
		[
			42631,
			42631
		],
		"valid"
	],
	[
		[
			42632,
			42632
		],
		"mapped",
		[
			42633
		]
	],
	[
		[
			42633,
			42633
		],
		"valid"
	],
	[
		[
			42634,
			42634
		],
		"mapped",
		[
			42635
		]
	],
	[
		[
			42635,
			42635
		],
		"valid"
	],
	[
		[
			42636,
			42636
		],
		"mapped",
		[
			42637
		]
	],
	[
		[
			42637,
			42637
		],
		"valid"
	],
	[
		[
			42638,
			42638
		],
		"mapped",
		[
			42639
		]
	],
	[
		[
			42639,
			42639
		],
		"valid"
	],
	[
		[
			42640,
			42640
		],
		"mapped",
		[
			42641
		]
	],
	[
		[
			42641,
			42641
		],
		"valid"
	],
	[
		[
			42642,
			42642
		],
		"mapped",
		[
			42643
		]
	],
	[
		[
			42643,
			42643
		],
		"valid"
	],
	[
		[
			42644,
			42644
		],
		"mapped",
		[
			42645
		]
	],
	[
		[
			42645,
			42645
		],
		"valid"
	],
	[
		[
			42646,
			42646
		],
		"mapped",
		[
			42647
		]
	],
	[
		[
			42647,
			42647
		],
		"valid"
	],
	[
		[
			42648,
			42648
		],
		"mapped",
		[
			42649
		]
	],
	[
		[
			42649,
			42649
		],
		"valid"
	],
	[
		[
			42650,
			42650
		],
		"mapped",
		[
			42651
		]
	],
	[
		[
			42651,
			42651
		],
		"valid"
	],
	[
		[
			42652,
			42652
		],
		"mapped",
		[
			1098
		]
	],
	[
		[
			42653,
			42653
		],
		"mapped",
		[
			1100
		]
	],
	[
		[
			42654,
			42654
		],
		"valid"
	],
	[
		[
			42655,
			42655
		],
		"valid"
	],
	[
		[
			42656,
			42725
		],
		"valid"
	],
	[
		[
			42726,
			42735
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			42736,
			42737
		],
		"valid"
	],
	[
		[
			42738,
			42743
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			42744,
			42751
		],
		"disallowed"
	],
	[
		[
			42752,
			42774
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			42775,
			42778
		],
		"valid"
	],
	[
		[
			42779,
			42783
		],
		"valid"
	],
	[
		[
			42784,
			42785
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			42786,
			42786
		],
		"mapped",
		[
			42787
		]
	],
	[
		[
			42787,
			42787
		],
		"valid"
	],
	[
		[
			42788,
			42788
		],
		"mapped",
		[
			42789
		]
	],
	[
		[
			42789,
			42789
		],
		"valid"
	],
	[
		[
			42790,
			42790
		],
		"mapped",
		[
			42791
		]
	],
	[
		[
			42791,
			42791
		],
		"valid"
	],
	[
		[
			42792,
			42792
		],
		"mapped",
		[
			42793
		]
	],
	[
		[
			42793,
			42793
		],
		"valid"
	],
	[
		[
			42794,
			42794
		],
		"mapped",
		[
			42795
		]
	],
	[
		[
			42795,
			42795
		],
		"valid"
	],
	[
		[
			42796,
			42796
		],
		"mapped",
		[
			42797
		]
	],
	[
		[
			42797,
			42797
		],
		"valid"
	],
	[
		[
			42798,
			42798
		],
		"mapped",
		[
			42799
		]
	],
	[
		[
			42799,
			42801
		],
		"valid"
	],
	[
		[
			42802,
			42802
		],
		"mapped",
		[
			42803
		]
	],
	[
		[
			42803,
			42803
		],
		"valid"
	],
	[
		[
			42804,
			42804
		],
		"mapped",
		[
			42805
		]
	],
	[
		[
			42805,
			42805
		],
		"valid"
	],
	[
		[
			42806,
			42806
		],
		"mapped",
		[
			42807
		]
	],
	[
		[
			42807,
			42807
		],
		"valid"
	],
	[
		[
			42808,
			42808
		],
		"mapped",
		[
			42809
		]
	],
	[
		[
			42809,
			42809
		],
		"valid"
	],
	[
		[
			42810,
			42810
		],
		"mapped",
		[
			42811
		]
	],
	[
		[
			42811,
			42811
		],
		"valid"
	],
	[
		[
			42812,
			42812
		],
		"mapped",
		[
			42813
		]
	],
	[
		[
			42813,
			42813
		],
		"valid"
	],
	[
		[
			42814,
			42814
		],
		"mapped",
		[
			42815
		]
	],
	[
		[
			42815,
			42815
		],
		"valid"
	],
	[
		[
			42816,
			42816
		],
		"mapped",
		[
			42817
		]
	],
	[
		[
			42817,
			42817
		],
		"valid"
	],
	[
		[
			42818,
			42818
		],
		"mapped",
		[
			42819
		]
	],
	[
		[
			42819,
			42819
		],
		"valid"
	],
	[
		[
			42820,
			42820
		],
		"mapped",
		[
			42821
		]
	],
	[
		[
			42821,
			42821
		],
		"valid"
	],
	[
		[
			42822,
			42822
		],
		"mapped",
		[
			42823
		]
	],
	[
		[
			42823,
			42823
		],
		"valid"
	],
	[
		[
			42824,
			42824
		],
		"mapped",
		[
			42825
		]
	],
	[
		[
			42825,
			42825
		],
		"valid"
	],
	[
		[
			42826,
			42826
		],
		"mapped",
		[
			42827
		]
	],
	[
		[
			42827,
			42827
		],
		"valid"
	],
	[
		[
			42828,
			42828
		],
		"mapped",
		[
			42829
		]
	],
	[
		[
			42829,
			42829
		],
		"valid"
	],
	[
		[
			42830,
			42830
		],
		"mapped",
		[
			42831
		]
	],
	[
		[
			42831,
			42831
		],
		"valid"
	],
	[
		[
			42832,
			42832
		],
		"mapped",
		[
			42833
		]
	],
	[
		[
			42833,
			42833
		],
		"valid"
	],
	[
		[
			42834,
			42834
		],
		"mapped",
		[
			42835
		]
	],
	[
		[
			42835,
			42835
		],
		"valid"
	],
	[
		[
			42836,
			42836
		],
		"mapped",
		[
			42837
		]
	],
	[
		[
			42837,
			42837
		],
		"valid"
	],
	[
		[
			42838,
			42838
		],
		"mapped",
		[
			42839
		]
	],
	[
		[
			42839,
			42839
		],
		"valid"
	],
	[
		[
			42840,
			42840
		],
		"mapped",
		[
			42841
		]
	],
	[
		[
			42841,
			42841
		],
		"valid"
	],
	[
		[
			42842,
			42842
		],
		"mapped",
		[
			42843
		]
	],
	[
		[
			42843,
			42843
		],
		"valid"
	],
	[
		[
			42844,
			42844
		],
		"mapped",
		[
			42845
		]
	],
	[
		[
			42845,
			42845
		],
		"valid"
	],
	[
		[
			42846,
			42846
		],
		"mapped",
		[
			42847
		]
	],
	[
		[
			42847,
			42847
		],
		"valid"
	],
	[
		[
			42848,
			42848
		],
		"mapped",
		[
			42849
		]
	],
	[
		[
			42849,
			42849
		],
		"valid"
	],
	[
		[
			42850,
			42850
		],
		"mapped",
		[
			42851
		]
	],
	[
		[
			42851,
			42851
		],
		"valid"
	],
	[
		[
			42852,
			42852
		],
		"mapped",
		[
			42853
		]
	],
	[
		[
			42853,
			42853
		],
		"valid"
	],
	[
		[
			42854,
			42854
		],
		"mapped",
		[
			42855
		]
	],
	[
		[
			42855,
			42855
		],
		"valid"
	],
	[
		[
			42856,
			42856
		],
		"mapped",
		[
			42857
		]
	],
	[
		[
			42857,
			42857
		],
		"valid"
	],
	[
		[
			42858,
			42858
		],
		"mapped",
		[
			42859
		]
	],
	[
		[
			42859,
			42859
		],
		"valid"
	],
	[
		[
			42860,
			42860
		],
		"mapped",
		[
			42861
		]
	],
	[
		[
			42861,
			42861
		],
		"valid"
	],
	[
		[
			42862,
			42862
		],
		"mapped",
		[
			42863
		]
	],
	[
		[
			42863,
			42863
		],
		"valid"
	],
	[
		[
			42864,
			42864
		],
		"mapped",
		[
			42863
		]
	],
	[
		[
			42865,
			42872
		],
		"valid"
	],
	[
		[
			42873,
			42873
		],
		"mapped",
		[
			42874
		]
	],
	[
		[
			42874,
			42874
		],
		"valid"
	],
	[
		[
			42875,
			42875
		],
		"mapped",
		[
			42876
		]
	],
	[
		[
			42876,
			42876
		],
		"valid"
	],
	[
		[
			42877,
			42877
		],
		"mapped",
		[
			7545
		]
	],
	[
		[
			42878,
			42878
		],
		"mapped",
		[
			42879
		]
	],
	[
		[
			42879,
			42879
		],
		"valid"
	],
	[
		[
			42880,
			42880
		],
		"mapped",
		[
			42881
		]
	],
	[
		[
			42881,
			42881
		],
		"valid"
	],
	[
		[
			42882,
			42882
		],
		"mapped",
		[
			42883
		]
	],
	[
		[
			42883,
			42883
		],
		"valid"
	],
	[
		[
			42884,
			42884
		],
		"mapped",
		[
			42885
		]
	],
	[
		[
			42885,
			42885
		],
		"valid"
	],
	[
		[
			42886,
			42886
		],
		"mapped",
		[
			42887
		]
	],
	[
		[
			42887,
			42888
		],
		"valid"
	],
	[
		[
			42889,
			42890
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			42891,
			42891
		],
		"mapped",
		[
			42892
		]
	],
	[
		[
			42892,
			42892
		],
		"valid"
	],
	[
		[
			42893,
			42893
		],
		"mapped",
		[
			613
		]
	],
	[
		[
			42894,
			42894
		],
		"valid"
	],
	[
		[
			42895,
			42895
		],
		"valid"
	],
	[
		[
			42896,
			42896
		],
		"mapped",
		[
			42897
		]
	],
	[
		[
			42897,
			42897
		],
		"valid"
	],
	[
		[
			42898,
			42898
		],
		"mapped",
		[
			42899
		]
	],
	[
		[
			42899,
			42899
		],
		"valid"
	],
	[
		[
			42900,
			42901
		],
		"valid"
	],
	[
		[
			42902,
			42902
		],
		"mapped",
		[
			42903
		]
	],
	[
		[
			42903,
			42903
		],
		"valid"
	],
	[
		[
			42904,
			42904
		],
		"mapped",
		[
			42905
		]
	],
	[
		[
			42905,
			42905
		],
		"valid"
	],
	[
		[
			42906,
			42906
		],
		"mapped",
		[
			42907
		]
	],
	[
		[
			42907,
			42907
		],
		"valid"
	],
	[
		[
			42908,
			42908
		],
		"mapped",
		[
			42909
		]
	],
	[
		[
			42909,
			42909
		],
		"valid"
	],
	[
		[
			42910,
			42910
		],
		"mapped",
		[
			42911
		]
	],
	[
		[
			42911,
			42911
		],
		"valid"
	],
	[
		[
			42912,
			42912
		],
		"mapped",
		[
			42913
		]
	],
	[
		[
			42913,
			42913
		],
		"valid"
	],
	[
		[
			42914,
			42914
		],
		"mapped",
		[
			42915
		]
	],
	[
		[
			42915,
			42915
		],
		"valid"
	],
	[
		[
			42916,
			42916
		],
		"mapped",
		[
			42917
		]
	],
	[
		[
			42917,
			42917
		],
		"valid"
	],
	[
		[
			42918,
			42918
		],
		"mapped",
		[
			42919
		]
	],
	[
		[
			42919,
			42919
		],
		"valid"
	],
	[
		[
			42920,
			42920
		],
		"mapped",
		[
			42921
		]
	],
	[
		[
			42921,
			42921
		],
		"valid"
	],
	[
		[
			42922,
			42922
		],
		"mapped",
		[
			614
		]
	],
	[
		[
			42923,
			42923
		],
		"mapped",
		[
			604
		]
	],
	[
		[
			42924,
			42924
		],
		"mapped",
		[
			609
		]
	],
	[
		[
			42925,
			42925
		],
		"mapped",
		[
			620
		]
	],
	[
		[
			42926,
			42927
		],
		"disallowed"
	],
	[
		[
			42928,
			42928
		],
		"mapped",
		[
			670
		]
	],
	[
		[
			42929,
			42929
		],
		"mapped",
		[
			647
		]
	],
	[
		[
			42930,
			42930
		],
		"mapped",
		[
			669
		]
	],
	[
		[
			42931,
			42931
		],
		"mapped",
		[
			43859
		]
	],
	[
		[
			42932,
			42932
		],
		"mapped",
		[
			42933
		]
	],
	[
		[
			42933,
			42933
		],
		"valid"
	],
	[
		[
			42934,
			42934
		],
		"mapped",
		[
			42935
		]
	],
	[
		[
			42935,
			42935
		],
		"valid"
	],
	[
		[
			42936,
			42998
		],
		"disallowed"
	],
	[
		[
			42999,
			42999
		],
		"valid"
	],
	[
		[
			43000,
			43000
		],
		"mapped",
		[
			295
		]
	],
	[
		[
			43001,
			43001
		],
		"mapped",
		[
			339
		]
	],
	[
		[
			43002,
			43002
		],
		"valid"
	],
	[
		[
			43003,
			43007
		],
		"valid"
	],
	[
		[
			43008,
			43047
		],
		"valid"
	],
	[
		[
			43048,
			43051
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			43052,
			43055
		],
		"disallowed"
	],
	[
		[
			43056,
			43065
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			43066,
			43071
		],
		"disallowed"
	],
	[
		[
			43072,
			43123
		],
		"valid"
	],
	[
		[
			43124,
			43127
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			43128,
			43135
		],
		"disallowed"
	],
	[
		[
			43136,
			43204
		],
		"valid"
	],
	[
		[
			43205,
			43213
		],
		"disallowed"
	],
	[
		[
			43214,
			43215
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			43216,
			43225
		],
		"valid"
	],
	[
		[
			43226,
			43231
		],
		"disallowed"
	],
	[
		[
			43232,
			43255
		],
		"valid"
	],
	[
		[
			43256,
			43258
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			43259,
			43259
		],
		"valid"
	],
	[
		[
			43260,
			43260
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			43261,
			43261
		],
		"valid"
	],
	[
		[
			43262,
			43263
		],
		"disallowed"
	],
	[
		[
			43264,
			43309
		],
		"valid"
	],
	[
		[
			43310,
			43311
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			43312,
			43347
		],
		"valid"
	],
	[
		[
			43348,
			43358
		],
		"disallowed"
	],
	[
		[
			43359,
			43359
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			43360,
			43388
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			43389,
			43391
		],
		"disallowed"
	],
	[
		[
			43392,
			43456
		],
		"valid"
	],
	[
		[
			43457,
			43469
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			43470,
			43470
		],
		"disallowed"
	],
	[
		[
			43471,
			43481
		],
		"valid"
	],
	[
		[
			43482,
			43485
		],
		"disallowed"
	],
	[
		[
			43486,
			43487
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			43488,
			43518
		],
		"valid"
	],
	[
		[
			43519,
			43519
		],
		"disallowed"
	],
	[
		[
			43520,
			43574
		],
		"valid"
	],
	[
		[
			43575,
			43583
		],
		"disallowed"
	],
	[
		[
			43584,
			43597
		],
		"valid"
	],
	[
		[
			43598,
			43599
		],
		"disallowed"
	],
	[
		[
			43600,
			43609
		],
		"valid"
	],
	[
		[
			43610,
			43611
		],
		"disallowed"
	],
	[
		[
			43612,
			43615
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			43616,
			43638
		],
		"valid"
	],
	[
		[
			43639,
			43641
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			43642,
			43643
		],
		"valid"
	],
	[
		[
			43644,
			43647
		],
		"valid"
	],
	[
		[
			43648,
			43714
		],
		"valid"
	],
	[
		[
			43715,
			43738
		],
		"disallowed"
	],
	[
		[
			43739,
			43741
		],
		"valid"
	],
	[
		[
			43742,
			43743
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			43744,
			43759
		],
		"valid"
	],
	[
		[
			43760,
			43761
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			43762,
			43766
		],
		"valid"
	],
	[
		[
			43767,
			43776
		],
		"disallowed"
	],
	[
		[
			43777,
			43782
		],
		"valid"
	],
	[
		[
			43783,
			43784
		],
		"disallowed"
	],
	[
		[
			43785,
			43790
		],
		"valid"
	],
	[
		[
			43791,
			43792
		],
		"disallowed"
	],
	[
		[
			43793,
			43798
		],
		"valid"
	],
	[
		[
			43799,
			43807
		],
		"disallowed"
	],
	[
		[
			43808,
			43814
		],
		"valid"
	],
	[
		[
			43815,
			43815
		],
		"disallowed"
	],
	[
		[
			43816,
			43822
		],
		"valid"
	],
	[
		[
			43823,
			43823
		],
		"disallowed"
	],
	[
		[
			43824,
			43866
		],
		"valid"
	],
	[
		[
			43867,
			43867
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			43868,
			43868
		],
		"mapped",
		[
			42791
		]
	],
	[
		[
			43869,
			43869
		],
		"mapped",
		[
			43831
		]
	],
	[
		[
			43870,
			43870
		],
		"mapped",
		[
			619
		]
	],
	[
		[
			43871,
			43871
		],
		"mapped",
		[
			43858
		]
	],
	[
		[
			43872,
			43875
		],
		"valid"
	],
	[
		[
			43876,
			43877
		],
		"valid"
	],
	[
		[
			43878,
			43887
		],
		"disallowed"
	],
	[
		[
			43888,
			43888
		],
		"mapped",
		[
			5024
		]
	],
	[
		[
			43889,
			43889
		],
		"mapped",
		[
			5025
		]
	],
	[
		[
			43890,
			43890
		],
		"mapped",
		[
			5026
		]
	],
	[
		[
			43891,
			43891
		],
		"mapped",
		[
			5027
		]
	],
	[
		[
			43892,
			43892
		],
		"mapped",
		[
			5028
		]
	],
	[
		[
			43893,
			43893
		],
		"mapped",
		[
			5029
		]
	],
	[
		[
			43894,
			43894
		],
		"mapped",
		[
			5030
		]
	],
	[
		[
			43895,
			43895
		],
		"mapped",
		[
			5031
		]
	],
	[
		[
			43896,
			43896
		],
		"mapped",
		[
			5032
		]
	],
	[
		[
			43897,
			43897
		],
		"mapped",
		[
			5033
		]
	],
	[
		[
			43898,
			43898
		],
		"mapped",
		[
			5034
		]
	],
	[
		[
			43899,
			43899
		],
		"mapped",
		[
			5035
		]
	],
	[
		[
			43900,
			43900
		],
		"mapped",
		[
			5036
		]
	],
	[
		[
			43901,
			43901
		],
		"mapped",
		[
			5037
		]
	],
	[
		[
			43902,
			43902
		],
		"mapped",
		[
			5038
		]
	],
	[
		[
			43903,
			43903
		],
		"mapped",
		[
			5039
		]
	],
	[
		[
			43904,
			43904
		],
		"mapped",
		[
			5040
		]
	],
	[
		[
			43905,
			43905
		],
		"mapped",
		[
			5041
		]
	],
	[
		[
			43906,
			43906
		],
		"mapped",
		[
			5042
		]
	],
	[
		[
			43907,
			43907
		],
		"mapped",
		[
			5043
		]
	],
	[
		[
			43908,
			43908
		],
		"mapped",
		[
			5044
		]
	],
	[
		[
			43909,
			43909
		],
		"mapped",
		[
			5045
		]
	],
	[
		[
			43910,
			43910
		],
		"mapped",
		[
			5046
		]
	],
	[
		[
			43911,
			43911
		],
		"mapped",
		[
			5047
		]
	],
	[
		[
			43912,
			43912
		],
		"mapped",
		[
			5048
		]
	],
	[
		[
			43913,
			43913
		],
		"mapped",
		[
			5049
		]
	],
	[
		[
			43914,
			43914
		],
		"mapped",
		[
			5050
		]
	],
	[
		[
			43915,
			43915
		],
		"mapped",
		[
			5051
		]
	],
	[
		[
			43916,
			43916
		],
		"mapped",
		[
			5052
		]
	],
	[
		[
			43917,
			43917
		],
		"mapped",
		[
			5053
		]
	],
	[
		[
			43918,
			43918
		],
		"mapped",
		[
			5054
		]
	],
	[
		[
			43919,
			43919
		],
		"mapped",
		[
			5055
		]
	],
	[
		[
			43920,
			43920
		],
		"mapped",
		[
			5056
		]
	],
	[
		[
			43921,
			43921
		],
		"mapped",
		[
			5057
		]
	],
	[
		[
			43922,
			43922
		],
		"mapped",
		[
			5058
		]
	],
	[
		[
			43923,
			43923
		],
		"mapped",
		[
			5059
		]
	],
	[
		[
			43924,
			43924
		],
		"mapped",
		[
			5060
		]
	],
	[
		[
			43925,
			43925
		],
		"mapped",
		[
			5061
		]
	],
	[
		[
			43926,
			43926
		],
		"mapped",
		[
			5062
		]
	],
	[
		[
			43927,
			43927
		],
		"mapped",
		[
			5063
		]
	],
	[
		[
			43928,
			43928
		],
		"mapped",
		[
			5064
		]
	],
	[
		[
			43929,
			43929
		],
		"mapped",
		[
			5065
		]
	],
	[
		[
			43930,
			43930
		],
		"mapped",
		[
			5066
		]
	],
	[
		[
			43931,
			43931
		],
		"mapped",
		[
			5067
		]
	],
	[
		[
			43932,
			43932
		],
		"mapped",
		[
			5068
		]
	],
	[
		[
			43933,
			43933
		],
		"mapped",
		[
			5069
		]
	],
	[
		[
			43934,
			43934
		],
		"mapped",
		[
			5070
		]
	],
	[
		[
			43935,
			43935
		],
		"mapped",
		[
			5071
		]
	],
	[
		[
			43936,
			43936
		],
		"mapped",
		[
			5072
		]
	],
	[
		[
			43937,
			43937
		],
		"mapped",
		[
			5073
		]
	],
	[
		[
			43938,
			43938
		],
		"mapped",
		[
			5074
		]
	],
	[
		[
			43939,
			43939
		],
		"mapped",
		[
			5075
		]
	],
	[
		[
			43940,
			43940
		],
		"mapped",
		[
			5076
		]
	],
	[
		[
			43941,
			43941
		],
		"mapped",
		[
			5077
		]
	],
	[
		[
			43942,
			43942
		],
		"mapped",
		[
			5078
		]
	],
	[
		[
			43943,
			43943
		],
		"mapped",
		[
			5079
		]
	],
	[
		[
			43944,
			43944
		],
		"mapped",
		[
			5080
		]
	],
	[
		[
			43945,
			43945
		],
		"mapped",
		[
			5081
		]
	],
	[
		[
			43946,
			43946
		],
		"mapped",
		[
			5082
		]
	],
	[
		[
			43947,
			43947
		],
		"mapped",
		[
			5083
		]
	],
	[
		[
			43948,
			43948
		],
		"mapped",
		[
			5084
		]
	],
	[
		[
			43949,
			43949
		],
		"mapped",
		[
			5085
		]
	],
	[
		[
			43950,
			43950
		],
		"mapped",
		[
			5086
		]
	],
	[
		[
			43951,
			43951
		],
		"mapped",
		[
			5087
		]
	],
	[
		[
			43952,
			43952
		],
		"mapped",
		[
			5088
		]
	],
	[
		[
			43953,
			43953
		],
		"mapped",
		[
			5089
		]
	],
	[
		[
			43954,
			43954
		],
		"mapped",
		[
			5090
		]
	],
	[
		[
			43955,
			43955
		],
		"mapped",
		[
			5091
		]
	],
	[
		[
			43956,
			43956
		],
		"mapped",
		[
			5092
		]
	],
	[
		[
			43957,
			43957
		],
		"mapped",
		[
			5093
		]
	],
	[
		[
			43958,
			43958
		],
		"mapped",
		[
			5094
		]
	],
	[
		[
			43959,
			43959
		],
		"mapped",
		[
			5095
		]
	],
	[
		[
			43960,
			43960
		],
		"mapped",
		[
			5096
		]
	],
	[
		[
			43961,
			43961
		],
		"mapped",
		[
			5097
		]
	],
	[
		[
			43962,
			43962
		],
		"mapped",
		[
			5098
		]
	],
	[
		[
			43963,
			43963
		],
		"mapped",
		[
			5099
		]
	],
	[
		[
			43964,
			43964
		],
		"mapped",
		[
			5100
		]
	],
	[
		[
			43965,
			43965
		],
		"mapped",
		[
			5101
		]
	],
	[
		[
			43966,
			43966
		],
		"mapped",
		[
			5102
		]
	],
	[
		[
			43967,
			43967
		],
		"mapped",
		[
			5103
		]
	],
	[
		[
			43968,
			44010
		],
		"valid"
	],
	[
		[
			44011,
			44011
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			44012,
			44013
		],
		"valid"
	],
	[
		[
			44014,
			44015
		],
		"disallowed"
	],
	[
		[
			44016,
			44025
		],
		"valid"
	],
	[
		[
			44026,
			44031
		],
		"disallowed"
	],
	[
		[
			44032,
			55203
		],
		"valid"
	],
	[
		[
			55204,
			55215
		],
		"disallowed"
	],
	[
		[
			55216,
			55238
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			55239,
			55242
		],
		"disallowed"
	],
	[
		[
			55243,
			55291
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			55292,
			55295
		],
		"disallowed"
	],
	[
		[
			55296,
			57343
		],
		"disallowed"
	],
	[
		[
			57344,
			63743
		],
		"disallowed"
	],
	[
		[
			63744,
			63744
		],
		"mapped",
		[
			35912
		]
	],
	[
		[
			63745,
			63745
		],
		"mapped",
		[
			26356
		]
	],
	[
		[
			63746,
			63746
		],
		"mapped",
		[
			36554
		]
	],
	[
		[
			63747,
			63747
		],
		"mapped",
		[
			36040
		]
	],
	[
		[
			63748,
			63748
		],
		"mapped",
		[
			28369
		]
	],
	[
		[
			63749,
			63749
		],
		"mapped",
		[
			20018
		]
	],
	[
		[
			63750,
			63750
		],
		"mapped",
		[
			21477
		]
	],
	[
		[
			63751,
			63752
		],
		"mapped",
		[
			40860
		]
	],
	[
		[
			63753,
			63753
		],
		"mapped",
		[
			22865
		]
	],
	[
		[
			63754,
			63754
		],
		"mapped",
		[
			37329
		]
	],
	[
		[
			63755,
			63755
		],
		"mapped",
		[
			21895
		]
	],
	[
		[
			63756,
			63756
		],
		"mapped",
		[
			22856
		]
	],
	[
		[
			63757,
			63757
		],
		"mapped",
		[
			25078
		]
	],
	[
		[
			63758,
			63758
		],
		"mapped",
		[
			30313
		]
	],
	[
		[
			63759,
			63759
		],
		"mapped",
		[
			32645
		]
	],
	[
		[
			63760,
			63760
		],
		"mapped",
		[
			34367
		]
	],
	[
		[
			63761,
			63761
		],
		"mapped",
		[
			34746
		]
	],
	[
		[
			63762,
			63762
		],
		"mapped",
		[
			35064
		]
	],
	[
		[
			63763,
			63763
		],
		"mapped",
		[
			37007
		]
	],
	[
		[
			63764,
			63764
		],
		"mapped",
		[
			27138
		]
	],
	[
		[
			63765,
			63765
		],
		"mapped",
		[
			27931
		]
	],
	[
		[
			63766,
			63766
		],
		"mapped",
		[
			28889
		]
	],
	[
		[
			63767,
			63767
		],
		"mapped",
		[
			29662
		]
	],
	[
		[
			63768,
			63768
		],
		"mapped",
		[
			33853
		]
	],
	[
		[
			63769,
			63769
		],
		"mapped",
		[
			37226
		]
	],
	[
		[
			63770,
			63770
		],
		"mapped",
		[
			39409
		]
	],
	[
		[
			63771,
			63771
		],
		"mapped",
		[
			20098
		]
	],
	[
		[
			63772,
			63772
		],
		"mapped",
		[
			21365
		]
	],
	[
		[
			63773,
			63773
		],
		"mapped",
		[
			27396
		]
	],
	[
		[
			63774,
			63774
		],
		"mapped",
		[
			29211
		]
	],
	[
		[
			63775,
			63775
		],
		"mapped",
		[
			34349
		]
	],
	[
		[
			63776,
			63776
		],
		"mapped",
		[
			40478
		]
	],
	[
		[
			63777,
			63777
		],
		"mapped",
		[
			23888
		]
	],
	[
		[
			63778,
			63778
		],
		"mapped",
		[
			28651
		]
	],
	[
		[
			63779,
			63779
		],
		"mapped",
		[
			34253
		]
	],
	[
		[
			63780,
			63780
		],
		"mapped",
		[
			35172
		]
	],
	[
		[
			63781,
			63781
		],
		"mapped",
		[
			25289
		]
	],
	[
		[
			63782,
			63782
		],
		"mapped",
		[
			33240
		]
	],
	[
		[
			63783,
			63783
		],
		"mapped",
		[
			34847
		]
	],
	[
		[
			63784,
			63784
		],
		"mapped",
		[
			24266
		]
	],
	[
		[
			63785,
			63785
		],
		"mapped",
		[
			26391
		]
	],
	[
		[
			63786,
			63786
		],
		"mapped",
		[
			28010
		]
	],
	[
		[
			63787,
			63787
		],
		"mapped",
		[
			29436
		]
	],
	[
		[
			63788,
			63788
		],
		"mapped",
		[
			37070
		]
	],
	[
		[
			63789,
			63789
		],
		"mapped",
		[
			20358
		]
	],
	[
		[
			63790,
			63790
		],
		"mapped",
		[
			20919
		]
	],
	[
		[
			63791,
			63791
		],
		"mapped",
		[
			21214
		]
	],
	[
		[
			63792,
			63792
		],
		"mapped",
		[
			25796
		]
	],
	[
		[
			63793,
			63793
		],
		"mapped",
		[
			27347
		]
	],
	[
		[
			63794,
			63794
		],
		"mapped",
		[
			29200
		]
	],
	[
		[
			63795,
			63795
		],
		"mapped",
		[
			30439
		]
	],
	[
		[
			63796,
			63796
		],
		"mapped",
		[
			32769
		]
	],
	[
		[
			63797,
			63797
		],
		"mapped",
		[
			34310
		]
	],
	[
		[
			63798,
			63798
		],
		"mapped",
		[
			34396
		]
	],
	[
		[
			63799,
			63799
		],
		"mapped",
		[
			36335
		]
	],
	[
		[
			63800,
			63800
		],
		"mapped",
		[
			38706
		]
	],
	[
		[
			63801,
			63801
		],
		"mapped",
		[
			39791
		]
	],
	[
		[
			63802,
			63802
		],
		"mapped",
		[
			40442
		]
	],
	[
		[
			63803,
			63803
		],
		"mapped",
		[
			30860
		]
	],
	[
		[
			63804,
			63804
		],
		"mapped",
		[
			31103
		]
	],
	[
		[
			63805,
			63805
		],
		"mapped",
		[
			32160
		]
	],
	[
		[
			63806,
			63806
		],
		"mapped",
		[
			33737
		]
	],
	[
		[
			63807,
			63807
		],
		"mapped",
		[
			37636
		]
	],
	[
		[
			63808,
			63808
		],
		"mapped",
		[
			40575
		]
	],
	[
		[
			63809,
			63809
		],
		"mapped",
		[
			35542
		]
	],
	[
		[
			63810,
			63810
		],
		"mapped",
		[
			22751
		]
	],
	[
		[
			63811,
			63811
		],
		"mapped",
		[
			24324
		]
	],
	[
		[
			63812,
			63812
		],
		"mapped",
		[
			31840
		]
	],
	[
		[
			63813,
			63813
		],
		"mapped",
		[
			32894
		]
	],
	[
		[
			63814,
			63814
		],
		"mapped",
		[
			29282
		]
	],
	[
		[
			63815,
			63815
		],
		"mapped",
		[
			30922
		]
	],
	[
		[
			63816,
			63816
		],
		"mapped",
		[
			36034
		]
	],
	[
		[
			63817,
			63817
		],
		"mapped",
		[
			38647
		]
	],
	[
		[
			63818,
			63818
		],
		"mapped",
		[
			22744
		]
	],
	[
		[
			63819,
			63819
		],
		"mapped",
		[
			23650
		]
	],
	[
		[
			63820,
			63820
		],
		"mapped",
		[
			27155
		]
	],
	[
		[
			63821,
			63821
		],
		"mapped",
		[
			28122
		]
	],
	[
		[
			63822,
			63822
		],
		"mapped",
		[
			28431
		]
	],
	[
		[
			63823,
			63823
		],
		"mapped",
		[
			32047
		]
	],
	[
		[
			63824,
			63824
		],
		"mapped",
		[
			32311
		]
	],
	[
		[
			63825,
			63825
		],
		"mapped",
		[
			38475
		]
	],
	[
		[
			63826,
			63826
		],
		"mapped",
		[
			21202
		]
	],
	[
		[
			63827,
			63827
		],
		"mapped",
		[
			32907
		]
	],
	[
		[
			63828,
			63828
		],
		"mapped",
		[
			20956
		]
	],
	[
		[
			63829,
			63829
		],
		"mapped",
		[
			20940
		]
	],
	[
		[
			63830,
			63830
		],
		"mapped",
		[
			31260
		]
	],
	[
		[
			63831,
			63831
		],
		"mapped",
		[
			32190
		]
	],
	[
		[
			63832,
			63832
		],
		"mapped",
		[
			33777
		]
	],
	[
		[
			63833,
			63833
		],
		"mapped",
		[
			38517
		]
	],
	[
		[
			63834,
			63834
		],
		"mapped",
		[
			35712
		]
	],
	[
		[
			63835,
			63835
		],
		"mapped",
		[
			25295
		]
	],
	[
		[
			63836,
			63836
		],
		"mapped",
		[
			27138
		]
	],
	[
		[
			63837,
			63837
		],
		"mapped",
		[
			35582
		]
	],
	[
		[
			63838,
			63838
		],
		"mapped",
		[
			20025
		]
	],
	[
		[
			63839,
			63839
		],
		"mapped",
		[
			23527
		]
	],
	[
		[
			63840,
			63840
		],
		"mapped",
		[
			24594
		]
	],
	[
		[
			63841,
			63841
		],
		"mapped",
		[
			29575
		]
	],
	[
		[
			63842,
			63842
		],
		"mapped",
		[
			30064
		]
	],
	[
		[
			63843,
			63843
		],
		"mapped",
		[
			21271
		]
	],
	[
		[
			63844,
			63844
		],
		"mapped",
		[
			30971
		]
	],
	[
		[
			63845,
			63845
		],
		"mapped",
		[
			20415
		]
	],
	[
		[
			63846,
			63846
		],
		"mapped",
		[
			24489
		]
	],
	[
		[
			63847,
			63847
		],
		"mapped",
		[
			19981
		]
	],
	[
		[
			63848,
			63848
		],
		"mapped",
		[
			27852
		]
	],
	[
		[
			63849,
			63849
		],
		"mapped",
		[
			25976
		]
	],
	[
		[
			63850,
			63850
		],
		"mapped",
		[
			32034
		]
	],
	[
		[
			63851,
			63851
		],
		"mapped",
		[
			21443
		]
	],
	[
		[
			63852,
			63852
		],
		"mapped",
		[
			22622
		]
	],
	[
		[
			63853,
			63853
		],
		"mapped",
		[
			30465
		]
	],
	[
		[
			63854,
			63854
		],
		"mapped",
		[
			33865
		]
	],
	[
		[
			63855,
			63855
		],
		"mapped",
		[
			35498
		]
	],
	[
		[
			63856,
			63856
		],
		"mapped",
		[
			27578
		]
	],
	[
		[
			63857,
			63857
		],
		"mapped",
		[
			36784
		]
	],
	[
		[
			63858,
			63858
		],
		"mapped",
		[
			27784
		]
	],
	[
		[
			63859,
			63859
		],
		"mapped",
		[
			25342
		]
	],
	[
		[
			63860,
			63860
		],
		"mapped",
		[
			33509
		]
	],
	[
		[
			63861,
			63861
		],
		"mapped",
		[
			25504
		]
	],
	[
		[
			63862,
			63862
		],
		"mapped",
		[
			30053
		]
	],
	[
		[
			63863,
			63863
		],
		"mapped",
		[
			20142
		]
	],
	[
		[
			63864,
			63864
		],
		"mapped",
		[
			20841
		]
	],
	[
		[
			63865,
			63865
		],
		"mapped",
		[
			20937
		]
	],
	[
		[
			63866,
			63866
		],
		"mapped",
		[
			26753
		]
	],
	[
		[
			63867,
			63867
		],
		"mapped",
		[
			31975
		]
	],
	[
		[
			63868,
			63868
		],
		"mapped",
		[
			33391
		]
	],
	[
		[
			63869,
			63869
		],
		"mapped",
		[
			35538
		]
	],
	[
		[
			63870,
			63870
		],
		"mapped",
		[
			37327
		]
	],
	[
		[
			63871,
			63871
		],
		"mapped",
		[
			21237
		]
	],
	[
		[
			63872,
			63872
		],
		"mapped",
		[
			21570
		]
	],
	[
		[
			63873,
			63873
		],
		"mapped",
		[
			22899
		]
	],
	[
		[
			63874,
			63874
		],
		"mapped",
		[
			24300
		]
	],
	[
		[
			63875,
			63875
		],
		"mapped",
		[
			26053
		]
	],
	[
		[
			63876,
			63876
		],
		"mapped",
		[
			28670
		]
	],
	[
		[
			63877,
			63877
		],
		"mapped",
		[
			31018
		]
	],
	[
		[
			63878,
			63878
		],
		"mapped",
		[
			38317
		]
	],
	[
		[
			63879,
			63879
		],
		"mapped",
		[
			39530
		]
	],
	[
		[
			63880,
			63880
		],
		"mapped",
		[
			40599
		]
	],
	[
		[
			63881,
			63881
		],
		"mapped",
		[
			40654
		]
	],
	[
		[
			63882,
			63882
		],
		"mapped",
		[
			21147
		]
	],
	[
		[
			63883,
			63883
		],
		"mapped",
		[
			26310
		]
	],
	[
		[
			63884,
			63884
		],
		"mapped",
		[
			27511
		]
	],
	[
		[
			63885,
			63885
		],
		"mapped",
		[
			36706
		]
	],
	[
		[
			63886,
			63886
		],
		"mapped",
		[
			24180
		]
	],
	[
		[
			63887,
			63887
		],
		"mapped",
		[
			24976
		]
	],
	[
		[
			63888,
			63888
		],
		"mapped",
		[
			25088
		]
	],
	[
		[
			63889,
			63889
		],
		"mapped",
		[
			25754
		]
	],
	[
		[
			63890,
			63890
		],
		"mapped",
		[
			28451
		]
	],
	[
		[
			63891,
			63891
		],
		"mapped",
		[
			29001
		]
	],
	[
		[
			63892,
			63892
		],
		"mapped",
		[
			29833
		]
	],
	[
		[
			63893,
			63893
		],
		"mapped",
		[
			31178
		]
	],
	[
		[
			63894,
			63894
		],
		"mapped",
		[
			32244
		]
	],
	[
		[
			63895,
			63895
		],
		"mapped",
		[
			32879
		]
	],
	[
		[
			63896,
			63896
		],
		"mapped",
		[
			36646
		]
	],
	[
		[
			63897,
			63897
		],
		"mapped",
		[
			34030
		]
	],
	[
		[
			63898,
			63898
		],
		"mapped",
		[
			36899
		]
	],
	[
		[
			63899,
			63899
		],
		"mapped",
		[
			37706
		]
	],
	[
		[
			63900,
			63900
		],
		"mapped",
		[
			21015
		]
	],
	[
		[
			63901,
			63901
		],
		"mapped",
		[
			21155
		]
	],
	[
		[
			63902,
			63902
		],
		"mapped",
		[
			21693
		]
	],
	[
		[
			63903,
			63903
		],
		"mapped",
		[
			28872
		]
	],
	[
		[
			63904,
			63904
		],
		"mapped",
		[
			35010
		]
	],
	[
		[
			63905,
			63905
		],
		"mapped",
		[
			35498
		]
	],
	[
		[
			63906,
			63906
		],
		"mapped",
		[
			24265
		]
	],
	[
		[
			63907,
			63907
		],
		"mapped",
		[
			24565
		]
	],
	[
		[
			63908,
			63908
		],
		"mapped",
		[
			25467
		]
	],
	[
		[
			63909,
			63909
		],
		"mapped",
		[
			27566
		]
	],
	[
		[
			63910,
			63910
		],
		"mapped",
		[
			31806
		]
	],
	[
		[
			63911,
			63911
		],
		"mapped",
		[
			29557
		]
	],
	[
		[
			63912,
			63912
		],
		"mapped",
		[
			20196
		]
	],
	[
		[
			63913,
			63913
		],
		"mapped",
		[
			22265
		]
	],
	[
		[
			63914,
			63914
		],
		"mapped",
		[
			23527
		]
	],
	[
		[
			63915,
			63915
		],
		"mapped",
		[
			23994
		]
	],
	[
		[
			63916,
			63916
		],
		"mapped",
		[
			24604
		]
	],
	[
		[
			63917,
			63917
		],
		"mapped",
		[
			29618
		]
	],
	[
		[
			63918,
			63918
		],
		"mapped",
		[
			29801
		]
	],
	[
		[
			63919,
			63919
		],
		"mapped",
		[
			32666
		]
	],
	[
		[
			63920,
			63920
		],
		"mapped",
		[
			32838
		]
	],
	[
		[
			63921,
			63921
		],
		"mapped",
		[
			37428
		]
	],
	[
		[
			63922,
			63922
		],
		"mapped",
		[
			38646
		]
	],
	[
		[
			63923,
			63923
		],
		"mapped",
		[
			38728
		]
	],
	[
		[
			63924,
			63924
		],
		"mapped",
		[
			38936
		]
	],
	[
		[
			63925,
			63925
		],
		"mapped",
		[
			20363
		]
	],
	[
		[
			63926,
			63926
		],
		"mapped",
		[
			31150
		]
	],
	[
		[
			63927,
			63927
		],
		"mapped",
		[
			37300
		]
	],
	[
		[
			63928,
			63928
		],
		"mapped",
		[
			38584
		]
	],
	[
		[
			63929,
			63929
		],
		"mapped",
		[
			24801
		]
	],
	[
		[
			63930,
			63930
		],
		"mapped",
		[
			20102
		]
	],
	[
		[
			63931,
			63931
		],
		"mapped",
		[
			20698
		]
	],
	[
		[
			63932,
			63932
		],
		"mapped",
		[
			23534
		]
	],
	[
		[
			63933,
			63933
		],
		"mapped",
		[
			23615
		]
	],
	[
		[
			63934,
			63934
		],
		"mapped",
		[
			26009
		]
	],
	[
		[
			63935,
			63935
		],
		"mapped",
		[
			27138
		]
	],
	[
		[
			63936,
			63936
		],
		"mapped",
		[
			29134
		]
	],
	[
		[
			63937,
			63937
		],
		"mapped",
		[
			30274
		]
	],
	[
		[
			63938,
			63938
		],
		"mapped",
		[
			34044
		]
	],
	[
		[
			63939,
			63939
		],
		"mapped",
		[
			36988
		]
	],
	[
		[
			63940,
			63940
		],
		"mapped",
		[
			40845
		]
	],
	[
		[
			63941,
			63941
		],
		"mapped",
		[
			26248
		]
	],
	[
		[
			63942,
			63942
		],
		"mapped",
		[
			38446
		]
	],
	[
		[
			63943,
			63943
		],
		"mapped",
		[
			21129
		]
	],
	[
		[
			63944,
			63944
		],
		"mapped",
		[
			26491
		]
	],
	[
		[
			63945,
			63945
		],
		"mapped",
		[
			26611
		]
	],
	[
		[
			63946,
			63946
		],
		"mapped",
		[
			27969
		]
	],
	[
		[
			63947,
			63947
		],
		"mapped",
		[
			28316
		]
	],
	[
		[
			63948,
			63948
		],
		"mapped",
		[
			29705
		]
	],
	[
		[
			63949,
			63949
		],
		"mapped",
		[
			30041
		]
	],
	[
		[
			63950,
			63950
		],
		"mapped",
		[
			30827
		]
	],
	[
		[
			63951,
			63951
		],
		"mapped",
		[
			32016
		]
	],
	[
		[
			63952,
			63952
		],
		"mapped",
		[
			39006
		]
	],
	[
		[
			63953,
			63953
		],
		"mapped",
		[
			20845
		]
	],
	[
		[
			63954,
			63954
		],
		"mapped",
		[
			25134
		]
	],
	[
		[
			63955,
			63955
		],
		"mapped",
		[
			38520
		]
	],
	[
		[
			63956,
			63956
		],
		"mapped",
		[
			20523
		]
	],
	[
		[
			63957,
			63957
		],
		"mapped",
		[
			23833
		]
	],
	[
		[
			63958,
			63958
		],
		"mapped",
		[
			28138
		]
	],
	[
		[
			63959,
			63959
		],
		"mapped",
		[
			36650
		]
	],
	[
		[
			63960,
			63960
		],
		"mapped",
		[
			24459
		]
	],
	[
		[
			63961,
			63961
		],
		"mapped",
		[
			24900
		]
	],
	[
		[
			63962,
			63962
		],
		"mapped",
		[
			26647
		]
	],
	[
		[
			63963,
			63963
		],
		"mapped",
		[
			29575
		]
	],
	[
		[
			63964,
			63964
		],
		"mapped",
		[
			38534
		]
	],
	[
		[
			63965,
			63965
		],
		"mapped",
		[
			21033
		]
	],
	[
		[
			63966,
			63966
		],
		"mapped",
		[
			21519
		]
	],
	[
		[
			63967,
			63967
		],
		"mapped",
		[
			23653
		]
	],
	[
		[
			63968,
			63968
		],
		"mapped",
		[
			26131
		]
	],
	[
		[
			63969,
			63969
		],
		"mapped",
		[
			26446
		]
	],
	[
		[
			63970,
			63970
		],
		"mapped",
		[
			26792
		]
	],
	[
		[
			63971,
			63971
		],
		"mapped",
		[
			27877
		]
	],
	[
		[
			63972,
			63972
		],
		"mapped",
		[
			29702
		]
	],
	[
		[
			63973,
			63973
		],
		"mapped",
		[
			30178
		]
	],
	[
		[
			63974,
			63974
		],
		"mapped",
		[
			32633
		]
	],
	[
		[
			63975,
			63975
		],
		"mapped",
		[
			35023
		]
	],
	[
		[
			63976,
			63976
		],
		"mapped",
		[
			35041
		]
	],
	[
		[
			63977,
			63977
		],
		"mapped",
		[
			37324
		]
	],
	[
		[
			63978,
			63978
		],
		"mapped",
		[
			38626
		]
	],
	[
		[
			63979,
			63979
		],
		"mapped",
		[
			21311
		]
	],
	[
		[
			63980,
			63980
		],
		"mapped",
		[
			28346
		]
	],
	[
		[
			63981,
			63981
		],
		"mapped",
		[
			21533
		]
	],
	[
		[
			63982,
			63982
		],
		"mapped",
		[
			29136
		]
	],
	[
		[
			63983,
			63983
		],
		"mapped",
		[
			29848
		]
	],
	[
		[
			63984,
			63984
		],
		"mapped",
		[
			34298
		]
	],
	[
		[
			63985,
			63985
		],
		"mapped",
		[
			38563
		]
	],
	[
		[
			63986,
			63986
		],
		"mapped",
		[
			40023
		]
	],
	[
		[
			63987,
			63987
		],
		"mapped",
		[
			40607
		]
	],
	[
		[
			63988,
			63988
		],
		"mapped",
		[
			26519
		]
	],
	[
		[
			63989,
			63989
		],
		"mapped",
		[
			28107
		]
	],
	[
		[
			63990,
			63990
		],
		"mapped",
		[
			33256
		]
	],
	[
		[
			63991,
			63991
		],
		"mapped",
		[
			31435
		]
	],
	[
		[
			63992,
			63992
		],
		"mapped",
		[
			31520
		]
	],
	[
		[
			63993,
			63993
		],
		"mapped",
		[
			31890
		]
	],
	[
		[
			63994,
			63994
		],
		"mapped",
		[
			29376
		]
	],
	[
		[
			63995,
			63995
		],
		"mapped",
		[
			28825
		]
	],
	[
		[
			63996,
			63996
		],
		"mapped",
		[
			35672
		]
	],
	[
		[
			63997,
			63997
		],
		"mapped",
		[
			20160
		]
	],
	[
		[
			63998,
			63998
		],
		"mapped",
		[
			33590
		]
	],
	[
		[
			63999,
			63999
		],
		"mapped",
		[
			21050
		]
	],
	[
		[
			64000,
			64000
		],
		"mapped",
		[
			20999
		]
	],
	[
		[
			64001,
			64001
		],
		"mapped",
		[
			24230
		]
	],
	[
		[
			64002,
			64002
		],
		"mapped",
		[
			25299
		]
	],
	[
		[
			64003,
			64003
		],
		"mapped",
		[
			31958
		]
	],
	[
		[
			64004,
			64004
		],
		"mapped",
		[
			23429
		]
	],
	[
		[
			64005,
			64005
		],
		"mapped",
		[
			27934
		]
	],
	[
		[
			64006,
			64006
		],
		"mapped",
		[
			26292
		]
	],
	[
		[
			64007,
			64007
		],
		"mapped",
		[
			36667
		]
	],
	[
		[
			64008,
			64008
		],
		"mapped",
		[
			34892
		]
	],
	[
		[
			64009,
			64009
		],
		"mapped",
		[
			38477
		]
	],
	[
		[
			64010,
			64010
		],
		"mapped",
		[
			35211
		]
	],
	[
		[
			64011,
			64011
		],
		"mapped",
		[
			24275
		]
	],
	[
		[
			64012,
			64012
		],
		"mapped",
		[
			20800
		]
	],
	[
		[
			64013,
			64013
		],
		"mapped",
		[
			21952
		]
	],
	[
		[
			64014,
			64015
		],
		"valid"
	],
	[
		[
			64016,
			64016
		],
		"mapped",
		[
			22618
		]
	],
	[
		[
			64017,
			64017
		],
		"valid"
	],
	[
		[
			64018,
			64018
		],
		"mapped",
		[
			26228
		]
	],
	[
		[
			64019,
			64020
		],
		"valid"
	],
	[
		[
			64021,
			64021
		],
		"mapped",
		[
			20958
		]
	],
	[
		[
			64022,
			64022
		],
		"mapped",
		[
			29482
		]
	],
	[
		[
			64023,
			64023
		],
		"mapped",
		[
			30410
		]
	],
	[
		[
			64024,
			64024
		],
		"mapped",
		[
			31036
		]
	],
	[
		[
			64025,
			64025
		],
		"mapped",
		[
			31070
		]
	],
	[
		[
			64026,
			64026
		],
		"mapped",
		[
			31077
		]
	],
	[
		[
			64027,
			64027
		],
		"mapped",
		[
			31119
		]
	],
	[
		[
			64028,
			64028
		],
		"mapped",
		[
			38742
		]
	],
	[
		[
			64029,
			64029
		],
		"mapped",
		[
			31934
		]
	],
	[
		[
			64030,
			64030
		],
		"mapped",
		[
			32701
		]
	],
	[
		[
			64031,
			64031
		],
		"valid"
	],
	[
		[
			64032,
			64032
		],
		"mapped",
		[
			34322
		]
	],
	[
		[
			64033,
			64033
		],
		"valid"
	],
	[
		[
			64034,
			64034
		],
		"mapped",
		[
			35576
		]
	],
	[
		[
			64035,
			64036
		],
		"valid"
	],
	[
		[
			64037,
			64037
		],
		"mapped",
		[
			36920
		]
	],
	[
		[
			64038,
			64038
		],
		"mapped",
		[
			37117
		]
	],
	[
		[
			64039,
			64041
		],
		"valid"
	],
	[
		[
			64042,
			64042
		],
		"mapped",
		[
			39151
		]
	],
	[
		[
			64043,
			64043
		],
		"mapped",
		[
			39164
		]
	],
	[
		[
			64044,
			64044
		],
		"mapped",
		[
			39208
		]
	],
	[
		[
			64045,
			64045
		],
		"mapped",
		[
			40372
		]
	],
	[
		[
			64046,
			64046
		],
		"mapped",
		[
			37086
		]
	],
	[
		[
			64047,
			64047
		],
		"mapped",
		[
			38583
		]
	],
	[
		[
			64048,
			64048
		],
		"mapped",
		[
			20398
		]
	],
	[
		[
			64049,
			64049
		],
		"mapped",
		[
			20711
		]
	],
	[
		[
			64050,
			64050
		],
		"mapped",
		[
			20813
		]
	],
	[
		[
			64051,
			64051
		],
		"mapped",
		[
			21193
		]
	],
	[
		[
			64052,
			64052
		],
		"mapped",
		[
			21220
		]
	],
	[
		[
			64053,
			64053
		],
		"mapped",
		[
			21329
		]
	],
	[
		[
			64054,
			64054
		],
		"mapped",
		[
			21917
		]
	],
	[
		[
			64055,
			64055
		],
		"mapped",
		[
			22022
		]
	],
	[
		[
			64056,
			64056
		],
		"mapped",
		[
			22120
		]
	],
	[
		[
			64057,
			64057
		],
		"mapped",
		[
			22592
		]
	],
	[
		[
			64058,
			64058
		],
		"mapped",
		[
			22696
		]
	],
	[
		[
			64059,
			64059
		],
		"mapped",
		[
			23652
		]
	],
	[
		[
			64060,
			64060
		],
		"mapped",
		[
			23662
		]
	],
	[
		[
			64061,
			64061
		],
		"mapped",
		[
			24724
		]
	],
	[
		[
			64062,
			64062
		],
		"mapped",
		[
			24936
		]
	],
	[
		[
			64063,
			64063
		],
		"mapped",
		[
			24974
		]
	],
	[
		[
			64064,
			64064
		],
		"mapped",
		[
			25074
		]
	],
	[
		[
			64065,
			64065
		],
		"mapped",
		[
			25935
		]
	],
	[
		[
			64066,
			64066
		],
		"mapped",
		[
			26082
		]
	],
	[
		[
			64067,
			64067
		],
		"mapped",
		[
			26257
		]
	],
	[
		[
			64068,
			64068
		],
		"mapped",
		[
			26757
		]
	],
	[
		[
			64069,
			64069
		],
		"mapped",
		[
			28023
		]
	],
	[
		[
			64070,
			64070
		],
		"mapped",
		[
			28186
		]
	],
	[
		[
			64071,
			64071
		],
		"mapped",
		[
			28450
		]
	],
	[
		[
			64072,
			64072
		],
		"mapped",
		[
			29038
		]
	],
	[
		[
			64073,
			64073
		],
		"mapped",
		[
			29227
		]
	],
	[
		[
			64074,
			64074
		],
		"mapped",
		[
			29730
		]
	],
	[
		[
			64075,
			64075
		],
		"mapped",
		[
			30865
		]
	],
	[
		[
			64076,
			64076
		],
		"mapped",
		[
			31038
		]
	],
	[
		[
			64077,
			64077
		],
		"mapped",
		[
			31049
		]
	],
	[
		[
			64078,
			64078
		],
		"mapped",
		[
			31048
		]
	],
	[
		[
			64079,
			64079
		],
		"mapped",
		[
			31056
		]
	],
	[
		[
			64080,
			64080
		],
		"mapped",
		[
			31062
		]
	],
	[
		[
			64081,
			64081
		],
		"mapped",
		[
			31069
		]
	],
	[
		[
			64082,
			64082
		],
		"mapped",
		[
			31117
		]
	],
	[
		[
			64083,
			64083
		],
		"mapped",
		[
			31118
		]
	],
	[
		[
			64084,
			64084
		],
		"mapped",
		[
			31296
		]
	],
	[
		[
			64085,
			64085
		],
		"mapped",
		[
			31361
		]
	],
	[
		[
			64086,
			64086
		],
		"mapped",
		[
			31680
		]
	],
	[
		[
			64087,
			64087
		],
		"mapped",
		[
			32244
		]
	],
	[
		[
			64088,
			64088
		],
		"mapped",
		[
			32265
		]
	],
	[
		[
			64089,
			64089
		],
		"mapped",
		[
			32321
		]
	],
	[
		[
			64090,
			64090
		],
		"mapped",
		[
			32626
		]
	],
	[
		[
			64091,
			64091
		],
		"mapped",
		[
			32773
		]
	],
	[
		[
			64092,
			64092
		],
		"mapped",
		[
			33261
		]
	],
	[
		[
			64093,
			64094
		],
		"mapped",
		[
			33401
		]
	],
	[
		[
			64095,
			64095
		],
		"mapped",
		[
			33879
		]
	],
	[
		[
			64096,
			64096
		],
		"mapped",
		[
			35088
		]
	],
	[
		[
			64097,
			64097
		],
		"mapped",
		[
			35222
		]
	],
	[
		[
			64098,
			64098
		],
		"mapped",
		[
			35585
		]
	],
	[
		[
			64099,
			64099
		],
		"mapped",
		[
			35641
		]
	],
	[
		[
			64100,
			64100
		],
		"mapped",
		[
			36051
		]
	],
	[
		[
			64101,
			64101
		],
		"mapped",
		[
			36104
		]
	],
	[
		[
			64102,
			64102
		],
		"mapped",
		[
			36790
		]
	],
	[
		[
			64103,
			64103
		],
		"mapped",
		[
			36920
		]
	],
	[
		[
			64104,
			64104
		],
		"mapped",
		[
			38627
		]
	],
	[
		[
			64105,
			64105
		],
		"mapped",
		[
			38911
		]
	],
	[
		[
			64106,
			64106
		],
		"mapped",
		[
			38971
		]
	],
	[
		[
			64107,
			64107
		],
		"mapped",
		[
			24693
		]
	],
	[
		[
			64108,
			64108
		],
		"mapped",
		[
			148206
		]
	],
	[
		[
			64109,
			64109
		],
		"mapped",
		[
			33304
		]
	],
	[
		[
			64110,
			64111
		],
		"disallowed"
	],
	[
		[
			64112,
			64112
		],
		"mapped",
		[
			20006
		]
	],
	[
		[
			64113,
			64113
		],
		"mapped",
		[
			20917
		]
	],
	[
		[
			64114,
			64114
		],
		"mapped",
		[
			20840
		]
	],
	[
		[
			64115,
			64115
		],
		"mapped",
		[
			20352
		]
	],
	[
		[
			64116,
			64116
		],
		"mapped",
		[
			20805
		]
	],
	[
		[
			64117,
			64117
		],
		"mapped",
		[
			20864
		]
	],
	[
		[
			64118,
			64118
		],
		"mapped",
		[
			21191
		]
	],
	[
		[
			64119,
			64119
		],
		"mapped",
		[
			21242
		]
	],
	[
		[
			64120,
			64120
		],
		"mapped",
		[
			21917
		]
	],
	[
		[
			64121,
			64121
		],
		"mapped",
		[
			21845
		]
	],
	[
		[
			64122,
			64122
		],
		"mapped",
		[
			21913
		]
	],
	[
		[
			64123,
			64123
		],
		"mapped",
		[
			21986
		]
	],
	[
		[
			64124,
			64124
		],
		"mapped",
		[
			22618
		]
	],
	[
		[
			64125,
			64125
		],
		"mapped",
		[
			22707
		]
	],
	[
		[
			64126,
			64126
		],
		"mapped",
		[
			22852
		]
	],
	[
		[
			64127,
			64127
		],
		"mapped",
		[
			22868
		]
	],
	[
		[
			64128,
			64128
		],
		"mapped",
		[
			23138
		]
	],
	[
		[
			64129,
			64129
		],
		"mapped",
		[
			23336
		]
	],
	[
		[
			64130,
			64130
		],
		"mapped",
		[
			24274
		]
	],
	[
		[
			64131,
			64131
		],
		"mapped",
		[
			24281
		]
	],
	[
		[
			64132,
			64132
		],
		"mapped",
		[
			24425
		]
	],
	[
		[
			64133,
			64133
		],
		"mapped",
		[
			24493
		]
	],
	[
		[
			64134,
			64134
		],
		"mapped",
		[
			24792
		]
	],
	[
		[
			64135,
			64135
		],
		"mapped",
		[
			24910
		]
	],
	[
		[
			64136,
			64136
		],
		"mapped",
		[
			24840
		]
	],
	[
		[
			64137,
			64137
		],
		"mapped",
		[
			24974
		]
	],
	[
		[
			64138,
			64138
		],
		"mapped",
		[
			24928
		]
	],
	[
		[
			64139,
			64139
		],
		"mapped",
		[
			25074
		]
	],
	[
		[
			64140,
			64140
		],
		"mapped",
		[
			25140
		]
	],
	[
		[
			64141,
			64141
		],
		"mapped",
		[
			25540
		]
	],
	[
		[
			64142,
			64142
		],
		"mapped",
		[
			25628
		]
	],
	[
		[
			64143,
			64143
		],
		"mapped",
		[
			25682
		]
	],
	[
		[
			64144,
			64144
		],
		"mapped",
		[
			25942
		]
	],
	[
		[
			64145,
			64145
		],
		"mapped",
		[
			26228
		]
	],
	[
		[
			64146,
			64146
		],
		"mapped",
		[
			26391
		]
	],
	[
		[
			64147,
			64147
		],
		"mapped",
		[
			26395
		]
	],
	[
		[
			64148,
			64148
		],
		"mapped",
		[
			26454
		]
	],
	[
		[
			64149,
			64149
		],
		"mapped",
		[
			27513
		]
	],
	[
		[
			64150,
			64150
		],
		"mapped",
		[
			27578
		]
	],
	[
		[
			64151,
			64151
		],
		"mapped",
		[
			27969
		]
	],
	[
		[
			64152,
			64152
		],
		"mapped",
		[
			28379
		]
	],
	[
		[
			64153,
			64153
		],
		"mapped",
		[
			28363
		]
	],
	[
		[
			64154,
			64154
		],
		"mapped",
		[
			28450
		]
	],
	[
		[
			64155,
			64155
		],
		"mapped",
		[
			28702
		]
	],
	[
		[
			64156,
			64156
		],
		"mapped",
		[
			29038
		]
	],
	[
		[
			64157,
			64157
		],
		"mapped",
		[
			30631
		]
	],
	[
		[
			64158,
			64158
		],
		"mapped",
		[
			29237
		]
	],
	[
		[
			64159,
			64159
		],
		"mapped",
		[
			29359
		]
	],
	[
		[
			64160,
			64160
		],
		"mapped",
		[
			29482
		]
	],
	[
		[
			64161,
			64161
		],
		"mapped",
		[
			29809
		]
	],
	[
		[
			64162,
			64162
		],
		"mapped",
		[
			29958
		]
	],
	[
		[
			64163,
			64163
		],
		"mapped",
		[
			30011
		]
	],
	[
		[
			64164,
			64164
		],
		"mapped",
		[
			30237
		]
	],
	[
		[
			64165,
			64165
		],
		"mapped",
		[
			30239
		]
	],
	[
		[
			64166,
			64166
		],
		"mapped",
		[
			30410
		]
	],
	[
		[
			64167,
			64167
		],
		"mapped",
		[
			30427
		]
	],
	[
		[
			64168,
			64168
		],
		"mapped",
		[
			30452
		]
	],
	[
		[
			64169,
			64169
		],
		"mapped",
		[
			30538
		]
	],
	[
		[
			64170,
			64170
		],
		"mapped",
		[
			30528
		]
	],
	[
		[
			64171,
			64171
		],
		"mapped",
		[
			30924
		]
	],
	[
		[
			64172,
			64172
		],
		"mapped",
		[
			31409
		]
	],
	[
		[
			64173,
			64173
		],
		"mapped",
		[
			31680
		]
	],
	[
		[
			64174,
			64174
		],
		"mapped",
		[
			31867
		]
	],
	[
		[
			64175,
			64175
		],
		"mapped",
		[
			32091
		]
	],
	[
		[
			64176,
			64176
		],
		"mapped",
		[
			32244
		]
	],
	[
		[
			64177,
			64177
		],
		"mapped",
		[
			32574
		]
	],
	[
		[
			64178,
			64178
		],
		"mapped",
		[
			32773
		]
	],
	[
		[
			64179,
			64179
		],
		"mapped",
		[
			33618
		]
	],
	[
		[
			64180,
			64180
		],
		"mapped",
		[
			33775
		]
	],
	[
		[
			64181,
			64181
		],
		"mapped",
		[
			34681
		]
	],
	[
		[
			64182,
			64182
		],
		"mapped",
		[
			35137
		]
	],
	[
		[
			64183,
			64183
		],
		"mapped",
		[
			35206
		]
	],
	[
		[
			64184,
			64184
		],
		"mapped",
		[
			35222
		]
	],
	[
		[
			64185,
			64185
		],
		"mapped",
		[
			35519
		]
	],
	[
		[
			64186,
			64186
		],
		"mapped",
		[
			35576
		]
	],
	[
		[
			64187,
			64187
		],
		"mapped",
		[
			35531
		]
	],
	[
		[
			64188,
			64188
		],
		"mapped",
		[
			35585
		]
	],
	[
		[
			64189,
			64189
		],
		"mapped",
		[
			35582
		]
	],
	[
		[
			64190,
			64190
		],
		"mapped",
		[
			35565
		]
	],
	[
		[
			64191,
			64191
		],
		"mapped",
		[
			35641
		]
	],
	[
		[
			64192,
			64192
		],
		"mapped",
		[
			35722
		]
	],
	[
		[
			64193,
			64193
		],
		"mapped",
		[
			36104
		]
	],
	[
		[
			64194,
			64194
		],
		"mapped",
		[
			36664
		]
	],
	[
		[
			64195,
			64195
		],
		"mapped",
		[
			36978
		]
	],
	[
		[
			64196,
			64196
		],
		"mapped",
		[
			37273
		]
	],
	[
		[
			64197,
			64197
		],
		"mapped",
		[
			37494
		]
	],
	[
		[
			64198,
			64198
		],
		"mapped",
		[
			38524
		]
	],
	[
		[
			64199,
			64199
		],
		"mapped",
		[
			38627
		]
	],
	[
		[
			64200,
			64200
		],
		"mapped",
		[
			38742
		]
	],
	[
		[
			64201,
			64201
		],
		"mapped",
		[
			38875
		]
	],
	[
		[
			64202,
			64202
		],
		"mapped",
		[
			38911
		]
	],
	[
		[
			64203,
			64203
		],
		"mapped",
		[
			38923
		]
	],
	[
		[
			64204,
			64204
		],
		"mapped",
		[
			38971
		]
	],
	[
		[
			64205,
			64205
		],
		"mapped",
		[
			39698
		]
	],
	[
		[
			64206,
			64206
		],
		"mapped",
		[
			40860
		]
	],
	[
		[
			64207,
			64207
		],
		"mapped",
		[
			141386
		]
	],
	[
		[
			64208,
			64208
		],
		"mapped",
		[
			141380
		]
	],
	[
		[
			64209,
			64209
		],
		"mapped",
		[
			144341
		]
	],
	[
		[
			64210,
			64210
		],
		"mapped",
		[
			15261
		]
	],
	[
		[
			64211,
			64211
		],
		"mapped",
		[
			16408
		]
	],
	[
		[
			64212,
			64212
		],
		"mapped",
		[
			16441
		]
	],
	[
		[
			64213,
			64213
		],
		"mapped",
		[
			152137
		]
	],
	[
		[
			64214,
			64214
		],
		"mapped",
		[
			154832
		]
	],
	[
		[
			64215,
			64215
		],
		"mapped",
		[
			163539
		]
	],
	[
		[
			64216,
			64216
		],
		"mapped",
		[
			40771
		]
	],
	[
		[
			64217,
			64217
		],
		"mapped",
		[
			40846
		]
	],
	[
		[
			64218,
			64255
		],
		"disallowed"
	],
	[
		[
			64256,
			64256
		],
		"mapped",
		[
			102,
			102
		]
	],
	[
		[
			64257,
			64257
		],
		"mapped",
		[
			102,
			105
		]
	],
	[
		[
			64258,
			64258
		],
		"mapped",
		[
			102,
			108
		]
	],
	[
		[
			64259,
			64259
		],
		"mapped",
		[
			102,
			102,
			105
		]
	],
	[
		[
			64260,
			64260
		],
		"mapped",
		[
			102,
			102,
			108
		]
	],
	[
		[
			64261,
			64262
		],
		"mapped",
		[
			115,
			116
		]
	],
	[
		[
			64263,
			64274
		],
		"disallowed"
	],
	[
		[
			64275,
			64275
		],
		"mapped",
		[
			1396,
			1398
		]
	],
	[
		[
			64276,
			64276
		],
		"mapped",
		[
			1396,
			1381
		]
	],
	[
		[
			64277,
			64277
		],
		"mapped",
		[
			1396,
			1387
		]
	],
	[
		[
			64278,
			64278
		],
		"mapped",
		[
			1406,
			1398
		]
	],
	[
		[
			64279,
			64279
		],
		"mapped",
		[
			1396,
			1389
		]
	],
	[
		[
			64280,
			64284
		],
		"disallowed"
	],
	[
		[
			64285,
			64285
		],
		"mapped",
		[
			1497,
			1460
		]
	],
	[
		[
			64286,
			64286
		],
		"valid"
	],
	[
		[
			64287,
			64287
		],
		"mapped",
		[
			1522,
			1463
		]
	],
	[
		[
			64288,
			64288
		],
		"mapped",
		[
			1506
		]
	],
	[
		[
			64289,
			64289
		],
		"mapped",
		[
			1488
		]
	],
	[
		[
			64290,
			64290
		],
		"mapped",
		[
			1491
		]
	],
	[
		[
			64291,
			64291
		],
		"mapped",
		[
			1492
		]
	],
	[
		[
			64292,
			64292
		],
		"mapped",
		[
			1499
		]
	],
	[
		[
			64293,
			64293
		],
		"mapped",
		[
			1500
		]
	],
	[
		[
			64294,
			64294
		],
		"mapped",
		[
			1501
		]
	],
	[
		[
			64295,
			64295
		],
		"mapped",
		[
			1512
		]
	],
	[
		[
			64296,
			64296
		],
		"mapped",
		[
			1514
		]
	],
	[
		[
			64297,
			64297
		],
		"disallowed_STD3_mapped",
		[
			43
		]
	],
	[
		[
			64298,
			64298
		],
		"mapped",
		[
			1513,
			1473
		]
	],
	[
		[
			64299,
			64299
		],
		"mapped",
		[
			1513,
			1474
		]
	],
	[
		[
			64300,
			64300
		],
		"mapped",
		[
			1513,
			1468,
			1473
		]
	],
	[
		[
			64301,
			64301
		],
		"mapped",
		[
			1513,
			1468,
			1474
		]
	],
	[
		[
			64302,
			64302
		],
		"mapped",
		[
			1488,
			1463
		]
	],
	[
		[
			64303,
			64303
		],
		"mapped",
		[
			1488,
			1464
		]
	],
	[
		[
			64304,
			64304
		],
		"mapped",
		[
			1488,
			1468
		]
	],
	[
		[
			64305,
			64305
		],
		"mapped",
		[
			1489,
			1468
		]
	],
	[
		[
			64306,
			64306
		],
		"mapped",
		[
			1490,
			1468
		]
	],
	[
		[
			64307,
			64307
		],
		"mapped",
		[
			1491,
			1468
		]
	],
	[
		[
			64308,
			64308
		],
		"mapped",
		[
			1492,
			1468
		]
	],
	[
		[
			64309,
			64309
		],
		"mapped",
		[
			1493,
			1468
		]
	],
	[
		[
			64310,
			64310
		],
		"mapped",
		[
			1494,
			1468
		]
	],
	[
		[
			64311,
			64311
		],
		"disallowed"
	],
	[
		[
			64312,
			64312
		],
		"mapped",
		[
			1496,
			1468
		]
	],
	[
		[
			64313,
			64313
		],
		"mapped",
		[
			1497,
			1468
		]
	],
	[
		[
			64314,
			64314
		],
		"mapped",
		[
			1498,
			1468
		]
	],
	[
		[
			64315,
			64315
		],
		"mapped",
		[
			1499,
			1468
		]
	],
	[
		[
			64316,
			64316
		],
		"mapped",
		[
			1500,
			1468
		]
	],
	[
		[
			64317,
			64317
		],
		"disallowed"
	],
	[
		[
			64318,
			64318
		],
		"mapped",
		[
			1502,
			1468
		]
	],
	[
		[
			64319,
			64319
		],
		"disallowed"
	],
	[
		[
			64320,
			64320
		],
		"mapped",
		[
			1504,
			1468
		]
	],
	[
		[
			64321,
			64321
		],
		"mapped",
		[
			1505,
			1468
		]
	],
	[
		[
			64322,
			64322
		],
		"disallowed"
	],
	[
		[
			64323,
			64323
		],
		"mapped",
		[
			1507,
			1468
		]
	],
	[
		[
			64324,
			64324
		],
		"mapped",
		[
			1508,
			1468
		]
	],
	[
		[
			64325,
			64325
		],
		"disallowed"
	],
	[
		[
			64326,
			64326
		],
		"mapped",
		[
			1510,
			1468
		]
	],
	[
		[
			64327,
			64327
		],
		"mapped",
		[
			1511,
			1468
		]
	],
	[
		[
			64328,
			64328
		],
		"mapped",
		[
			1512,
			1468
		]
	],
	[
		[
			64329,
			64329
		],
		"mapped",
		[
			1513,
			1468
		]
	],
	[
		[
			64330,
			64330
		],
		"mapped",
		[
			1514,
			1468
		]
	],
	[
		[
			64331,
			64331
		],
		"mapped",
		[
			1493,
			1465
		]
	],
	[
		[
			64332,
			64332
		],
		"mapped",
		[
			1489,
			1471
		]
	],
	[
		[
			64333,
			64333
		],
		"mapped",
		[
			1499,
			1471
		]
	],
	[
		[
			64334,
			64334
		],
		"mapped",
		[
			1508,
			1471
		]
	],
	[
		[
			64335,
			64335
		],
		"mapped",
		[
			1488,
			1500
		]
	],
	[
		[
			64336,
			64337
		],
		"mapped",
		[
			1649
		]
	],
	[
		[
			64338,
			64341
		],
		"mapped",
		[
			1659
		]
	],
	[
		[
			64342,
			64345
		],
		"mapped",
		[
			1662
		]
	],
	[
		[
			64346,
			64349
		],
		"mapped",
		[
			1664
		]
	],
	[
		[
			64350,
			64353
		],
		"mapped",
		[
			1658
		]
	],
	[
		[
			64354,
			64357
		],
		"mapped",
		[
			1663
		]
	],
	[
		[
			64358,
			64361
		],
		"mapped",
		[
			1657
		]
	],
	[
		[
			64362,
			64365
		],
		"mapped",
		[
			1700
		]
	],
	[
		[
			64366,
			64369
		],
		"mapped",
		[
			1702
		]
	],
	[
		[
			64370,
			64373
		],
		"mapped",
		[
			1668
		]
	],
	[
		[
			64374,
			64377
		],
		"mapped",
		[
			1667
		]
	],
	[
		[
			64378,
			64381
		],
		"mapped",
		[
			1670
		]
	],
	[
		[
			64382,
			64385
		],
		"mapped",
		[
			1671
		]
	],
	[
		[
			64386,
			64387
		],
		"mapped",
		[
			1677
		]
	],
	[
		[
			64388,
			64389
		],
		"mapped",
		[
			1676
		]
	],
	[
		[
			64390,
			64391
		],
		"mapped",
		[
			1678
		]
	],
	[
		[
			64392,
			64393
		],
		"mapped",
		[
			1672
		]
	],
	[
		[
			64394,
			64395
		],
		"mapped",
		[
			1688
		]
	],
	[
		[
			64396,
			64397
		],
		"mapped",
		[
			1681
		]
	],
	[
		[
			64398,
			64401
		],
		"mapped",
		[
			1705
		]
	],
	[
		[
			64402,
			64405
		],
		"mapped",
		[
			1711
		]
	],
	[
		[
			64406,
			64409
		],
		"mapped",
		[
			1715
		]
	],
	[
		[
			64410,
			64413
		],
		"mapped",
		[
			1713
		]
	],
	[
		[
			64414,
			64415
		],
		"mapped",
		[
			1722
		]
	],
	[
		[
			64416,
			64419
		],
		"mapped",
		[
			1723
		]
	],
	[
		[
			64420,
			64421
		],
		"mapped",
		[
			1728
		]
	],
	[
		[
			64422,
			64425
		],
		"mapped",
		[
			1729
		]
	],
	[
		[
			64426,
			64429
		],
		"mapped",
		[
			1726
		]
	],
	[
		[
			64430,
			64431
		],
		"mapped",
		[
			1746
		]
	],
	[
		[
			64432,
			64433
		],
		"mapped",
		[
			1747
		]
	],
	[
		[
			64434,
			64449
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			64450,
			64466
		],
		"disallowed"
	],
	[
		[
			64467,
			64470
		],
		"mapped",
		[
			1709
		]
	],
	[
		[
			64471,
			64472
		],
		"mapped",
		[
			1735
		]
	],
	[
		[
			64473,
			64474
		],
		"mapped",
		[
			1734
		]
	],
	[
		[
			64475,
			64476
		],
		"mapped",
		[
			1736
		]
	],
	[
		[
			64477,
			64477
		],
		"mapped",
		[
			1735,
			1652
		]
	],
	[
		[
			64478,
			64479
		],
		"mapped",
		[
			1739
		]
	],
	[
		[
			64480,
			64481
		],
		"mapped",
		[
			1733
		]
	],
	[
		[
			64482,
			64483
		],
		"mapped",
		[
			1737
		]
	],
	[
		[
			64484,
			64487
		],
		"mapped",
		[
			1744
		]
	],
	[
		[
			64488,
			64489
		],
		"mapped",
		[
			1609
		]
	],
	[
		[
			64490,
			64491
		],
		"mapped",
		[
			1574,
			1575
		]
	],
	[
		[
			64492,
			64493
		],
		"mapped",
		[
			1574,
			1749
		]
	],
	[
		[
			64494,
			64495
		],
		"mapped",
		[
			1574,
			1608
		]
	],
	[
		[
			64496,
			64497
		],
		"mapped",
		[
			1574,
			1735
		]
	],
	[
		[
			64498,
			64499
		],
		"mapped",
		[
			1574,
			1734
		]
	],
	[
		[
			64500,
			64501
		],
		"mapped",
		[
			1574,
			1736
		]
	],
	[
		[
			64502,
			64504
		],
		"mapped",
		[
			1574,
			1744
		]
	],
	[
		[
			64505,
			64507
		],
		"mapped",
		[
			1574,
			1609
		]
	],
	[
		[
			64508,
			64511
		],
		"mapped",
		[
			1740
		]
	],
	[
		[
			64512,
			64512
		],
		"mapped",
		[
			1574,
			1580
		]
	],
	[
		[
			64513,
			64513
		],
		"mapped",
		[
			1574,
			1581
		]
	],
	[
		[
			64514,
			64514
		],
		"mapped",
		[
			1574,
			1605
		]
	],
	[
		[
			64515,
			64515
		],
		"mapped",
		[
			1574,
			1609
		]
	],
	[
		[
			64516,
			64516
		],
		"mapped",
		[
			1574,
			1610
		]
	],
	[
		[
			64517,
			64517
		],
		"mapped",
		[
			1576,
			1580
		]
	],
	[
		[
			64518,
			64518
		],
		"mapped",
		[
			1576,
			1581
		]
	],
	[
		[
			64519,
			64519
		],
		"mapped",
		[
			1576,
			1582
		]
	],
	[
		[
			64520,
			64520
		],
		"mapped",
		[
			1576,
			1605
		]
	],
	[
		[
			64521,
			64521
		],
		"mapped",
		[
			1576,
			1609
		]
	],
	[
		[
			64522,
			64522
		],
		"mapped",
		[
			1576,
			1610
		]
	],
	[
		[
			64523,
			64523
		],
		"mapped",
		[
			1578,
			1580
		]
	],
	[
		[
			64524,
			64524
		],
		"mapped",
		[
			1578,
			1581
		]
	],
	[
		[
			64525,
			64525
		],
		"mapped",
		[
			1578,
			1582
		]
	],
	[
		[
			64526,
			64526
		],
		"mapped",
		[
			1578,
			1605
		]
	],
	[
		[
			64527,
			64527
		],
		"mapped",
		[
			1578,
			1609
		]
	],
	[
		[
			64528,
			64528
		],
		"mapped",
		[
			1578,
			1610
		]
	],
	[
		[
			64529,
			64529
		],
		"mapped",
		[
			1579,
			1580
		]
	],
	[
		[
			64530,
			64530
		],
		"mapped",
		[
			1579,
			1605
		]
	],
	[
		[
			64531,
			64531
		],
		"mapped",
		[
			1579,
			1609
		]
	],
	[
		[
			64532,
			64532
		],
		"mapped",
		[
			1579,
			1610
		]
	],
	[
		[
			64533,
			64533
		],
		"mapped",
		[
			1580,
			1581
		]
	],
	[
		[
			64534,
			64534
		],
		"mapped",
		[
			1580,
			1605
		]
	],
	[
		[
			64535,
			64535
		],
		"mapped",
		[
			1581,
			1580
		]
	],
	[
		[
			64536,
			64536
		],
		"mapped",
		[
			1581,
			1605
		]
	],
	[
		[
			64537,
			64537
		],
		"mapped",
		[
			1582,
			1580
		]
	],
	[
		[
			64538,
			64538
		],
		"mapped",
		[
			1582,
			1581
		]
	],
	[
		[
			64539,
			64539
		],
		"mapped",
		[
			1582,
			1605
		]
	],
	[
		[
			64540,
			64540
		],
		"mapped",
		[
			1587,
			1580
		]
	],
	[
		[
			64541,
			64541
		],
		"mapped",
		[
			1587,
			1581
		]
	],
	[
		[
			64542,
			64542
		],
		"mapped",
		[
			1587,
			1582
		]
	],
	[
		[
			64543,
			64543
		],
		"mapped",
		[
			1587,
			1605
		]
	],
	[
		[
			64544,
			64544
		],
		"mapped",
		[
			1589,
			1581
		]
	],
	[
		[
			64545,
			64545
		],
		"mapped",
		[
			1589,
			1605
		]
	],
	[
		[
			64546,
			64546
		],
		"mapped",
		[
			1590,
			1580
		]
	],
	[
		[
			64547,
			64547
		],
		"mapped",
		[
			1590,
			1581
		]
	],
	[
		[
			64548,
			64548
		],
		"mapped",
		[
			1590,
			1582
		]
	],
	[
		[
			64549,
			64549
		],
		"mapped",
		[
			1590,
			1605
		]
	],
	[
		[
			64550,
			64550
		],
		"mapped",
		[
			1591,
			1581
		]
	],
	[
		[
			64551,
			64551
		],
		"mapped",
		[
			1591,
			1605
		]
	],
	[
		[
			64552,
			64552
		],
		"mapped",
		[
			1592,
			1605
		]
	],
	[
		[
			64553,
			64553
		],
		"mapped",
		[
			1593,
			1580
		]
	],
	[
		[
			64554,
			64554
		],
		"mapped",
		[
			1593,
			1605
		]
	],
	[
		[
			64555,
			64555
		],
		"mapped",
		[
			1594,
			1580
		]
	],
	[
		[
			64556,
			64556
		],
		"mapped",
		[
			1594,
			1605
		]
	],
	[
		[
			64557,
			64557
		],
		"mapped",
		[
			1601,
			1580
		]
	],
	[
		[
			64558,
			64558
		],
		"mapped",
		[
			1601,
			1581
		]
	],
	[
		[
			64559,
			64559
		],
		"mapped",
		[
			1601,
			1582
		]
	],
	[
		[
			64560,
			64560
		],
		"mapped",
		[
			1601,
			1605
		]
	],
	[
		[
			64561,
			64561
		],
		"mapped",
		[
			1601,
			1609
		]
	],
	[
		[
			64562,
			64562
		],
		"mapped",
		[
			1601,
			1610
		]
	],
	[
		[
			64563,
			64563
		],
		"mapped",
		[
			1602,
			1581
		]
	],
	[
		[
			64564,
			64564
		],
		"mapped",
		[
			1602,
			1605
		]
	],
	[
		[
			64565,
			64565
		],
		"mapped",
		[
			1602,
			1609
		]
	],
	[
		[
			64566,
			64566
		],
		"mapped",
		[
			1602,
			1610
		]
	],
	[
		[
			64567,
			64567
		],
		"mapped",
		[
			1603,
			1575
		]
	],
	[
		[
			64568,
			64568
		],
		"mapped",
		[
			1603,
			1580
		]
	],
	[
		[
			64569,
			64569
		],
		"mapped",
		[
			1603,
			1581
		]
	],
	[
		[
			64570,
			64570
		],
		"mapped",
		[
			1603,
			1582
		]
	],
	[
		[
			64571,
			64571
		],
		"mapped",
		[
			1603,
			1604
		]
	],
	[
		[
			64572,
			64572
		],
		"mapped",
		[
			1603,
			1605
		]
	],
	[
		[
			64573,
			64573
		],
		"mapped",
		[
			1603,
			1609
		]
	],
	[
		[
			64574,
			64574
		],
		"mapped",
		[
			1603,
			1610
		]
	],
	[
		[
			64575,
			64575
		],
		"mapped",
		[
			1604,
			1580
		]
	],
	[
		[
			64576,
			64576
		],
		"mapped",
		[
			1604,
			1581
		]
	],
	[
		[
			64577,
			64577
		],
		"mapped",
		[
			1604,
			1582
		]
	],
	[
		[
			64578,
			64578
		],
		"mapped",
		[
			1604,
			1605
		]
	],
	[
		[
			64579,
			64579
		],
		"mapped",
		[
			1604,
			1609
		]
	],
	[
		[
			64580,
			64580
		],
		"mapped",
		[
			1604,
			1610
		]
	],
	[
		[
			64581,
			64581
		],
		"mapped",
		[
			1605,
			1580
		]
	],
	[
		[
			64582,
			64582
		],
		"mapped",
		[
			1605,
			1581
		]
	],
	[
		[
			64583,
			64583
		],
		"mapped",
		[
			1605,
			1582
		]
	],
	[
		[
			64584,
			64584
		],
		"mapped",
		[
			1605,
			1605
		]
	],
	[
		[
			64585,
			64585
		],
		"mapped",
		[
			1605,
			1609
		]
	],
	[
		[
			64586,
			64586
		],
		"mapped",
		[
			1605,
			1610
		]
	],
	[
		[
			64587,
			64587
		],
		"mapped",
		[
			1606,
			1580
		]
	],
	[
		[
			64588,
			64588
		],
		"mapped",
		[
			1606,
			1581
		]
	],
	[
		[
			64589,
			64589
		],
		"mapped",
		[
			1606,
			1582
		]
	],
	[
		[
			64590,
			64590
		],
		"mapped",
		[
			1606,
			1605
		]
	],
	[
		[
			64591,
			64591
		],
		"mapped",
		[
			1606,
			1609
		]
	],
	[
		[
			64592,
			64592
		],
		"mapped",
		[
			1606,
			1610
		]
	],
	[
		[
			64593,
			64593
		],
		"mapped",
		[
			1607,
			1580
		]
	],
	[
		[
			64594,
			64594
		],
		"mapped",
		[
			1607,
			1605
		]
	],
	[
		[
			64595,
			64595
		],
		"mapped",
		[
			1607,
			1609
		]
	],
	[
		[
			64596,
			64596
		],
		"mapped",
		[
			1607,
			1610
		]
	],
	[
		[
			64597,
			64597
		],
		"mapped",
		[
			1610,
			1580
		]
	],
	[
		[
			64598,
			64598
		],
		"mapped",
		[
			1610,
			1581
		]
	],
	[
		[
			64599,
			64599
		],
		"mapped",
		[
			1610,
			1582
		]
	],
	[
		[
			64600,
			64600
		],
		"mapped",
		[
			1610,
			1605
		]
	],
	[
		[
			64601,
			64601
		],
		"mapped",
		[
			1610,
			1609
		]
	],
	[
		[
			64602,
			64602
		],
		"mapped",
		[
			1610,
			1610
		]
	],
	[
		[
			64603,
			64603
		],
		"mapped",
		[
			1584,
			1648
		]
	],
	[
		[
			64604,
			64604
		],
		"mapped",
		[
			1585,
			1648
		]
	],
	[
		[
			64605,
			64605
		],
		"mapped",
		[
			1609,
			1648
		]
	],
	[
		[
			64606,
			64606
		],
		"disallowed_STD3_mapped",
		[
			32,
			1612,
			1617
		]
	],
	[
		[
			64607,
			64607
		],
		"disallowed_STD3_mapped",
		[
			32,
			1613,
			1617
		]
	],
	[
		[
			64608,
			64608
		],
		"disallowed_STD3_mapped",
		[
			32,
			1614,
			1617
		]
	],
	[
		[
			64609,
			64609
		],
		"disallowed_STD3_mapped",
		[
			32,
			1615,
			1617
		]
	],
	[
		[
			64610,
			64610
		],
		"disallowed_STD3_mapped",
		[
			32,
			1616,
			1617
		]
	],
	[
		[
			64611,
			64611
		],
		"disallowed_STD3_mapped",
		[
			32,
			1617,
			1648
		]
	],
	[
		[
			64612,
			64612
		],
		"mapped",
		[
			1574,
			1585
		]
	],
	[
		[
			64613,
			64613
		],
		"mapped",
		[
			1574,
			1586
		]
	],
	[
		[
			64614,
			64614
		],
		"mapped",
		[
			1574,
			1605
		]
	],
	[
		[
			64615,
			64615
		],
		"mapped",
		[
			1574,
			1606
		]
	],
	[
		[
			64616,
			64616
		],
		"mapped",
		[
			1574,
			1609
		]
	],
	[
		[
			64617,
			64617
		],
		"mapped",
		[
			1574,
			1610
		]
	],
	[
		[
			64618,
			64618
		],
		"mapped",
		[
			1576,
			1585
		]
	],
	[
		[
			64619,
			64619
		],
		"mapped",
		[
			1576,
			1586
		]
	],
	[
		[
			64620,
			64620
		],
		"mapped",
		[
			1576,
			1605
		]
	],
	[
		[
			64621,
			64621
		],
		"mapped",
		[
			1576,
			1606
		]
	],
	[
		[
			64622,
			64622
		],
		"mapped",
		[
			1576,
			1609
		]
	],
	[
		[
			64623,
			64623
		],
		"mapped",
		[
			1576,
			1610
		]
	],
	[
		[
			64624,
			64624
		],
		"mapped",
		[
			1578,
			1585
		]
	],
	[
		[
			64625,
			64625
		],
		"mapped",
		[
			1578,
			1586
		]
	],
	[
		[
			64626,
			64626
		],
		"mapped",
		[
			1578,
			1605
		]
	],
	[
		[
			64627,
			64627
		],
		"mapped",
		[
			1578,
			1606
		]
	],
	[
		[
			64628,
			64628
		],
		"mapped",
		[
			1578,
			1609
		]
	],
	[
		[
			64629,
			64629
		],
		"mapped",
		[
			1578,
			1610
		]
	],
	[
		[
			64630,
			64630
		],
		"mapped",
		[
			1579,
			1585
		]
	],
	[
		[
			64631,
			64631
		],
		"mapped",
		[
			1579,
			1586
		]
	],
	[
		[
			64632,
			64632
		],
		"mapped",
		[
			1579,
			1605
		]
	],
	[
		[
			64633,
			64633
		],
		"mapped",
		[
			1579,
			1606
		]
	],
	[
		[
			64634,
			64634
		],
		"mapped",
		[
			1579,
			1609
		]
	],
	[
		[
			64635,
			64635
		],
		"mapped",
		[
			1579,
			1610
		]
	],
	[
		[
			64636,
			64636
		],
		"mapped",
		[
			1601,
			1609
		]
	],
	[
		[
			64637,
			64637
		],
		"mapped",
		[
			1601,
			1610
		]
	],
	[
		[
			64638,
			64638
		],
		"mapped",
		[
			1602,
			1609
		]
	],
	[
		[
			64639,
			64639
		],
		"mapped",
		[
			1602,
			1610
		]
	],
	[
		[
			64640,
			64640
		],
		"mapped",
		[
			1603,
			1575
		]
	],
	[
		[
			64641,
			64641
		],
		"mapped",
		[
			1603,
			1604
		]
	],
	[
		[
			64642,
			64642
		],
		"mapped",
		[
			1603,
			1605
		]
	],
	[
		[
			64643,
			64643
		],
		"mapped",
		[
			1603,
			1609
		]
	],
	[
		[
			64644,
			64644
		],
		"mapped",
		[
			1603,
			1610
		]
	],
	[
		[
			64645,
			64645
		],
		"mapped",
		[
			1604,
			1605
		]
	],
	[
		[
			64646,
			64646
		],
		"mapped",
		[
			1604,
			1609
		]
	],
	[
		[
			64647,
			64647
		],
		"mapped",
		[
			1604,
			1610
		]
	],
	[
		[
			64648,
			64648
		],
		"mapped",
		[
			1605,
			1575
		]
	],
	[
		[
			64649,
			64649
		],
		"mapped",
		[
			1605,
			1605
		]
	],
	[
		[
			64650,
			64650
		],
		"mapped",
		[
			1606,
			1585
		]
	],
	[
		[
			64651,
			64651
		],
		"mapped",
		[
			1606,
			1586
		]
	],
	[
		[
			64652,
			64652
		],
		"mapped",
		[
			1606,
			1605
		]
	],
	[
		[
			64653,
			64653
		],
		"mapped",
		[
			1606,
			1606
		]
	],
	[
		[
			64654,
			64654
		],
		"mapped",
		[
			1606,
			1609
		]
	],
	[
		[
			64655,
			64655
		],
		"mapped",
		[
			1606,
			1610
		]
	],
	[
		[
			64656,
			64656
		],
		"mapped",
		[
			1609,
			1648
		]
	],
	[
		[
			64657,
			64657
		],
		"mapped",
		[
			1610,
			1585
		]
	],
	[
		[
			64658,
			64658
		],
		"mapped",
		[
			1610,
			1586
		]
	],
	[
		[
			64659,
			64659
		],
		"mapped",
		[
			1610,
			1605
		]
	],
	[
		[
			64660,
			64660
		],
		"mapped",
		[
			1610,
			1606
		]
	],
	[
		[
			64661,
			64661
		],
		"mapped",
		[
			1610,
			1609
		]
	],
	[
		[
			64662,
			64662
		],
		"mapped",
		[
			1610,
			1610
		]
	],
	[
		[
			64663,
			64663
		],
		"mapped",
		[
			1574,
			1580
		]
	],
	[
		[
			64664,
			64664
		],
		"mapped",
		[
			1574,
			1581
		]
	],
	[
		[
			64665,
			64665
		],
		"mapped",
		[
			1574,
			1582
		]
	],
	[
		[
			64666,
			64666
		],
		"mapped",
		[
			1574,
			1605
		]
	],
	[
		[
			64667,
			64667
		],
		"mapped",
		[
			1574,
			1607
		]
	],
	[
		[
			64668,
			64668
		],
		"mapped",
		[
			1576,
			1580
		]
	],
	[
		[
			64669,
			64669
		],
		"mapped",
		[
			1576,
			1581
		]
	],
	[
		[
			64670,
			64670
		],
		"mapped",
		[
			1576,
			1582
		]
	],
	[
		[
			64671,
			64671
		],
		"mapped",
		[
			1576,
			1605
		]
	],
	[
		[
			64672,
			64672
		],
		"mapped",
		[
			1576,
			1607
		]
	],
	[
		[
			64673,
			64673
		],
		"mapped",
		[
			1578,
			1580
		]
	],
	[
		[
			64674,
			64674
		],
		"mapped",
		[
			1578,
			1581
		]
	],
	[
		[
			64675,
			64675
		],
		"mapped",
		[
			1578,
			1582
		]
	],
	[
		[
			64676,
			64676
		],
		"mapped",
		[
			1578,
			1605
		]
	],
	[
		[
			64677,
			64677
		],
		"mapped",
		[
			1578,
			1607
		]
	],
	[
		[
			64678,
			64678
		],
		"mapped",
		[
			1579,
			1605
		]
	],
	[
		[
			64679,
			64679
		],
		"mapped",
		[
			1580,
			1581
		]
	],
	[
		[
			64680,
			64680
		],
		"mapped",
		[
			1580,
			1605
		]
	],
	[
		[
			64681,
			64681
		],
		"mapped",
		[
			1581,
			1580
		]
	],
	[
		[
			64682,
			64682
		],
		"mapped",
		[
			1581,
			1605
		]
	],
	[
		[
			64683,
			64683
		],
		"mapped",
		[
			1582,
			1580
		]
	],
	[
		[
			64684,
			64684
		],
		"mapped",
		[
			1582,
			1605
		]
	],
	[
		[
			64685,
			64685
		],
		"mapped",
		[
			1587,
			1580
		]
	],
	[
		[
			64686,
			64686
		],
		"mapped",
		[
			1587,
			1581
		]
	],
	[
		[
			64687,
			64687
		],
		"mapped",
		[
			1587,
			1582
		]
	],
	[
		[
			64688,
			64688
		],
		"mapped",
		[
			1587,
			1605
		]
	],
	[
		[
			64689,
			64689
		],
		"mapped",
		[
			1589,
			1581
		]
	],
	[
		[
			64690,
			64690
		],
		"mapped",
		[
			1589,
			1582
		]
	],
	[
		[
			64691,
			64691
		],
		"mapped",
		[
			1589,
			1605
		]
	],
	[
		[
			64692,
			64692
		],
		"mapped",
		[
			1590,
			1580
		]
	],
	[
		[
			64693,
			64693
		],
		"mapped",
		[
			1590,
			1581
		]
	],
	[
		[
			64694,
			64694
		],
		"mapped",
		[
			1590,
			1582
		]
	],
	[
		[
			64695,
			64695
		],
		"mapped",
		[
			1590,
			1605
		]
	],
	[
		[
			64696,
			64696
		],
		"mapped",
		[
			1591,
			1581
		]
	],
	[
		[
			64697,
			64697
		],
		"mapped",
		[
			1592,
			1605
		]
	],
	[
		[
			64698,
			64698
		],
		"mapped",
		[
			1593,
			1580
		]
	],
	[
		[
			64699,
			64699
		],
		"mapped",
		[
			1593,
			1605
		]
	],
	[
		[
			64700,
			64700
		],
		"mapped",
		[
			1594,
			1580
		]
	],
	[
		[
			64701,
			64701
		],
		"mapped",
		[
			1594,
			1605
		]
	],
	[
		[
			64702,
			64702
		],
		"mapped",
		[
			1601,
			1580
		]
	],
	[
		[
			64703,
			64703
		],
		"mapped",
		[
			1601,
			1581
		]
	],
	[
		[
			64704,
			64704
		],
		"mapped",
		[
			1601,
			1582
		]
	],
	[
		[
			64705,
			64705
		],
		"mapped",
		[
			1601,
			1605
		]
	],
	[
		[
			64706,
			64706
		],
		"mapped",
		[
			1602,
			1581
		]
	],
	[
		[
			64707,
			64707
		],
		"mapped",
		[
			1602,
			1605
		]
	],
	[
		[
			64708,
			64708
		],
		"mapped",
		[
			1603,
			1580
		]
	],
	[
		[
			64709,
			64709
		],
		"mapped",
		[
			1603,
			1581
		]
	],
	[
		[
			64710,
			64710
		],
		"mapped",
		[
			1603,
			1582
		]
	],
	[
		[
			64711,
			64711
		],
		"mapped",
		[
			1603,
			1604
		]
	],
	[
		[
			64712,
			64712
		],
		"mapped",
		[
			1603,
			1605
		]
	],
	[
		[
			64713,
			64713
		],
		"mapped",
		[
			1604,
			1580
		]
	],
	[
		[
			64714,
			64714
		],
		"mapped",
		[
			1604,
			1581
		]
	],
	[
		[
			64715,
			64715
		],
		"mapped",
		[
			1604,
			1582
		]
	],
	[
		[
			64716,
			64716
		],
		"mapped",
		[
			1604,
			1605
		]
	],
	[
		[
			64717,
			64717
		],
		"mapped",
		[
			1604,
			1607
		]
	],
	[
		[
			64718,
			64718
		],
		"mapped",
		[
			1605,
			1580
		]
	],
	[
		[
			64719,
			64719
		],
		"mapped",
		[
			1605,
			1581
		]
	],
	[
		[
			64720,
			64720
		],
		"mapped",
		[
			1605,
			1582
		]
	],
	[
		[
			64721,
			64721
		],
		"mapped",
		[
			1605,
			1605
		]
	],
	[
		[
			64722,
			64722
		],
		"mapped",
		[
			1606,
			1580
		]
	],
	[
		[
			64723,
			64723
		],
		"mapped",
		[
			1606,
			1581
		]
	],
	[
		[
			64724,
			64724
		],
		"mapped",
		[
			1606,
			1582
		]
	],
	[
		[
			64725,
			64725
		],
		"mapped",
		[
			1606,
			1605
		]
	],
	[
		[
			64726,
			64726
		],
		"mapped",
		[
			1606,
			1607
		]
	],
	[
		[
			64727,
			64727
		],
		"mapped",
		[
			1607,
			1580
		]
	],
	[
		[
			64728,
			64728
		],
		"mapped",
		[
			1607,
			1605
		]
	],
	[
		[
			64729,
			64729
		],
		"mapped",
		[
			1607,
			1648
		]
	],
	[
		[
			64730,
			64730
		],
		"mapped",
		[
			1610,
			1580
		]
	],
	[
		[
			64731,
			64731
		],
		"mapped",
		[
			1610,
			1581
		]
	],
	[
		[
			64732,
			64732
		],
		"mapped",
		[
			1610,
			1582
		]
	],
	[
		[
			64733,
			64733
		],
		"mapped",
		[
			1610,
			1605
		]
	],
	[
		[
			64734,
			64734
		],
		"mapped",
		[
			1610,
			1607
		]
	],
	[
		[
			64735,
			64735
		],
		"mapped",
		[
			1574,
			1605
		]
	],
	[
		[
			64736,
			64736
		],
		"mapped",
		[
			1574,
			1607
		]
	],
	[
		[
			64737,
			64737
		],
		"mapped",
		[
			1576,
			1605
		]
	],
	[
		[
			64738,
			64738
		],
		"mapped",
		[
			1576,
			1607
		]
	],
	[
		[
			64739,
			64739
		],
		"mapped",
		[
			1578,
			1605
		]
	],
	[
		[
			64740,
			64740
		],
		"mapped",
		[
			1578,
			1607
		]
	],
	[
		[
			64741,
			64741
		],
		"mapped",
		[
			1579,
			1605
		]
	],
	[
		[
			64742,
			64742
		],
		"mapped",
		[
			1579,
			1607
		]
	],
	[
		[
			64743,
			64743
		],
		"mapped",
		[
			1587,
			1605
		]
	],
	[
		[
			64744,
			64744
		],
		"mapped",
		[
			1587,
			1607
		]
	],
	[
		[
			64745,
			64745
		],
		"mapped",
		[
			1588,
			1605
		]
	],
	[
		[
			64746,
			64746
		],
		"mapped",
		[
			1588,
			1607
		]
	],
	[
		[
			64747,
			64747
		],
		"mapped",
		[
			1603,
			1604
		]
	],
	[
		[
			64748,
			64748
		],
		"mapped",
		[
			1603,
			1605
		]
	],
	[
		[
			64749,
			64749
		],
		"mapped",
		[
			1604,
			1605
		]
	],
	[
		[
			64750,
			64750
		],
		"mapped",
		[
			1606,
			1605
		]
	],
	[
		[
			64751,
			64751
		],
		"mapped",
		[
			1606,
			1607
		]
	],
	[
		[
			64752,
			64752
		],
		"mapped",
		[
			1610,
			1605
		]
	],
	[
		[
			64753,
			64753
		],
		"mapped",
		[
			1610,
			1607
		]
	],
	[
		[
			64754,
			64754
		],
		"mapped",
		[
			1600,
			1614,
			1617
		]
	],
	[
		[
			64755,
			64755
		],
		"mapped",
		[
			1600,
			1615,
			1617
		]
	],
	[
		[
			64756,
			64756
		],
		"mapped",
		[
			1600,
			1616,
			1617
		]
	],
	[
		[
			64757,
			64757
		],
		"mapped",
		[
			1591,
			1609
		]
	],
	[
		[
			64758,
			64758
		],
		"mapped",
		[
			1591,
			1610
		]
	],
	[
		[
			64759,
			64759
		],
		"mapped",
		[
			1593,
			1609
		]
	],
	[
		[
			64760,
			64760
		],
		"mapped",
		[
			1593,
			1610
		]
	],
	[
		[
			64761,
			64761
		],
		"mapped",
		[
			1594,
			1609
		]
	],
	[
		[
			64762,
			64762
		],
		"mapped",
		[
			1594,
			1610
		]
	],
	[
		[
			64763,
			64763
		],
		"mapped",
		[
			1587,
			1609
		]
	],
	[
		[
			64764,
			64764
		],
		"mapped",
		[
			1587,
			1610
		]
	],
	[
		[
			64765,
			64765
		],
		"mapped",
		[
			1588,
			1609
		]
	],
	[
		[
			64766,
			64766
		],
		"mapped",
		[
			1588,
			1610
		]
	],
	[
		[
			64767,
			64767
		],
		"mapped",
		[
			1581,
			1609
		]
	],
	[
		[
			64768,
			64768
		],
		"mapped",
		[
			1581,
			1610
		]
	],
	[
		[
			64769,
			64769
		],
		"mapped",
		[
			1580,
			1609
		]
	],
	[
		[
			64770,
			64770
		],
		"mapped",
		[
			1580,
			1610
		]
	],
	[
		[
			64771,
			64771
		],
		"mapped",
		[
			1582,
			1609
		]
	],
	[
		[
			64772,
			64772
		],
		"mapped",
		[
			1582,
			1610
		]
	],
	[
		[
			64773,
			64773
		],
		"mapped",
		[
			1589,
			1609
		]
	],
	[
		[
			64774,
			64774
		],
		"mapped",
		[
			1589,
			1610
		]
	],
	[
		[
			64775,
			64775
		],
		"mapped",
		[
			1590,
			1609
		]
	],
	[
		[
			64776,
			64776
		],
		"mapped",
		[
			1590,
			1610
		]
	],
	[
		[
			64777,
			64777
		],
		"mapped",
		[
			1588,
			1580
		]
	],
	[
		[
			64778,
			64778
		],
		"mapped",
		[
			1588,
			1581
		]
	],
	[
		[
			64779,
			64779
		],
		"mapped",
		[
			1588,
			1582
		]
	],
	[
		[
			64780,
			64780
		],
		"mapped",
		[
			1588,
			1605
		]
	],
	[
		[
			64781,
			64781
		],
		"mapped",
		[
			1588,
			1585
		]
	],
	[
		[
			64782,
			64782
		],
		"mapped",
		[
			1587,
			1585
		]
	],
	[
		[
			64783,
			64783
		],
		"mapped",
		[
			1589,
			1585
		]
	],
	[
		[
			64784,
			64784
		],
		"mapped",
		[
			1590,
			1585
		]
	],
	[
		[
			64785,
			64785
		],
		"mapped",
		[
			1591,
			1609
		]
	],
	[
		[
			64786,
			64786
		],
		"mapped",
		[
			1591,
			1610
		]
	],
	[
		[
			64787,
			64787
		],
		"mapped",
		[
			1593,
			1609
		]
	],
	[
		[
			64788,
			64788
		],
		"mapped",
		[
			1593,
			1610
		]
	],
	[
		[
			64789,
			64789
		],
		"mapped",
		[
			1594,
			1609
		]
	],
	[
		[
			64790,
			64790
		],
		"mapped",
		[
			1594,
			1610
		]
	],
	[
		[
			64791,
			64791
		],
		"mapped",
		[
			1587,
			1609
		]
	],
	[
		[
			64792,
			64792
		],
		"mapped",
		[
			1587,
			1610
		]
	],
	[
		[
			64793,
			64793
		],
		"mapped",
		[
			1588,
			1609
		]
	],
	[
		[
			64794,
			64794
		],
		"mapped",
		[
			1588,
			1610
		]
	],
	[
		[
			64795,
			64795
		],
		"mapped",
		[
			1581,
			1609
		]
	],
	[
		[
			64796,
			64796
		],
		"mapped",
		[
			1581,
			1610
		]
	],
	[
		[
			64797,
			64797
		],
		"mapped",
		[
			1580,
			1609
		]
	],
	[
		[
			64798,
			64798
		],
		"mapped",
		[
			1580,
			1610
		]
	],
	[
		[
			64799,
			64799
		],
		"mapped",
		[
			1582,
			1609
		]
	],
	[
		[
			64800,
			64800
		],
		"mapped",
		[
			1582,
			1610
		]
	],
	[
		[
			64801,
			64801
		],
		"mapped",
		[
			1589,
			1609
		]
	],
	[
		[
			64802,
			64802
		],
		"mapped",
		[
			1589,
			1610
		]
	],
	[
		[
			64803,
			64803
		],
		"mapped",
		[
			1590,
			1609
		]
	],
	[
		[
			64804,
			64804
		],
		"mapped",
		[
			1590,
			1610
		]
	],
	[
		[
			64805,
			64805
		],
		"mapped",
		[
			1588,
			1580
		]
	],
	[
		[
			64806,
			64806
		],
		"mapped",
		[
			1588,
			1581
		]
	],
	[
		[
			64807,
			64807
		],
		"mapped",
		[
			1588,
			1582
		]
	],
	[
		[
			64808,
			64808
		],
		"mapped",
		[
			1588,
			1605
		]
	],
	[
		[
			64809,
			64809
		],
		"mapped",
		[
			1588,
			1585
		]
	],
	[
		[
			64810,
			64810
		],
		"mapped",
		[
			1587,
			1585
		]
	],
	[
		[
			64811,
			64811
		],
		"mapped",
		[
			1589,
			1585
		]
	],
	[
		[
			64812,
			64812
		],
		"mapped",
		[
			1590,
			1585
		]
	],
	[
		[
			64813,
			64813
		],
		"mapped",
		[
			1588,
			1580
		]
	],
	[
		[
			64814,
			64814
		],
		"mapped",
		[
			1588,
			1581
		]
	],
	[
		[
			64815,
			64815
		],
		"mapped",
		[
			1588,
			1582
		]
	],
	[
		[
			64816,
			64816
		],
		"mapped",
		[
			1588,
			1605
		]
	],
	[
		[
			64817,
			64817
		],
		"mapped",
		[
			1587,
			1607
		]
	],
	[
		[
			64818,
			64818
		],
		"mapped",
		[
			1588,
			1607
		]
	],
	[
		[
			64819,
			64819
		],
		"mapped",
		[
			1591,
			1605
		]
	],
	[
		[
			64820,
			64820
		],
		"mapped",
		[
			1587,
			1580
		]
	],
	[
		[
			64821,
			64821
		],
		"mapped",
		[
			1587,
			1581
		]
	],
	[
		[
			64822,
			64822
		],
		"mapped",
		[
			1587,
			1582
		]
	],
	[
		[
			64823,
			64823
		],
		"mapped",
		[
			1588,
			1580
		]
	],
	[
		[
			64824,
			64824
		],
		"mapped",
		[
			1588,
			1581
		]
	],
	[
		[
			64825,
			64825
		],
		"mapped",
		[
			1588,
			1582
		]
	],
	[
		[
			64826,
			64826
		],
		"mapped",
		[
			1591,
			1605
		]
	],
	[
		[
			64827,
			64827
		],
		"mapped",
		[
			1592,
			1605
		]
	],
	[
		[
			64828,
			64829
		],
		"mapped",
		[
			1575,
			1611
		]
	],
	[
		[
			64830,
			64831
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			64832,
			64847
		],
		"disallowed"
	],
	[
		[
			64848,
			64848
		],
		"mapped",
		[
			1578,
			1580,
			1605
		]
	],
	[
		[
			64849,
			64850
		],
		"mapped",
		[
			1578,
			1581,
			1580
		]
	],
	[
		[
			64851,
			64851
		],
		"mapped",
		[
			1578,
			1581,
			1605
		]
	],
	[
		[
			64852,
			64852
		],
		"mapped",
		[
			1578,
			1582,
			1605
		]
	],
	[
		[
			64853,
			64853
		],
		"mapped",
		[
			1578,
			1605,
			1580
		]
	],
	[
		[
			64854,
			64854
		],
		"mapped",
		[
			1578,
			1605,
			1581
		]
	],
	[
		[
			64855,
			64855
		],
		"mapped",
		[
			1578,
			1605,
			1582
		]
	],
	[
		[
			64856,
			64857
		],
		"mapped",
		[
			1580,
			1605,
			1581
		]
	],
	[
		[
			64858,
			64858
		],
		"mapped",
		[
			1581,
			1605,
			1610
		]
	],
	[
		[
			64859,
			64859
		],
		"mapped",
		[
			1581,
			1605,
			1609
		]
	],
	[
		[
			64860,
			64860
		],
		"mapped",
		[
			1587,
			1581,
			1580
		]
	],
	[
		[
			64861,
			64861
		],
		"mapped",
		[
			1587,
			1580,
			1581
		]
	],
	[
		[
			64862,
			64862
		],
		"mapped",
		[
			1587,
			1580,
			1609
		]
	],
	[
		[
			64863,
			64864
		],
		"mapped",
		[
			1587,
			1605,
			1581
		]
	],
	[
		[
			64865,
			64865
		],
		"mapped",
		[
			1587,
			1605,
			1580
		]
	],
	[
		[
			64866,
			64867
		],
		"mapped",
		[
			1587,
			1605,
			1605
		]
	],
	[
		[
			64868,
			64869
		],
		"mapped",
		[
			1589,
			1581,
			1581
		]
	],
	[
		[
			64870,
			64870
		],
		"mapped",
		[
			1589,
			1605,
			1605
		]
	],
	[
		[
			64871,
			64872
		],
		"mapped",
		[
			1588,
			1581,
			1605
		]
	],
	[
		[
			64873,
			64873
		],
		"mapped",
		[
			1588,
			1580,
			1610
		]
	],
	[
		[
			64874,
			64875
		],
		"mapped",
		[
			1588,
			1605,
			1582
		]
	],
	[
		[
			64876,
			64877
		],
		"mapped",
		[
			1588,
			1605,
			1605
		]
	],
	[
		[
			64878,
			64878
		],
		"mapped",
		[
			1590,
			1581,
			1609
		]
	],
	[
		[
			64879,
			64880
		],
		"mapped",
		[
			1590,
			1582,
			1605
		]
	],
	[
		[
			64881,
			64882
		],
		"mapped",
		[
			1591,
			1605,
			1581
		]
	],
	[
		[
			64883,
			64883
		],
		"mapped",
		[
			1591,
			1605,
			1605
		]
	],
	[
		[
			64884,
			64884
		],
		"mapped",
		[
			1591,
			1605,
			1610
		]
	],
	[
		[
			64885,
			64885
		],
		"mapped",
		[
			1593,
			1580,
			1605
		]
	],
	[
		[
			64886,
			64887
		],
		"mapped",
		[
			1593,
			1605,
			1605
		]
	],
	[
		[
			64888,
			64888
		],
		"mapped",
		[
			1593,
			1605,
			1609
		]
	],
	[
		[
			64889,
			64889
		],
		"mapped",
		[
			1594,
			1605,
			1605
		]
	],
	[
		[
			64890,
			64890
		],
		"mapped",
		[
			1594,
			1605,
			1610
		]
	],
	[
		[
			64891,
			64891
		],
		"mapped",
		[
			1594,
			1605,
			1609
		]
	],
	[
		[
			64892,
			64893
		],
		"mapped",
		[
			1601,
			1582,
			1605
		]
	],
	[
		[
			64894,
			64894
		],
		"mapped",
		[
			1602,
			1605,
			1581
		]
	],
	[
		[
			64895,
			64895
		],
		"mapped",
		[
			1602,
			1605,
			1605
		]
	],
	[
		[
			64896,
			64896
		],
		"mapped",
		[
			1604,
			1581,
			1605
		]
	],
	[
		[
			64897,
			64897
		],
		"mapped",
		[
			1604,
			1581,
			1610
		]
	],
	[
		[
			64898,
			64898
		],
		"mapped",
		[
			1604,
			1581,
			1609
		]
	],
	[
		[
			64899,
			64900
		],
		"mapped",
		[
			1604,
			1580,
			1580
		]
	],
	[
		[
			64901,
			64902
		],
		"mapped",
		[
			1604,
			1582,
			1605
		]
	],
	[
		[
			64903,
			64904
		],
		"mapped",
		[
			1604,
			1605,
			1581
		]
	],
	[
		[
			64905,
			64905
		],
		"mapped",
		[
			1605,
			1581,
			1580
		]
	],
	[
		[
			64906,
			64906
		],
		"mapped",
		[
			1605,
			1581,
			1605
		]
	],
	[
		[
			64907,
			64907
		],
		"mapped",
		[
			1605,
			1581,
			1610
		]
	],
	[
		[
			64908,
			64908
		],
		"mapped",
		[
			1605,
			1580,
			1581
		]
	],
	[
		[
			64909,
			64909
		],
		"mapped",
		[
			1605,
			1580,
			1605
		]
	],
	[
		[
			64910,
			64910
		],
		"mapped",
		[
			1605,
			1582,
			1580
		]
	],
	[
		[
			64911,
			64911
		],
		"mapped",
		[
			1605,
			1582,
			1605
		]
	],
	[
		[
			64912,
			64913
		],
		"disallowed"
	],
	[
		[
			64914,
			64914
		],
		"mapped",
		[
			1605,
			1580,
			1582
		]
	],
	[
		[
			64915,
			64915
		],
		"mapped",
		[
			1607,
			1605,
			1580
		]
	],
	[
		[
			64916,
			64916
		],
		"mapped",
		[
			1607,
			1605,
			1605
		]
	],
	[
		[
			64917,
			64917
		],
		"mapped",
		[
			1606,
			1581,
			1605
		]
	],
	[
		[
			64918,
			64918
		],
		"mapped",
		[
			1606,
			1581,
			1609
		]
	],
	[
		[
			64919,
			64920
		],
		"mapped",
		[
			1606,
			1580,
			1605
		]
	],
	[
		[
			64921,
			64921
		],
		"mapped",
		[
			1606,
			1580,
			1609
		]
	],
	[
		[
			64922,
			64922
		],
		"mapped",
		[
			1606,
			1605,
			1610
		]
	],
	[
		[
			64923,
			64923
		],
		"mapped",
		[
			1606,
			1605,
			1609
		]
	],
	[
		[
			64924,
			64925
		],
		"mapped",
		[
			1610,
			1605,
			1605
		]
	],
	[
		[
			64926,
			64926
		],
		"mapped",
		[
			1576,
			1582,
			1610
		]
	],
	[
		[
			64927,
			64927
		],
		"mapped",
		[
			1578,
			1580,
			1610
		]
	],
	[
		[
			64928,
			64928
		],
		"mapped",
		[
			1578,
			1580,
			1609
		]
	],
	[
		[
			64929,
			64929
		],
		"mapped",
		[
			1578,
			1582,
			1610
		]
	],
	[
		[
			64930,
			64930
		],
		"mapped",
		[
			1578,
			1582,
			1609
		]
	],
	[
		[
			64931,
			64931
		],
		"mapped",
		[
			1578,
			1605,
			1610
		]
	],
	[
		[
			64932,
			64932
		],
		"mapped",
		[
			1578,
			1605,
			1609
		]
	],
	[
		[
			64933,
			64933
		],
		"mapped",
		[
			1580,
			1605,
			1610
		]
	],
	[
		[
			64934,
			64934
		],
		"mapped",
		[
			1580,
			1581,
			1609
		]
	],
	[
		[
			64935,
			64935
		],
		"mapped",
		[
			1580,
			1605,
			1609
		]
	],
	[
		[
			64936,
			64936
		],
		"mapped",
		[
			1587,
			1582,
			1609
		]
	],
	[
		[
			64937,
			64937
		],
		"mapped",
		[
			1589,
			1581,
			1610
		]
	],
	[
		[
			64938,
			64938
		],
		"mapped",
		[
			1588,
			1581,
			1610
		]
	],
	[
		[
			64939,
			64939
		],
		"mapped",
		[
			1590,
			1581,
			1610
		]
	],
	[
		[
			64940,
			64940
		],
		"mapped",
		[
			1604,
			1580,
			1610
		]
	],
	[
		[
			64941,
			64941
		],
		"mapped",
		[
			1604,
			1605,
			1610
		]
	],
	[
		[
			64942,
			64942
		],
		"mapped",
		[
			1610,
			1581,
			1610
		]
	],
	[
		[
			64943,
			64943
		],
		"mapped",
		[
			1610,
			1580,
			1610
		]
	],
	[
		[
			64944,
			64944
		],
		"mapped",
		[
			1610,
			1605,
			1610
		]
	],
	[
		[
			64945,
			64945
		],
		"mapped",
		[
			1605,
			1605,
			1610
		]
	],
	[
		[
			64946,
			64946
		],
		"mapped",
		[
			1602,
			1605,
			1610
		]
	],
	[
		[
			64947,
			64947
		],
		"mapped",
		[
			1606,
			1581,
			1610
		]
	],
	[
		[
			64948,
			64948
		],
		"mapped",
		[
			1602,
			1605,
			1581
		]
	],
	[
		[
			64949,
			64949
		],
		"mapped",
		[
			1604,
			1581,
			1605
		]
	],
	[
		[
			64950,
			64950
		],
		"mapped",
		[
			1593,
			1605,
			1610
		]
	],
	[
		[
			64951,
			64951
		],
		"mapped",
		[
			1603,
			1605,
			1610
		]
	],
	[
		[
			64952,
			64952
		],
		"mapped",
		[
			1606,
			1580,
			1581
		]
	],
	[
		[
			64953,
			64953
		],
		"mapped",
		[
			1605,
			1582,
			1610
		]
	],
	[
		[
			64954,
			64954
		],
		"mapped",
		[
			1604,
			1580,
			1605
		]
	],
	[
		[
			64955,
			64955
		],
		"mapped",
		[
			1603,
			1605,
			1605
		]
	],
	[
		[
			64956,
			64956
		],
		"mapped",
		[
			1604,
			1580,
			1605
		]
	],
	[
		[
			64957,
			64957
		],
		"mapped",
		[
			1606,
			1580,
			1581
		]
	],
	[
		[
			64958,
			64958
		],
		"mapped",
		[
			1580,
			1581,
			1610
		]
	],
	[
		[
			64959,
			64959
		],
		"mapped",
		[
			1581,
			1580,
			1610
		]
	],
	[
		[
			64960,
			64960
		],
		"mapped",
		[
			1605,
			1580,
			1610
		]
	],
	[
		[
			64961,
			64961
		],
		"mapped",
		[
			1601,
			1605,
			1610
		]
	],
	[
		[
			64962,
			64962
		],
		"mapped",
		[
			1576,
			1581,
			1610
		]
	],
	[
		[
			64963,
			64963
		],
		"mapped",
		[
			1603,
			1605,
			1605
		]
	],
	[
		[
			64964,
			64964
		],
		"mapped",
		[
			1593,
			1580,
			1605
		]
	],
	[
		[
			64965,
			64965
		],
		"mapped",
		[
			1589,
			1605,
			1605
		]
	],
	[
		[
			64966,
			64966
		],
		"mapped",
		[
			1587,
			1582,
			1610
		]
	],
	[
		[
			64967,
			64967
		],
		"mapped",
		[
			1606,
			1580,
			1610
		]
	],
	[
		[
			64968,
			64975
		],
		"disallowed"
	],
	[
		[
			64976,
			65007
		],
		"disallowed"
	],
	[
		[
			65008,
			65008
		],
		"mapped",
		[
			1589,
			1604,
			1746
		]
	],
	[
		[
			65009,
			65009
		],
		"mapped",
		[
			1602,
			1604,
			1746
		]
	],
	[
		[
			65010,
			65010
		],
		"mapped",
		[
			1575,
			1604,
			1604,
			1607
		]
	],
	[
		[
			65011,
			65011
		],
		"mapped",
		[
			1575,
			1603,
			1576,
			1585
		]
	],
	[
		[
			65012,
			65012
		],
		"mapped",
		[
			1605,
			1581,
			1605,
			1583
		]
	],
	[
		[
			65013,
			65013
		],
		"mapped",
		[
			1589,
			1604,
			1593,
			1605
		]
	],
	[
		[
			65014,
			65014
		],
		"mapped",
		[
			1585,
			1587,
			1608,
			1604
		]
	],
	[
		[
			65015,
			65015
		],
		"mapped",
		[
			1593,
			1604,
			1610,
			1607
		]
	],
	[
		[
			65016,
			65016
		],
		"mapped",
		[
			1608,
			1587,
			1604,
			1605
		]
	],
	[
		[
			65017,
			65017
		],
		"mapped",
		[
			1589,
			1604,
			1609
		]
	],
	[
		[
			65018,
			65018
		],
		"disallowed_STD3_mapped",
		[
			1589,
			1604,
			1609,
			32,
			1575,
			1604,
			1604,
			1607,
			32,
			1593,
			1604,
			1610,
			1607,
			32,
			1608,
			1587,
			1604,
			1605
		]
	],
	[
		[
			65019,
			65019
		],
		"disallowed_STD3_mapped",
		[
			1580,
			1604,
			32,
			1580,
			1604,
			1575,
			1604,
			1607
		]
	],
	[
		[
			65020,
			65020
		],
		"mapped",
		[
			1585,
			1740,
			1575,
			1604
		]
	],
	[
		[
			65021,
			65021
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			65022,
			65023
		],
		"disallowed"
	],
	[
		[
			65024,
			65039
		],
		"ignored"
	],
	[
		[
			65040,
			65040
		],
		"disallowed_STD3_mapped",
		[
			44
		]
	],
	[
		[
			65041,
			65041
		],
		"mapped",
		[
			12289
		]
	],
	[
		[
			65042,
			65042
		],
		"disallowed"
	],
	[
		[
			65043,
			65043
		],
		"disallowed_STD3_mapped",
		[
			58
		]
	],
	[
		[
			65044,
			65044
		],
		"disallowed_STD3_mapped",
		[
			59
		]
	],
	[
		[
			65045,
			65045
		],
		"disallowed_STD3_mapped",
		[
			33
		]
	],
	[
		[
			65046,
			65046
		],
		"disallowed_STD3_mapped",
		[
			63
		]
	],
	[
		[
			65047,
			65047
		],
		"mapped",
		[
			12310
		]
	],
	[
		[
			65048,
			65048
		],
		"mapped",
		[
			12311
		]
	],
	[
		[
			65049,
			65049
		],
		"disallowed"
	],
	[
		[
			65050,
			65055
		],
		"disallowed"
	],
	[
		[
			65056,
			65059
		],
		"valid"
	],
	[
		[
			65060,
			65062
		],
		"valid"
	],
	[
		[
			65063,
			65069
		],
		"valid"
	],
	[
		[
			65070,
			65071
		],
		"valid"
	],
	[
		[
			65072,
			65072
		],
		"disallowed"
	],
	[
		[
			65073,
			65073
		],
		"mapped",
		[
			8212
		]
	],
	[
		[
			65074,
			65074
		],
		"mapped",
		[
			8211
		]
	],
	[
		[
			65075,
			65076
		],
		"disallowed_STD3_mapped",
		[
			95
		]
	],
	[
		[
			65077,
			65077
		],
		"disallowed_STD3_mapped",
		[
			40
		]
	],
	[
		[
			65078,
			65078
		],
		"disallowed_STD3_mapped",
		[
			41
		]
	],
	[
		[
			65079,
			65079
		],
		"disallowed_STD3_mapped",
		[
			123
		]
	],
	[
		[
			65080,
			65080
		],
		"disallowed_STD3_mapped",
		[
			125
		]
	],
	[
		[
			65081,
			65081
		],
		"mapped",
		[
			12308
		]
	],
	[
		[
			65082,
			65082
		],
		"mapped",
		[
			12309
		]
	],
	[
		[
			65083,
			65083
		],
		"mapped",
		[
			12304
		]
	],
	[
		[
			65084,
			65084
		],
		"mapped",
		[
			12305
		]
	],
	[
		[
			65085,
			65085
		],
		"mapped",
		[
			12298
		]
	],
	[
		[
			65086,
			65086
		],
		"mapped",
		[
			12299
		]
	],
	[
		[
			65087,
			65087
		],
		"mapped",
		[
			12296
		]
	],
	[
		[
			65088,
			65088
		],
		"mapped",
		[
			12297
		]
	],
	[
		[
			65089,
			65089
		],
		"mapped",
		[
			12300
		]
	],
	[
		[
			65090,
			65090
		],
		"mapped",
		[
			12301
		]
	],
	[
		[
			65091,
			65091
		],
		"mapped",
		[
			12302
		]
	],
	[
		[
			65092,
			65092
		],
		"mapped",
		[
			12303
		]
	],
	[
		[
			65093,
			65094
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			65095,
			65095
		],
		"disallowed_STD3_mapped",
		[
			91
		]
	],
	[
		[
			65096,
			65096
		],
		"disallowed_STD3_mapped",
		[
			93
		]
	],
	[
		[
			65097,
			65100
		],
		"disallowed_STD3_mapped",
		[
			32,
			773
		]
	],
	[
		[
			65101,
			65103
		],
		"disallowed_STD3_mapped",
		[
			95
		]
	],
	[
		[
			65104,
			65104
		],
		"disallowed_STD3_mapped",
		[
			44
		]
	],
	[
		[
			65105,
			65105
		],
		"mapped",
		[
			12289
		]
	],
	[
		[
			65106,
			65106
		],
		"disallowed"
	],
	[
		[
			65107,
			65107
		],
		"disallowed"
	],
	[
		[
			65108,
			65108
		],
		"disallowed_STD3_mapped",
		[
			59
		]
	],
	[
		[
			65109,
			65109
		],
		"disallowed_STD3_mapped",
		[
			58
		]
	],
	[
		[
			65110,
			65110
		],
		"disallowed_STD3_mapped",
		[
			63
		]
	],
	[
		[
			65111,
			65111
		],
		"disallowed_STD3_mapped",
		[
			33
		]
	],
	[
		[
			65112,
			65112
		],
		"mapped",
		[
			8212
		]
	],
	[
		[
			65113,
			65113
		],
		"disallowed_STD3_mapped",
		[
			40
		]
	],
	[
		[
			65114,
			65114
		],
		"disallowed_STD3_mapped",
		[
			41
		]
	],
	[
		[
			65115,
			65115
		],
		"disallowed_STD3_mapped",
		[
			123
		]
	],
	[
		[
			65116,
			65116
		],
		"disallowed_STD3_mapped",
		[
			125
		]
	],
	[
		[
			65117,
			65117
		],
		"mapped",
		[
			12308
		]
	],
	[
		[
			65118,
			65118
		],
		"mapped",
		[
			12309
		]
	],
	[
		[
			65119,
			65119
		],
		"disallowed_STD3_mapped",
		[
			35
		]
	],
	[
		[
			65120,
			65120
		],
		"disallowed_STD3_mapped",
		[
			38
		]
	],
	[
		[
			65121,
			65121
		],
		"disallowed_STD3_mapped",
		[
			42
		]
	],
	[
		[
			65122,
			65122
		],
		"disallowed_STD3_mapped",
		[
			43
		]
	],
	[
		[
			65123,
			65123
		],
		"mapped",
		[
			45
		]
	],
	[
		[
			65124,
			65124
		],
		"disallowed_STD3_mapped",
		[
			60
		]
	],
	[
		[
			65125,
			65125
		],
		"disallowed_STD3_mapped",
		[
			62
		]
	],
	[
		[
			65126,
			65126
		],
		"disallowed_STD3_mapped",
		[
			61
		]
	],
	[
		[
			65127,
			65127
		],
		"disallowed"
	],
	[
		[
			65128,
			65128
		],
		"disallowed_STD3_mapped",
		[
			92
		]
	],
	[
		[
			65129,
			65129
		],
		"disallowed_STD3_mapped",
		[
			36
		]
	],
	[
		[
			65130,
			65130
		],
		"disallowed_STD3_mapped",
		[
			37
		]
	],
	[
		[
			65131,
			65131
		],
		"disallowed_STD3_mapped",
		[
			64
		]
	],
	[
		[
			65132,
			65135
		],
		"disallowed"
	],
	[
		[
			65136,
			65136
		],
		"disallowed_STD3_mapped",
		[
			32,
			1611
		]
	],
	[
		[
			65137,
			65137
		],
		"mapped",
		[
			1600,
			1611
		]
	],
	[
		[
			65138,
			65138
		],
		"disallowed_STD3_mapped",
		[
			32,
			1612
		]
	],
	[
		[
			65139,
			65139
		],
		"valid"
	],
	[
		[
			65140,
			65140
		],
		"disallowed_STD3_mapped",
		[
			32,
			1613
		]
	],
	[
		[
			65141,
			65141
		],
		"disallowed"
	],
	[
		[
			65142,
			65142
		],
		"disallowed_STD3_mapped",
		[
			32,
			1614
		]
	],
	[
		[
			65143,
			65143
		],
		"mapped",
		[
			1600,
			1614
		]
	],
	[
		[
			65144,
			65144
		],
		"disallowed_STD3_mapped",
		[
			32,
			1615
		]
	],
	[
		[
			65145,
			65145
		],
		"mapped",
		[
			1600,
			1615
		]
	],
	[
		[
			65146,
			65146
		],
		"disallowed_STD3_mapped",
		[
			32,
			1616
		]
	],
	[
		[
			65147,
			65147
		],
		"mapped",
		[
			1600,
			1616
		]
	],
	[
		[
			65148,
			65148
		],
		"disallowed_STD3_mapped",
		[
			32,
			1617
		]
	],
	[
		[
			65149,
			65149
		],
		"mapped",
		[
			1600,
			1617
		]
	],
	[
		[
			65150,
			65150
		],
		"disallowed_STD3_mapped",
		[
			32,
			1618
		]
	],
	[
		[
			65151,
			65151
		],
		"mapped",
		[
			1600,
			1618
		]
	],
	[
		[
			65152,
			65152
		],
		"mapped",
		[
			1569
		]
	],
	[
		[
			65153,
			65154
		],
		"mapped",
		[
			1570
		]
	],
	[
		[
			65155,
			65156
		],
		"mapped",
		[
			1571
		]
	],
	[
		[
			65157,
			65158
		],
		"mapped",
		[
			1572
		]
	],
	[
		[
			65159,
			65160
		],
		"mapped",
		[
			1573
		]
	],
	[
		[
			65161,
			65164
		],
		"mapped",
		[
			1574
		]
	],
	[
		[
			65165,
			65166
		],
		"mapped",
		[
			1575
		]
	],
	[
		[
			65167,
			65170
		],
		"mapped",
		[
			1576
		]
	],
	[
		[
			65171,
			65172
		],
		"mapped",
		[
			1577
		]
	],
	[
		[
			65173,
			65176
		],
		"mapped",
		[
			1578
		]
	],
	[
		[
			65177,
			65180
		],
		"mapped",
		[
			1579
		]
	],
	[
		[
			65181,
			65184
		],
		"mapped",
		[
			1580
		]
	],
	[
		[
			65185,
			65188
		],
		"mapped",
		[
			1581
		]
	],
	[
		[
			65189,
			65192
		],
		"mapped",
		[
			1582
		]
	],
	[
		[
			65193,
			65194
		],
		"mapped",
		[
			1583
		]
	],
	[
		[
			65195,
			65196
		],
		"mapped",
		[
			1584
		]
	],
	[
		[
			65197,
			65198
		],
		"mapped",
		[
			1585
		]
	],
	[
		[
			65199,
			65200
		],
		"mapped",
		[
			1586
		]
	],
	[
		[
			65201,
			65204
		],
		"mapped",
		[
			1587
		]
	],
	[
		[
			65205,
			65208
		],
		"mapped",
		[
			1588
		]
	],
	[
		[
			65209,
			65212
		],
		"mapped",
		[
			1589
		]
	],
	[
		[
			65213,
			65216
		],
		"mapped",
		[
			1590
		]
	],
	[
		[
			65217,
			65220
		],
		"mapped",
		[
			1591
		]
	],
	[
		[
			65221,
			65224
		],
		"mapped",
		[
			1592
		]
	],
	[
		[
			65225,
			65228
		],
		"mapped",
		[
			1593
		]
	],
	[
		[
			65229,
			65232
		],
		"mapped",
		[
			1594
		]
	],
	[
		[
			65233,
			65236
		],
		"mapped",
		[
			1601
		]
	],
	[
		[
			65237,
			65240
		],
		"mapped",
		[
			1602
		]
	],
	[
		[
			65241,
			65244
		],
		"mapped",
		[
			1603
		]
	],
	[
		[
			65245,
			65248
		],
		"mapped",
		[
			1604
		]
	],
	[
		[
			65249,
			65252
		],
		"mapped",
		[
			1605
		]
	],
	[
		[
			65253,
			65256
		],
		"mapped",
		[
			1606
		]
	],
	[
		[
			65257,
			65260
		],
		"mapped",
		[
			1607
		]
	],
	[
		[
			65261,
			65262
		],
		"mapped",
		[
			1608
		]
	],
	[
		[
			65263,
			65264
		],
		"mapped",
		[
			1609
		]
	],
	[
		[
			65265,
			65268
		],
		"mapped",
		[
			1610
		]
	],
	[
		[
			65269,
			65270
		],
		"mapped",
		[
			1604,
			1570
		]
	],
	[
		[
			65271,
			65272
		],
		"mapped",
		[
			1604,
			1571
		]
	],
	[
		[
			65273,
			65274
		],
		"mapped",
		[
			1604,
			1573
		]
	],
	[
		[
			65275,
			65276
		],
		"mapped",
		[
			1604,
			1575
		]
	],
	[
		[
			65277,
			65278
		],
		"disallowed"
	],
	[
		[
			65279,
			65279
		],
		"ignored"
	],
	[
		[
			65280,
			65280
		],
		"disallowed"
	],
	[
		[
			65281,
			65281
		],
		"disallowed_STD3_mapped",
		[
			33
		]
	],
	[
		[
			65282,
			65282
		],
		"disallowed_STD3_mapped",
		[
			34
		]
	],
	[
		[
			65283,
			65283
		],
		"disallowed_STD3_mapped",
		[
			35
		]
	],
	[
		[
			65284,
			65284
		],
		"disallowed_STD3_mapped",
		[
			36
		]
	],
	[
		[
			65285,
			65285
		],
		"disallowed_STD3_mapped",
		[
			37
		]
	],
	[
		[
			65286,
			65286
		],
		"disallowed_STD3_mapped",
		[
			38
		]
	],
	[
		[
			65287,
			65287
		],
		"disallowed_STD3_mapped",
		[
			39
		]
	],
	[
		[
			65288,
			65288
		],
		"disallowed_STD3_mapped",
		[
			40
		]
	],
	[
		[
			65289,
			65289
		],
		"disallowed_STD3_mapped",
		[
			41
		]
	],
	[
		[
			65290,
			65290
		],
		"disallowed_STD3_mapped",
		[
			42
		]
	],
	[
		[
			65291,
			65291
		],
		"disallowed_STD3_mapped",
		[
			43
		]
	],
	[
		[
			65292,
			65292
		],
		"disallowed_STD3_mapped",
		[
			44
		]
	],
	[
		[
			65293,
			65293
		],
		"mapped",
		[
			45
		]
	],
	[
		[
			65294,
			65294
		],
		"mapped",
		[
			46
		]
	],
	[
		[
			65295,
			65295
		],
		"disallowed_STD3_mapped",
		[
			47
		]
	],
	[
		[
			65296,
			65296
		],
		"mapped",
		[
			48
		]
	],
	[
		[
			65297,
			65297
		],
		"mapped",
		[
			49
		]
	],
	[
		[
			65298,
			65298
		],
		"mapped",
		[
			50
		]
	],
	[
		[
			65299,
			65299
		],
		"mapped",
		[
			51
		]
	],
	[
		[
			65300,
			65300
		],
		"mapped",
		[
			52
		]
	],
	[
		[
			65301,
			65301
		],
		"mapped",
		[
			53
		]
	],
	[
		[
			65302,
			65302
		],
		"mapped",
		[
			54
		]
	],
	[
		[
			65303,
			65303
		],
		"mapped",
		[
			55
		]
	],
	[
		[
			65304,
			65304
		],
		"mapped",
		[
			56
		]
	],
	[
		[
			65305,
			65305
		],
		"mapped",
		[
			57
		]
	],
	[
		[
			65306,
			65306
		],
		"disallowed_STD3_mapped",
		[
			58
		]
	],
	[
		[
			65307,
			65307
		],
		"disallowed_STD3_mapped",
		[
			59
		]
	],
	[
		[
			65308,
			65308
		],
		"disallowed_STD3_mapped",
		[
			60
		]
	],
	[
		[
			65309,
			65309
		],
		"disallowed_STD3_mapped",
		[
			61
		]
	],
	[
		[
			65310,
			65310
		],
		"disallowed_STD3_mapped",
		[
			62
		]
	],
	[
		[
			65311,
			65311
		],
		"disallowed_STD3_mapped",
		[
			63
		]
	],
	[
		[
			65312,
			65312
		],
		"disallowed_STD3_mapped",
		[
			64
		]
	],
	[
		[
			65313,
			65313
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			65314,
			65314
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			65315,
			65315
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			65316,
			65316
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			65317,
			65317
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			65318,
			65318
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			65319,
			65319
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			65320,
			65320
		],
		"mapped",
		[
			104
		]
	],
	[
		[
			65321,
			65321
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			65322,
			65322
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			65323,
			65323
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			65324,
			65324
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			65325,
			65325
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			65326,
			65326
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			65327,
			65327
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			65328,
			65328
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			65329,
			65329
		],
		"mapped",
		[
			113
		]
	],
	[
		[
			65330,
			65330
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			65331,
			65331
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			65332,
			65332
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			65333,
			65333
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			65334,
			65334
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			65335,
			65335
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			65336,
			65336
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			65337,
			65337
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			65338,
			65338
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			65339,
			65339
		],
		"disallowed_STD3_mapped",
		[
			91
		]
	],
	[
		[
			65340,
			65340
		],
		"disallowed_STD3_mapped",
		[
			92
		]
	],
	[
		[
			65341,
			65341
		],
		"disallowed_STD3_mapped",
		[
			93
		]
	],
	[
		[
			65342,
			65342
		],
		"disallowed_STD3_mapped",
		[
			94
		]
	],
	[
		[
			65343,
			65343
		],
		"disallowed_STD3_mapped",
		[
			95
		]
	],
	[
		[
			65344,
			65344
		],
		"disallowed_STD3_mapped",
		[
			96
		]
	],
	[
		[
			65345,
			65345
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			65346,
			65346
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			65347,
			65347
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			65348,
			65348
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			65349,
			65349
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			65350,
			65350
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			65351,
			65351
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			65352,
			65352
		],
		"mapped",
		[
			104
		]
	],
	[
		[
			65353,
			65353
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			65354,
			65354
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			65355,
			65355
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			65356,
			65356
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			65357,
			65357
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			65358,
			65358
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			65359,
			65359
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			65360,
			65360
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			65361,
			65361
		],
		"mapped",
		[
			113
		]
	],
	[
		[
			65362,
			65362
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			65363,
			65363
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			65364,
			65364
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			65365,
			65365
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			65366,
			65366
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			65367,
			65367
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			65368,
			65368
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			65369,
			65369
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			65370,
			65370
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			65371,
			65371
		],
		"disallowed_STD3_mapped",
		[
			123
		]
	],
	[
		[
			65372,
			65372
		],
		"disallowed_STD3_mapped",
		[
			124
		]
	],
	[
		[
			65373,
			65373
		],
		"disallowed_STD3_mapped",
		[
			125
		]
	],
	[
		[
			65374,
			65374
		],
		"disallowed_STD3_mapped",
		[
			126
		]
	],
	[
		[
			65375,
			65375
		],
		"mapped",
		[
			10629
		]
	],
	[
		[
			65376,
			65376
		],
		"mapped",
		[
			10630
		]
	],
	[
		[
			65377,
			65377
		],
		"mapped",
		[
			46
		]
	],
	[
		[
			65378,
			65378
		],
		"mapped",
		[
			12300
		]
	],
	[
		[
			65379,
			65379
		],
		"mapped",
		[
			12301
		]
	],
	[
		[
			65380,
			65380
		],
		"mapped",
		[
			12289
		]
	],
	[
		[
			65381,
			65381
		],
		"mapped",
		[
			12539
		]
	],
	[
		[
			65382,
			65382
		],
		"mapped",
		[
			12530
		]
	],
	[
		[
			65383,
			65383
		],
		"mapped",
		[
			12449
		]
	],
	[
		[
			65384,
			65384
		],
		"mapped",
		[
			12451
		]
	],
	[
		[
			65385,
			65385
		],
		"mapped",
		[
			12453
		]
	],
	[
		[
			65386,
			65386
		],
		"mapped",
		[
			12455
		]
	],
	[
		[
			65387,
			65387
		],
		"mapped",
		[
			12457
		]
	],
	[
		[
			65388,
			65388
		],
		"mapped",
		[
			12515
		]
	],
	[
		[
			65389,
			65389
		],
		"mapped",
		[
			12517
		]
	],
	[
		[
			65390,
			65390
		],
		"mapped",
		[
			12519
		]
	],
	[
		[
			65391,
			65391
		],
		"mapped",
		[
			12483
		]
	],
	[
		[
			65392,
			65392
		],
		"mapped",
		[
			12540
		]
	],
	[
		[
			65393,
			65393
		],
		"mapped",
		[
			12450
		]
	],
	[
		[
			65394,
			65394
		],
		"mapped",
		[
			12452
		]
	],
	[
		[
			65395,
			65395
		],
		"mapped",
		[
			12454
		]
	],
	[
		[
			65396,
			65396
		],
		"mapped",
		[
			12456
		]
	],
	[
		[
			65397,
			65397
		],
		"mapped",
		[
			12458
		]
	],
	[
		[
			65398,
			65398
		],
		"mapped",
		[
			12459
		]
	],
	[
		[
			65399,
			65399
		],
		"mapped",
		[
			12461
		]
	],
	[
		[
			65400,
			65400
		],
		"mapped",
		[
			12463
		]
	],
	[
		[
			65401,
			65401
		],
		"mapped",
		[
			12465
		]
	],
	[
		[
			65402,
			65402
		],
		"mapped",
		[
			12467
		]
	],
	[
		[
			65403,
			65403
		],
		"mapped",
		[
			12469
		]
	],
	[
		[
			65404,
			65404
		],
		"mapped",
		[
			12471
		]
	],
	[
		[
			65405,
			65405
		],
		"mapped",
		[
			12473
		]
	],
	[
		[
			65406,
			65406
		],
		"mapped",
		[
			12475
		]
	],
	[
		[
			65407,
			65407
		],
		"mapped",
		[
			12477
		]
	],
	[
		[
			65408,
			65408
		],
		"mapped",
		[
			12479
		]
	],
	[
		[
			65409,
			65409
		],
		"mapped",
		[
			12481
		]
	],
	[
		[
			65410,
			65410
		],
		"mapped",
		[
			12484
		]
	],
	[
		[
			65411,
			65411
		],
		"mapped",
		[
			12486
		]
	],
	[
		[
			65412,
			65412
		],
		"mapped",
		[
			12488
		]
	],
	[
		[
			65413,
			65413
		],
		"mapped",
		[
			12490
		]
	],
	[
		[
			65414,
			65414
		],
		"mapped",
		[
			12491
		]
	],
	[
		[
			65415,
			65415
		],
		"mapped",
		[
			12492
		]
	],
	[
		[
			65416,
			65416
		],
		"mapped",
		[
			12493
		]
	],
	[
		[
			65417,
			65417
		],
		"mapped",
		[
			12494
		]
	],
	[
		[
			65418,
			65418
		],
		"mapped",
		[
			12495
		]
	],
	[
		[
			65419,
			65419
		],
		"mapped",
		[
			12498
		]
	],
	[
		[
			65420,
			65420
		],
		"mapped",
		[
			12501
		]
	],
	[
		[
			65421,
			65421
		],
		"mapped",
		[
			12504
		]
	],
	[
		[
			65422,
			65422
		],
		"mapped",
		[
			12507
		]
	],
	[
		[
			65423,
			65423
		],
		"mapped",
		[
			12510
		]
	],
	[
		[
			65424,
			65424
		],
		"mapped",
		[
			12511
		]
	],
	[
		[
			65425,
			65425
		],
		"mapped",
		[
			12512
		]
	],
	[
		[
			65426,
			65426
		],
		"mapped",
		[
			12513
		]
	],
	[
		[
			65427,
			65427
		],
		"mapped",
		[
			12514
		]
	],
	[
		[
			65428,
			65428
		],
		"mapped",
		[
			12516
		]
	],
	[
		[
			65429,
			65429
		],
		"mapped",
		[
			12518
		]
	],
	[
		[
			65430,
			65430
		],
		"mapped",
		[
			12520
		]
	],
	[
		[
			65431,
			65431
		],
		"mapped",
		[
			12521
		]
	],
	[
		[
			65432,
			65432
		],
		"mapped",
		[
			12522
		]
	],
	[
		[
			65433,
			65433
		],
		"mapped",
		[
			12523
		]
	],
	[
		[
			65434,
			65434
		],
		"mapped",
		[
			12524
		]
	],
	[
		[
			65435,
			65435
		],
		"mapped",
		[
			12525
		]
	],
	[
		[
			65436,
			65436
		],
		"mapped",
		[
			12527
		]
	],
	[
		[
			65437,
			65437
		],
		"mapped",
		[
			12531
		]
	],
	[
		[
			65438,
			65438
		],
		"mapped",
		[
			12441
		]
	],
	[
		[
			65439,
			65439
		],
		"mapped",
		[
			12442
		]
	],
	[
		[
			65440,
			65440
		],
		"disallowed"
	],
	[
		[
			65441,
			65441
		],
		"mapped",
		[
			4352
		]
	],
	[
		[
			65442,
			65442
		],
		"mapped",
		[
			4353
		]
	],
	[
		[
			65443,
			65443
		],
		"mapped",
		[
			4522
		]
	],
	[
		[
			65444,
			65444
		],
		"mapped",
		[
			4354
		]
	],
	[
		[
			65445,
			65445
		],
		"mapped",
		[
			4524
		]
	],
	[
		[
			65446,
			65446
		],
		"mapped",
		[
			4525
		]
	],
	[
		[
			65447,
			65447
		],
		"mapped",
		[
			4355
		]
	],
	[
		[
			65448,
			65448
		],
		"mapped",
		[
			4356
		]
	],
	[
		[
			65449,
			65449
		],
		"mapped",
		[
			4357
		]
	],
	[
		[
			65450,
			65450
		],
		"mapped",
		[
			4528
		]
	],
	[
		[
			65451,
			65451
		],
		"mapped",
		[
			4529
		]
	],
	[
		[
			65452,
			65452
		],
		"mapped",
		[
			4530
		]
	],
	[
		[
			65453,
			65453
		],
		"mapped",
		[
			4531
		]
	],
	[
		[
			65454,
			65454
		],
		"mapped",
		[
			4532
		]
	],
	[
		[
			65455,
			65455
		],
		"mapped",
		[
			4533
		]
	],
	[
		[
			65456,
			65456
		],
		"mapped",
		[
			4378
		]
	],
	[
		[
			65457,
			65457
		],
		"mapped",
		[
			4358
		]
	],
	[
		[
			65458,
			65458
		],
		"mapped",
		[
			4359
		]
	],
	[
		[
			65459,
			65459
		],
		"mapped",
		[
			4360
		]
	],
	[
		[
			65460,
			65460
		],
		"mapped",
		[
			4385
		]
	],
	[
		[
			65461,
			65461
		],
		"mapped",
		[
			4361
		]
	],
	[
		[
			65462,
			65462
		],
		"mapped",
		[
			4362
		]
	],
	[
		[
			65463,
			65463
		],
		"mapped",
		[
			4363
		]
	],
	[
		[
			65464,
			65464
		],
		"mapped",
		[
			4364
		]
	],
	[
		[
			65465,
			65465
		],
		"mapped",
		[
			4365
		]
	],
	[
		[
			65466,
			65466
		],
		"mapped",
		[
			4366
		]
	],
	[
		[
			65467,
			65467
		],
		"mapped",
		[
			4367
		]
	],
	[
		[
			65468,
			65468
		],
		"mapped",
		[
			4368
		]
	],
	[
		[
			65469,
			65469
		],
		"mapped",
		[
			4369
		]
	],
	[
		[
			65470,
			65470
		],
		"mapped",
		[
			4370
		]
	],
	[
		[
			65471,
			65473
		],
		"disallowed"
	],
	[
		[
			65474,
			65474
		],
		"mapped",
		[
			4449
		]
	],
	[
		[
			65475,
			65475
		],
		"mapped",
		[
			4450
		]
	],
	[
		[
			65476,
			65476
		],
		"mapped",
		[
			4451
		]
	],
	[
		[
			65477,
			65477
		],
		"mapped",
		[
			4452
		]
	],
	[
		[
			65478,
			65478
		],
		"mapped",
		[
			4453
		]
	],
	[
		[
			65479,
			65479
		],
		"mapped",
		[
			4454
		]
	],
	[
		[
			65480,
			65481
		],
		"disallowed"
	],
	[
		[
			65482,
			65482
		],
		"mapped",
		[
			4455
		]
	],
	[
		[
			65483,
			65483
		],
		"mapped",
		[
			4456
		]
	],
	[
		[
			65484,
			65484
		],
		"mapped",
		[
			4457
		]
	],
	[
		[
			65485,
			65485
		],
		"mapped",
		[
			4458
		]
	],
	[
		[
			65486,
			65486
		],
		"mapped",
		[
			4459
		]
	],
	[
		[
			65487,
			65487
		],
		"mapped",
		[
			4460
		]
	],
	[
		[
			65488,
			65489
		],
		"disallowed"
	],
	[
		[
			65490,
			65490
		],
		"mapped",
		[
			4461
		]
	],
	[
		[
			65491,
			65491
		],
		"mapped",
		[
			4462
		]
	],
	[
		[
			65492,
			65492
		],
		"mapped",
		[
			4463
		]
	],
	[
		[
			65493,
			65493
		],
		"mapped",
		[
			4464
		]
	],
	[
		[
			65494,
			65494
		],
		"mapped",
		[
			4465
		]
	],
	[
		[
			65495,
			65495
		],
		"mapped",
		[
			4466
		]
	],
	[
		[
			65496,
			65497
		],
		"disallowed"
	],
	[
		[
			65498,
			65498
		],
		"mapped",
		[
			4467
		]
	],
	[
		[
			65499,
			65499
		],
		"mapped",
		[
			4468
		]
	],
	[
		[
			65500,
			65500
		],
		"mapped",
		[
			4469
		]
	],
	[
		[
			65501,
			65503
		],
		"disallowed"
	],
	[
		[
			65504,
			65504
		],
		"mapped",
		[
			162
		]
	],
	[
		[
			65505,
			65505
		],
		"mapped",
		[
			163
		]
	],
	[
		[
			65506,
			65506
		],
		"mapped",
		[
			172
		]
	],
	[
		[
			65507,
			65507
		],
		"disallowed_STD3_mapped",
		[
			32,
			772
		]
	],
	[
		[
			65508,
			65508
		],
		"mapped",
		[
			166
		]
	],
	[
		[
			65509,
			65509
		],
		"mapped",
		[
			165
		]
	],
	[
		[
			65510,
			65510
		],
		"mapped",
		[
			8361
		]
	],
	[
		[
			65511,
			65511
		],
		"disallowed"
	],
	[
		[
			65512,
			65512
		],
		"mapped",
		[
			9474
		]
	],
	[
		[
			65513,
			65513
		],
		"mapped",
		[
			8592
		]
	],
	[
		[
			65514,
			65514
		],
		"mapped",
		[
			8593
		]
	],
	[
		[
			65515,
			65515
		],
		"mapped",
		[
			8594
		]
	],
	[
		[
			65516,
			65516
		],
		"mapped",
		[
			8595
		]
	],
	[
		[
			65517,
			65517
		],
		"mapped",
		[
			9632
		]
	],
	[
		[
			65518,
			65518
		],
		"mapped",
		[
			9675
		]
	],
	[
		[
			65519,
			65528
		],
		"disallowed"
	],
	[
		[
			65529,
			65531
		],
		"disallowed"
	],
	[
		[
			65532,
			65532
		],
		"disallowed"
	],
	[
		[
			65533,
			65533
		],
		"disallowed"
	],
	[
		[
			65534,
			65535
		],
		"disallowed"
	],
	[
		[
			65536,
			65547
		],
		"valid"
	],
	[
		[
			65548,
			65548
		],
		"disallowed"
	],
	[
		[
			65549,
			65574
		],
		"valid"
	],
	[
		[
			65575,
			65575
		],
		"disallowed"
	],
	[
		[
			65576,
			65594
		],
		"valid"
	],
	[
		[
			65595,
			65595
		],
		"disallowed"
	],
	[
		[
			65596,
			65597
		],
		"valid"
	],
	[
		[
			65598,
			65598
		],
		"disallowed"
	],
	[
		[
			65599,
			65613
		],
		"valid"
	],
	[
		[
			65614,
			65615
		],
		"disallowed"
	],
	[
		[
			65616,
			65629
		],
		"valid"
	],
	[
		[
			65630,
			65663
		],
		"disallowed"
	],
	[
		[
			65664,
			65786
		],
		"valid"
	],
	[
		[
			65787,
			65791
		],
		"disallowed"
	],
	[
		[
			65792,
			65794
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			65795,
			65798
		],
		"disallowed"
	],
	[
		[
			65799,
			65843
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			65844,
			65846
		],
		"disallowed"
	],
	[
		[
			65847,
			65855
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			65856,
			65930
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			65931,
			65932
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			65933,
			65935
		],
		"disallowed"
	],
	[
		[
			65936,
			65947
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			65948,
			65951
		],
		"disallowed"
	],
	[
		[
			65952,
			65952
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			65953,
			65999
		],
		"disallowed"
	],
	[
		[
			66000,
			66044
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			66045,
			66045
		],
		"valid"
	],
	[
		[
			66046,
			66175
		],
		"disallowed"
	],
	[
		[
			66176,
			66204
		],
		"valid"
	],
	[
		[
			66205,
			66207
		],
		"disallowed"
	],
	[
		[
			66208,
			66256
		],
		"valid"
	],
	[
		[
			66257,
			66271
		],
		"disallowed"
	],
	[
		[
			66272,
			66272
		],
		"valid"
	],
	[
		[
			66273,
			66299
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			66300,
			66303
		],
		"disallowed"
	],
	[
		[
			66304,
			66334
		],
		"valid"
	],
	[
		[
			66335,
			66335
		],
		"valid"
	],
	[
		[
			66336,
			66339
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			66340,
			66351
		],
		"disallowed"
	],
	[
		[
			66352,
			66368
		],
		"valid"
	],
	[
		[
			66369,
			66369
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			66370,
			66377
		],
		"valid"
	],
	[
		[
			66378,
			66378
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			66379,
			66383
		],
		"disallowed"
	],
	[
		[
			66384,
			66426
		],
		"valid"
	],
	[
		[
			66427,
			66431
		],
		"disallowed"
	],
	[
		[
			66432,
			66461
		],
		"valid"
	],
	[
		[
			66462,
			66462
		],
		"disallowed"
	],
	[
		[
			66463,
			66463
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			66464,
			66499
		],
		"valid"
	],
	[
		[
			66500,
			66503
		],
		"disallowed"
	],
	[
		[
			66504,
			66511
		],
		"valid"
	],
	[
		[
			66512,
			66517
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			66518,
			66559
		],
		"disallowed"
	],
	[
		[
			66560,
			66560
		],
		"mapped",
		[
			66600
		]
	],
	[
		[
			66561,
			66561
		],
		"mapped",
		[
			66601
		]
	],
	[
		[
			66562,
			66562
		],
		"mapped",
		[
			66602
		]
	],
	[
		[
			66563,
			66563
		],
		"mapped",
		[
			66603
		]
	],
	[
		[
			66564,
			66564
		],
		"mapped",
		[
			66604
		]
	],
	[
		[
			66565,
			66565
		],
		"mapped",
		[
			66605
		]
	],
	[
		[
			66566,
			66566
		],
		"mapped",
		[
			66606
		]
	],
	[
		[
			66567,
			66567
		],
		"mapped",
		[
			66607
		]
	],
	[
		[
			66568,
			66568
		],
		"mapped",
		[
			66608
		]
	],
	[
		[
			66569,
			66569
		],
		"mapped",
		[
			66609
		]
	],
	[
		[
			66570,
			66570
		],
		"mapped",
		[
			66610
		]
	],
	[
		[
			66571,
			66571
		],
		"mapped",
		[
			66611
		]
	],
	[
		[
			66572,
			66572
		],
		"mapped",
		[
			66612
		]
	],
	[
		[
			66573,
			66573
		],
		"mapped",
		[
			66613
		]
	],
	[
		[
			66574,
			66574
		],
		"mapped",
		[
			66614
		]
	],
	[
		[
			66575,
			66575
		],
		"mapped",
		[
			66615
		]
	],
	[
		[
			66576,
			66576
		],
		"mapped",
		[
			66616
		]
	],
	[
		[
			66577,
			66577
		],
		"mapped",
		[
			66617
		]
	],
	[
		[
			66578,
			66578
		],
		"mapped",
		[
			66618
		]
	],
	[
		[
			66579,
			66579
		],
		"mapped",
		[
			66619
		]
	],
	[
		[
			66580,
			66580
		],
		"mapped",
		[
			66620
		]
	],
	[
		[
			66581,
			66581
		],
		"mapped",
		[
			66621
		]
	],
	[
		[
			66582,
			66582
		],
		"mapped",
		[
			66622
		]
	],
	[
		[
			66583,
			66583
		],
		"mapped",
		[
			66623
		]
	],
	[
		[
			66584,
			66584
		],
		"mapped",
		[
			66624
		]
	],
	[
		[
			66585,
			66585
		],
		"mapped",
		[
			66625
		]
	],
	[
		[
			66586,
			66586
		],
		"mapped",
		[
			66626
		]
	],
	[
		[
			66587,
			66587
		],
		"mapped",
		[
			66627
		]
	],
	[
		[
			66588,
			66588
		],
		"mapped",
		[
			66628
		]
	],
	[
		[
			66589,
			66589
		],
		"mapped",
		[
			66629
		]
	],
	[
		[
			66590,
			66590
		],
		"mapped",
		[
			66630
		]
	],
	[
		[
			66591,
			66591
		],
		"mapped",
		[
			66631
		]
	],
	[
		[
			66592,
			66592
		],
		"mapped",
		[
			66632
		]
	],
	[
		[
			66593,
			66593
		],
		"mapped",
		[
			66633
		]
	],
	[
		[
			66594,
			66594
		],
		"mapped",
		[
			66634
		]
	],
	[
		[
			66595,
			66595
		],
		"mapped",
		[
			66635
		]
	],
	[
		[
			66596,
			66596
		],
		"mapped",
		[
			66636
		]
	],
	[
		[
			66597,
			66597
		],
		"mapped",
		[
			66637
		]
	],
	[
		[
			66598,
			66598
		],
		"mapped",
		[
			66638
		]
	],
	[
		[
			66599,
			66599
		],
		"mapped",
		[
			66639
		]
	],
	[
		[
			66600,
			66637
		],
		"valid"
	],
	[
		[
			66638,
			66717
		],
		"valid"
	],
	[
		[
			66718,
			66719
		],
		"disallowed"
	],
	[
		[
			66720,
			66729
		],
		"valid"
	],
	[
		[
			66730,
			66815
		],
		"disallowed"
	],
	[
		[
			66816,
			66855
		],
		"valid"
	],
	[
		[
			66856,
			66863
		],
		"disallowed"
	],
	[
		[
			66864,
			66915
		],
		"valid"
	],
	[
		[
			66916,
			66926
		],
		"disallowed"
	],
	[
		[
			66927,
			66927
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			66928,
			67071
		],
		"disallowed"
	],
	[
		[
			67072,
			67382
		],
		"valid"
	],
	[
		[
			67383,
			67391
		],
		"disallowed"
	],
	[
		[
			67392,
			67413
		],
		"valid"
	],
	[
		[
			67414,
			67423
		],
		"disallowed"
	],
	[
		[
			67424,
			67431
		],
		"valid"
	],
	[
		[
			67432,
			67583
		],
		"disallowed"
	],
	[
		[
			67584,
			67589
		],
		"valid"
	],
	[
		[
			67590,
			67591
		],
		"disallowed"
	],
	[
		[
			67592,
			67592
		],
		"valid"
	],
	[
		[
			67593,
			67593
		],
		"disallowed"
	],
	[
		[
			67594,
			67637
		],
		"valid"
	],
	[
		[
			67638,
			67638
		],
		"disallowed"
	],
	[
		[
			67639,
			67640
		],
		"valid"
	],
	[
		[
			67641,
			67643
		],
		"disallowed"
	],
	[
		[
			67644,
			67644
		],
		"valid"
	],
	[
		[
			67645,
			67646
		],
		"disallowed"
	],
	[
		[
			67647,
			67647
		],
		"valid"
	],
	[
		[
			67648,
			67669
		],
		"valid"
	],
	[
		[
			67670,
			67670
		],
		"disallowed"
	],
	[
		[
			67671,
			67679
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			67680,
			67702
		],
		"valid"
	],
	[
		[
			67703,
			67711
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			67712,
			67742
		],
		"valid"
	],
	[
		[
			67743,
			67750
		],
		"disallowed"
	],
	[
		[
			67751,
			67759
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			67760,
			67807
		],
		"disallowed"
	],
	[
		[
			67808,
			67826
		],
		"valid"
	],
	[
		[
			67827,
			67827
		],
		"disallowed"
	],
	[
		[
			67828,
			67829
		],
		"valid"
	],
	[
		[
			67830,
			67834
		],
		"disallowed"
	],
	[
		[
			67835,
			67839
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			67840,
			67861
		],
		"valid"
	],
	[
		[
			67862,
			67865
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			67866,
			67867
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			67868,
			67870
		],
		"disallowed"
	],
	[
		[
			67871,
			67871
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			67872,
			67897
		],
		"valid"
	],
	[
		[
			67898,
			67902
		],
		"disallowed"
	],
	[
		[
			67903,
			67903
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			67904,
			67967
		],
		"disallowed"
	],
	[
		[
			67968,
			68023
		],
		"valid"
	],
	[
		[
			68024,
			68027
		],
		"disallowed"
	],
	[
		[
			68028,
			68029
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			68030,
			68031
		],
		"valid"
	],
	[
		[
			68032,
			68047
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			68048,
			68049
		],
		"disallowed"
	],
	[
		[
			68050,
			68095
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			68096,
			68099
		],
		"valid"
	],
	[
		[
			68100,
			68100
		],
		"disallowed"
	],
	[
		[
			68101,
			68102
		],
		"valid"
	],
	[
		[
			68103,
			68107
		],
		"disallowed"
	],
	[
		[
			68108,
			68115
		],
		"valid"
	],
	[
		[
			68116,
			68116
		],
		"disallowed"
	],
	[
		[
			68117,
			68119
		],
		"valid"
	],
	[
		[
			68120,
			68120
		],
		"disallowed"
	],
	[
		[
			68121,
			68147
		],
		"valid"
	],
	[
		[
			68148,
			68151
		],
		"disallowed"
	],
	[
		[
			68152,
			68154
		],
		"valid"
	],
	[
		[
			68155,
			68158
		],
		"disallowed"
	],
	[
		[
			68159,
			68159
		],
		"valid"
	],
	[
		[
			68160,
			68167
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			68168,
			68175
		],
		"disallowed"
	],
	[
		[
			68176,
			68184
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			68185,
			68191
		],
		"disallowed"
	],
	[
		[
			68192,
			68220
		],
		"valid"
	],
	[
		[
			68221,
			68223
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			68224,
			68252
		],
		"valid"
	],
	[
		[
			68253,
			68255
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			68256,
			68287
		],
		"disallowed"
	],
	[
		[
			68288,
			68295
		],
		"valid"
	],
	[
		[
			68296,
			68296
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			68297,
			68326
		],
		"valid"
	],
	[
		[
			68327,
			68330
		],
		"disallowed"
	],
	[
		[
			68331,
			68342
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			68343,
			68351
		],
		"disallowed"
	],
	[
		[
			68352,
			68405
		],
		"valid"
	],
	[
		[
			68406,
			68408
		],
		"disallowed"
	],
	[
		[
			68409,
			68415
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			68416,
			68437
		],
		"valid"
	],
	[
		[
			68438,
			68439
		],
		"disallowed"
	],
	[
		[
			68440,
			68447
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			68448,
			68466
		],
		"valid"
	],
	[
		[
			68467,
			68471
		],
		"disallowed"
	],
	[
		[
			68472,
			68479
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			68480,
			68497
		],
		"valid"
	],
	[
		[
			68498,
			68504
		],
		"disallowed"
	],
	[
		[
			68505,
			68508
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			68509,
			68520
		],
		"disallowed"
	],
	[
		[
			68521,
			68527
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			68528,
			68607
		],
		"disallowed"
	],
	[
		[
			68608,
			68680
		],
		"valid"
	],
	[
		[
			68681,
			68735
		],
		"disallowed"
	],
	[
		[
			68736,
			68736
		],
		"mapped",
		[
			68800
		]
	],
	[
		[
			68737,
			68737
		],
		"mapped",
		[
			68801
		]
	],
	[
		[
			68738,
			68738
		],
		"mapped",
		[
			68802
		]
	],
	[
		[
			68739,
			68739
		],
		"mapped",
		[
			68803
		]
	],
	[
		[
			68740,
			68740
		],
		"mapped",
		[
			68804
		]
	],
	[
		[
			68741,
			68741
		],
		"mapped",
		[
			68805
		]
	],
	[
		[
			68742,
			68742
		],
		"mapped",
		[
			68806
		]
	],
	[
		[
			68743,
			68743
		],
		"mapped",
		[
			68807
		]
	],
	[
		[
			68744,
			68744
		],
		"mapped",
		[
			68808
		]
	],
	[
		[
			68745,
			68745
		],
		"mapped",
		[
			68809
		]
	],
	[
		[
			68746,
			68746
		],
		"mapped",
		[
			68810
		]
	],
	[
		[
			68747,
			68747
		],
		"mapped",
		[
			68811
		]
	],
	[
		[
			68748,
			68748
		],
		"mapped",
		[
			68812
		]
	],
	[
		[
			68749,
			68749
		],
		"mapped",
		[
			68813
		]
	],
	[
		[
			68750,
			68750
		],
		"mapped",
		[
			68814
		]
	],
	[
		[
			68751,
			68751
		],
		"mapped",
		[
			68815
		]
	],
	[
		[
			68752,
			68752
		],
		"mapped",
		[
			68816
		]
	],
	[
		[
			68753,
			68753
		],
		"mapped",
		[
			68817
		]
	],
	[
		[
			68754,
			68754
		],
		"mapped",
		[
			68818
		]
	],
	[
		[
			68755,
			68755
		],
		"mapped",
		[
			68819
		]
	],
	[
		[
			68756,
			68756
		],
		"mapped",
		[
			68820
		]
	],
	[
		[
			68757,
			68757
		],
		"mapped",
		[
			68821
		]
	],
	[
		[
			68758,
			68758
		],
		"mapped",
		[
			68822
		]
	],
	[
		[
			68759,
			68759
		],
		"mapped",
		[
			68823
		]
	],
	[
		[
			68760,
			68760
		],
		"mapped",
		[
			68824
		]
	],
	[
		[
			68761,
			68761
		],
		"mapped",
		[
			68825
		]
	],
	[
		[
			68762,
			68762
		],
		"mapped",
		[
			68826
		]
	],
	[
		[
			68763,
			68763
		],
		"mapped",
		[
			68827
		]
	],
	[
		[
			68764,
			68764
		],
		"mapped",
		[
			68828
		]
	],
	[
		[
			68765,
			68765
		],
		"mapped",
		[
			68829
		]
	],
	[
		[
			68766,
			68766
		],
		"mapped",
		[
			68830
		]
	],
	[
		[
			68767,
			68767
		],
		"mapped",
		[
			68831
		]
	],
	[
		[
			68768,
			68768
		],
		"mapped",
		[
			68832
		]
	],
	[
		[
			68769,
			68769
		],
		"mapped",
		[
			68833
		]
	],
	[
		[
			68770,
			68770
		],
		"mapped",
		[
			68834
		]
	],
	[
		[
			68771,
			68771
		],
		"mapped",
		[
			68835
		]
	],
	[
		[
			68772,
			68772
		],
		"mapped",
		[
			68836
		]
	],
	[
		[
			68773,
			68773
		],
		"mapped",
		[
			68837
		]
	],
	[
		[
			68774,
			68774
		],
		"mapped",
		[
			68838
		]
	],
	[
		[
			68775,
			68775
		],
		"mapped",
		[
			68839
		]
	],
	[
		[
			68776,
			68776
		],
		"mapped",
		[
			68840
		]
	],
	[
		[
			68777,
			68777
		],
		"mapped",
		[
			68841
		]
	],
	[
		[
			68778,
			68778
		],
		"mapped",
		[
			68842
		]
	],
	[
		[
			68779,
			68779
		],
		"mapped",
		[
			68843
		]
	],
	[
		[
			68780,
			68780
		],
		"mapped",
		[
			68844
		]
	],
	[
		[
			68781,
			68781
		],
		"mapped",
		[
			68845
		]
	],
	[
		[
			68782,
			68782
		],
		"mapped",
		[
			68846
		]
	],
	[
		[
			68783,
			68783
		],
		"mapped",
		[
			68847
		]
	],
	[
		[
			68784,
			68784
		],
		"mapped",
		[
			68848
		]
	],
	[
		[
			68785,
			68785
		],
		"mapped",
		[
			68849
		]
	],
	[
		[
			68786,
			68786
		],
		"mapped",
		[
			68850
		]
	],
	[
		[
			68787,
			68799
		],
		"disallowed"
	],
	[
		[
			68800,
			68850
		],
		"valid"
	],
	[
		[
			68851,
			68857
		],
		"disallowed"
	],
	[
		[
			68858,
			68863
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			68864,
			69215
		],
		"disallowed"
	],
	[
		[
			69216,
			69246
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			69247,
			69631
		],
		"disallowed"
	],
	[
		[
			69632,
			69702
		],
		"valid"
	],
	[
		[
			69703,
			69709
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			69710,
			69713
		],
		"disallowed"
	],
	[
		[
			69714,
			69733
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			69734,
			69743
		],
		"valid"
	],
	[
		[
			69744,
			69758
		],
		"disallowed"
	],
	[
		[
			69759,
			69759
		],
		"valid"
	],
	[
		[
			69760,
			69818
		],
		"valid"
	],
	[
		[
			69819,
			69820
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			69821,
			69821
		],
		"disallowed"
	],
	[
		[
			69822,
			69825
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			69826,
			69839
		],
		"disallowed"
	],
	[
		[
			69840,
			69864
		],
		"valid"
	],
	[
		[
			69865,
			69871
		],
		"disallowed"
	],
	[
		[
			69872,
			69881
		],
		"valid"
	],
	[
		[
			69882,
			69887
		],
		"disallowed"
	],
	[
		[
			69888,
			69940
		],
		"valid"
	],
	[
		[
			69941,
			69941
		],
		"disallowed"
	],
	[
		[
			69942,
			69951
		],
		"valid"
	],
	[
		[
			69952,
			69955
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			69956,
			69967
		],
		"disallowed"
	],
	[
		[
			69968,
			70003
		],
		"valid"
	],
	[
		[
			70004,
			70005
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			70006,
			70006
		],
		"valid"
	],
	[
		[
			70007,
			70015
		],
		"disallowed"
	],
	[
		[
			70016,
			70084
		],
		"valid"
	],
	[
		[
			70085,
			70088
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			70089,
			70089
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			70090,
			70092
		],
		"valid"
	],
	[
		[
			70093,
			70093
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			70094,
			70095
		],
		"disallowed"
	],
	[
		[
			70096,
			70105
		],
		"valid"
	],
	[
		[
			70106,
			70106
		],
		"valid"
	],
	[
		[
			70107,
			70107
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			70108,
			70108
		],
		"valid"
	],
	[
		[
			70109,
			70111
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			70112,
			70112
		],
		"disallowed"
	],
	[
		[
			70113,
			70132
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			70133,
			70143
		],
		"disallowed"
	],
	[
		[
			70144,
			70161
		],
		"valid"
	],
	[
		[
			70162,
			70162
		],
		"disallowed"
	],
	[
		[
			70163,
			70199
		],
		"valid"
	],
	[
		[
			70200,
			70205
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			70206,
			70271
		],
		"disallowed"
	],
	[
		[
			70272,
			70278
		],
		"valid"
	],
	[
		[
			70279,
			70279
		],
		"disallowed"
	],
	[
		[
			70280,
			70280
		],
		"valid"
	],
	[
		[
			70281,
			70281
		],
		"disallowed"
	],
	[
		[
			70282,
			70285
		],
		"valid"
	],
	[
		[
			70286,
			70286
		],
		"disallowed"
	],
	[
		[
			70287,
			70301
		],
		"valid"
	],
	[
		[
			70302,
			70302
		],
		"disallowed"
	],
	[
		[
			70303,
			70312
		],
		"valid"
	],
	[
		[
			70313,
			70313
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			70314,
			70319
		],
		"disallowed"
	],
	[
		[
			70320,
			70378
		],
		"valid"
	],
	[
		[
			70379,
			70383
		],
		"disallowed"
	],
	[
		[
			70384,
			70393
		],
		"valid"
	],
	[
		[
			70394,
			70399
		],
		"disallowed"
	],
	[
		[
			70400,
			70400
		],
		"valid"
	],
	[
		[
			70401,
			70403
		],
		"valid"
	],
	[
		[
			70404,
			70404
		],
		"disallowed"
	],
	[
		[
			70405,
			70412
		],
		"valid"
	],
	[
		[
			70413,
			70414
		],
		"disallowed"
	],
	[
		[
			70415,
			70416
		],
		"valid"
	],
	[
		[
			70417,
			70418
		],
		"disallowed"
	],
	[
		[
			70419,
			70440
		],
		"valid"
	],
	[
		[
			70441,
			70441
		],
		"disallowed"
	],
	[
		[
			70442,
			70448
		],
		"valid"
	],
	[
		[
			70449,
			70449
		],
		"disallowed"
	],
	[
		[
			70450,
			70451
		],
		"valid"
	],
	[
		[
			70452,
			70452
		],
		"disallowed"
	],
	[
		[
			70453,
			70457
		],
		"valid"
	],
	[
		[
			70458,
			70459
		],
		"disallowed"
	],
	[
		[
			70460,
			70468
		],
		"valid"
	],
	[
		[
			70469,
			70470
		],
		"disallowed"
	],
	[
		[
			70471,
			70472
		],
		"valid"
	],
	[
		[
			70473,
			70474
		],
		"disallowed"
	],
	[
		[
			70475,
			70477
		],
		"valid"
	],
	[
		[
			70478,
			70479
		],
		"disallowed"
	],
	[
		[
			70480,
			70480
		],
		"valid"
	],
	[
		[
			70481,
			70486
		],
		"disallowed"
	],
	[
		[
			70487,
			70487
		],
		"valid"
	],
	[
		[
			70488,
			70492
		],
		"disallowed"
	],
	[
		[
			70493,
			70499
		],
		"valid"
	],
	[
		[
			70500,
			70501
		],
		"disallowed"
	],
	[
		[
			70502,
			70508
		],
		"valid"
	],
	[
		[
			70509,
			70511
		],
		"disallowed"
	],
	[
		[
			70512,
			70516
		],
		"valid"
	],
	[
		[
			70517,
			70783
		],
		"disallowed"
	],
	[
		[
			70784,
			70853
		],
		"valid"
	],
	[
		[
			70854,
			70854
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			70855,
			70855
		],
		"valid"
	],
	[
		[
			70856,
			70863
		],
		"disallowed"
	],
	[
		[
			70864,
			70873
		],
		"valid"
	],
	[
		[
			70874,
			71039
		],
		"disallowed"
	],
	[
		[
			71040,
			71093
		],
		"valid"
	],
	[
		[
			71094,
			71095
		],
		"disallowed"
	],
	[
		[
			71096,
			71104
		],
		"valid"
	],
	[
		[
			71105,
			71113
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			71114,
			71127
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			71128,
			71133
		],
		"valid"
	],
	[
		[
			71134,
			71167
		],
		"disallowed"
	],
	[
		[
			71168,
			71232
		],
		"valid"
	],
	[
		[
			71233,
			71235
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			71236,
			71236
		],
		"valid"
	],
	[
		[
			71237,
			71247
		],
		"disallowed"
	],
	[
		[
			71248,
			71257
		],
		"valid"
	],
	[
		[
			71258,
			71295
		],
		"disallowed"
	],
	[
		[
			71296,
			71351
		],
		"valid"
	],
	[
		[
			71352,
			71359
		],
		"disallowed"
	],
	[
		[
			71360,
			71369
		],
		"valid"
	],
	[
		[
			71370,
			71423
		],
		"disallowed"
	],
	[
		[
			71424,
			71449
		],
		"valid"
	],
	[
		[
			71450,
			71452
		],
		"disallowed"
	],
	[
		[
			71453,
			71467
		],
		"valid"
	],
	[
		[
			71468,
			71471
		],
		"disallowed"
	],
	[
		[
			71472,
			71481
		],
		"valid"
	],
	[
		[
			71482,
			71487
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			71488,
			71839
		],
		"disallowed"
	],
	[
		[
			71840,
			71840
		],
		"mapped",
		[
			71872
		]
	],
	[
		[
			71841,
			71841
		],
		"mapped",
		[
			71873
		]
	],
	[
		[
			71842,
			71842
		],
		"mapped",
		[
			71874
		]
	],
	[
		[
			71843,
			71843
		],
		"mapped",
		[
			71875
		]
	],
	[
		[
			71844,
			71844
		],
		"mapped",
		[
			71876
		]
	],
	[
		[
			71845,
			71845
		],
		"mapped",
		[
			71877
		]
	],
	[
		[
			71846,
			71846
		],
		"mapped",
		[
			71878
		]
	],
	[
		[
			71847,
			71847
		],
		"mapped",
		[
			71879
		]
	],
	[
		[
			71848,
			71848
		],
		"mapped",
		[
			71880
		]
	],
	[
		[
			71849,
			71849
		],
		"mapped",
		[
			71881
		]
	],
	[
		[
			71850,
			71850
		],
		"mapped",
		[
			71882
		]
	],
	[
		[
			71851,
			71851
		],
		"mapped",
		[
			71883
		]
	],
	[
		[
			71852,
			71852
		],
		"mapped",
		[
			71884
		]
	],
	[
		[
			71853,
			71853
		],
		"mapped",
		[
			71885
		]
	],
	[
		[
			71854,
			71854
		],
		"mapped",
		[
			71886
		]
	],
	[
		[
			71855,
			71855
		],
		"mapped",
		[
			71887
		]
	],
	[
		[
			71856,
			71856
		],
		"mapped",
		[
			71888
		]
	],
	[
		[
			71857,
			71857
		],
		"mapped",
		[
			71889
		]
	],
	[
		[
			71858,
			71858
		],
		"mapped",
		[
			71890
		]
	],
	[
		[
			71859,
			71859
		],
		"mapped",
		[
			71891
		]
	],
	[
		[
			71860,
			71860
		],
		"mapped",
		[
			71892
		]
	],
	[
		[
			71861,
			71861
		],
		"mapped",
		[
			71893
		]
	],
	[
		[
			71862,
			71862
		],
		"mapped",
		[
			71894
		]
	],
	[
		[
			71863,
			71863
		],
		"mapped",
		[
			71895
		]
	],
	[
		[
			71864,
			71864
		],
		"mapped",
		[
			71896
		]
	],
	[
		[
			71865,
			71865
		],
		"mapped",
		[
			71897
		]
	],
	[
		[
			71866,
			71866
		],
		"mapped",
		[
			71898
		]
	],
	[
		[
			71867,
			71867
		],
		"mapped",
		[
			71899
		]
	],
	[
		[
			71868,
			71868
		],
		"mapped",
		[
			71900
		]
	],
	[
		[
			71869,
			71869
		],
		"mapped",
		[
			71901
		]
	],
	[
		[
			71870,
			71870
		],
		"mapped",
		[
			71902
		]
	],
	[
		[
			71871,
			71871
		],
		"mapped",
		[
			71903
		]
	],
	[
		[
			71872,
			71913
		],
		"valid"
	],
	[
		[
			71914,
			71922
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			71923,
			71934
		],
		"disallowed"
	],
	[
		[
			71935,
			71935
		],
		"valid"
	],
	[
		[
			71936,
			72383
		],
		"disallowed"
	],
	[
		[
			72384,
			72440
		],
		"valid"
	],
	[
		[
			72441,
			73727
		],
		"disallowed"
	],
	[
		[
			73728,
			74606
		],
		"valid"
	],
	[
		[
			74607,
			74648
		],
		"valid"
	],
	[
		[
			74649,
			74649
		],
		"valid"
	],
	[
		[
			74650,
			74751
		],
		"disallowed"
	],
	[
		[
			74752,
			74850
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			74851,
			74862
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			74863,
			74863
		],
		"disallowed"
	],
	[
		[
			74864,
			74867
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			74868,
			74868
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			74869,
			74879
		],
		"disallowed"
	],
	[
		[
			74880,
			75075
		],
		"valid"
	],
	[
		[
			75076,
			77823
		],
		"disallowed"
	],
	[
		[
			77824,
			78894
		],
		"valid"
	],
	[
		[
			78895,
			82943
		],
		"disallowed"
	],
	[
		[
			82944,
			83526
		],
		"valid"
	],
	[
		[
			83527,
			92159
		],
		"disallowed"
	],
	[
		[
			92160,
			92728
		],
		"valid"
	],
	[
		[
			92729,
			92735
		],
		"disallowed"
	],
	[
		[
			92736,
			92766
		],
		"valid"
	],
	[
		[
			92767,
			92767
		],
		"disallowed"
	],
	[
		[
			92768,
			92777
		],
		"valid"
	],
	[
		[
			92778,
			92781
		],
		"disallowed"
	],
	[
		[
			92782,
			92783
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			92784,
			92879
		],
		"disallowed"
	],
	[
		[
			92880,
			92909
		],
		"valid"
	],
	[
		[
			92910,
			92911
		],
		"disallowed"
	],
	[
		[
			92912,
			92916
		],
		"valid"
	],
	[
		[
			92917,
			92917
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			92918,
			92927
		],
		"disallowed"
	],
	[
		[
			92928,
			92982
		],
		"valid"
	],
	[
		[
			92983,
			92991
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			92992,
			92995
		],
		"valid"
	],
	[
		[
			92996,
			92997
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			92998,
			93007
		],
		"disallowed"
	],
	[
		[
			93008,
			93017
		],
		"valid"
	],
	[
		[
			93018,
			93018
		],
		"disallowed"
	],
	[
		[
			93019,
			93025
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			93026,
			93026
		],
		"disallowed"
	],
	[
		[
			93027,
			93047
		],
		"valid"
	],
	[
		[
			93048,
			93052
		],
		"disallowed"
	],
	[
		[
			93053,
			93071
		],
		"valid"
	],
	[
		[
			93072,
			93951
		],
		"disallowed"
	],
	[
		[
			93952,
			94020
		],
		"valid"
	],
	[
		[
			94021,
			94031
		],
		"disallowed"
	],
	[
		[
			94032,
			94078
		],
		"valid"
	],
	[
		[
			94079,
			94094
		],
		"disallowed"
	],
	[
		[
			94095,
			94111
		],
		"valid"
	],
	[
		[
			94112,
			110591
		],
		"disallowed"
	],
	[
		[
			110592,
			110593
		],
		"valid"
	],
	[
		[
			110594,
			113663
		],
		"disallowed"
	],
	[
		[
			113664,
			113770
		],
		"valid"
	],
	[
		[
			113771,
			113775
		],
		"disallowed"
	],
	[
		[
			113776,
			113788
		],
		"valid"
	],
	[
		[
			113789,
			113791
		],
		"disallowed"
	],
	[
		[
			113792,
			113800
		],
		"valid"
	],
	[
		[
			113801,
			113807
		],
		"disallowed"
	],
	[
		[
			113808,
			113817
		],
		"valid"
	],
	[
		[
			113818,
			113819
		],
		"disallowed"
	],
	[
		[
			113820,
			113820
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			113821,
			113822
		],
		"valid"
	],
	[
		[
			113823,
			113823
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			113824,
			113827
		],
		"ignored"
	],
	[
		[
			113828,
			118783
		],
		"disallowed"
	],
	[
		[
			118784,
			119029
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			119030,
			119039
		],
		"disallowed"
	],
	[
		[
			119040,
			119078
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			119079,
			119080
		],
		"disallowed"
	],
	[
		[
			119081,
			119081
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			119082,
			119133
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			119134,
			119134
		],
		"mapped",
		[
			119127,
			119141
		]
	],
	[
		[
			119135,
			119135
		],
		"mapped",
		[
			119128,
			119141
		]
	],
	[
		[
			119136,
			119136
		],
		"mapped",
		[
			119128,
			119141,
			119150
		]
	],
	[
		[
			119137,
			119137
		],
		"mapped",
		[
			119128,
			119141,
			119151
		]
	],
	[
		[
			119138,
			119138
		],
		"mapped",
		[
			119128,
			119141,
			119152
		]
	],
	[
		[
			119139,
			119139
		],
		"mapped",
		[
			119128,
			119141,
			119153
		]
	],
	[
		[
			119140,
			119140
		],
		"mapped",
		[
			119128,
			119141,
			119154
		]
	],
	[
		[
			119141,
			119154
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			119155,
			119162
		],
		"disallowed"
	],
	[
		[
			119163,
			119226
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			119227,
			119227
		],
		"mapped",
		[
			119225,
			119141
		]
	],
	[
		[
			119228,
			119228
		],
		"mapped",
		[
			119226,
			119141
		]
	],
	[
		[
			119229,
			119229
		],
		"mapped",
		[
			119225,
			119141,
			119150
		]
	],
	[
		[
			119230,
			119230
		],
		"mapped",
		[
			119226,
			119141,
			119150
		]
	],
	[
		[
			119231,
			119231
		],
		"mapped",
		[
			119225,
			119141,
			119151
		]
	],
	[
		[
			119232,
			119232
		],
		"mapped",
		[
			119226,
			119141,
			119151
		]
	],
	[
		[
			119233,
			119261
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			119262,
			119272
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			119273,
			119295
		],
		"disallowed"
	],
	[
		[
			119296,
			119365
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			119366,
			119551
		],
		"disallowed"
	],
	[
		[
			119552,
			119638
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			119639,
			119647
		],
		"disallowed"
	],
	[
		[
			119648,
			119665
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			119666,
			119807
		],
		"disallowed"
	],
	[
		[
			119808,
			119808
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			119809,
			119809
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			119810,
			119810
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			119811,
			119811
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			119812,
			119812
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			119813,
			119813
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			119814,
			119814
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			119815,
			119815
		],
		"mapped",
		[
			104
		]
	],
	[
		[
			119816,
			119816
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			119817,
			119817
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			119818,
			119818
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			119819,
			119819
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			119820,
			119820
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			119821,
			119821
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			119822,
			119822
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			119823,
			119823
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			119824,
			119824
		],
		"mapped",
		[
			113
		]
	],
	[
		[
			119825,
			119825
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			119826,
			119826
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			119827,
			119827
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			119828,
			119828
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			119829,
			119829
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			119830,
			119830
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			119831,
			119831
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			119832,
			119832
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			119833,
			119833
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			119834,
			119834
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			119835,
			119835
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			119836,
			119836
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			119837,
			119837
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			119838,
			119838
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			119839,
			119839
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			119840,
			119840
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			119841,
			119841
		],
		"mapped",
		[
			104
		]
	],
	[
		[
			119842,
			119842
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			119843,
			119843
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			119844,
			119844
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			119845,
			119845
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			119846,
			119846
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			119847,
			119847
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			119848,
			119848
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			119849,
			119849
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			119850,
			119850
		],
		"mapped",
		[
			113
		]
	],
	[
		[
			119851,
			119851
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			119852,
			119852
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			119853,
			119853
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			119854,
			119854
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			119855,
			119855
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			119856,
			119856
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			119857,
			119857
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			119858,
			119858
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			119859,
			119859
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			119860,
			119860
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			119861,
			119861
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			119862,
			119862
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			119863,
			119863
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			119864,
			119864
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			119865,
			119865
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			119866,
			119866
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			119867,
			119867
		],
		"mapped",
		[
			104
		]
	],
	[
		[
			119868,
			119868
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			119869,
			119869
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			119870,
			119870
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			119871,
			119871
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			119872,
			119872
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			119873,
			119873
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			119874,
			119874
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			119875,
			119875
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			119876,
			119876
		],
		"mapped",
		[
			113
		]
	],
	[
		[
			119877,
			119877
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			119878,
			119878
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			119879,
			119879
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			119880,
			119880
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			119881,
			119881
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			119882,
			119882
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			119883,
			119883
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			119884,
			119884
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			119885,
			119885
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			119886,
			119886
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			119887,
			119887
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			119888,
			119888
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			119889,
			119889
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			119890,
			119890
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			119891,
			119891
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			119892,
			119892
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			119893,
			119893
		],
		"disallowed"
	],
	[
		[
			119894,
			119894
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			119895,
			119895
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			119896,
			119896
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			119897,
			119897
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			119898,
			119898
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			119899,
			119899
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			119900,
			119900
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			119901,
			119901
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			119902,
			119902
		],
		"mapped",
		[
			113
		]
	],
	[
		[
			119903,
			119903
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			119904,
			119904
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			119905,
			119905
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			119906,
			119906
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			119907,
			119907
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			119908,
			119908
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			119909,
			119909
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			119910,
			119910
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			119911,
			119911
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			119912,
			119912
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			119913,
			119913
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			119914,
			119914
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			119915,
			119915
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			119916,
			119916
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			119917,
			119917
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			119918,
			119918
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			119919,
			119919
		],
		"mapped",
		[
			104
		]
	],
	[
		[
			119920,
			119920
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			119921,
			119921
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			119922,
			119922
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			119923,
			119923
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			119924,
			119924
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			119925,
			119925
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			119926,
			119926
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			119927,
			119927
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			119928,
			119928
		],
		"mapped",
		[
			113
		]
	],
	[
		[
			119929,
			119929
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			119930,
			119930
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			119931,
			119931
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			119932,
			119932
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			119933,
			119933
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			119934,
			119934
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			119935,
			119935
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			119936,
			119936
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			119937,
			119937
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			119938,
			119938
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			119939,
			119939
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			119940,
			119940
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			119941,
			119941
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			119942,
			119942
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			119943,
			119943
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			119944,
			119944
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			119945,
			119945
		],
		"mapped",
		[
			104
		]
	],
	[
		[
			119946,
			119946
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			119947,
			119947
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			119948,
			119948
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			119949,
			119949
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			119950,
			119950
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			119951,
			119951
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			119952,
			119952
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			119953,
			119953
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			119954,
			119954
		],
		"mapped",
		[
			113
		]
	],
	[
		[
			119955,
			119955
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			119956,
			119956
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			119957,
			119957
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			119958,
			119958
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			119959,
			119959
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			119960,
			119960
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			119961,
			119961
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			119962,
			119962
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			119963,
			119963
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			119964,
			119964
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			119965,
			119965
		],
		"disallowed"
	],
	[
		[
			119966,
			119966
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			119967,
			119967
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			119968,
			119969
		],
		"disallowed"
	],
	[
		[
			119970,
			119970
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			119971,
			119972
		],
		"disallowed"
	],
	[
		[
			119973,
			119973
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			119974,
			119974
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			119975,
			119976
		],
		"disallowed"
	],
	[
		[
			119977,
			119977
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			119978,
			119978
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			119979,
			119979
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			119980,
			119980
		],
		"mapped",
		[
			113
		]
	],
	[
		[
			119981,
			119981
		],
		"disallowed"
	],
	[
		[
			119982,
			119982
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			119983,
			119983
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			119984,
			119984
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			119985,
			119985
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			119986,
			119986
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			119987,
			119987
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			119988,
			119988
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			119989,
			119989
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			119990,
			119990
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			119991,
			119991
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			119992,
			119992
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			119993,
			119993
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			119994,
			119994
		],
		"disallowed"
	],
	[
		[
			119995,
			119995
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			119996,
			119996
		],
		"disallowed"
	],
	[
		[
			119997,
			119997
		],
		"mapped",
		[
			104
		]
	],
	[
		[
			119998,
			119998
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			119999,
			119999
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			120000,
			120000
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			120001,
			120001
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			120002,
			120002
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			120003,
			120003
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			120004,
			120004
		],
		"disallowed"
	],
	[
		[
			120005,
			120005
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			120006,
			120006
		],
		"mapped",
		[
			113
		]
	],
	[
		[
			120007,
			120007
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			120008,
			120008
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			120009,
			120009
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			120010,
			120010
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			120011,
			120011
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			120012,
			120012
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			120013,
			120013
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			120014,
			120014
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			120015,
			120015
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			120016,
			120016
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			120017,
			120017
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			120018,
			120018
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			120019,
			120019
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			120020,
			120020
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			120021,
			120021
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			120022,
			120022
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			120023,
			120023
		],
		"mapped",
		[
			104
		]
	],
	[
		[
			120024,
			120024
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			120025,
			120025
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			120026,
			120026
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			120027,
			120027
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			120028,
			120028
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			120029,
			120029
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			120030,
			120030
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			120031,
			120031
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			120032,
			120032
		],
		"mapped",
		[
			113
		]
	],
	[
		[
			120033,
			120033
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			120034,
			120034
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			120035,
			120035
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			120036,
			120036
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			120037,
			120037
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			120038,
			120038
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			120039,
			120039
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			120040,
			120040
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			120041,
			120041
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			120042,
			120042
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			120043,
			120043
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			120044,
			120044
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			120045,
			120045
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			120046,
			120046
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			120047,
			120047
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			120048,
			120048
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			120049,
			120049
		],
		"mapped",
		[
			104
		]
	],
	[
		[
			120050,
			120050
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			120051,
			120051
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			120052,
			120052
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			120053,
			120053
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			120054,
			120054
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			120055,
			120055
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			120056,
			120056
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			120057,
			120057
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			120058,
			120058
		],
		"mapped",
		[
			113
		]
	],
	[
		[
			120059,
			120059
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			120060,
			120060
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			120061,
			120061
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			120062,
			120062
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			120063,
			120063
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			120064,
			120064
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			120065,
			120065
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			120066,
			120066
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			120067,
			120067
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			120068,
			120068
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			120069,
			120069
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			120070,
			120070
		],
		"disallowed"
	],
	[
		[
			120071,
			120071
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			120072,
			120072
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			120073,
			120073
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			120074,
			120074
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			120075,
			120076
		],
		"disallowed"
	],
	[
		[
			120077,
			120077
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			120078,
			120078
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			120079,
			120079
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			120080,
			120080
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			120081,
			120081
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			120082,
			120082
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			120083,
			120083
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			120084,
			120084
		],
		"mapped",
		[
			113
		]
	],
	[
		[
			120085,
			120085
		],
		"disallowed"
	],
	[
		[
			120086,
			120086
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			120087,
			120087
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			120088,
			120088
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			120089,
			120089
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			120090,
			120090
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			120091,
			120091
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			120092,
			120092
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			120093,
			120093
		],
		"disallowed"
	],
	[
		[
			120094,
			120094
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			120095,
			120095
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			120096,
			120096
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			120097,
			120097
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			120098,
			120098
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			120099,
			120099
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			120100,
			120100
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			120101,
			120101
		],
		"mapped",
		[
			104
		]
	],
	[
		[
			120102,
			120102
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			120103,
			120103
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			120104,
			120104
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			120105,
			120105
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			120106,
			120106
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			120107,
			120107
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			120108,
			120108
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			120109,
			120109
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			120110,
			120110
		],
		"mapped",
		[
			113
		]
	],
	[
		[
			120111,
			120111
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			120112,
			120112
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			120113,
			120113
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			120114,
			120114
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			120115,
			120115
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			120116,
			120116
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			120117,
			120117
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			120118,
			120118
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			120119,
			120119
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			120120,
			120120
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			120121,
			120121
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			120122,
			120122
		],
		"disallowed"
	],
	[
		[
			120123,
			120123
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			120124,
			120124
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			120125,
			120125
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			120126,
			120126
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			120127,
			120127
		],
		"disallowed"
	],
	[
		[
			120128,
			120128
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			120129,
			120129
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			120130,
			120130
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			120131,
			120131
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			120132,
			120132
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			120133,
			120133
		],
		"disallowed"
	],
	[
		[
			120134,
			120134
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			120135,
			120137
		],
		"disallowed"
	],
	[
		[
			120138,
			120138
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			120139,
			120139
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			120140,
			120140
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			120141,
			120141
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			120142,
			120142
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			120143,
			120143
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			120144,
			120144
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			120145,
			120145
		],
		"disallowed"
	],
	[
		[
			120146,
			120146
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			120147,
			120147
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			120148,
			120148
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			120149,
			120149
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			120150,
			120150
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			120151,
			120151
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			120152,
			120152
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			120153,
			120153
		],
		"mapped",
		[
			104
		]
	],
	[
		[
			120154,
			120154
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			120155,
			120155
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			120156,
			120156
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			120157,
			120157
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			120158,
			120158
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			120159,
			120159
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			120160,
			120160
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			120161,
			120161
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			120162,
			120162
		],
		"mapped",
		[
			113
		]
	],
	[
		[
			120163,
			120163
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			120164,
			120164
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			120165,
			120165
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			120166,
			120166
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			120167,
			120167
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			120168,
			120168
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			120169,
			120169
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			120170,
			120170
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			120171,
			120171
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			120172,
			120172
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			120173,
			120173
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			120174,
			120174
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			120175,
			120175
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			120176,
			120176
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			120177,
			120177
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			120178,
			120178
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			120179,
			120179
		],
		"mapped",
		[
			104
		]
	],
	[
		[
			120180,
			120180
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			120181,
			120181
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			120182,
			120182
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			120183,
			120183
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			120184,
			120184
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			120185,
			120185
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			120186,
			120186
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			120187,
			120187
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			120188,
			120188
		],
		"mapped",
		[
			113
		]
	],
	[
		[
			120189,
			120189
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			120190,
			120190
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			120191,
			120191
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			120192,
			120192
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			120193,
			120193
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			120194,
			120194
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			120195,
			120195
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			120196,
			120196
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			120197,
			120197
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			120198,
			120198
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			120199,
			120199
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			120200,
			120200
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			120201,
			120201
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			120202,
			120202
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			120203,
			120203
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			120204,
			120204
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			120205,
			120205
		],
		"mapped",
		[
			104
		]
	],
	[
		[
			120206,
			120206
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			120207,
			120207
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			120208,
			120208
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			120209,
			120209
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			120210,
			120210
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			120211,
			120211
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			120212,
			120212
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			120213,
			120213
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			120214,
			120214
		],
		"mapped",
		[
			113
		]
	],
	[
		[
			120215,
			120215
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			120216,
			120216
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			120217,
			120217
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			120218,
			120218
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			120219,
			120219
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			120220,
			120220
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			120221,
			120221
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			120222,
			120222
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			120223,
			120223
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			120224,
			120224
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			120225,
			120225
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			120226,
			120226
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			120227,
			120227
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			120228,
			120228
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			120229,
			120229
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			120230,
			120230
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			120231,
			120231
		],
		"mapped",
		[
			104
		]
	],
	[
		[
			120232,
			120232
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			120233,
			120233
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			120234,
			120234
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			120235,
			120235
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			120236,
			120236
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			120237,
			120237
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			120238,
			120238
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			120239,
			120239
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			120240,
			120240
		],
		"mapped",
		[
			113
		]
	],
	[
		[
			120241,
			120241
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			120242,
			120242
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			120243,
			120243
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			120244,
			120244
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			120245,
			120245
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			120246,
			120246
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			120247,
			120247
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			120248,
			120248
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			120249,
			120249
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			120250,
			120250
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			120251,
			120251
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			120252,
			120252
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			120253,
			120253
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			120254,
			120254
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			120255,
			120255
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			120256,
			120256
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			120257,
			120257
		],
		"mapped",
		[
			104
		]
	],
	[
		[
			120258,
			120258
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			120259,
			120259
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			120260,
			120260
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			120261,
			120261
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			120262,
			120262
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			120263,
			120263
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			120264,
			120264
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			120265,
			120265
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			120266,
			120266
		],
		"mapped",
		[
			113
		]
	],
	[
		[
			120267,
			120267
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			120268,
			120268
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			120269,
			120269
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			120270,
			120270
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			120271,
			120271
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			120272,
			120272
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			120273,
			120273
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			120274,
			120274
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			120275,
			120275
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			120276,
			120276
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			120277,
			120277
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			120278,
			120278
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			120279,
			120279
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			120280,
			120280
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			120281,
			120281
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			120282,
			120282
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			120283,
			120283
		],
		"mapped",
		[
			104
		]
	],
	[
		[
			120284,
			120284
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			120285,
			120285
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			120286,
			120286
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			120287,
			120287
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			120288,
			120288
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			120289,
			120289
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			120290,
			120290
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			120291,
			120291
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			120292,
			120292
		],
		"mapped",
		[
			113
		]
	],
	[
		[
			120293,
			120293
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			120294,
			120294
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			120295,
			120295
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			120296,
			120296
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			120297,
			120297
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			120298,
			120298
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			120299,
			120299
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			120300,
			120300
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			120301,
			120301
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			120302,
			120302
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			120303,
			120303
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			120304,
			120304
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			120305,
			120305
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			120306,
			120306
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			120307,
			120307
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			120308,
			120308
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			120309,
			120309
		],
		"mapped",
		[
			104
		]
	],
	[
		[
			120310,
			120310
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			120311,
			120311
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			120312,
			120312
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			120313,
			120313
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			120314,
			120314
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			120315,
			120315
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			120316,
			120316
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			120317,
			120317
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			120318,
			120318
		],
		"mapped",
		[
			113
		]
	],
	[
		[
			120319,
			120319
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			120320,
			120320
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			120321,
			120321
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			120322,
			120322
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			120323,
			120323
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			120324,
			120324
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			120325,
			120325
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			120326,
			120326
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			120327,
			120327
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			120328,
			120328
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			120329,
			120329
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			120330,
			120330
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			120331,
			120331
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			120332,
			120332
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			120333,
			120333
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			120334,
			120334
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			120335,
			120335
		],
		"mapped",
		[
			104
		]
	],
	[
		[
			120336,
			120336
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			120337,
			120337
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			120338,
			120338
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			120339,
			120339
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			120340,
			120340
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			120341,
			120341
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			120342,
			120342
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			120343,
			120343
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			120344,
			120344
		],
		"mapped",
		[
			113
		]
	],
	[
		[
			120345,
			120345
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			120346,
			120346
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			120347,
			120347
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			120348,
			120348
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			120349,
			120349
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			120350,
			120350
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			120351,
			120351
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			120352,
			120352
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			120353,
			120353
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			120354,
			120354
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			120355,
			120355
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			120356,
			120356
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			120357,
			120357
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			120358,
			120358
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			120359,
			120359
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			120360,
			120360
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			120361,
			120361
		],
		"mapped",
		[
			104
		]
	],
	[
		[
			120362,
			120362
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			120363,
			120363
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			120364,
			120364
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			120365,
			120365
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			120366,
			120366
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			120367,
			120367
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			120368,
			120368
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			120369,
			120369
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			120370,
			120370
		],
		"mapped",
		[
			113
		]
	],
	[
		[
			120371,
			120371
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			120372,
			120372
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			120373,
			120373
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			120374,
			120374
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			120375,
			120375
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			120376,
			120376
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			120377,
			120377
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			120378,
			120378
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			120379,
			120379
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			120380,
			120380
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			120381,
			120381
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			120382,
			120382
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			120383,
			120383
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			120384,
			120384
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			120385,
			120385
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			120386,
			120386
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			120387,
			120387
		],
		"mapped",
		[
			104
		]
	],
	[
		[
			120388,
			120388
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			120389,
			120389
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			120390,
			120390
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			120391,
			120391
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			120392,
			120392
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			120393,
			120393
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			120394,
			120394
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			120395,
			120395
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			120396,
			120396
		],
		"mapped",
		[
			113
		]
	],
	[
		[
			120397,
			120397
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			120398,
			120398
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			120399,
			120399
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			120400,
			120400
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			120401,
			120401
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			120402,
			120402
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			120403,
			120403
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			120404,
			120404
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			120405,
			120405
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			120406,
			120406
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			120407,
			120407
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			120408,
			120408
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			120409,
			120409
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			120410,
			120410
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			120411,
			120411
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			120412,
			120412
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			120413,
			120413
		],
		"mapped",
		[
			104
		]
	],
	[
		[
			120414,
			120414
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			120415,
			120415
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			120416,
			120416
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			120417,
			120417
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			120418,
			120418
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			120419,
			120419
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			120420,
			120420
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			120421,
			120421
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			120422,
			120422
		],
		"mapped",
		[
			113
		]
	],
	[
		[
			120423,
			120423
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			120424,
			120424
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			120425,
			120425
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			120426,
			120426
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			120427,
			120427
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			120428,
			120428
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			120429,
			120429
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			120430,
			120430
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			120431,
			120431
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			120432,
			120432
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			120433,
			120433
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			120434,
			120434
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			120435,
			120435
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			120436,
			120436
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			120437,
			120437
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			120438,
			120438
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			120439,
			120439
		],
		"mapped",
		[
			104
		]
	],
	[
		[
			120440,
			120440
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			120441,
			120441
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			120442,
			120442
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			120443,
			120443
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			120444,
			120444
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			120445,
			120445
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			120446,
			120446
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			120447,
			120447
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			120448,
			120448
		],
		"mapped",
		[
			113
		]
	],
	[
		[
			120449,
			120449
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			120450,
			120450
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			120451,
			120451
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			120452,
			120452
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			120453,
			120453
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			120454,
			120454
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			120455,
			120455
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			120456,
			120456
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			120457,
			120457
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			120458,
			120458
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			120459,
			120459
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			120460,
			120460
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			120461,
			120461
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			120462,
			120462
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			120463,
			120463
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			120464,
			120464
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			120465,
			120465
		],
		"mapped",
		[
			104
		]
	],
	[
		[
			120466,
			120466
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			120467,
			120467
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			120468,
			120468
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			120469,
			120469
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			120470,
			120470
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			120471,
			120471
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			120472,
			120472
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			120473,
			120473
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			120474,
			120474
		],
		"mapped",
		[
			113
		]
	],
	[
		[
			120475,
			120475
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			120476,
			120476
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			120477,
			120477
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			120478,
			120478
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			120479,
			120479
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			120480,
			120480
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			120481,
			120481
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			120482,
			120482
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			120483,
			120483
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			120484,
			120484
		],
		"mapped",
		[
			305
		]
	],
	[
		[
			120485,
			120485
		],
		"mapped",
		[
			567
		]
	],
	[
		[
			120486,
			120487
		],
		"disallowed"
	],
	[
		[
			120488,
			120488
		],
		"mapped",
		[
			945
		]
	],
	[
		[
			120489,
			120489
		],
		"mapped",
		[
			946
		]
	],
	[
		[
			120490,
			120490
		],
		"mapped",
		[
			947
		]
	],
	[
		[
			120491,
			120491
		],
		"mapped",
		[
			948
		]
	],
	[
		[
			120492,
			120492
		],
		"mapped",
		[
			949
		]
	],
	[
		[
			120493,
			120493
		],
		"mapped",
		[
			950
		]
	],
	[
		[
			120494,
			120494
		],
		"mapped",
		[
			951
		]
	],
	[
		[
			120495,
			120495
		],
		"mapped",
		[
			952
		]
	],
	[
		[
			120496,
			120496
		],
		"mapped",
		[
			953
		]
	],
	[
		[
			120497,
			120497
		],
		"mapped",
		[
			954
		]
	],
	[
		[
			120498,
			120498
		],
		"mapped",
		[
			955
		]
	],
	[
		[
			120499,
			120499
		],
		"mapped",
		[
			956
		]
	],
	[
		[
			120500,
			120500
		],
		"mapped",
		[
			957
		]
	],
	[
		[
			120501,
			120501
		],
		"mapped",
		[
			958
		]
	],
	[
		[
			120502,
			120502
		],
		"mapped",
		[
			959
		]
	],
	[
		[
			120503,
			120503
		],
		"mapped",
		[
			960
		]
	],
	[
		[
			120504,
			120504
		],
		"mapped",
		[
			961
		]
	],
	[
		[
			120505,
			120505
		],
		"mapped",
		[
			952
		]
	],
	[
		[
			120506,
			120506
		],
		"mapped",
		[
			963
		]
	],
	[
		[
			120507,
			120507
		],
		"mapped",
		[
			964
		]
	],
	[
		[
			120508,
			120508
		],
		"mapped",
		[
			965
		]
	],
	[
		[
			120509,
			120509
		],
		"mapped",
		[
			966
		]
	],
	[
		[
			120510,
			120510
		],
		"mapped",
		[
			967
		]
	],
	[
		[
			120511,
			120511
		],
		"mapped",
		[
			968
		]
	],
	[
		[
			120512,
			120512
		],
		"mapped",
		[
			969
		]
	],
	[
		[
			120513,
			120513
		],
		"mapped",
		[
			8711
		]
	],
	[
		[
			120514,
			120514
		],
		"mapped",
		[
			945
		]
	],
	[
		[
			120515,
			120515
		],
		"mapped",
		[
			946
		]
	],
	[
		[
			120516,
			120516
		],
		"mapped",
		[
			947
		]
	],
	[
		[
			120517,
			120517
		],
		"mapped",
		[
			948
		]
	],
	[
		[
			120518,
			120518
		],
		"mapped",
		[
			949
		]
	],
	[
		[
			120519,
			120519
		],
		"mapped",
		[
			950
		]
	],
	[
		[
			120520,
			120520
		],
		"mapped",
		[
			951
		]
	],
	[
		[
			120521,
			120521
		],
		"mapped",
		[
			952
		]
	],
	[
		[
			120522,
			120522
		],
		"mapped",
		[
			953
		]
	],
	[
		[
			120523,
			120523
		],
		"mapped",
		[
			954
		]
	],
	[
		[
			120524,
			120524
		],
		"mapped",
		[
			955
		]
	],
	[
		[
			120525,
			120525
		],
		"mapped",
		[
			956
		]
	],
	[
		[
			120526,
			120526
		],
		"mapped",
		[
			957
		]
	],
	[
		[
			120527,
			120527
		],
		"mapped",
		[
			958
		]
	],
	[
		[
			120528,
			120528
		],
		"mapped",
		[
			959
		]
	],
	[
		[
			120529,
			120529
		],
		"mapped",
		[
			960
		]
	],
	[
		[
			120530,
			120530
		],
		"mapped",
		[
			961
		]
	],
	[
		[
			120531,
			120532
		],
		"mapped",
		[
			963
		]
	],
	[
		[
			120533,
			120533
		],
		"mapped",
		[
			964
		]
	],
	[
		[
			120534,
			120534
		],
		"mapped",
		[
			965
		]
	],
	[
		[
			120535,
			120535
		],
		"mapped",
		[
			966
		]
	],
	[
		[
			120536,
			120536
		],
		"mapped",
		[
			967
		]
	],
	[
		[
			120537,
			120537
		],
		"mapped",
		[
			968
		]
	],
	[
		[
			120538,
			120538
		],
		"mapped",
		[
			969
		]
	],
	[
		[
			120539,
			120539
		],
		"mapped",
		[
			8706
		]
	],
	[
		[
			120540,
			120540
		],
		"mapped",
		[
			949
		]
	],
	[
		[
			120541,
			120541
		],
		"mapped",
		[
			952
		]
	],
	[
		[
			120542,
			120542
		],
		"mapped",
		[
			954
		]
	],
	[
		[
			120543,
			120543
		],
		"mapped",
		[
			966
		]
	],
	[
		[
			120544,
			120544
		],
		"mapped",
		[
			961
		]
	],
	[
		[
			120545,
			120545
		],
		"mapped",
		[
			960
		]
	],
	[
		[
			120546,
			120546
		],
		"mapped",
		[
			945
		]
	],
	[
		[
			120547,
			120547
		],
		"mapped",
		[
			946
		]
	],
	[
		[
			120548,
			120548
		],
		"mapped",
		[
			947
		]
	],
	[
		[
			120549,
			120549
		],
		"mapped",
		[
			948
		]
	],
	[
		[
			120550,
			120550
		],
		"mapped",
		[
			949
		]
	],
	[
		[
			120551,
			120551
		],
		"mapped",
		[
			950
		]
	],
	[
		[
			120552,
			120552
		],
		"mapped",
		[
			951
		]
	],
	[
		[
			120553,
			120553
		],
		"mapped",
		[
			952
		]
	],
	[
		[
			120554,
			120554
		],
		"mapped",
		[
			953
		]
	],
	[
		[
			120555,
			120555
		],
		"mapped",
		[
			954
		]
	],
	[
		[
			120556,
			120556
		],
		"mapped",
		[
			955
		]
	],
	[
		[
			120557,
			120557
		],
		"mapped",
		[
			956
		]
	],
	[
		[
			120558,
			120558
		],
		"mapped",
		[
			957
		]
	],
	[
		[
			120559,
			120559
		],
		"mapped",
		[
			958
		]
	],
	[
		[
			120560,
			120560
		],
		"mapped",
		[
			959
		]
	],
	[
		[
			120561,
			120561
		],
		"mapped",
		[
			960
		]
	],
	[
		[
			120562,
			120562
		],
		"mapped",
		[
			961
		]
	],
	[
		[
			120563,
			120563
		],
		"mapped",
		[
			952
		]
	],
	[
		[
			120564,
			120564
		],
		"mapped",
		[
			963
		]
	],
	[
		[
			120565,
			120565
		],
		"mapped",
		[
			964
		]
	],
	[
		[
			120566,
			120566
		],
		"mapped",
		[
			965
		]
	],
	[
		[
			120567,
			120567
		],
		"mapped",
		[
			966
		]
	],
	[
		[
			120568,
			120568
		],
		"mapped",
		[
			967
		]
	],
	[
		[
			120569,
			120569
		],
		"mapped",
		[
			968
		]
	],
	[
		[
			120570,
			120570
		],
		"mapped",
		[
			969
		]
	],
	[
		[
			120571,
			120571
		],
		"mapped",
		[
			8711
		]
	],
	[
		[
			120572,
			120572
		],
		"mapped",
		[
			945
		]
	],
	[
		[
			120573,
			120573
		],
		"mapped",
		[
			946
		]
	],
	[
		[
			120574,
			120574
		],
		"mapped",
		[
			947
		]
	],
	[
		[
			120575,
			120575
		],
		"mapped",
		[
			948
		]
	],
	[
		[
			120576,
			120576
		],
		"mapped",
		[
			949
		]
	],
	[
		[
			120577,
			120577
		],
		"mapped",
		[
			950
		]
	],
	[
		[
			120578,
			120578
		],
		"mapped",
		[
			951
		]
	],
	[
		[
			120579,
			120579
		],
		"mapped",
		[
			952
		]
	],
	[
		[
			120580,
			120580
		],
		"mapped",
		[
			953
		]
	],
	[
		[
			120581,
			120581
		],
		"mapped",
		[
			954
		]
	],
	[
		[
			120582,
			120582
		],
		"mapped",
		[
			955
		]
	],
	[
		[
			120583,
			120583
		],
		"mapped",
		[
			956
		]
	],
	[
		[
			120584,
			120584
		],
		"mapped",
		[
			957
		]
	],
	[
		[
			120585,
			120585
		],
		"mapped",
		[
			958
		]
	],
	[
		[
			120586,
			120586
		],
		"mapped",
		[
			959
		]
	],
	[
		[
			120587,
			120587
		],
		"mapped",
		[
			960
		]
	],
	[
		[
			120588,
			120588
		],
		"mapped",
		[
			961
		]
	],
	[
		[
			120589,
			120590
		],
		"mapped",
		[
			963
		]
	],
	[
		[
			120591,
			120591
		],
		"mapped",
		[
			964
		]
	],
	[
		[
			120592,
			120592
		],
		"mapped",
		[
			965
		]
	],
	[
		[
			120593,
			120593
		],
		"mapped",
		[
			966
		]
	],
	[
		[
			120594,
			120594
		],
		"mapped",
		[
			967
		]
	],
	[
		[
			120595,
			120595
		],
		"mapped",
		[
			968
		]
	],
	[
		[
			120596,
			120596
		],
		"mapped",
		[
			969
		]
	],
	[
		[
			120597,
			120597
		],
		"mapped",
		[
			8706
		]
	],
	[
		[
			120598,
			120598
		],
		"mapped",
		[
			949
		]
	],
	[
		[
			120599,
			120599
		],
		"mapped",
		[
			952
		]
	],
	[
		[
			120600,
			120600
		],
		"mapped",
		[
			954
		]
	],
	[
		[
			120601,
			120601
		],
		"mapped",
		[
			966
		]
	],
	[
		[
			120602,
			120602
		],
		"mapped",
		[
			961
		]
	],
	[
		[
			120603,
			120603
		],
		"mapped",
		[
			960
		]
	],
	[
		[
			120604,
			120604
		],
		"mapped",
		[
			945
		]
	],
	[
		[
			120605,
			120605
		],
		"mapped",
		[
			946
		]
	],
	[
		[
			120606,
			120606
		],
		"mapped",
		[
			947
		]
	],
	[
		[
			120607,
			120607
		],
		"mapped",
		[
			948
		]
	],
	[
		[
			120608,
			120608
		],
		"mapped",
		[
			949
		]
	],
	[
		[
			120609,
			120609
		],
		"mapped",
		[
			950
		]
	],
	[
		[
			120610,
			120610
		],
		"mapped",
		[
			951
		]
	],
	[
		[
			120611,
			120611
		],
		"mapped",
		[
			952
		]
	],
	[
		[
			120612,
			120612
		],
		"mapped",
		[
			953
		]
	],
	[
		[
			120613,
			120613
		],
		"mapped",
		[
			954
		]
	],
	[
		[
			120614,
			120614
		],
		"mapped",
		[
			955
		]
	],
	[
		[
			120615,
			120615
		],
		"mapped",
		[
			956
		]
	],
	[
		[
			120616,
			120616
		],
		"mapped",
		[
			957
		]
	],
	[
		[
			120617,
			120617
		],
		"mapped",
		[
			958
		]
	],
	[
		[
			120618,
			120618
		],
		"mapped",
		[
			959
		]
	],
	[
		[
			120619,
			120619
		],
		"mapped",
		[
			960
		]
	],
	[
		[
			120620,
			120620
		],
		"mapped",
		[
			961
		]
	],
	[
		[
			120621,
			120621
		],
		"mapped",
		[
			952
		]
	],
	[
		[
			120622,
			120622
		],
		"mapped",
		[
			963
		]
	],
	[
		[
			120623,
			120623
		],
		"mapped",
		[
			964
		]
	],
	[
		[
			120624,
			120624
		],
		"mapped",
		[
			965
		]
	],
	[
		[
			120625,
			120625
		],
		"mapped",
		[
			966
		]
	],
	[
		[
			120626,
			120626
		],
		"mapped",
		[
			967
		]
	],
	[
		[
			120627,
			120627
		],
		"mapped",
		[
			968
		]
	],
	[
		[
			120628,
			120628
		],
		"mapped",
		[
			969
		]
	],
	[
		[
			120629,
			120629
		],
		"mapped",
		[
			8711
		]
	],
	[
		[
			120630,
			120630
		],
		"mapped",
		[
			945
		]
	],
	[
		[
			120631,
			120631
		],
		"mapped",
		[
			946
		]
	],
	[
		[
			120632,
			120632
		],
		"mapped",
		[
			947
		]
	],
	[
		[
			120633,
			120633
		],
		"mapped",
		[
			948
		]
	],
	[
		[
			120634,
			120634
		],
		"mapped",
		[
			949
		]
	],
	[
		[
			120635,
			120635
		],
		"mapped",
		[
			950
		]
	],
	[
		[
			120636,
			120636
		],
		"mapped",
		[
			951
		]
	],
	[
		[
			120637,
			120637
		],
		"mapped",
		[
			952
		]
	],
	[
		[
			120638,
			120638
		],
		"mapped",
		[
			953
		]
	],
	[
		[
			120639,
			120639
		],
		"mapped",
		[
			954
		]
	],
	[
		[
			120640,
			120640
		],
		"mapped",
		[
			955
		]
	],
	[
		[
			120641,
			120641
		],
		"mapped",
		[
			956
		]
	],
	[
		[
			120642,
			120642
		],
		"mapped",
		[
			957
		]
	],
	[
		[
			120643,
			120643
		],
		"mapped",
		[
			958
		]
	],
	[
		[
			120644,
			120644
		],
		"mapped",
		[
			959
		]
	],
	[
		[
			120645,
			120645
		],
		"mapped",
		[
			960
		]
	],
	[
		[
			120646,
			120646
		],
		"mapped",
		[
			961
		]
	],
	[
		[
			120647,
			120648
		],
		"mapped",
		[
			963
		]
	],
	[
		[
			120649,
			120649
		],
		"mapped",
		[
			964
		]
	],
	[
		[
			120650,
			120650
		],
		"mapped",
		[
			965
		]
	],
	[
		[
			120651,
			120651
		],
		"mapped",
		[
			966
		]
	],
	[
		[
			120652,
			120652
		],
		"mapped",
		[
			967
		]
	],
	[
		[
			120653,
			120653
		],
		"mapped",
		[
			968
		]
	],
	[
		[
			120654,
			120654
		],
		"mapped",
		[
			969
		]
	],
	[
		[
			120655,
			120655
		],
		"mapped",
		[
			8706
		]
	],
	[
		[
			120656,
			120656
		],
		"mapped",
		[
			949
		]
	],
	[
		[
			120657,
			120657
		],
		"mapped",
		[
			952
		]
	],
	[
		[
			120658,
			120658
		],
		"mapped",
		[
			954
		]
	],
	[
		[
			120659,
			120659
		],
		"mapped",
		[
			966
		]
	],
	[
		[
			120660,
			120660
		],
		"mapped",
		[
			961
		]
	],
	[
		[
			120661,
			120661
		],
		"mapped",
		[
			960
		]
	],
	[
		[
			120662,
			120662
		],
		"mapped",
		[
			945
		]
	],
	[
		[
			120663,
			120663
		],
		"mapped",
		[
			946
		]
	],
	[
		[
			120664,
			120664
		],
		"mapped",
		[
			947
		]
	],
	[
		[
			120665,
			120665
		],
		"mapped",
		[
			948
		]
	],
	[
		[
			120666,
			120666
		],
		"mapped",
		[
			949
		]
	],
	[
		[
			120667,
			120667
		],
		"mapped",
		[
			950
		]
	],
	[
		[
			120668,
			120668
		],
		"mapped",
		[
			951
		]
	],
	[
		[
			120669,
			120669
		],
		"mapped",
		[
			952
		]
	],
	[
		[
			120670,
			120670
		],
		"mapped",
		[
			953
		]
	],
	[
		[
			120671,
			120671
		],
		"mapped",
		[
			954
		]
	],
	[
		[
			120672,
			120672
		],
		"mapped",
		[
			955
		]
	],
	[
		[
			120673,
			120673
		],
		"mapped",
		[
			956
		]
	],
	[
		[
			120674,
			120674
		],
		"mapped",
		[
			957
		]
	],
	[
		[
			120675,
			120675
		],
		"mapped",
		[
			958
		]
	],
	[
		[
			120676,
			120676
		],
		"mapped",
		[
			959
		]
	],
	[
		[
			120677,
			120677
		],
		"mapped",
		[
			960
		]
	],
	[
		[
			120678,
			120678
		],
		"mapped",
		[
			961
		]
	],
	[
		[
			120679,
			120679
		],
		"mapped",
		[
			952
		]
	],
	[
		[
			120680,
			120680
		],
		"mapped",
		[
			963
		]
	],
	[
		[
			120681,
			120681
		],
		"mapped",
		[
			964
		]
	],
	[
		[
			120682,
			120682
		],
		"mapped",
		[
			965
		]
	],
	[
		[
			120683,
			120683
		],
		"mapped",
		[
			966
		]
	],
	[
		[
			120684,
			120684
		],
		"mapped",
		[
			967
		]
	],
	[
		[
			120685,
			120685
		],
		"mapped",
		[
			968
		]
	],
	[
		[
			120686,
			120686
		],
		"mapped",
		[
			969
		]
	],
	[
		[
			120687,
			120687
		],
		"mapped",
		[
			8711
		]
	],
	[
		[
			120688,
			120688
		],
		"mapped",
		[
			945
		]
	],
	[
		[
			120689,
			120689
		],
		"mapped",
		[
			946
		]
	],
	[
		[
			120690,
			120690
		],
		"mapped",
		[
			947
		]
	],
	[
		[
			120691,
			120691
		],
		"mapped",
		[
			948
		]
	],
	[
		[
			120692,
			120692
		],
		"mapped",
		[
			949
		]
	],
	[
		[
			120693,
			120693
		],
		"mapped",
		[
			950
		]
	],
	[
		[
			120694,
			120694
		],
		"mapped",
		[
			951
		]
	],
	[
		[
			120695,
			120695
		],
		"mapped",
		[
			952
		]
	],
	[
		[
			120696,
			120696
		],
		"mapped",
		[
			953
		]
	],
	[
		[
			120697,
			120697
		],
		"mapped",
		[
			954
		]
	],
	[
		[
			120698,
			120698
		],
		"mapped",
		[
			955
		]
	],
	[
		[
			120699,
			120699
		],
		"mapped",
		[
			956
		]
	],
	[
		[
			120700,
			120700
		],
		"mapped",
		[
			957
		]
	],
	[
		[
			120701,
			120701
		],
		"mapped",
		[
			958
		]
	],
	[
		[
			120702,
			120702
		],
		"mapped",
		[
			959
		]
	],
	[
		[
			120703,
			120703
		],
		"mapped",
		[
			960
		]
	],
	[
		[
			120704,
			120704
		],
		"mapped",
		[
			961
		]
	],
	[
		[
			120705,
			120706
		],
		"mapped",
		[
			963
		]
	],
	[
		[
			120707,
			120707
		],
		"mapped",
		[
			964
		]
	],
	[
		[
			120708,
			120708
		],
		"mapped",
		[
			965
		]
	],
	[
		[
			120709,
			120709
		],
		"mapped",
		[
			966
		]
	],
	[
		[
			120710,
			120710
		],
		"mapped",
		[
			967
		]
	],
	[
		[
			120711,
			120711
		],
		"mapped",
		[
			968
		]
	],
	[
		[
			120712,
			120712
		],
		"mapped",
		[
			969
		]
	],
	[
		[
			120713,
			120713
		],
		"mapped",
		[
			8706
		]
	],
	[
		[
			120714,
			120714
		],
		"mapped",
		[
			949
		]
	],
	[
		[
			120715,
			120715
		],
		"mapped",
		[
			952
		]
	],
	[
		[
			120716,
			120716
		],
		"mapped",
		[
			954
		]
	],
	[
		[
			120717,
			120717
		],
		"mapped",
		[
			966
		]
	],
	[
		[
			120718,
			120718
		],
		"mapped",
		[
			961
		]
	],
	[
		[
			120719,
			120719
		],
		"mapped",
		[
			960
		]
	],
	[
		[
			120720,
			120720
		],
		"mapped",
		[
			945
		]
	],
	[
		[
			120721,
			120721
		],
		"mapped",
		[
			946
		]
	],
	[
		[
			120722,
			120722
		],
		"mapped",
		[
			947
		]
	],
	[
		[
			120723,
			120723
		],
		"mapped",
		[
			948
		]
	],
	[
		[
			120724,
			120724
		],
		"mapped",
		[
			949
		]
	],
	[
		[
			120725,
			120725
		],
		"mapped",
		[
			950
		]
	],
	[
		[
			120726,
			120726
		],
		"mapped",
		[
			951
		]
	],
	[
		[
			120727,
			120727
		],
		"mapped",
		[
			952
		]
	],
	[
		[
			120728,
			120728
		],
		"mapped",
		[
			953
		]
	],
	[
		[
			120729,
			120729
		],
		"mapped",
		[
			954
		]
	],
	[
		[
			120730,
			120730
		],
		"mapped",
		[
			955
		]
	],
	[
		[
			120731,
			120731
		],
		"mapped",
		[
			956
		]
	],
	[
		[
			120732,
			120732
		],
		"mapped",
		[
			957
		]
	],
	[
		[
			120733,
			120733
		],
		"mapped",
		[
			958
		]
	],
	[
		[
			120734,
			120734
		],
		"mapped",
		[
			959
		]
	],
	[
		[
			120735,
			120735
		],
		"mapped",
		[
			960
		]
	],
	[
		[
			120736,
			120736
		],
		"mapped",
		[
			961
		]
	],
	[
		[
			120737,
			120737
		],
		"mapped",
		[
			952
		]
	],
	[
		[
			120738,
			120738
		],
		"mapped",
		[
			963
		]
	],
	[
		[
			120739,
			120739
		],
		"mapped",
		[
			964
		]
	],
	[
		[
			120740,
			120740
		],
		"mapped",
		[
			965
		]
	],
	[
		[
			120741,
			120741
		],
		"mapped",
		[
			966
		]
	],
	[
		[
			120742,
			120742
		],
		"mapped",
		[
			967
		]
	],
	[
		[
			120743,
			120743
		],
		"mapped",
		[
			968
		]
	],
	[
		[
			120744,
			120744
		],
		"mapped",
		[
			969
		]
	],
	[
		[
			120745,
			120745
		],
		"mapped",
		[
			8711
		]
	],
	[
		[
			120746,
			120746
		],
		"mapped",
		[
			945
		]
	],
	[
		[
			120747,
			120747
		],
		"mapped",
		[
			946
		]
	],
	[
		[
			120748,
			120748
		],
		"mapped",
		[
			947
		]
	],
	[
		[
			120749,
			120749
		],
		"mapped",
		[
			948
		]
	],
	[
		[
			120750,
			120750
		],
		"mapped",
		[
			949
		]
	],
	[
		[
			120751,
			120751
		],
		"mapped",
		[
			950
		]
	],
	[
		[
			120752,
			120752
		],
		"mapped",
		[
			951
		]
	],
	[
		[
			120753,
			120753
		],
		"mapped",
		[
			952
		]
	],
	[
		[
			120754,
			120754
		],
		"mapped",
		[
			953
		]
	],
	[
		[
			120755,
			120755
		],
		"mapped",
		[
			954
		]
	],
	[
		[
			120756,
			120756
		],
		"mapped",
		[
			955
		]
	],
	[
		[
			120757,
			120757
		],
		"mapped",
		[
			956
		]
	],
	[
		[
			120758,
			120758
		],
		"mapped",
		[
			957
		]
	],
	[
		[
			120759,
			120759
		],
		"mapped",
		[
			958
		]
	],
	[
		[
			120760,
			120760
		],
		"mapped",
		[
			959
		]
	],
	[
		[
			120761,
			120761
		],
		"mapped",
		[
			960
		]
	],
	[
		[
			120762,
			120762
		],
		"mapped",
		[
			961
		]
	],
	[
		[
			120763,
			120764
		],
		"mapped",
		[
			963
		]
	],
	[
		[
			120765,
			120765
		],
		"mapped",
		[
			964
		]
	],
	[
		[
			120766,
			120766
		],
		"mapped",
		[
			965
		]
	],
	[
		[
			120767,
			120767
		],
		"mapped",
		[
			966
		]
	],
	[
		[
			120768,
			120768
		],
		"mapped",
		[
			967
		]
	],
	[
		[
			120769,
			120769
		],
		"mapped",
		[
			968
		]
	],
	[
		[
			120770,
			120770
		],
		"mapped",
		[
			969
		]
	],
	[
		[
			120771,
			120771
		],
		"mapped",
		[
			8706
		]
	],
	[
		[
			120772,
			120772
		],
		"mapped",
		[
			949
		]
	],
	[
		[
			120773,
			120773
		],
		"mapped",
		[
			952
		]
	],
	[
		[
			120774,
			120774
		],
		"mapped",
		[
			954
		]
	],
	[
		[
			120775,
			120775
		],
		"mapped",
		[
			966
		]
	],
	[
		[
			120776,
			120776
		],
		"mapped",
		[
			961
		]
	],
	[
		[
			120777,
			120777
		],
		"mapped",
		[
			960
		]
	],
	[
		[
			120778,
			120779
		],
		"mapped",
		[
			989
		]
	],
	[
		[
			120780,
			120781
		],
		"disallowed"
	],
	[
		[
			120782,
			120782
		],
		"mapped",
		[
			48
		]
	],
	[
		[
			120783,
			120783
		],
		"mapped",
		[
			49
		]
	],
	[
		[
			120784,
			120784
		],
		"mapped",
		[
			50
		]
	],
	[
		[
			120785,
			120785
		],
		"mapped",
		[
			51
		]
	],
	[
		[
			120786,
			120786
		],
		"mapped",
		[
			52
		]
	],
	[
		[
			120787,
			120787
		],
		"mapped",
		[
			53
		]
	],
	[
		[
			120788,
			120788
		],
		"mapped",
		[
			54
		]
	],
	[
		[
			120789,
			120789
		],
		"mapped",
		[
			55
		]
	],
	[
		[
			120790,
			120790
		],
		"mapped",
		[
			56
		]
	],
	[
		[
			120791,
			120791
		],
		"mapped",
		[
			57
		]
	],
	[
		[
			120792,
			120792
		],
		"mapped",
		[
			48
		]
	],
	[
		[
			120793,
			120793
		],
		"mapped",
		[
			49
		]
	],
	[
		[
			120794,
			120794
		],
		"mapped",
		[
			50
		]
	],
	[
		[
			120795,
			120795
		],
		"mapped",
		[
			51
		]
	],
	[
		[
			120796,
			120796
		],
		"mapped",
		[
			52
		]
	],
	[
		[
			120797,
			120797
		],
		"mapped",
		[
			53
		]
	],
	[
		[
			120798,
			120798
		],
		"mapped",
		[
			54
		]
	],
	[
		[
			120799,
			120799
		],
		"mapped",
		[
			55
		]
	],
	[
		[
			120800,
			120800
		],
		"mapped",
		[
			56
		]
	],
	[
		[
			120801,
			120801
		],
		"mapped",
		[
			57
		]
	],
	[
		[
			120802,
			120802
		],
		"mapped",
		[
			48
		]
	],
	[
		[
			120803,
			120803
		],
		"mapped",
		[
			49
		]
	],
	[
		[
			120804,
			120804
		],
		"mapped",
		[
			50
		]
	],
	[
		[
			120805,
			120805
		],
		"mapped",
		[
			51
		]
	],
	[
		[
			120806,
			120806
		],
		"mapped",
		[
			52
		]
	],
	[
		[
			120807,
			120807
		],
		"mapped",
		[
			53
		]
	],
	[
		[
			120808,
			120808
		],
		"mapped",
		[
			54
		]
	],
	[
		[
			120809,
			120809
		],
		"mapped",
		[
			55
		]
	],
	[
		[
			120810,
			120810
		],
		"mapped",
		[
			56
		]
	],
	[
		[
			120811,
			120811
		],
		"mapped",
		[
			57
		]
	],
	[
		[
			120812,
			120812
		],
		"mapped",
		[
			48
		]
	],
	[
		[
			120813,
			120813
		],
		"mapped",
		[
			49
		]
	],
	[
		[
			120814,
			120814
		],
		"mapped",
		[
			50
		]
	],
	[
		[
			120815,
			120815
		],
		"mapped",
		[
			51
		]
	],
	[
		[
			120816,
			120816
		],
		"mapped",
		[
			52
		]
	],
	[
		[
			120817,
			120817
		],
		"mapped",
		[
			53
		]
	],
	[
		[
			120818,
			120818
		],
		"mapped",
		[
			54
		]
	],
	[
		[
			120819,
			120819
		],
		"mapped",
		[
			55
		]
	],
	[
		[
			120820,
			120820
		],
		"mapped",
		[
			56
		]
	],
	[
		[
			120821,
			120821
		],
		"mapped",
		[
			57
		]
	],
	[
		[
			120822,
			120822
		],
		"mapped",
		[
			48
		]
	],
	[
		[
			120823,
			120823
		],
		"mapped",
		[
			49
		]
	],
	[
		[
			120824,
			120824
		],
		"mapped",
		[
			50
		]
	],
	[
		[
			120825,
			120825
		],
		"mapped",
		[
			51
		]
	],
	[
		[
			120826,
			120826
		],
		"mapped",
		[
			52
		]
	],
	[
		[
			120827,
			120827
		],
		"mapped",
		[
			53
		]
	],
	[
		[
			120828,
			120828
		],
		"mapped",
		[
			54
		]
	],
	[
		[
			120829,
			120829
		],
		"mapped",
		[
			55
		]
	],
	[
		[
			120830,
			120830
		],
		"mapped",
		[
			56
		]
	],
	[
		[
			120831,
			120831
		],
		"mapped",
		[
			57
		]
	],
	[
		[
			120832,
			121343
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			121344,
			121398
		],
		"valid"
	],
	[
		[
			121399,
			121402
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			121403,
			121452
		],
		"valid"
	],
	[
		[
			121453,
			121460
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			121461,
			121461
		],
		"valid"
	],
	[
		[
			121462,
			121475
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			121476,
			121476
		],
		"valid"
	],
	[
		[
			121477,
			121483
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			121484,
			121498
		],
		"disallowed"
	],
	[
		[
			121499,
			121503
		],
		"valid"
	],
	[
		[
			121504,
			121504
		],
		"disallowed"
	],
	[
		[
			121505,
			121519
		],
		"valid"
	],
	[
		[
			121520,
			124927
		],
		"disallowed"
	],
	[
		[
			124928,
			125124
		],
		"valid"
	],
	[
		[
			125125,
			125126
		],
		"disallowed"
	],
	[
		[
			125127,
			125135
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			125136,
			125142
		],
		"valid"
	],
	[
		[
			125143,
			126463
		],
		"disallowed"
	],
	[
		[
			126464,
			126464
		],
		"mapped",
		[
			1575
		]
	],
	[
		[
			126465,
			126465
		],
		"mapped",
		[
			1576
		]
	],
	[
		[
			126466,
			126466
		],
		"mapped",
		[
			1580
		]
	],
	[
		[
			126467,
			126467
		],
		"mapped",
		[
			1583
		]
	],
	[
		[
			126468,
			126468
		],
		"disallowed"
	],
	[
		[
			126469,
			126469
		],
		"mapped",
		[
			1608
		]
	],
	[
		[
			126470,
			126470
		],
		"mapped",
		[
			1586
		]
	],
	[
		[
			126471,
			126471
		],
		"mapped",
		[
			1581
		]
	],
	[
		[
			126472,
			126472
		],
		"mapped",
		[
			1591
		]
	],
	[
		[
			126473,
			126473
		],
		"mapped",
		[
			1610
		]
	],
	[
		[
			126474,
			126474
		],
		"mapped",
		[
			1603
		]
	],
	[
		[
			126475,
			126475
		],
		"mapped",
		[
			1604
		]
	],
	[
		[
			126476,
			126476
		],
		"mapped",
		[
			1605
		]
	],
	[
		[
			126477,
			126477
		],
		"mapped",
		[
			1606
		]
	],
	[
		[
			126478,
			126478
		],
		"mapped",
		[
			1587
		]
	],
	[
		[
			126479,
			126479
		],
		"mapped",
		[
			1593
		]
	],
	[
		[
			126480,
			126480
		],
		"mapped",
		[
			1601
		]
	],
	[
		[
			126481,
			126481
		],
		"mapped",
		[
			1589
		]
	],
	[
		[
			126482,
			126482
		],
		"mapped",
		[
			1602
		]
	],
	[
		[
			126483,
			126483
		],
		"mapped",
		[
			1585
		]
	],
	[
		[
			126484,
			126484
		],
		"mapped",
		[
			1588
		]
	],
	[
		[
			126485,
			126485
		],
		"mapped",
		[
			1578
		]
	],
	[
		[
			126486,
			126486
		],
		"mapped",
		[
			1579
		]
	],
	[
		[
			126487,
			126487
		],
		"mapped",
		[
			1582
		]
	],
	[
		[
			126488,
			126488
		],
		"mapped",
		[
			1584
		]
	],
	[
		[
			126489,
			126489
		],
		"mapped",
		[
			1590
		]
	],
	[
		[
			126490,
			126490
		],
		"mapped",
		[
			1592
		]
	],
	[
		[
			126491,
			126491
		],
		"mapped",
		[
			1594
		]
	],
	[
		[
			126492,
			126492
		],
		"mapped",
		[
			1646
		]
	],
	[
		[
			126493,
			126493
		],
		"mapped",
		[
			1722
		]
	],
	[
		[
			126494,
			126494
		],
		"mapped",
		[
			1697
		]
	],
	[
		[
			126495,
			126495
		],
		"mapped",
		[
			1647
		]
	],
	[
		[
			126496,
			126496
		],
		"disallowed"
	],
	[
		[
			126497,
			126497
		],
		"mapped",
		[
			1576
		]
	],
	[
		[
			126498,
			126498
		],
		"mapped",
		[
			1580
		]
	],
	[
		[
			126499,
			126499
		],
		"disallowed"
	],
	[
		[
			126500,
			126500
		],
		"mapped",
		[
			1607
		]
	],
	[
		[
			126501,
			126502
		],
		"disallowed"
	],
	[
		[
			126503,
			126503
		],
		"mapped",
		[
			1581
		]
	],
	[
		[
			126504,
			126504
		],
		"disallowed"
	],
	[
		[
			126505,
			126505
		],
		"mapped",
		[
			1610
		]
	],
	[
		[
			126506,
			126506
		],
		"mapped",
		[
			1603
		]
	],
	[
		[
			126507,
			126507
		],
		"mapped",
		[
			1604
		]
	],
	[
		[
			126508,
			126508
		],
		"mapped",
		[
			1605
		]
	],
	[
		[
			126509,
			126509
		],
		"mapped",
		[
			1606
		]
	],
	[
		[
			126510,
			126510
		],
		"mapped",
		[
			1587
		]
	],
	[
		[
			126511,
			126511
		],
		"mapped",
		[
			1593
		]
	],
	[
		[
			126512,
			126512
		],
		"mapped",
		[
			1601
		]
	],
	[
		[
			126513,
			126513
		],
		"mapped",
		[
			1589
		]
	],
	[
		[
			126514,
			126514
		],
		"mapped",
		[
			1602
		]
	],
	[
		[
			126515,
			126515
		],
		"disallowed"
	],
	[
		[
			126516,
			126516
		],
		"mapped",
		[
			1588
		]
	],
	[
		[
			126517,
			126517
		],
		"mapped",
		[
			1578
		]
	],
	[
		[
			126518,
			126518
		],
		"mapped",
		[
			1579
		]
	],
	[
		[
			126519,
			126519
		],
		"mapped",
		[
			1582
		]
	],
	[
		[
			126520,
			126520
		],
		"disallowed"
	],
	[
		[
			126521,
			126521
		],
		"mapped",
		[
			1590
		]
	],
	[
		[
			126522,
			126522
		],
		"disallowed"
	],
	[
		[
			126523,
			126523
		],
		"mapped",
		[
			1594
		]
	],
	[
		[
			126524,
			126529
		],
		"disallowed"
	],
	[
		[
			126530,
			126530
		],
		"mapped",
		[
			1580
		]
	],
	[
		[
			126531,
			126534
		],
		"disallowed"
	],
	[
		[
			126535,
			126535
		],
		"mapped",
		[
			1581
		]
	],
	[
		[
			126536,
			126536
		],
		"disallowed"
	],
	[
		[
			126537,
			126537
		],
		"mapped",
		[
			1610
		]
	],
	[
		[
			126538,
			126538
		],
		"disallowed"
	],
	[
		[
			126539,
			126539
		],
		"mapped",
		[
			1604
		]
	],
	[
		[
			126540,
			126540
		],
		"disallowed"
	],
	[
		[
			126541,
			126541
		],
		"mapped",
		[
			1606
		]
	],
	[
		[
			126542,
			126542
		],
		"mapped",
		[
			1587
		]
	],
	[
		[
			126543,
			126543
		],
		"mapped",
		[
			1593
		]
	],
	[
		[
			126544,
			126544
		],
		"disallowed"
	],
	[
		[
			126545,
			126545
		],
		"mapped",
		[
			1589
		]
	],
	[
		[
			126546,
			126546
		],
		"mapped",
		[
			1602
		]
	],
	[
		[
			126547,
			126547
		],
		"disallowed"
	],
	[
		[
			126548,
			126548
		],
		"mapped",
		[
			1588
		]
	],
	[
		[
			126549,
			126550
		],
		"disallowed"
	],
	[
		[
			126551,
			126551
		],
		"mapped",
		[
			1582
		]
	],
	[
		[
			126552,
			126552
		],
		"disallowed"
	],
	[
		[
			126553,
			126553
		],
		"mapped",
		[
			1590
		]
	],
	[
		[
			126554,
			126554
		],
		"disallowed"
	],
	[
		[
			126555,
			126555
		],
		"mapped",
		[
			1594
		]
	],
	[
		[
			126556,
			126556
		],
		"disallowed"
	],
	[
		[
			126557,
			126557
		],
		"mapped",
		[
			1722
		]
	],
	[
		[
			126558,
			126558
		],
		"disallowed"
	],
	[
		[
			126559,
			126559
		],
		"mapped",
		[
			1647
		]
	],
	[
		[
			126560,
			126560
		],
		"disallowed"
	],
	[
		[
			126561,
			126561
		],
		"mapped",
		[
			1576
		]
	],
	[
		[
			126562,
			126562
		],
		"mapped",
		[
			1580
		]
	],
	[
		[
			126563,
			126563
		],
		"disallowed"
	],
	[
		[
			126564,
			126564
		],
		"mapped",
		[
			1607
		]
	],
	[
		[
			126565,
			126566
		],
		"disallowed"
	],
	[
		[
			126567,
			126567
		],
		"mapped",
		[
			1581
		]
	],
	[
		[
			126568,
			126568
		],
		"mapped",
		[
			1591
		]
	],
	[
		[
			126569,
			126569
		],
		"mapped",
		[
			1610
		]
	],
	[
		[
			126570,
			126570
		],
		"mapped",
		[
			1603
		]
	],
	[
		[
			126571,
			126571
		],
		"disallowed"
	],
	[
		[
			126572,
			126572
		],
		"mapped",
		[
			1605
		]
	],
	[
		[
			126573,
			126573
		],
		"mapped",
		[
			1606
		]
	],
	[
		[
			126574,
			126574
		],
		"mapped",
		[
			1587
		]
	],
	[
		[
			126575,
			126575
		],
		"mapped",
		[
			1593
		]
	],
	[
		[
			126576,
			126576
		],
		"mapped",
		[
			1601
		]
	],
	[
		[
			126577,
			126577
		],
		"mapped",
		[
			1589
		]
	],
	[
		[
			126578,
			126578
		],
		"mapped",
		[
			1602
		]
	],
	[
		[
			126579,
			126579
		],
		"disallowed"
	],
	[
		[
			126580,
			126580
		],
		"mapped",
		[
			1588
		]
	],
	[
		[
			126581,
			126581
		],
		"mapped",
		[
			1578
		]
	],
	[
		[
			126582,
			126582
		],
		"mapped",
		[
			1579
		]
	],
	[
		[
			126583,
			126583
		],
		"mapped",
		[
			1582
		]
	],
	[
		[
			126584,
			126584
		],
		"disallowed"
	],
	[
		[
			126585,
			126585
		],
		"mapped",
		[
			1590
		]
	],
	[
		[
			126586,
			126586
		],
		"mapped",
		[
			1592
		]
	],
	[
		[
			126587,
			126587
		],
		"mapped",
		[
			1594
		]
	],
	[
		[
			126588,
			126588
		],
		"mapped",
		[
			1646
		]
	],
	[
		[
			126589,
			126589
		],
		"disallowed"
	],
	[
		[
			126590,
			126590
		],
		"mapped",
		[
			1697
		]
	],
	[
		[
			126591,
			126591
		],
		"disallowed"
	],
	[
		[
			126592,
			126592
		],
		"mapped",
		[
			1575
		]
	],
	[
		[
			126593,
			126593
		],
		"mapped",
		[
			1576
		]
	],
	[
		[
			126594,
			126594
		],
		"mapped",
		[
			1580
		]
	],
	[
		[
			126595,
			126595
		],
		"mapped",
		[
			1583
		]
	],
	[
		[
			126596,
			126596
		],
		"mapped",
		[
			1607
		]
	],
	[
		[
			126597,
			126597
		],
		"mapped",
		[
			1608
		]
	],
	[
		[
			126598,
			126598
		],
		"mapped",
		[
			1586
		]
	],
	[
		[
			126599,
			126599
		],
		"mapped",
		[
			1581
		]
	],
	[
		[
			126600,
			126600
		],
		"mapped",
		[
			1591
		]
	],
	[
		[
			126601,
			126601
		],
		"mapped",
		[
			1610
		]
	],
	[
		[
			126602,
			126602
		],
		"disallowed"
	],
	[
		[
			126603,
			126603
		],
		"mapped",
		[
			1604
		]
	],
	[
		[
			126604,
			126604
		],
		"mapped",
		[
			1605
		]
	],
	[
		[
			126605,
			126605
		],
		"mapped",
		[
			1606
		]
	],
	[
		[
			126606,
			126606
		],
		"mapped",
		[
			1587
		]
	],
	[
		[
			126607,
			126607
		],
		"mapped",
		[
			1593
		]
	],
	[
		[
			126608,
			126608
		],
		"mapped",
		[
			1601
		]
	],
	[
		[
			126609,
			126609
		],
		"mapped",
		[
			1589
		]
	],
	[
		[
			126610,
			126610
		],
		"mapped",
		[
			1602
		]
	],
	[
		[
			126611,
			126611
		],
		"mapped",
		[
			1585
		]
	],
	[
		[
			126612,
			126612
		],
		"mapped",
		[
			1588
		]
	],
	[
		[
			126613,
			126613
		],
		"mapped",
		[
			1578
		]
	],
	[
		[
			126614,
			126614
		],
		"mapped",
		[
			1579
		]
	],
	[
		[
			126615,
			126615
		],
		"mapped",
		[
			1582
		]
	],
	[
		[
			126616,
			126616
		],
		"mapped",
		[
			1584
		]
	],
	[
		[
			126617,
			126617
		],
		"mapped",
		[
			1590
		]
	],
	[
		[
			126618,
			126618
		],
		"mapped",
		[
			1592
		]
	],
	[
		[
			126619,
			126619
		],
		"mapped",
		[
			1594
		]
	],
	[
		[
			126620,
			126624
		],
		"disallowed"
	],
	[
		[
			126625,
			126625
		],
		"mapped",
		[
			1576
		]
	],
	[
		[
			126626,
			126626
		],
		"mapped",
		[
			1580
		]
	],
	[
		[
			126627,
			126627
		],
		"mapped",
		[
			1583
		]
	],
	[
		[
			126628,
			126628
		],
		"disallowed"
	],
	[
		[
			126629,
			126629
		],
		"mapped",
		[
			1608
		]
	],
	[
		[
			126630,
			126630
		],
		"mapped",
		[
			1586
		]
	],
	[
		[
			126631,
			126631
		],
		"mapped",
		[
			1581
		]
	],
	[
		[
			126632,
			126632
		],
		"mapped",
		[
			1591
		]
	],
	[
		[
			126633,
			126633
		],
		"mapped",
		[
			1610
		]
	],
	[
		[
			126634,
			126634
		],
		"disallowed"
	],
	[
		[
			126635,
			126635
		],
		"mapped",
		[
			1604
		]
	],
	[
		[
			126636,
			126636
		],
		"mapped",
		[
			1605
		]
	],
	[
		[
			126637,
			126637
		],
		"mapped",
		[
			1606
		]
	],
	[
		[
			126638,
			126638
		],
		"mapped",
		[
			1587
		]
	],
	[
		[
			126639,
			126639
		],
		"mapped",
		[
			1593
		]
	],
	[
		[
			126640,
			126640
		],
		"mapped",
		[
			1601
		]
	],
	[
		[
			126641,
			126641
		],
		"mapped",
		[
			1589
		]
	],
	[
		[
			126642,
			126642
		],
		"mapped",
		[
			1602
		]
	],
	[
		[
			126643,
			126643
		],
		"mapped",
		[
			1585
		]
	],
	[
		[
			126644,
			126644
		],
		"mapped",
		[
			1588
		]
	],
	[
		[
			126645,
			126645
		],
		"mapped",
		[
			1578
		]
	],
	[
		[
			126646,
			126646
		],
		"mapped",
		[
			1579
		]
	],
	[
		[
			126647,
			126647
		],
		"mapped",
		[
			1582
		]
	],
	[
		[
			126648,
			126648
		],
		"mapped",
		[
			1584
		]
	],
	[
		[
			126649,
			126649
		],
		"mapped",
		[
			1590
		]
	],
	[
		[
			126650,
			126650
		],
		"mapped",
		[
			1592
		]
	],
	[
		[
			126651,
			126651
		],
		"mapped",
		[
			1594
		]
	],
	[
		[
			126652,
			126703
		],
		"disallowed"
	],
	[
		[
			126704,
			126705
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			126706,
			126975
		],
		"disallowed"
	],
	[
		[
			126976,
			127019
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127020,
			127023
		],
		"disallowed"
	],
	[
		[
			127024,
			127123
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127124,
			127135
		],
		"disallowed"
	],
	[
		[
			127136,
			127150
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127151,
			127152
		],
		"disallowed"
	],
	[
		[
			127153,
			127166
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127167,
			127167
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127168,
			127168
		],
		"disallowed"
	],
	[
		[
			127169,
			127183
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127184,
			127184
		],
		"disallowed"
	],
	[
		[
			127185,
			127199
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127200,
			127221
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127222,
			127231
		],
		"disallowed"
	],
	[
		[
			127232,
			127232
		],
		"disallowed"
	],
	[
		[
			127233,
			127233
		],
		"disallowed_STD3_mapped",
		[
			48,
			44
		]
	],
	[
		[
			127234,
			127234
		],
		"disallowed_STD3_mapped",
		[
			49,
			44
		]
	],
	[
		[
			127235,
			127235
		],
		"disallowed_STD3_mapped",
		[
			50,
			44
		]
	],
	[
		[
			127236,
			127236
		],
		"disallowed_STD3_mapped",
		[
			51,
			44
		]
	],
	[
		[
			127237,
			127237
		],
		"disallowed_STD3_mapped",
		[
			52,
			44
		]
	],
	[
		[
			127238,
			127238
		],
		"disallowed_STD3_mapped",
		[
			53,
			44
		]
	],
	[
		[
			127239,
			127239
		],
		"disallowed_STD3_mapped",
		[
			54,
			44
		]
	],
	[
		[
			127240,
			127240
		],
		"disallowed_STD3_mapped",
		[
			55,
			44
		]
	],
	[
		[
			127241,
			127241
		],
		"disallowed_STD3_mapped",
		[
			56,
			44
		]
	],
	[
		[
			127242,
			127242
		],
		"disallowed_STD3_mapped",
		[
			57,
			44
		]
	],
	[
		[
			127243,
			127244
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127245,
			127247
		],
		"disallowed"
	],
	[
		[
			127248,
			127248
		],
		"disallowed_STD3_mapped",
		[
			40,
			97,
			41
		]
	],
	[
		[
			127249,
			127249
		],
		"disallowed_STD3_mapped",
		[
			40,
			98,
			41
		]
	],
	[
		[
			127250,
			127250
		],
		"disallowed_STD3_mapped",
		[
			40,
			99,
			41
		]
	],
	[
		[
			127251,
			127251
		],
		"disallowed_STD3_mapped",
		[
			40,
			100,
			41
		]
	],
	[
		[
			127252,
			127252
		],
		"disallowed_STD3_mapped",
		[
			40,
			101,
			41
		]
	],
	[
		[
			127253,
			127253
		],
		"disallowed_STD3_mapped",
		[
			40,
			102,
			41
		]
	],
	[
		[
			127254,
			127254
		],
		"disallowed_STD3_mapped",
		[
			40,
			103,
			41
		]
	],
	[
		[
			127255,
			127255
		],
		"disallowed_STD3_mapped",
		[
			40,
			104,
			41
		]
	],
	[
		[
			127256,
			127256
		],
		"disallowed_STD3_mapped",
		[
			40,
			105,
			41
		]
	],
	[
		[
			127257,
			127257
		],
		"disallowed_STD3_mapped",
		[
			40,
			106,
			41
		]
	],
	[
		[
			127258,
			127258
		],
		"disallowed_STD3_mapped",
		[
			40,
			107,
			41
		]
	],
	[
		[
			127259,
			127259
		],
		"disallowed_STD3_mapped",
		[
			40,
			108,
			41
		]
	],
	[
		[
			127260,
			127260
		],
		"disallowed_STD3_mapped",
		[
			40,
			109,
			41
		]
	],
	[
		[
			127261,
			127261
		],
		"disallowed_STD3_mapped",
		[
			40,
			110,
			41
		]
	],
	[
		[
			127262,
			127262
		],
		"disallowed_STD3_mapped",
		[
			40,
			111,
			41
		]
	],
	[
		[
			127263,
			127263
		],
		"disallowed_STD3_mapped",
		[
			40,
			112,
			41
		]
	],
	[
		[
			127264,
			127264
		],
		"disallowed_STD3_mapped",
		[
			40,
			113,
			41
		]
	],
	[
		[
			127265,
			127265
		],
		"disallowed_STD3_mapped",
		[
			40,
			114,
			41
		]
	],
	[
		[
			127266,
			127266
		],
		"disallowed_STD3_mapped",
		[
			40,
			115,
			41
		]
	],
	[
		[
			127267,
			127267
		],
		"disallowed_STD3_mapped",
		[
			40,
			116,
			41
		]
	],
	[
		[
			127268,
			127268
		],
		"disallowed_STD3_mapped",
		[
			40,
			117,
			41
		]
	],
	[
		[
			127269,
			127269
		],
		"disallowed_STD3_mapped",
		[
			40,
			118,
			41
		]
	],
	[
		[
			127270,
			127270
		],
		"disallowed_STD3_mapped",
		[
			40,
			119,
			41
		]
	],
	[
		[
			127271,
			127271
		],
		"disallowed_STD3_mapped",
		[
			40,
			120,
			41
		]
	],
	[
		[
			127272,
			127272
		],
		"disallowed_STD3_mapped",
		[
			40,
			121,
			41
		]
	],
	[
		[
			127273,
			127273
		],
		"disallowed_STD3_mapped",
		[
			40,
			122,
			41
		]
	],
	[
		[
			127274,
			127274
		],
		"mapped",
		[
			12308,
			115,
			12309
		]
	],
	[
		[
			127275,
			127275
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			127276,
			127276
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			127277,
			127277
		],
		"mapped",
		[
			99,
			100
		]
	],
	[
		[
			127278,
			127278
		],
		"mapped",
		[
			119,
			122
		]
	],
	[
		[
			127279,
			127279
		],
		"disallowed"
	],
	[
		[
			127280,
			127280
		],
		"mapped",
		[
			97
		]
	],
	[
		[
			127281,
			127281
		],
		"mapped",
		[
			98
		]
	],
	[
		[
			127282,
			127282
		],
		"mapped",
		[
			99
		]
	],
	[
		[
			127283,
			127283
		],
		"mapped",
		[
			100
		]
	],
	[
		[
			127284,
			127284
		],
		"mapped",
		[
			101
		]
	],
	[
		[
			127285,
			127285
		],
		"mapped",
		[
			102
		]
	],
	[
		[
			127286,
			127286
		],
		"mapped",
		[
			103
		]
	],
	[
		[
			127287,
			127287
		],
		"mapped",
		[
			104
		]
	],
	[
		[
			127288,
			127288
		],
		"mapped",
		[
			105
		]
	],
	[
		[
			127289,
			127289
		],
		"mapped",
		[
			106
		]
	],
	[
		[
			127290,
			127290
		],
		"mapped",
		[
			107
		]
	],
	[
		[
			127291,
			127291
		],
		"mapped",
		[
			108
		]
	],
	[
		[
			127292,
			127292
		],
		"mapped",
		[
			109
		]
	],
	[
		[
			127293,
			127293
		],
		"mapped",
		[
			110
		]
	],
	[
		[
			127294,
			127294
		],
		"mapped",
		[
			111
		]
	],
	[
		[
			127295,
			127295
		],
		"mapped",
		[
			112
		]
	],
	[
		[
			127296,
			127296
		],
		"mapped",
		[
			113
		]
	],
	[
		[
			127297,
			127297
		],
		"mapped",
		[
			114
		]
	],
	[
		[
			127298,
			127298
		],
		"mapped",
		[
			115
		]
	],
	[
		[
			127299,
			127299
		],
		"mapped",
		[
			116
		]
	],
	[
		[
			127300,
			127300
		],
		"mapped",
		[
			117
		]
	],
	[
		[
			127301,
			127301
		],
		"mapped",
		[
			118
		]
	],
	[
		[
			127302,
			127302
		],
		"mapped",
		[
			119
		]
	],
	[
		[
			127303,
			127303
		],
		"mapped",
		[
			120
		]
	],
	[
		[
			127304,
			127304
		],
		"mapped",
		[
			121
		]
	],
	[
		[
			127305,
			127305
		],
		"mapped",
		[
			122
		]
	],
	[
		[
			127306,
			127306
		],
		"mapped",
		[
			104,
			118
		]
	],
	[
		[
			127307,
			127307
		],
		"mapped",
		[
			109,
			118
		]
	],
	[
		[
			127308,
			127308
		],
		"mapped",
		[
			115,
			100
		]
	],
	[
		[
			127309,
			127309
		],
		"mapped",
		[
			115,
			115
		]
	],
	[
		[
			127310,
			127310
		],
		"mapped",
		[
			112,
			112,
			118
		]
	],
	[
		[
			127311,
			127311
		],
		"mapped",
		[
			119,
			99
		]
	],
	[
		[
			127312,
			127318
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127319,
			127319
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127320,
			127326
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127327,
			127327
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127328,
			127337
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127338,
			127338
		],
		"mapped",
		[
			109,
			99
		]
	],
	[
		[
			127339,
			127339
		],
		"mapped",
		[
			109,
			100
		]
	],
	[
		[
			127340,
			127343
		],
		"disallowed"
	],
	[
		[
			127344,
			127352
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127353,
			127353
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127354,
			127354
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127355,
			127356
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127357,
			127358
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127359,
			127359
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127360,
			127369
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127370,
			127373
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127374,
			127375
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127376,
			127376
		],
		"mapped",
		[
			100,
			106
		]
	],
	[
		[
			127377,
			127386
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127387,
			127461
		],
		"disallowed"
	],
	[
		[
			127462,
			127487
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127488,
			127488
		],
		"mapped",
		[
			12411,
			12363
		]
	],
	[
		[
			127489,
			127489
		],
		"mapped",
		[
			12467,
			12467
		]
	],
	[
		[
			127490,
			127490
		],
		"mapped",
		[
			12469
		]
	],
	[
		[
			127491,
			127503
		],
		"disallowed"
	],
	[
		[
			127504,
			127504
		],
		"mapped",
		[
			25163
		]
	],
	[
		[
			127505,
			127505
		],
		"mapped",
		[
			23383
		]
	],
	[
		[
			127506,
			127506
		],
		"mapped",
		[
			21452
		]
	],
	[
		[
			127507,
			127507
		],
		"mapped",
		[
			12487
		]
	],
	[
		[
			127508,
			127508
		],
		"mapped",
		[
			20108
		]
	],
	[
		[
			127509,
			127509
		],
		"mapped",
		[
			22810
		]
	],
	[
		[
			127510,
			127510
		],
		"mapped",
		[
			35299
		]
	],
	[
		[
			127511,
			127511
		],
		"mapped",
		[
			22825
		]
	],
	[
		[
			127512,
			127512
		],
		"mapped",
		[
			20132
		]
	],
	[
		[
			127513,
			127513
		],
		"mapped",
		[
			26144
		]
	],
	[
		[
			127514,
			127514
		],
		"mapped",
		[
			28961
		]
	],
	[
		[
			127515,
			127515
		],
		"mapped",
		[
			26009
		]
	],
	[
		[
			127516,
			127516
		],
		"mapped",
		[
			21069
		]
	],
	[
		[
			127517,
			127517
		],
		"mapped",
		[
			24460
		]
	],
	[
		[
			127518,
			127518
		],
		"mapped",
		[
			20877
		]
	],
	[
		[
			127519,
			127519
		],
		"mapped",
		[
			26032
		]
	],
	[
		[
			127520,
			127520
		],
		"mapped",
		[
			21021
		]
	],
	[
		[
			127521,
			127521
		],
		"mapped",
		[
			32066
		]
	],
	[
		[
			127522,
			127522
		],
		"mapped",
		[
			29983
		]
	],
	[
		[
			127523,
			127523
		],
		"mapped",
		[
			36009
		]
	],
	[
		[
			127524,
			127524
		],
		"mapped",
		[
			22768
		]
	],
	[
		[
			127525,
			127525
		],
		"mapped",
		[
			21561
		]
	],
	[
		[
			127526,
			127526
		],
		"mapped",
		[
			28436
		]
	],
	[
		[
			127527,
			127527
		],
		"mapped",
		[
			25237
		]
	],
	[
		[
			127528,
			127528
		],
		"mapped",
		[
			25429
		]
	],
	[
		[
			127529,
			127529
		],
		"mapped",
		[
			19968
		]
	],
	[
		[
			127530,
			127530
		],
		"mapped",
		[
			19977
		]
	],
	[
		[
			127531,
			127531
		],
		"mapped",
		[
			36938
		]
	],
	[
		[
			127532,
			127532
		],
		"mapped",
		[
			24038
		]
	],
	[
		[
			127533,
			127533
		],
		"mapped",
		[
			20013
		]
	],
	[
		[
			127534,
			127534
		],
		"mapped",
		[
			21491
		]
	],
	[
		[
			127535,
			127535
		],
		"mapped",
		[
			25351
		]
	],
	[
		[
			127536,
			127536
		],
		"mapped",
		[
			36208
		]
	],
	[
		[
			127537,
			127537
		],
		"mapped",
		[
			25171
		]
	],
	[
		[
			127538,
			127538
		],
		"mapped",
		[
			31105
		]
	],
	[
		[
			127539,
			127539
		],
		"mapped",
		[
			31354
		]
	],
	[
		[
			127540,
			127540
		],
		"mapped",
		[
			21512
		]
	],
	[
		[
			127541,
			127541
		],
		"mapped",
		[
			28288
		]
	],
	[
		[
			127542,
			127542
		],
		"mapped",
		[
			26377
		]
	],
	[
		[
			127543,
			127543
		],
		"mapped",
		[
			26376
		]
	],
	[
		[
			127544,
			127544
		],
		"mapped",
		[
			30003
		]
	],
	[
		[
			127545,
			127545
		],
		"mapped",
		[
			21106
		]
	],
	[
		[
			127546,
			127546
		],
		"mapped",
		[
			21942
		]
	],
	[
		[
			127547,
			127551
		],
		"disallowed"
	],
	[
		[
			127552,
			127552
		],
		"mapped",
		[
			12308,
			26412,
			12309
		]
	],
	[
		[
			127553,
			127553
		],
		"mapped",
		[
			12308,
			19977,
			12309
		]
	],
	[
		[
			127554,
			127554
		],
		"mapped",
		[
			12308,
			20108,
			12309
		]
	],
	[
		[
			127555,
			127555
		],
		"mapped",
		[
			12308,
			23433,
			12309
		]
	],
	[
		[
			127556,
			127556
		],
		"mapped",
		[
			12308,
			28857,
			12309
		]
	],
	[
		[
			127557,
			127557
		],
		"mapped",
		[
			12308,
			25171,
			12309
		]
	],
	[
		[
			127558,
			127558
		],
		"mapped",
		[
			12308,
			30423,
			12309
		]
	],
	[
		[
			127559,
			127559
		],
		"mapped",
		[
			12308,
			21213,
			12309
		]
	],
	[
		[
			127560,
			127560
		],
		"mapped",
		[
			12308,
			25943,
			12309
		]
	],
	[
		[
			127561,
			127567
		],
		"disallowed"
	],
	[
		[
			127568,
			127568
		],
		"mapped",
		[
			24471
		]
	],
	[
		[
			127569,
			127569
		],
		"mapped",
		[
			21487
		]
	],
	[
		[
			127570,
			127743
		],
		"disallowed"
	],
	[
		[
			127744,
			127776
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127777,
			127788
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127789,
			127791
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127792,
			127797
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127798,
			127798
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127799,
			127868
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127869,
			127869
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127870,
			127871
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127872,
			127891
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127892,
			127903
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127904,
			127940
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127941,
			127941
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127942,
			127946
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127947,
			127950
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127951,
			127955
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127956,
			127967
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127968,
			127984
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127985,
			127991
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			127992,
			127999
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128000,
			128062
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128063,
			128063
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128064,
			128064
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128065,
			128065
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128066,
			128247
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128248,
			128248
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128249,
			128252
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128253,
			128254
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128255,
			128255
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128256,
			128317
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128318,
			128319
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128320,
			128323
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128324,
			128330
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128331,
			128335
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128336,
			128359
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128360,
			128377
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128378,
			128378
		],
		"disallowed"
	],
	[
		[
			128379,
			128419
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128420,
			128420
		],
		"disallowed"
	],
	[
		[
			128421,
			128506
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128507,
			128511
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128512,
			128512
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128513,
			128528
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128529,
			128529
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128530,
			128532
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128533,
			128533
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128534,
			128534
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128535,
			128535
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128536,
			128536
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128537,
			128537
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128538,
			128538
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128539,
			128539
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128540,
			128542
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128543,
			128543
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128544,
			128549
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128550,
			128551
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128552,
			128555
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128556,
			128556
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128557,
			128557
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128558,
			128559
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128560,
			128563
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128564,
			128564
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128565,
			128576
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128577,
			128578
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128579,
			128580
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128581,
			128591
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128592,
			128639
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128640,
			128709
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128710,
			128719
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128720,
			128720
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128721,
			128735
		],
		"disallowed"
	],
	[
		[
			128736,
			128748
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128749,
			128751
		],
		"disallowed"
	],
	[
		[
			128752,
			128755
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128756,
			128767
		],
		"disallowed"
	],
	[
		[
			128768,
			128883
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128884,
			128895
		],
		"disallowed"
	],
	[
		[
			128896,
			128980
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			128981,
			129023
		],
		"disallowed"
	],
	[
		[
			129024,
			129035
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			129036,
			129039
		],
		"disallowed"
	],
	[
		[
			129040,
			129095
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			129096,
			129103
		],
		"disallowed"
	],
	[
		[
			129104,
			129113
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			129114,
			129119
		],
		"disallowed"
	],
	[
		[
			129120,
			129159
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			129160,
			129167
		],
		"disallowed"
	],
	[
		[
			129168,
			129197
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			129198,
			129295
		],
		"disallowed"
	],
	[
		[
			129296,
			129304
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			129305,
			129407
		],
		"disallowed"
	],
	[
		[
			129408,
			129412
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			129413,
			129471
		],
		"disallowed"
	],
	[
		[
			129472,
			129472
		],
		"valid",
		[
		],
		"NV8"
	],
	[
		[
			129473,
			131069
		],
		"disallowed"
	],
	[
		[
			131070,
			131071
		],
		"disallowed"
	],
	[
		[
			131072,
			173782
		],
		"valid"
	],
	[
		[
			173783,
			173823
		],
		"disallowed"
	],
	[
		[
			173824,
			177972
		],
		"valid"
	],
	[
		[
			177973,
			177983
		],
		"disallowed"
	],
	[
		[
			177984,
			178205
		],
		"valid"
	],
	[
		[
			178206,
			178207
		],
		"disallowed"
	],
	[
		[
			178208,
			183969
		],
		"valid"
	],
	[
		[
			183970,
			194559
		],
		"disallowed"
	],
	[
		[
			194560,
			194560
		],
		"mapped",
		[
			20029
		]
	],
	[
		[
			194561,
			194561
		],
		"mapped",
		[
			20024
		]
	],
	[
		[
			194562,
			194562
		],
		"mapped",
		[
			20033
		]
	],
	[
		[
			194563,
			194563
		],
		"mapped",
		[
			131362
		]
	],
	[
		[
			194564,
			194564
		],
		"mapped",
		[
			20320
		]
	],
	[
		[
			194565,
			194565
		],
		"mapped",
		[
			20398
		]
	],
	[
		[
			194566,
			194566
		],
		"mapped",
		[
			20411
		]
	],
	[
		[
			194567,
			194567
		],
		"mapped",
		[
			20482
		]
	],
	[
		[
			194568,
			194568
		],
		"mapped",
		[
			20602
		]
	],
	[
		[
			194569,
			194569
		],
		"mapped",
		[
			20633
		]
	],
	[
		[
			194570,
			194570
		],
		"mapped",
		[
			20711
		]
	],
	[
		[
			194571,
			194571
		],
		"mapped",
		[
			20687
		]
	],
	[
		[
			194572,
			194572
		],
		"mapped",
		[
			13470
		]
	],
	[
		[
			194573,
			194573
		],
		"mapped",
		[
			132666
		]
	],
	[
		[
			194574,
			194574
		],
		"mapped",
		[
			20813
		]
	],
	[
		[
			194575,
			194575
		],
		"mapped",
		[
			20820
		]
	],
	[
		[
			194576,
			194576
		],
		"mapped",
		[
			20836
		]
	],
	[
		[
			194577,
			194577
		],
		"mapped",
		[
			20855
		]
	],
	[
		[
			194578,
			194578
		],
		"mapped",
		[
			132380
		]
	],
	[
		[
			194579,
			194579
		],
		"mapped",
		[
			13497
		]
	],
	[
		[
			194580,
			194580
		],
		"mapped",
		[
			20839
		]
	],
	[
		[
			194581,
			194581
		],
		"mapped",
		[
			20877
		]
	],
	[
		[
			194582,
			194582
		],
		"mapped",
		[
			132427
		]
	],
	[
		[
			194583,
			194583
		],
		"mapped",
		[
			20887
		]
	],
	[
		[
			194584,
			194584
		],
		"mapped",
		[
			20900
		]
	],
	[
		[
			194585,
			194585
		],
		"mapped",
		[
			20172
		]
	],
	[
		[
			194586,
			194586
		],
		"mapped",
		[
			20908
		]
	],
	[
		[
			194587,
			194587
		],
		"mapped",
		[
			20917
		]
	],
	[
		[
			194588,
			194588
		],
		"mapped",
		[
			168415
		]
	],
	[
		[
			194589,
			194589
		],
		"mapped",
		[
			20981
		]
	],
	[
		[
			194590,
			194590
		],
		"mapped",
		[
			20995
		]
	],
	[
		[
			194591,
			194591
		],
		"mapped",
		[
			13535
		]
	],
	[
		[
			194592,
			194592
		],
		"mapped",
		[
			21051
		]
	],
	[
		[
			194593,
			194593
		],
		"mapped",
		[
			21062
		]
	],
	[
		[
			194594,
			194594
		],
		"mapped",
		[
			21106
		]
	],
	[
		[
			194595,
			194595
		],
		"mapped",
		[
			21111
		]
	],
	[
		[
			194596,
			194596
		],
		"mapped",
		[
			13589
		]
	],
	[
		[
			194597,
			194597
		],
		"mapped",
		[
			21191
		]
	],
	[
		[
			194598,
			194598
		],
		"mapped",
		[
			21193
		]
	],
	[
		[
			194599,
			194599
		],
		"mapped",
		[
			21220
		]
	],
	[
		[
			194600,
			194600
		],
		"mapped",
		[
			21242
		]
	],
	[
		[
			194601,
			194601
		],
		"mapped",
		[
			21253
		]
	],
	[
		[
			194602,
			194602
		],
		"mapped",
		[
			21254
		]
	],
	[
		[
			194603,
			194603
		],
		"mapped",
		[
			21271
		]
	],
	[
		[
			194604,
			194604
		],
		"mapped",
		[
			21321
		]
	],
	[
		[
			194605,
			194605
		],
		"mapped",
		[
			21329
		]
	],
	[
		[
			194606,
			194606
		],
		"mapped",
		[
			21338
		]
	],
	[
		[
			194607,
			194607
		],
		"mapped",
		[
			21363
		]
	],
	[
		[
			194608,
			194608
		],
		"mapped",
		[
			21373
		]
	],
	[
		[
			194609,
			194611
		],
		"mapped",
		[
			21375
		]
	],
	[
		[
			194612,
			194612
		],
		"mapped",
		[
			133676
		]
	],
	[
		[
			194613,
			194613
		],
		"mapped",
		[
			28784
		]
	],
	[
		[
			194614,
			194614
		],
		"mapped",
		[
			21450
		]
	],
	[
		[
			194615,
			194615
		],
		"mapped",
		[
			21471
		]
	],
	[
		[
			194616,
			194616
		],
		"mapped",
		[
			133987
		]
	],
	[
		[
			194617,
			194617
		],
		"mapped",
		[
			21483
		]
	],
	[
		[
			194618,
			194618
		],
		"mapped",
		[
			21489
		]
	],
	[
		[
			194619,
			194619
		],
		"mapped",
		[
			21510
		]
	],
	[
		[
			194620,
			194620
		],
		"mapped",
		[
			21662
		]
	],
	[
		[
			194621,
			194621
		],
		"mapped",
		[
			21560
		]
	],
	[
		[
			194622,
			194622
		],
		"mapped",
		[
			21576
		]
	],
	[
		[
			194623,
			194623
		],
		"mapped",
		[
			21608
		]
	],
	[
		[
			194624,
			194624
		],
		"mapped",
		[
			21666
		]
	],
	[
		[
			194625,
			194625
		],
		"mapped",
		[
			21750
		]
	],
	[
		[
			194626,
			194626
		],
		"mapped",
		[
			21776
		]
	],
	[
		[
			194627,
			194627
		],
		"mapped",
		[
			21843
		]
	],
	[
		[
			194628,
			194628
		],
		"mapped",
		[
			21859
		]
	],
	[
		[
			194629,
			194630
		],
		"mapped",
		[
			21892
		]
	],
	[
		[
			194631,
			194631
		],
		"mapped",
		[
			21913
		]
	],
	[
		[
			194632,
			194632
		],
		"mapped",
		[
			21931
		]
	],
	[
		[
			194633,
			194633
		],
		"mapped",
		[
			21939
		]
	],
	[
		[
			194634,
			194634
		],
		"mapped",
		[
			21954
		]
	],
	[
		[
			194635,
			194635
		],
		"mapped",
		[
			22294
		]
	],
	[
		[
			194636,
			194636
		],
		"mapped",
		[
			22022
		]
	],
	[
		[
			194637,
			194637
		],
		"mapped",
		[
			22295
		]
	],
	[
		[
			194638,
			194638
		],
		"mapped",
		[
			22097
		]
	],
	[
		[
			194639,
			194639
		],
		"mapped",
		[
			22132
		]
	],
	[
		[
			194640,
			194640
		],
		"mapped",
		[
			20999
		]
	],
	[
		[
			194641,
			194641
		],
		"mapped",
		[
			22766
		]
	],
	[
		[
			194642,
			194642
		],
		"mapped",
		[
			22478
		]
	],
	[
		[
			194643,
			194643
		],
		"mapped",
		[
			22516
		]
	],
	[
		[
			194644,
			194644
		],
		"mapped",
		[
			22541
		]
	],
	[
		[
			194645,
			194645
		],
		"mapped",
		[
			22411
		]
	],
	[
		[
			194646,
			194646
		],
		"mapped",
		[
			22578
		]
	],
	[
		[
			194647,
			194647
		],
		"mapped",
		[
			22577
		]
	],
	[
		[
			194648,
			194648
		],
		"mapped",
		[
			22700
		]
	],
	[
		[
			194649,
			194649
		],
		"mapped",
		[
			136420
		]
	],
	[
		[
			194650,
			194650
		],
		"mapped",
		[
			22770
		]
	],
	[
		[
			194651,
			194651
		],
		"mapped",
		[
			22775
		]
	],
	[
		[
			194652,
			194652
		],
		"mapped",
		[
			22790
		]
	],
	[
		[
			194653,
			194653
		],
		"mapped",
		[
			22810
		]
	],
	[
		[
			194654,
			194654
		],
		"mapped",
		[
			22818
		]
	],
	[
		[
			194655,
			194655
		],
		"mapped",
		[
			22882
		]
	],
	[
		[
			194656,
			194656
		],
		"mapped",
		[
			136872
		]
	],
	[
		[
			194657,
			194657
		],
		"mapped",
		[
			136938
		]
	],
	[
		[
			194658,
			194658
		],
		"mapped",
		[
			23020
		]
	],
	[
		[
			194659,
			194659
		],
		"mapped",
		[
			23067
		]
	],
	[
		[
			194660,
			194660
		],
		"mapped",
		[
			23079
		]
	],
	[
		[
			194661,
			194661
		],
		"mapped",
		[
			23000
		]
	],
	[
		[
			194662,
			194662
		],
		"mapped",
		[
			23142
		]
	],
	[
		[
			194663,
			194663
		],
		"mapped",
		[
			14062
		]
	],
	[
		[
			194664,
			194664
		],
		"disallowed"
	],
	[
		[
			194665,
			194665
		],
		"mapped",
		[
			23304
		]
	],
	[
		[
			194666,
			194667
		],
		"mapped",
		[
			23358
		]
	],
	[
		[
			194668,
			194668
		],
		"mapped",
		[
			137672
		]
	],
	[
		[
			194669,
			194669
		],
		"mapped",
		[
			23491
		]
	],
	[
		[
			194670,
			194670
		],
		"mapped",
		[
			23512
		]
	],
	[
		[
			194671,
			194671
		],
		"mapped",
		[
			23527
		]
	],
	[
		[
			194672,
			194672
		],
		"mapped",
		[
			23539
		]
	],
	[
		[
			194673,
			194673
		],
		"mapped",
		[
			138008
		]
	],
	[
		[
			194674,
			194674
		],
		"mapped",
		[
			23551
		]
	],
	[
		[
			194675,
			194675
		],
		"mapped",
		[
			23558
		]
	],
	[
		[
			194676,
			194676
		],
		"disallowed"
	],
	[
		[
			194677,
			194677
		],
		"mapped",
		[
			23586
		]
	],
	[
		[
			194678,
			194678
		],
		"mapped",
		[
			14209
		]
	],
	[
		[
			194679,
			194679
		],
		"mapped",
		[
			23648
		]
	],
	[
		[
			194680,
			194680
		],
		"mapped",
		[
			23662
		]
	],
	[
		[
			194681,
			194681
		],
		"mapped",
		[
			23744
		]
	],
	[
		[
			194682,
			194682
		],
		"mapped",
		[
			23693
		]
	],
	[
		[
			194683,
			194683
		],
		"mapped",
		[
			138724
		]
	],
	[
		[
			194684,
			194684
		],
		"mapped",
		[
			23875
		]
	],
	[
		[
			194685,
			194685
		],
		"mapped",
		[
			138726
		]
	],
	[
		[
			194686,
			194686
		],
		"mapped",
		[
			23918
		]
	],
	[
		[
			194687,
			194687
		],
		"mapped",
		[
			23915
		]
	],
	[
		[
			194688,
			194688
		],
		"mapped",
		[
			23932
		]
	],
	[
		[
			194689,
			194689
		],
		"mapped",
		[
			24033
		]
	],
	[
		[
			194690,
			194690
		],
		"mapped",
		[
			24034
		]
	],
	[
		[
			194691,
			194691
		],
		"mapped",
		[
			14383
		]
	],
	[
		[
			194692,
			194692
		],
		"mapped",
		[
			24061
		]
	],
	[
		[
			194693,
			194693
		],
		"mapped",
		[
			24104
		]
	],
	[
		[
			194694,
			194694
		],
		"mapped",
		[
			24125
		]
	],
	[
		[
			194695,
			194695
		],
		"mapped",
		[
			24169
		]
	],
	[
		[
			194696,
			194696
		],
		"mapped",
		[
			14434
		]
	],
	[
		[
			194697,
			194697
		],
		"mapped",
		[
			139651
		]
	],
	[
		[
			194698,
			194698
		],
		"mapped",
		[
			14460
		]
	],
	[
		[
			194699,
			194699
		],
		"mapped",
		[
			24240
		]
	],
	[
		[
			194700,
			194700
		],
		"mapped",
		[
			24243
		]
	],
	[
		[
			194701,
			194701
		],
		"mapped",
		[
			24246
		]
	],
	[
		[
			194702,
			194702
		],
		"mapped",
		[
			24266
		]
	],
	[
		[
			194703,
			194703
		],
		"mapped",
		[
			172946
		]
	],
	[
		[
			194704,
			194704
		],
		"mapped",
		[
			24318
		]
	],
	[
		[
			194705,
			194706
		],
		"mapped",
		[
			140081
		]
	],
	[
		[
			194707,
			194707
		],
		"mapped",
		[
			33281
		]
	],
	[
		[
			194708,
			194709
		],
		"mapped",
		[
			24354
		]
	],
	[
		[
			194710,
			194710
		],
		"mapped",
		[
			14535
		]
	],
	[
		[
			194711,
			194711
		],
		"mapped",
		[
			144056
		]
	],
	[
		[
			194712,
			194712
		],
		"mapped",
		[
			156122
		]
	],
	[
		[
			194713,
			194713
		],
		"mapped",
		[
			24418
		]
	],
	[
		[
			194714,
			194714
		],
		"mapped",
		[
			24427
		]
	],
	[
		[
			194715,
			194715
		],
		"mapped",
		[
			14563
		]
	],
	[
		[
			194716,
			194716
		],
		"mapped",
		[
			24474
		]
	],
	[
		[
			194717,
			194717
		],
		"mapped",
		[
			24525
		]
	],
	[
		[
			194718,
			194718
		],
		"mapped",
		[
			24535
		]
	],
	[
		[
			194719,
			194719
		],
		"mapped",
		[
			24569
		]
	],
	[
		[
			194720,
			194720
		],
		"mapped",
		[
			24705
		]
	],
	[
		[
			194721,
			194721
		],
		"mapped",
		[
			14650
		]
	],
	[
		[
			194722,
			194722
		],
		"mapped",
		[
			14620
		]
	],
	[
		[
			194723,
			194723
		],
		"mapped",
		[
			24724
		]
	],
	[
		[
			194724,
			194724
		],
		"mapped",
		[
			141012
		]
	],
	[
		[
			194725,
			194725
		],
		"mapped",
		[
			24775
		]
	],
	[
		[
			194726,
			194726
		],
		"mapped",
		[
			24904
		]
	],
	[
		[
			194727,
			194727
		],
		"mapped",
		[
			24908
		]
	],
	[
		[
			194728,
			194728
		],
		"mapped",
		[
			24910
		]
	],
	[
		[
			194729,
			194729
		],
		"mapped",
		[
			24908
		]
	],
	[
		[
			194730,
			194730
		],
		"mapped",
		[
			24954
		]
	],
	[
		[
			194731,
			194731
		],
		"mapped",
		[
			24974
		]
	],
	[
		[
			194732,
			194732
		],
		"mapped",
		[
			25010
		]
	],
	[
		[
			194733,
			194733
		],
		"mapped",
		[
			24996
		]
	],
	[
		[
			194734,
			194734
		],
		"mapped",
		[
			25007
		]
	],
	[
		[
			194735,
			194735
		],
		"mapped",
		[
			25054
		]
	],
	[
		[
			194736,
			194736
		],
		"mapped",
		[
			25074
		]
	],
	[
		[
			194737,
			194737
		],
		"mapped",
		[
			25078
		]
	],
	[
		[
			194738,
			194738
		],
		"mapped",
		[
			25104
		]
	],
	[
		[
			194739,
			194739
		],
		"mapped",
		[
			25115
		]
	],
	[
		[
			194740,
			194740
		],
		"mapped",
		[
			25181
		]
	],
	[
		[
			194741,
			194741
		],
		"mapped",
		[
			25265
		]
	],
	[
		[
			194742,
			194742
		],
		"mapped",
		[
			25300
		]
	],
	[
		[
			194743,
			194743
		],
		"mapped",
		[
			25424
		]
	],
	[
		[
			194744,
			194744
		],
		"mapped",
		[
			142092
		]
	],
	[
		[
			194745,
			194745
		],
		"mapped",
		[
			25405
		]
	],
	[
		[
			194746,
			194746
		],
		"mapped",
		[
			25340
		]
	],
	[
		[
			194747,
			194747
		],
		"mapped",
		[
			25448
		]
	],
	[
		[
			194748,
			194748
		],
		"mapped",
		[
			25475
		]
	],
	[
		[
			194749,
			194749
		],
		"mapped",
		[
			25572
		]
	],
	[
		[
			194750,
			194750
		],
		"mapped",
		[
			142321
		]
	],
	[
		[
			194751,
			194751
		],
		"mapped",
		[
			25634
		]
	],
	[
		[
			194752,
			194752
		],
		"mapped",
		[
			25541
		]
	],
	[
		[
			194753,
			194753
		],
		"mapped",
		[
			25513
		]
	],
	[
		[
			194754,
			194754
		],
		"mapped",
		[
			14894
		]
	],
	[
		[
			194755,
			194755
		],
		"mapped",
		[
			25705
		]
	],
	[
		[
			194756,
			194756
		],
		"mapped",
		[
			25726
		]
	],
	[
		[
			194757,
			194757
		],
		"mapped",
		[
			25757
		]
	],
	[
		[
			194758,
			194758
		],
		"mapped",
		[
			25719
		]
	],
	[
		[
			194759,
			194759
		],
		"mapped",
		[
			14956
		]
	],
	[
		[
			194760,
			194760
		],
		"mapped",
		[
			25935
		]
	],
	[
		[
			194761,
			194761
		],
		"mapped",
		[
			25964
		]
	],
	[
		[
			194762,
			194762
		],
		"mapped",
		[
			143370
		]
	],
	[
		[
			194763,
			194763
		],
		"mapped",
		[
			26083
		]
	],
	[
		[
			194764,
			194764
		],
		"mapped",
		[
			26360
		]
	],
	[
		[
			194765,
			194765
		],
		"mapped",
		[
			26185
		]
	],
	[
		[
			194766,
			194766
		],
		"mapped",
		[
			15129
		]
	],
	[
		[
			194767,
			194767
		],
		"mapped",
		[
			26257
		]
	],
	[
		[
			194768,
			194768
		],
		"mapped",
		[
			15112
		]
	],
	[
		[
			194769,
			194769
		],
		"mapped",
		[
			15076
		]
	],
	[
		[
			194770,
			194770
		],
		"mapped",
		[
			20882
		]
	],
	[
		[
			194771,
			194771
		],
		"mapped",
		[
			20885
		]
	],
	[
		[
			194772,
			194772
		],
		"mapped",
		[
			26368
		]
	],
	[
		[
			194773,
			194773
		],
		"mapped",
		[
			26268
		]
	],
	[
		[
			194774,
			194774
		],
		"mapped",
		[
			32941
		]
	],
	[
		[
			194775,
			194775
		],
		"mapped",
		[
			17369
		]
	],
	[
		[
			194776,
			194776
		],
		"mapped",
		[
			26391
		]
	],
	[
		[
			194777,
			194777
		],
		"mapped",
		[
			26395
		]
	],
	[
		[
			194778,
			194778
		],
		"mapped",
		[
			26401
		]
	],
	[
		[
			194779,
			194779
		],
		"mapped",
		[
			26462
		]
	],
	[
		[
			194780,
			194780
		],
		"mapped",
		[
			26451
		]
	],
	[
		[
			194781,
			194781
		],
		"mapped",
		[
			144323
		]
	],
	[
		[
			194782,
			194782
		],
		"mapped",
		[
			15177
		]
	],
	[
		[
			194783,
			194783
		],
		"mapped",
		[
			26618
		]
	],
	[
		[
			194784,
			194784
		],
		"mapped",
		[
			26501
		]
	],
	[
		[
			194785,
			194785
		],
		"mapped",
		[
			26706
		]
	],
	[
		[
			194786,
			194786
		],
		"mapped",
		[
			26757
		]
	],
	[
		[
			194787,
			194787
		],
		"mapped",
		[
			144493
		]
	],
	[
		[
			194788,
			194788
		],
		"mapped",
		[
			26766
		]
	],
	[
		[
			194789,
			194789
		],
		"mapped",
		[
			26655
		]
	],
	[
		[
			194790,
			194790
		],
		"mapped",
		[
			26900
		]
	],
	[
		[
			194791,
			194791
		],
		"mapped",
		[
			15261
		]
	],
	[
		[
			194792,
			194792
		],
		"mapped",
		[
			26946
		]
	],
	[
		[
			194793,
			194793
		],
		"mapped",
		[
			27043
		]
	],
	[
		[
			194794,
			194794
		],
		"mapped",
		[
			27114
		]
	],
	[
		[
			194795,
			194795
		],
		"mapped",
		[
			27304
		]
	],
	[
		[
			194796,
			194796
		],
		"mapped",
		[
			145059
		]
	],
	[
		[
			194797,
			194797
		],
		"mapped",
		[
			27355
		]
	],
	[
		[
			194798,
			194798
		],
		"mapped",
		[
			15384
		]
	],
	[
		[
			194799,
			194799
		],
		"mapped",
		[
			27425
		]
	],
	[
		[
			194800,
			194800
		],
		"mapped",
		[
			145575
		]
	],
	[
		[
			194801,
			194801
		],
		"mapped",
		[
			27476
		]
	],
	[
		[
			194802,
			194802
		],
		"mapped",
		[
			15438
		]
	],
	[
		[
			194803,
			194803
		],
		"mapped",
		[
			27506
		]
	],
	[
		[
			194804,
			194804
		],
		"mapped",
		[
			27551
		]
	],
	[
		[
			194805,
			194805
		],
		"mapped",
		[
			27578
		]
	],
	[
		[
			194806,
			194806
		],
		"mapped",
		[
			27579
		]
	],
	[
		[
			194807,
			194807
		],
		"mapped",
		[
			146061
		]
	],
	[
		[
			194808,
			194808
		],
		"mapped",
		[
			138507
		]
	],
	[
		[
			194809,
			194809
		],
		"mapped",
		[
			146170
		]
	],
	[
		[
			194810,
			194810
		],
		"mapped",
		[
			27726
		]
	],
	[
		[
			194811,
			194811
		],
		"mapped",
		[
			146620
		]
	],
	[
		[
			194812,
			194812
		],
		"mapped",
		[
			27839
		]
	],
	[
		[
			194813,
			194813
		],
		"mapped",
		[
			27853
		]
	],
	[
		[
			194814,
			194814
		],
		"mapped",
		[
			27751
		]
	],
	[
		[
			194815,
			194815
		],
		"mapped",
		[
			27926
		]
	],
	[
		[
			194816,
			194816
		],
		"mapped",
		[
			27966
		]
	],
	[
		[
			194817,
			194817
		],
		"mapped",
		[
			28023
		]
	],
	[
		[
			194818,
			194818
		],
		"mapped",
		[
			27969
		]
	],
	[
		[
			194819,
			194819
		],
		"mapped",
		[
			28009
		]
	],
	[
		[
			194820,
			194820
		],
		"mapped",
		[
			28024
		]
	],
	[
		[
			194821,
			194821
		],
		"mapped",
		[
			28037
		]
	],
	[
		[
			194822,
			194822
		],
		"mapped",
		[
			146718
		]
	],
	[
		[
			194823,
			194823
		],
		"mapped",
		[
			27956
		]
	],
	[
		[
			194824,
			194824
		],
		"mapped",
		[
			28207
		]
	],
	[
		[
			194825,
			194825
		],
		"mapped",
		[
			28270
		]
	],
	[
		[
			194826,
			194826
		],
		"mapped",
		[
			15667
		]
	],
	[
		[
			194827,
			194827
		],
		"mapped",
		[
			28363
		]
	],
	[
		[
			194828,
			194828
		],
		"mapped",
		[
			28359
		]
	],
	[
		[
			194829,
			194829
		],
		"mapped",
		[
			147153
		]
	],
	[
		[
			194830,
			194830
		],
		"mapped",
		[
			28153
		]
	],
	[
		[
			194831,
			194831
		],
		"mapped",
		[
			28526
		]
	],
	[
		[
			194832,
			194832
		],
		"mapped",
		[
			147294
		]
	],
	[
		[
			194833,
			194833
		],
		"mapped",
		[
			147342
		]
	],
	[
		[
			194834,
			194834
		],
		"mapped",
		[
			28614
		]
	],
	[
		[
			194835,
			194835
		],
		"mapped",
		[
			28729
		]
	],
	[
		[
			194836,
			194836
		],
		"mapped",
		[
			28702
		]
	],
	[
		[
			194837,
			194837
		],
		"mapped",
		[
			28699
		]
	],
	[
		[
			194838,
			194838
		],
		"mapped",
		[
			15766
		]
	],
	[
		[
			194839,
			194839
		],
		"mapped",
		[
			28746
		]
	],
	[
		[
			194840,
			194840
		],
		"mapped",
		[
			28797
		]
	],
	[
		[
			194841,
			194841
		],
		"mapped",
		[
			28791
		]
	],
	[
		[
			194842,
			194842
		],
		"mapped",
		[
			28845
		]
	],
	[
		[
			194843,
			194843
		],
		"mapped",
		[
			132389
		]
	],
	[
		[
			194844,
			194844
		],
		"mapped",
		[
			28997
		]
	],
	[
		[
			194845,
			194845
		],
		"mapped",
		[
			148067
		]
	],
	[
		[
			194846,
			194846
		],
		"mapped",
		[
			29084
		]
	],
	[
		[
			194847,
			194847
		],
		"disallowed"
	],
	[
		[
			194848,
			194848
		],
		"mapped",
		[
			29224
		]
	],
	[
		[
			194849,
			194849
		],
		"mapped",
		[
			29237
		]
	],
	[
		[
			194850,
			194850
		],
		"mapped",
		[
			29264
		]
	],
	[
		[
			194851,
			194851
		],
		"mapped",
		[
			149000
		]
	],
	[
		[
			194852,
			194852
		],
		"mapped",
		[
			29312
		]
	],
	[
		[
			194853,
			194853
		],
		"mapped",
		[
			29333
		]
	],
	[
		[
			194854,
			194854
		],
		"mapped",
		[
			149301
		]
	],
	[
		[
			194855,
			194855
		],
		"mapped",
		[
			149524
		]
	],
	[
		[
			194856,
			194856
		],
		"mapped",
		[
			29562
		]
	],
	[
		[
			194857,
			194857
		],
		"mapped",
		[
			29579
		]
	],
	[
		[
			194858,
			194858
		],
		"mapped",
		[
			16044
		]
	],
	[
		[
			194859,
			194859
		],
		"mapped",
		[
			29605
		]
	],
	[
		[
			194860,
			194861
		],
		"mapped",
		[
			16056
		]
	],
	[
		[
			194862,
			194862
		],
		"mapped",
		[
			29767
		]
	],
	[
		[
			194863,
			194863
		],
		"mapped",
		[
			29788
		]
	],
	[
		[
			194864,
			194864
		],
		"mapped",
		[
			29809
		]
	],
	[
		[
			194865,
			194865
		],
		"mapped",
		[
			29829
		]
	],
	[
		[
			194866,
			194866
		],
		"mapped",
		[
			29898
		]
	],
	[
		[
			194867,
			194867
		],
		"mapped",
		[
			16155
		]
	],
	[
		[
			194868,
			194868
		],
		"mapped",
		[
			29988
		]
	],
	[
		[
			194869,
			194869
		],
		"mapped",
		[
			150582
		]
	],
	[
		[
			194870,
			194870
		],
		"mapped",
		[
			30014
		]
	],
	[
		[
			194871,
			194871
		],
		"mapped",
		[
			150674
		]
	],
	[
		[
			194872,
			194872
		],
		"mapped",
		[
			30064
		]
	],
	[
		[
			194873,
			194873
		],
		"mapped",
		[
			139679
		]
	],
	[
		[
			194874,
			194874
		],
		"mapped",
		[
			30224
		]
	],
	[
		[
			194875,
			194875
		],
		"mapped",
		[
			151457
		]
	],
	[
		[
			194876,
			194876
		],
		"mapped",
		[
			151480
		]
	],
	[
		[
			194877,
			194877
		],
		"mapped",
		[
			151620
		]
	],
	[
		[
			194878,
			194878
		],
		"mapped",
		[
			16380
		]
	],
	[
		[
			194879,
			194879
		],
		"mapped",
		[
			16392
		]
	],
	[
		[
			194880,
			194880
		],
		"mapped",
		[
			30452
		]
	],
	[
		[
			194881,
			194881
		],
		"mapped",
		[
			151795
		]
	],
	[
		[
			194882,
			194882
		],
		"mapped",
		[
			151794
		]
	],
	[
		[
			194883,
			194883
		],
		"mapped",
		[
			151833
		]
	],
	[
		[
			194884,
			194884
		],
		"mapped",
		[
			151859
		]
	],
	[
		[
			194885,
			194885
		],
		"mapped",
		[
			30494
		]
	],
	[
		[
			194886,
			194887
		],
		"mapped",
		[
			30495
		]
	],
	[
		[
			194888,
			194888
		],
		"mapped",
		[
			30538
		]
	],
	[
		[
			194889,
			194889
		],
		"mapped",
		[
			16441
		]
	],
	[
		[
			194890,
			194890
		],
		"mapped",
		[
			30603
		]
	],
	[
		[
			194891,
			194891
		],
		"mapped",
		[
			16454
		]
	],
	[
		[
			194892,
			194892
		],
		"mapped",
		[
			16534
		]
	],
	[
		[
			194893,
			194893
		],
		"mapped",
		[
			152605
		]
	],
	[
		[
			194894,
			194894
		],
		"mapped",
		[
			30798
		]
	],
	[
		[
			194895,
			194895
		],
		"mapped",
		[
			30860
		]
	],
	[
		[
			194896,
			194896
		],
		"mapped",
		[
			30924
		]
	],
	[
		[
			194897,
			194897
		],
		"mapped",
		[
			16611
		]
	],
	[
		[
			194898,
			194898
		],
		"mapped",
		[
			153126
		]
	],
	[
		[
			194899,
			194899
		],
		"mapped",
		[
			31062
		]
	],
	[
		[
			194900,
			194900
		],
		"mapped",
		[
			153242
		]
	],
	[
		[
			194901,
			194901
		],
		"mapped",
		[
			153285
		]
	],
	[
		[
			194902,
			194902
		],
		"mapped",
		[
			31119
		]
	],
	[
		[
			194903,
			194903
		],
		"mapped",
		[
			31211
		]
	],
	[
		[
			194904,
			194904
		],
		"mapped",
		[
			16687
		]
	],
	[
		[
			194905,
			194905
		],
		"mapped",
		[
			31296
		]
	],
	[
		[
			194906,
			194906
		],
		"mapped",
		[
			31306
		]
	],
	[
		[
			194907,
			194907
		],
		"mapped",
		[
			31311
		]
	],
	[
		[
			194908,
			194908
		],
		"mapped",
		[
			153980
		]
	],
	[
		[
			194909,
			194910
		],
		"mapped",
		[
			154279
		]
	],
	[
		[
			194911,
			194911
		],
		"disallowed"
	],
	[
		[
			194912,
			194912
		],
		"mapped",
		[
			16898
		]
	],
	[
		[
			194913,
			194913
		],
		"mapped",
		[
			154539
		]
	],
	[
		[
			194914,
			194914
		],
		"mapped",
		[
			31686
		]
	],
	[
		[
			194915,
			194915
		],
		"mapped",
		[
			31689
		]
	],
	[
		[
			194916,
			194916
		],
		"mapped",
		[
			16935
		]
	],
	[
		[
			194917,
			194917
		],
		"mapped",
		[
			154752
		]
	],
	[
		[
			194918,
			194918
		],
		"mapped",
		[
			31954
		]
	],
	[
		[
			194919,
			194919
		],
		"mapped",
		[
			17056
		]
	],
	[
		[
			194920,
			194920
		],
		"mapped",
		[
			31976
		]
	],
	[
		[
			194921,
			194921
		],
		"mapped",
		[
			31971
		]
	],
	[
		[
			194922,
			194922
		],
		"mapped",
		[
			32000
		]
	],
	[
		[
			194923,
			194923
		],
		"mapped",
		[
			155526
		]
	],
	[
		[
			194924,
			194924
		],
		"mapped",
		[
			32099
		]
	],
	[
		[
			194925,
			194925
		],
		"mapped",
		[
			17153
		]
	],
	[
		[
			194926,
			194926
		],
		"mapped",
		[
			32199
		]
	],
	[
		[
			194927,
			194927
		],
		"mapped",
		[
			32258
		]
	],
	[
		[
			194928,
			194928
		],
		"mapped",
		[
			32325
		]
	],
	[
		[
			194929,
			194929
		],
		"mapped",
		[
			17204
		]
	],
	[
		[
			194930,
			194930
		],
		"mapped",
		[
			156200
		]
	],
	[
		[
			194931,
			194931
		],
		"mapped",
		[
			156231
		]
	],
	[
		[
			194932,
			194932
		],
		"mapped",
		[
			17241
		]
	],
	[
		[
			194933,
			194933
		],
		"mapped",
		[
			156377
		]
	],
	[
		[
			194934,
			194934
		],
		"mapped",
		[
			32634
		]
	],
	[
		[
			194935,
			194935
		],
		"mapped",
		[
			156478
		]
	],
	[
		[
			194936,
			194936
		],
		"mapped",
		[
			32661
		]
	],
	[
		[
			194937,
			194937
		],
		"mapped",
		[
			32762
		]
	],
	[
		[
			194938,
			194938
		],
		"mapped",
		[
			32773
		]
	],
	[
		[
			194939,
			194939
		],
		"mapped",
		[
			156890
		]
	],
	[
		[
			194940,
			194940
		],
		"mapped",
		[
			156963
		]
	],
	[
		[
			194941,
			194941
		],
		"mapped",
		[
			32864
		]
	],
	[
		[
			194942,
			194942
		],
		"mapped",
		[
			157096
		]
	],
	[
		[
			194943,
			194943
		],
		"mapped",
		[
			32880
		]
	],
	[
		[
			194944,
			194944
		],
		"mapped",
		[
			144223
		]
	],
	[
		[
			194945,
			194945
		],
		"mapped",
		[
			17365
		]
	],
	[
		[
			194946,
			194946
		],
		"mapped",
		[
			32946
		]
	],
	[
		[
			194947,
			194947
		],
		"mapped",
		[
			33027
		]
	],
	[
		[
			194948,
			194948
		],
		"mapped",
		[
			17419
		]
	],
	[
		[
			194949,
			194949
		],
		"mapped",
		[
			33086
		]
	],
	[
		[
			194950,
			194950
		],
		"mapped",
		[
			23221
		]
	],
	[
		[
			194951,
			194951
		],
		"mapped",
		[
			157607
		]
	],
	[
		[
			194952,
			194952
		],
		"mapped",
		[
			157621
		]
	],
	[
		[
			194953,
			194953
		],
		"mapped",
		[
			144275
		]
	],
	[
		[
			194954,
			194954
		],
		"mapped",
		[
			144284
		]
	],
	[
		[
			194955,
			194955
		],
		"mapped",
		[
			33281
		]
	],
	[
		[
			194956,
			194956
		],
		"mapped",
		[
			33284
		]
	],
	[
		[
			194957,
			194957
		],
		"mapped",
		[
			36766
		]
	],
	[
		[
			194958,
			194958
		],
		"mapped",
		[
			17515
		]
	],
	[
		[
			194959,
			194959
		],
		"mapped",
		[
			33425
		]
	],
	[
		[
			194960,
			194960
		],
		"mapped",
		[
			33419
		]
	],
	[
		[
			194961,
			194961
		],
		"mapped",
		[
			33437
		]
	],
	[
		[
			194962,
			194962
		],
		"mapped",
		[
			21171
		]
	],
	[
		[
			194963,
			194963
		],
		"mapped",
		[
			33457
		]
	],
	[
		[
			194964,
			194964
		],
		"mapped",
		[
			33459
		]
	],
	[
		[
			194965,
			194965
		],
		"mapped",
		[
			33469
		]
	],
	[
		[
			194966,
			194966
		],
		"mapped",
		[
			33510
		]
	],
	[
		[
			194967,
			194967
		],
		"mapped",
		[
			158524
		]
	],
	[
		[
			194968,
			194968
		],
		"mapped",
		[
			33509
		]
	],
	[
		[
			194969,
			194969
		],
		"mapped",
		[
			33565
		]
	],
	[
		[
			194970,
			194970
		],
		"mapped",
		[
			33635
		]
	],
	[
		[
			194971,
			194971
		],
		"mapped",
		[
			33709
		]
	],
	[
		[
			194972,
			194972
		],
		"mapped",
		[
			33571
		]
	],
	[
		[
			194973,
			194973
		],
		"mapped",
		[
			33725
		]
	],
	[
		[
			194974,
			194974
		],
		"mapped",
		[
			33767
		]
	],
	[
		[
			194975,
			194975
		],
		"mapped",
		[
			33879
		]
	],
	[
		[
			194976,
			194976
		],
		"mapped",
		[
			33619
		]
	],
	[
		[
			194977,
			194977
		],
		"mapped",
		[
			33738
		]
	],
	[
		[
			194978,
			194978
		],
		"mapped",
		[
			33740
		]
	],
	[
		[
			194979,
			194979
		],
		"mapped",
		[
			33756
		]
	],
	[
		[
			194980,
			194980
		],
		"mapped",
		[
			158774
		]
	],
	[
		[
			194981,
			194981
		],
		"mapped",
		[
			159083
		]
	],
	[
		[
			194982,
			194982
		],
		"mapped",
		[
			158933
		]
	],
	[
		[
			194983,
			194983
		],
		"mapped",
		[
			17707
		]
	],
	[
		[
			194984,
			194984
		],
		"mapped",
		[
			34033
		]
	],
	[
		[
			194985,
			194985
		],
		"mapped",
		[
			34035
		]
	],
	[
		[
			194986,
			194986
		],
		"mapped",
		[
			34070
		]
	],
	[
		[
			194987,
			194987
		],
		"mapped",
		[
			160714
		]
	],
	[
		[
			194988,
			194988
		],
		"mapped",
		[
			34148
		]
	],
	[
		[
			194989,
			194989
		],
		"mapped",
		[
			159532
		]
	],
	[
		[
			194990,
			194990
		],
		"mapped",
		[
			17757
		]
	],
	[
		[
			194991,
			194991
		],
		"mapped",
		[
			17761
		]
	],
	[
		[
			194992,
			194992
		],
		"mapped",
		[
			159665
		]
	],
	[
		[
			194993,
			194993
		],
		"mapped",
		[
			159954
		]
	],
	[
		[
			194994,
			194994
		],
		"mapped",
		[
			17771
		]
	],
	[
		[
			194995,
			194995
		],
		"mapped",
		[
			34384
		]
	],
	[
		[
			194996,
			194996
		],
		"mapped",
		[
			34396
		]
	],
	[
		[
			194997,
			194997
		],
		"mapped",
		[
			34407
		]
	],
	[
		[
			194998,
			194998
		],
		"mapped",
		[
			34409
		]
	],
	[
		[
			194999,
			194999
		],
		"mapped",
		[
			34473
		]
	],
	[
		[
			195000,
			195000
		],
		"mapped",
		[
			34440
		]
	],
	[
		[
			195001,
			195001
		],
		"mapped",
		[
			34574
		]
	],
	[
		[
			195002,
			195002
		],
		"mapped",
		[
			34530
		]
	],
	[
		[
			195003,
			195003
		],
		"mapped",
		[
			34681
		]
	],
	[
		[
			195004,
			195004
		],
		"mapped",
		[
			34600
		]
	],
	[
		[
			195005,
			195005
		],
		"mapped",
		[
			34667
		]
	],
	[
		[
			195006,
			195006
		],
		"mapped",
		[
			34694
		]
	],
	[
		[
			195007,
			195007
		],
		"disallowed"
	],
	[
		[
			195008,
			195008
		],
		"mapped",
		[
			34785
		]
	],
	[
		[
			195009,
			195009
		],
		"mapped",
		[
			34817
		]
	],
	[
		[
			195010,
			195010
		],
		"mapped",
		[
			17913
		]
	],
	[
		[
			195011,
			195011
		],
		"mapped",
		[
			34912
		]
	],
	[
		[
			195012,
			195012
		],
		"mapped",
		[
			34915
		]
	],
	[
		[
			195013,
			195013
		],
		"mapped",
		[
			161383
		]
	],
	[
		[
			195014,
			195014
		],
		"mapped",
		[
			35031
		]
	],
	[
		[
			195015,
			195015
		],
		"mapped",
		[
			35038
		]
	],
	[
		[
			195016,
			195016
		],
		"mapped",
		[
			17973
		]
	],
	[
		[
			195017,
			195017
		],
		"mapped",
		[
			35066
		]
	],
	[
		[
			195018,
			195018
		],
		"mapped",
		[
			13499
		]
	],
	[
		[
			195019,
			195019
		],
		"mapped",
		[
			161966
		]
	],
	[
		[
			195020,
			195020
		],
		"mapped",
		[
			162150
		]
	],
	[
		[
			195021,
			195021
		],
		"mapped",
		[
			18110
		]
	],
	[
		[
			195022,
			195022
		],
		"mapped",
		[
			18119
		]
	],
	[
		[
			195023,
			195023
		],
		"mapped",
		[
			35488
		]
	],
	[
		[
			195024,
			195024
		],
		"mapped",
		[
			35565
		]
	],
	[
		[
			195025,
			195025
		],
		"mapped",
		[
			35722
		]
	],
	[
		[
			195026,
			195026
		],
		"mapped",
		[
			35925
		]
	],
	[
		[
			195027,
			195027
		],
		"mapped",
		[
			162984
		]
	],
	[
		[
			195028,
			195028
		],
		"mapped",
		[
			36011
		]
	],
	[
		[
			195029,
			195029
		],
		"mapped",
		[
			36033
		]
	],
	[
		[
			195030,
			195030
		],
		"mapped",
		[
			36123
		]
	],
	[
		[
			195031,
			195031
		],
		"mapped",
		[
			36215
		]
	],
	[
		[
			195032,
			195032
		],
		"mapped",
		[
			163631
		]
	],
	[
		[
			195033,
			195033
		],
		"mapped",
		[
			133124
		]
	],
	[
		[
			195034,
			195034
		],
		"mapped",
		[
			36299
		]
	],
	[
		[
			195035,
			195035
		],
		"mapped",
		[
			36284
		]
	],
	[
		[
			195036,
			195036
		],
		"mapped",
		[
			36336
		]
	],
	[
		[
			195037,
			195037
		],
		"mapped",
		[
			133342
		]
	],
	[
		[
			195038,
			195038
		],
		"mapped",
		[
			36564
		]
	],
	[
		[
			195039,
			195039
		],
		"mapped",
		[
			36664
		]
	],
	[
		[
			195040,
			195040
		],
		"mapped",
		[
			165330
		]
	],
	[
		[
			195041,
			195041
		],
		"mapped",
		[
			165357
		]
	],
	[
		[
			195042,
			195042
		],
		"mapped",
		[
			37012
		]
	],
	[
		[
			195043,
			195043
		],
		"mapped",
		[
			37105
		]
	],
	[
		[
			195044,
			195044
		],
		"mapped",
		[
			37137
		]
	],
	[
		[
			195045,
			195045
		],
		"mapped",
		[
			165678
		]
	],
	[
		[
			195046,
			195046
		],
		"mapped",
		[
			37147
		]
	],
	[
		[
			195047,
			195047
		],
		"mapped",
		[
			37432
		]
	],
	[
		[
			195048,
			195048
		],
		"mapped",
		[
			37591
		]
	],
	[
		[
			195049,
			195049
		],
		"mapped",
		[
			37592
		]
	],
	[
		[
			195050,
			195050
		],
		"mapped",
		[
			37500
		]
	],
	[
		[
			195051,
			195051
		],
		"mapped",
		[
			37881
		]
	],
	[
		[
			195052,
			195052
		],
		"mapped",
		[
			37909
		]
	],
	[
		[
			195053,
			195053
		],
		"mapped",
		[
			166906
		]
	],
	[
		[
			195054,
			195054
		],
		"mapped",
		[
			38283
		]
	],
	[
		[
			195055,
			195055
		],
		"mapped",
		[
			18837
		]
	],
	[
		[
			195056,
			195056
		],
		"mapped",
		[
			38327
		]
	],
	[
		[
			195057,
			195057
		],
		"mapped",
		[
			167287
		]
	],
	[
		[
			195058,
			195058
		],
		"mapped",
		[
			18918
		]
	],
	[
		[
			195059,
			195059
		],
		"mapped",
		[
			38595
		]
	],
	[
		[
			195060,
			195060
		],
		"mapped",
		[
			23986
		]
	],
	[
		[
			195061,
			195061
		],
		"mapped",
		[
			38691
		]
	],
	[
		[
			195062,
			195062
		],
		"mapped",
		[
			168261
		]
	],
	[
		[
			195063,
			195063
		],
		"mapped",
		[
			168474
		]
	],
	[
		[
			195064,
			195064
		],
		"mapped",
		[
			19054
		]
	],
	[
		[
			195065,
			195065
		],
		"mapped",
		[
			19062
		]
	],
	[
		[
			195066,
			195066
		],
		"mapped",
		[
			38880
		]
	],
	[
		[
			195067,
			195067
		],
		"mapped",
		[
			168970
		]
	],
	[
		[
			195068,
			195068
		],
		"mapped",
		[
			19122
		]
	],
	[
		[
			195069,
			195069
		],
		"mapped",
		[
			169110
		]
	],
	[
		[
			195070,
			195071
		],
		"mapped",
		[
			38923
		]
	],
	[
		[
			195072,
			195072
		],
		"mapped",
		[
			38953
		]
	],
	[
		[
			195073,
			195073
		],
		"mapped",
		[
			169398
		]
	],
	[
		[
			195074,
			195074
		],
		"mapped",
		[
			39138
		]
	],
	[
		[
			195075,
			195075
		],
		"mapped",
		[
			19251
		]
	],
	[
		[
			195076,
			195076
		],
		"mapped",
		[
			39209
		]
	],
	[
		[
			195077,
			195077
		],
		"mapped",
		[
			39335
		]
	],
	[
		[
			195078,
			195078
		],
		"mapped",
		[
			39362
		]
	],
	[
		[
			195079,
			195079
		],
		"mapped",
		[
			39422
		]
	],
	[
		[
			195080,
			195080
		],
		"mapped",
		[
			19406
		]
	],
	[
		[
			195081,
			195081
		],
		"mapped",
		[
			170800
		]
	],
	[
		[
			195082,
			195082
		],
		"mapped",
		[
			39698
		]
	],
	[
		[
			195083,
			195083
		],
		"mapped",
		[
			40000
		]
	],
	[
		[
			195084,
			195084
		],
		"mapped",
		[
			40189
		]
	],
	[
		[
			195085,
			195085
		],
		"mapped",
		[
			19662
		]
	],
	[
		[
			195086,
			195086
		],
		"mapped",
		[
			19693
		]
	],
	[
		[
			195087,
			195087
		],
		"mapped",
		[
			40295
		]
	],
	[
		[
			195088,
			195088
		],
		"mapped",
		[
			172238
		]
	],
	[
		[
			195089,
			195089
		],
		"mapped",
		[
			19704
		]
	],
	[
		[
			195090,
			195090
		],
		"mapped",
		[
			172293
		]
	],
	[
		[
			195091,
			195091
		],
		"mapped",
		[
			172558
		]
	],
	[
		[
			195092,
			195092
		],
		"mapped",
		[
			172689
		]
	],
	[
		[
			195093,
			195093
		],
		"mapped",
		[
			40635
		]
	],
	[
		[
			195094,
			195094
		],
		"mapped",
		[
			19798
		]
	],
	[
		[
			195095,
			195095
		],
		"mapped",
		[
			40697
		]
	],
	[
		[
			195096,
			195096
		],
		"mapped",
		[
			40702
		]
	],
	[
		[
			195097,
			195097
		],
		"mapped",
		[
			40709
		]
	],
	[
		[
			195098,
			195098
		],
		"mapped",
		[
			40719
		]
	],
	[
		[
			195099,
			195099
		],
		"mapped",
		[
			40726
		]
	],
	[
		[
			195100,
			195100
		],
		"mapped",
		[
			40763
		]
	],
	[
		[
			195101,
			195101
		],
		"mapped",
		[
			173568
		]
	],
	[
		[
			195102,
			196605
		],
		"disallowed"
	],
	[
		[
			196606,
			196607
		],
		"disallowed"
	],
	[
		[
			196608,
			262141
		],
		"disallowed"
	],
	[
		[
			262142,
			262143
		],
		"disallowed"
	],
	[
		[
			262144,
			327677
		],
		"disallowed"
	],
	[
		[
			327678,
			327679
		],
		"disallowed"
	],
	[
		[
			327680,
			393213
		],
		"disallowed"
	],
	[
		[
			393214,
			393215
		],
		"disallowed"
	],
	[
		[
			393216,
			458749
		],
		"disallowed"
	],
	[
		[
			458750,
			458751
		],
		"disallowed"
	],
	[
		[
			458752,
			524285
		],
		"disallowed"
	],
	[
		[
			524286,
			524287
		],
		"disallowed"
	],
	[
		[
			524288,
			589821
		],
		"disallowed"
	],
	[
		[
			589822,
			589823
		],
		"disallowed"
	],
	[
		[
			589824,
			655357
		],
		"disallowed"
	],
	[
		[
			655358,
			655359
		],
		"disallowed"
	],
	[
		[
			655360,
			720893
		],
		"disallowed"
	],
	[
		[
			720894,
			720895
		],
		"disallowed"
	],
	[
		[
			720896,
			786429
		],
		"disallowed"
	],
	[
		[
			786430,
			786431
		],
		"disallowed"
	],
	[
		[
			786432,
			851965
		],
		"disallowed"
	],
	[
		[
			851966,
			851967
		],
		"disallowed"
	],
	[
		[
			851968,
			917501
		],
		"disallowed"
	],
	[
		[
			917502,
			917503
		],
		"disallowed"
	],
	[
		[
			917504,
			917504
		],
		"disallowed"
	],
	[
		[
			917505,
			917505
		],
		"disallowed"
	],
	[
		[
			917506,
			917535
		],
		"disallowed"
	],
	[
		[
			917536,
			917631
		],
		"disallowed"
	],
	[
		[
			917632,
			917759
		],
		"disallowed"
	],
	[
		[
			917760,
			917999
		],
		"ignored"
	],
	[
		[
			918000,
			983037
		],
		"disallowed"
	],
	[
		[
			983038,
			983039
		],
		"disallowed"
	],
	[
		[
			983040,
			1048573
		],
		"disallowed"
	],
	[
		[
			1048574,
			1048575
		],
		"disallowed"
	],
	[
		[
			1048576,
			1114109
		],
		"disallowed"
	],
	[
		[
			1114110,
			1114111
		],
		"disallowed"
	]
];

var punycode = require$$0$3;
var mappingTable = require$$1;

var PROCESSING_OPTIONS = {
  TRANSITIONAL: 0,
  NONTRANSITIONAL: 1
};

function normalize(str) { // fix bug in v8
  return str.split('\u0000').map(function (s) { return s.normalize('NFC'); }).join('\u0000');
}

function findStatus(val) {
  var start = 0;
  var end = mappingTable.length - 1;

  while (start <= end) {
    var mid = Math.floor((start + end) / 2);

    var target = mappingTable[mid];
    if (target[0][0] <= val && target[0][1] >= val) {
      return target;
    } else if (target[0][0] > val) {
      end = mid - 1;
    } else {
      start = mid + 1;
    }
  }

  return null;
}

var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;

function countSymbols(string) {
  return string
    // replace every surrogate pair with a BMP symbol
    .replace(regexAstralSymbols, '_')
    // then get the length
    .length;
}

function mapChars(domain_name, useSTD3, processing_option) {
  var hasError = false;
  var processed = "";

  var len = countSymbols(domain_name);
  for (var i = 0; i < len; ++i) {
    var codePoint = domain_name.codePointAt(i);
    var status = findStatus(codePoint);

    switch (status[1]) {
      case "disallowed":
        hasError = true;
        processed += String.fromCodePoint(codePoint);
        break;
      case "ignored":
        break;
      case "mapped":
        processed += String.fromCodePoint.apply(String, status[2]);
        break;
      case "deviation":
        if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
          processed += String.fromCodePoint.apply(String, status[2]);
        } else {
          processed += String.fromCodePoint(codePoint);
        }
        break;
      case "valid":
        processed += String.fromCodePoint(codePoint);
        break;
      case "disallowed_STD3_mapped":
        if (useSTD3) {
          hasError = true;
          processed += String.fromCodePoint(codePoint);
        } else {
          processed += String.fromCodePoint.apply(String, status[2]);
        }
        break;
      case "disallowed_STD3_valid":
        if (useSTD3) {
          hasError = true;
        }

        processed += String.fromCodePoint(codePoint);
        break;
    }
  }

  return {
    string: processed,
    error: hasError
  };
}

var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;

function validateLabel(label, processing_option) {
  if (label.substr(0, 4) === "xn--") {
    label = punycode.toUnicode(label);
  }

  var error = false;

  if (normalize(label) !== label ||
      (label[3] === "-" && label[4] === "-") ||
      label[0] === "-" || label[label.length - 1] === "-" ||
      label.indexOf(".") !== -1 ||
      label.search(combiningMarksRegex) === 0) {
    error = true;
  }

  var len = countSymbols(label);
  for (var i = 0; i < len; ++i) {
    var status = findStatus(label.codePointAt(i));
    if ((processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid") ||
        (processing === PROCESSING_OPTIONS.NONTRANSITIONAL &&
         status[1] !== "valid" && status[1] !== "deviation")) {
      error = true;
      break;
    }
  }

  return {
    label: label,
    error: error
  };
}

function processing(domain_name, useSTD3, processing_option) {
  var result = mapChars(domain_name, useSTD3, processing_option);
  result.string = normalize(result.string);

  var labels = result.string.split(".");
  for (var i = 0; i < labels.length; ++i) {
    try {
      var validation = validateLabel(labels[i]);
      labels[i] = validation.label;
      result.error = result.error || validation.error;
    } catch(e) {
      result.error = true;
    }
  }

  return {
    string: labels.join("."),
    error: result.error
  };
}

tr46.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
  var result = processing(domain_name, useSTD3, processing_option);
  var labels = result.string.split(".");
  labels = labels.map(function(l) {
    try {
      return punycode.toASCII(l);
    } catch(e) {
      result.error = true;
      return l;
    }
  });

  if (verifyDnsLength) {
    var total = labels.slice(0, labels.length - 1).join(".").length;
    if (total.length > 253 || total.length === 0) {
      result.error = true;
    }

    for (var i=0; i < labels.length; ++i) {
      if (labels.length > 63 || labels.length === 0) {
        result.error = true;
        break;
      }
    }
  }

  if (result.error) return null;
  return labels.join(".");
};

tr46.toUnicode = function(domain_name, useSTD3) {
  var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);

  return {
    domain: result.string,
    error: result.error
  };
};

tr46.PROCESSING_OPTIONS = PROCESSING_OPTIONS;

(function (module) {
	const punycode = require$$0$3;
	const tr46$1 = tr46;

	const specialSchemes = {
	  ftp: 21,
	  file: null,
	  gopher: 70,
	  http: 80,
	  https: 443,
	  ws: 80,
	  wss: 443
	};

	const failure = Symbol("failure");

	function countSymbols(str) {
	  return punycode.ucs2.decode(str).length;
	}

	function at(input, idx) {
	  const c = input[idx];
	  return isNaN(c) ? undefined : String.fromCodePoint(c);
	}

	function isASCIIDigit(c) {
	  return c >= 0x30 && c <= 0x39;
	}

	function isASCIIAlpha(c) {
	  return (c >= 0x41 && c <= 0x5A) || (c >= 0x61 && c <= 0x7A);
	}

	function isASCIIAlphanumeric(c) {
	  return isASCIIAlpha(c) || isASCIIDigit(c);
	}

	function isASCIIHex(c) {
	  return isASCIIDigit(c) || (c >= 0x41 && c <= 0x46) || (c >= 0x61 && c <= 0x66);
	}

	function isSingleDot(buffer) {
	  return buffer === "." || buffer.toLowerCase() === "%2e";
	}

	function isDoubleDot(buffer) {
	  buffer = buffer.toLowerCase();
	  return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
	}

	function isWindowsDriveLetterCodePoints(cp1, cp2) {
	  return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
	}

	function isWindowsDriveLetterString(string) {
	  return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
	}

	function isNormalizedWindowsDriveLetterString(string) {
	  return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
	}

	function containsForbiddenHostCodePoint(string) {
	  return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
	}

	function containsForbiddenHostCodePointExcludingPercent(string) {
	  return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
	}

	function isSpecialScheme(scheme) {
	  return specialSchemes[scheme] !== undefined;
	}

	function isSpecial(url) {
	  return isSpecialScheme(url.scheme);
	}

	function defaultPort(scheme) {
	  return specialSchemes[scheme];
	}

	function percentEncode(c) {
	  let hex = c.toString(16).toUpperCase();
	  if (hex.length === 1) {
	    hex = "0" + hex;
	  }

	  return "%" + hex;
	}

	function utf8PercentEncode(c) {
	  const buf = new Buffer(c);

	  let str = "";

	  for (let i = 0; i < buf.length; ++i) {
	    str += percentEncode(buf[i]);
	  }

	  return str;
	}

	function utf8PercentDecode(str) {
	  const input = new Buffer(str);
	  const output = [];
	  for (let i = 0; i < input.length; ++i) {
	    if (input[i] !== 37) {
	      output.push(input[i]);
	    } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
	      output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
	      i += 2;
	    } else {
	      output.push(input[i]);
	    }
	  }
	  return new Buffer(output).toString();
	}

	function isC0ControlPercentEncode(c) {
	  return c <= 0x1F || c > 0x7E;
	}

	const extraPathPercentEncodeSet = new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
	function isPathPercentEncode(c) {
	  return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
	}

	const extraUserinfoPercentEncodeSet =
	  new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
	function isUserinfoPercentEncode(c) {
	  return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
	}

	function percentEncodeChar(c, encodeSetPredicate) {
	  const cStr = String.fromCodePoint(c);

	  if (encodeSetPredicate(c)) {
	    return utf8PercentEncode(cStr);
	  }

	  return cStr;
	}

	function parseIPv4Number(input) {
	  let R = 10;

	  if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
	    input = input.substring(2);
	    R = 16;
	  } else if (input.length >= 2 && input.charAt(0) === "0") {
	    input = input.substring(1);
	    R = 8;
	  }

	  if (input === "") {
	    return 0;
	  }

	  const regex = R === 10 ? /[^0-9]/ : (R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/);
	  if (regex.test(input)) {
	    return failure;
	  }

	  return parseInt(input, R);
	}

	function parseIPv4(input) {
	  const parts = input.split(".");
	  if (parts[parts.length - 1] === "") {
	    if (parts.length > 1) {
	      parts.pop();
	    }
	  }

	  if (parts.length > 4) {
	    return input;
	  }

	  const numbers = [];
	  for (const part of parts) {
	    if (part === "") {
	      return input;
	    }
	    const n = parseIPv4Number(part);
	    if (n === failure) {
	      return input;
	    }

	    numbers.push(n);
	  }

	  for (let i = 0; i < numbers.length - 1; ++i) {
	    if (numbers[i] > 255) {
	      return failure;
	    }
	  }
	  if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
	    return failure;
	  }

	  let ipv4 = numbers.pop();
	  let counter = 0;

	  for (const n of numbers) {
	    ipv4 += n * Math.pow(256, 3 - counter);
	    ++counter;
	  }

	  return ipv4;
	}

	function serializeIPv4(address) {
	  let output = "";
	  let n = address;

	  for (let i = 1; i <= 4; ++i) {
	    output = String(n % 256) + output;
	    if (i !== 4) {
	      output = "." + output;
	    }
	    n = Math.floor(n / 256);
	  }

	  return output;
	}

	function parseIPv6(input) {
	  const address = [0, 0, 0, 0, 0, 0, 0, 0];
	  let pieceIndex = 0;
	  let compress = null;
	  let pointer = 0;

	  input = punycode.ucs2.decode(input);

	  if (input[pointer] === 58) {
	    if (input[pointer + 1] !== 58) {
	      return failure;
	    }

	    pointer += 2;
	    ++pieceIndex;
	    compress = pieceIndex;
	  }

	  while (pointer < input.length) {
	    if (pieceIndex === 8) {
	      return failure;
	    }

	    if (input[pointer] === 58) {
	      if (compress !== null) {
	        return failure;
	      }
	      ++pointer;
	      ++pieceIndex;
	      compress = pieceIndex;
	      continue;
	    }

	    let value = 0;
	    let length = 0;

	    while (length < 4 && isASCIIHex(input[pointer])) {
	      value = value * 0x10 + parseInt(at(input, pointer), 16);
	      ++pointer;
	      ++length;
	    }

	    if (input[pointer] === 46) {
	      if (length === 0) {
	        return failure;
	      }

	      pointer -= length;

	      if (pieceIndex > 6) {
	        return failure;
	      }

	      let numbersSeen = 0;

	      while (input[pointer] !== undefined) {
	        let ipv4Piece = null;

	        if (numbersSeen > 0) {
	          if (input[pointer] === 46 && numbersSeen < 4) {
	            ++pointer;
	          } else {
	            return failure;
	          }
	        }

	        if (!isASCIIDigit(input[pointer])) {
	          return failure;
	        }

	        while (isASCIIDigit(input[pointer])) {
	          const number = parseInt(at(input, pointer));
	          if (ipv4Piece === null) {
	            ipv4Piece = number;
	          } else if (ipv4Piece === 0) {
	            return failure;
	          } else {
	            ipv4Piece = ipv4Piece * 10 + number;
	          }
	          if (ipv4Piece > 255) {
	            return failure;
	          }
	          ++pointer;
	        }

	        address[pieceIndex] = address[pieceIndex] * 0x100 + ipv4Piece;

	        ++numbersSeen;

	        if (numbersSeen === 2 || numbersSeen === 4) {
	          ++pieceIndex;
	        }
	      }

	      if (numbersSeen !== 4) {
	        return failure;
	      }

	      break;
	    } else if (input[pointer] === 58) {
	      ++pointer;
	      if (input[pointer] === undefined) {
	        return failure;
	      }
	    } else if (input[pointer] !== undefined) {
	      return failure;
	    }

	    address[pieceIndex] = value;
	    ++pieceIndex;
	  }

	  if (compress !== null) {
	    let swaps = pieceIndex - compress;
	    pieceIndex = 7;
	    while (pieceIndex !== 0 && swaps > 0) {
	      const temp = address[compress + swaps - 1];
	      address[compress + swaps - 1] = address[pieceIndex];
	      address[pieceIndex] = temp;
	      --pieceIndex;
	      --swaps;
	    }
	  } else if (compress === null && pieceIndex !== 8) {
	    return failure;
	  }

	  return address;
	}

	function serializeIPv6(address) {
	  let output = "";
	  const seqResult = findLongestZeroSequence(address);
	  const compress = seqResult.idx;
	  let ignore0 = false;

	  for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
	    if (ignore0 && address[pieceIndex] === 0) {
	      continue;
	    } else if (ignore0) {
	      ignore0 = false;
	    }

	    if (compress === pieceIndex) {
	      const separator = pieceIndex === 0 ? "::" : ":";
	      output += separator;
	      ignore0 = true;
	      continue;
	    }

	    output += address[pieceIndex].toString(16);

	    if (pieceIndex !== 7) {
	      output += ":";
	    }
	  }

	  return output;
	}

	function parseHost(input, isSpecialArg) {
	  if (input[0] === "[") {
	    if (input[input.length - 1] !== "]") {
	      return failure;
	    }

	    return parseIPv6(input.substring(1, input.length - 1));
	  }

	  if (!isSpecialArg) {
	    return parseOpaqueHost(input);
	  }

	  const domain = utf8PercentDecode(input);
	  const asciiDomain = tr46$1.toASCII(domain, false, tr46$1.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
	  if (asciiDomain === null) {
	    return failure;
	  }

	  if (containsForbiddenHostCodePoint(asciiDomain)) {
	    return failure;
	  }

	  const ipv4Host = parseIPv4(asciiDomain);
	  if (typeof ipv4Host === "number" || ipv4Host === failure) {
	    return ipv4Host;
	  }

	  return asciiDomain;
	}

	function parseOpaqueHost(input) {
	  if (containsForbiddenHostCodePointExcludingPercent(input)) {
	    return failure;
	  }

	  let output = "";
	  const decoded = punycode.ucs2.decode(input);
	  for (let i = 0; i < decoded.length; ++i) {
	    output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
	  }
	  return output;
	}

	function findLongestZeroSequence(arr) {
	  let maxIdx = null;
	  let maxLen = 1; // only find elements > 1
	  let currStart = null;
	  let currLen = 0;

	  for (let i = 0; i < arr.length; ++i) {
	    if (arr[i] !== 0) {
	      if (currLen > maxLen) {
	        maxIdx = currStart;
	        maxLen = currLen;
	      }

	      currStart = null;
	      currLen = 0;
	    } else {
	      if (currStart === null) {
	        currStart = i;
	      }
	      ++currLen;
	    }
	  }

	  // if trailing zeros
	  if (currLen > maxLen) {
	    maxIdx = currStart;
	    maxLen = currLen;
	  }

	  return {
	    idx: maxIdx,
	    len: maxLen
	  };
	}

	function serializeHost(host) {
	  if (typeof host === "number") {
	    return serializeIPv4(host);
	  }

	  // IPv6 serializer
	  if (host instanceof Array) {
	    return "[" + serializeIPv6(host) + "]";
	  }

	  return host;
	}

	function trimControlChars(url) {
	  return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
	}

	function trimTabAndNewline(url) {
	  return url.replace(/\u0009|\u000A|\u000D/g, "");
	}

	function shortenPath(url) {
	  const path = url.path;
	  if (path.length === 0) {
	    return;
	  }
	  if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
	    return;
	  }

	  path.pop();
	}

	function includesCredentials(url) {
	  return url.username !== "" || url.password !== "";
	}

	function cannotHaveAUsernamePasswordPort(url) {
	  return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
	}

	function isNormalizedWindowsDriveLetter(string) {
	  return /^[A-Za-z]:$/.test(string);
	}

	function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
	  this.pointer = 0;
	  this.input = input;
	  this.base = base || null;
	  this.encodingOverride = encodingOverride || "utf-8";
	  this.stateOverride = stateOverride;
	  this.url = url;
	  this.failure = false;
	  this.parseError = false;

	  if (!this.url) {
	    this.url = {
	      scheme: "",
	      username: "",
	      password: "",
	      host: null,
	      port: null,
	      path: [],
	      query: null,
	      fragment: null,

	      cannotBeABaseURL: false
	    };

	    const res = trimControlChars(this.input);
	    if (res !== this.input) {
	      this.parseError = true;
	    }
	    this.input = res;
	  }

	  const res = trimTabAndNewline(this.input);
	  if (res !== this.input) {
	    this.parseError = true;
	  }
	  this.input = res;

	  this.state = stateOverride || "scheme start";

	  this.buffer = "";
	  this.atFlag = false;
	  this.arrFlag = false;
	  this.passwordTokenSeenFlag = false;

	  this.input = punycode.ucs2.decode(this.input);

	  for (; this.pointer <= this.input.length; ++this.pointer) {
	    const c = this.input[this.pointer];
	    const cStr = isNaN(c) ? undefined : String.fromCodePoint(c);

	    // exec state machine
	    const ret = this["parse " + this.state](c, cStr);
	    if (!ret) {
	      break; // terminate algorithm
	    } else if (ret === failure) {
	      this.failure = true;
	      break;
	    }
	  }
	}

	URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
	  if (isASCIIAlpha(c)) {
	    this.buffer += cStr.toLowerCase();
	    this.state = "scheme";
	  } else if (!this.stateOverride) {
	    this.state = "no scheme";
	    --this.pointer;
	  } else {
	    this.parseError = true;
	    return failure;
	  }

	  return true;
	};

	URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
	  if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
	    this.buffer += cStr.toLowerCase();
	  } else if (c === 58) {
	    if (this.stateOverride) {
	      if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
	        return false;
	      }

	      if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
	        return false;
	      }

	      if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
	        return false;
	      }

	      if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
	        return false;
	      }
	    }
	    this.url.scheme = this.buffer;
	    this.buffer = "";
	    if (this.stateOverride) {
	      return false;
	    }
	    if (this.url.scheme === "file") {
	      if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
	        this.parseError = true;
	      }
	      this.state = "file";
	    } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
	      this.state = "special relative or authority";
	    } else if (isSpecial(this.url)) {
	      this.state = "special authority slashes";
	    } else if (this.input[this.pointer + 1] === 47) {
	      this.state = "path or authority";
	      ++this.pointer;
	    } else {
	      this.url.cannotBeABaseURL = true;
	      this.url.path.push("");
	      this.state = "cannot-be-a-base-URL path";
	    }
	  } else if (!this.stateOverride) {
	    this.buffer = "";
	    this.state = "no scheme";
	    this.pointer = -1;
	  } else {
	    this.parseError = true;
	    return failure;
	  }

	  return true;
	};

	URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
	  if (this.base === null || (this.base.cannotBeABaseURL && c !== 35)) {
	    return failure;
	  } else if (this.base.cannotBeABaseURL && c === 35) {
	    this.url.scheme = this.base.scheme;
	    this.url.path = this.base.path.slice();
	    this.url.query = this.base.query;
	    this.url.fragment = "";
	    this.url.cannotBeABaseURL = true;
	    this.state = "fragment";
	  } else if (this.base.scheme === "file") {
	    this.state = "file";
	    --this.pointer;
	  } else {
	    this.state = "relative";
	    --this.pointer;
	  }

	  return true;
	};

	URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
	  if (c === 47 && this.input[this.pointer + 1] === 47) {
	    this.state = "special authority ignore slashes";
	    ++this.pointer;
	  } else {
	    this.parseError = true;
	    this.state = "relative";
	    --this.pointer;
	  }

	  return true;
	};

	URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
	  if (c === 47) {
	    this.state = "authority";
	  } else {
	    this.state = "path";
	    --this.pointer;
	  }

	  return true;
	};

	URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
	  this.url.scheme = this.base.scheme;
	  if (isNaN(c)) {
	    this.url.username = this.base.username;
	    this.url.password = this.base.password;
	    this.url.host = this.base.host;
	    this.url.port = this.base.port;
	    this.url.path = this.base.path.slice();
	    this.url.query = this.base.query;
	  } else if (c === 47) {
	    this.state = "relative slash";
	  } else if (c === 63) {
	    this.url.username = this.base.username;
	    this.url.password = this.base.password;
	    this.url.host = this.base.host;
	    this.url.port = this.base.port;
	    this.url.path = this.base.path.slice();
	    this.url.query = "";
	    this.state = "query";
	  } else if (c === 35) {
	    this.url.username = this.base.username;
	    this.url.password = this.base.password;
	    this.url.host = this.base.host;
	    this.url.port = this.base.port;
	    this.url.path = this.base.path.slice();
	    this.url.query = this.base.query;
	    this.url.fragment = "";
	    this.state = "fragment";
	  } else if (isSpecial(this.url) && c === 92) {
	    this.parseError = true;
	    this.state = "relative slash";
	  } else {
	    this.url.username = this.base.username;
	    this.url.password = this.base.password;
	    this.url.host = this.base.host;
	    this.url.port = this.base.port;
	    this.url.path = this.base.path.slice(0, this.base.path.length - 1);

	    this.state = "path";
	    --this.pointer;
	  }

	  return true;
	};

	URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
	  if (isSpecial(this.url) && (c === 47 || c === 92)) {
	    if (c === 92) {
	      this.parseError = true;
	    }
	    this.state = "special authority ignore slashes";
	  } else if (c === 47) {
	    this.state = "authority";
	  } else {
	    this.url.username = this.base.username;
	    this.url.password = this.base.password;
	    this.url.host = this.base.host;
	    this.url.port = this.base.port;
	    this.state = "path";
	    --this.pointer;
	  }

	  return true;
	};

	URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
	  if (c === 47 && this.input[this.pointer + 1] === 47) {
	    this.state = "special authority ignore slashes";
	    ++this.pointer;
	  } else {
	    this.parseError = true;
	    this.state = "special authority ignore slashes";
	    --this.pointer;
	  }

	  return true;
	};

	URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
	  if (c !== 47 && c !== 92) {
	    this.state = "authority";
	    --this.pointer;
	  } else {
	    this.parseError = true;
	  }

	  return true;
	};

	URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
	  if (c === 64) {
	    this.parseError = true;
	    if (this.atFlag) {
	      this.buffer = "%40" + this.buffer;
	    }
	    this.atFlag = true;

	    // careful, this is based on buffer and has its own pointer (this.pointer != pointer) and inner chars
	    const len = countSymbols(this.buffer);
	    for (let pointer = 0; pointer < len; ++pointer) {
	      const codePoint = this.buffer.codePointAt(pointer);

	      if (codePoint === 58 && !this.passwordTokenSeenFlag) {
	        this.passwordTokenSeenFlag = true;
	        continue;
	      }
	      const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
	      if (this.passwordTokenSeenFlag) {
	        this.url.password += encodedCodePoints;
	      } else {
	        this.url.username += encodedCodePoints;
	      }
	    }
	    this.buffer = "";
	  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||
	             (isSpecial(this.url) && c === 92)) {
	    if (this.atFlag && this.buffer === "") {
	      this.parseError = true;
	      return failure;
	    }
	    this.pointer -= countSymbols(this.buffer) + 1;
	    this.buffer = "";
	    this.state = "host";
	  } else {
	    this.buffer += cStr;
	  }

	  return true;
	};

	URLStateMachine.prototype["parse hostname"] =
	URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
	  if (this.stateOverride && this.url.scheme === "file") {
	    --this.pointer;
	    this.state = "file host";
	  } else if (c === 58 && !this.arrFlag) {
	    if (this.buffer === "") {
	      this.parseError = true;
	      return failure;
	    }

	    const host = parseHost(this.buffer, isSpecial(this.url));
	    if (host === failure) {
	      return failure;
	    }

	    this.url.host = host;
	    this.buffer = "";
	    this.state = "port";
	    if (this.stateOverride === "hostname") {
	      return false;
	    }
	  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||
	             (isSpecial(this.url) && c === 92)) {
	    --this.pointer;
	    if (isSpecial(this.url) && this.buffer === "") {
	      this.parseError = true;
	      return failure;
	    } else if (this.stateOverride && this.buffer === "" &&
	               (includesCredentials(this.url) || this.url.port !== null)) {
	      this.parseError = true;
	      return false;
	    }

	    const host = parseHost(this.buffer, isSpecial(this.url));
	    if (host === failure) {
	      return failure;
	    }

	    this.url.host = host;
	    this.buffer = "";
	    this.state = "path start";
	    if (this.stateOverride) {
	      return false;
	    }
	  } else {
	    if (c === 91) {
	      this.arrFlag = true;
	    } else if (c === 93) {
	      this.arrFlag = false;
	    }
	    this.buffer += cStr;
	  }

	  return true;
	};

	URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
	  if (isASCIIDigit(c)) {
	    this.buffer += cStr;
	  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||
	             (isSpecial(this.url) && c === 92) ||
	             this.stateOverride) {
	    if (this.buffer !== "") {
	      const port = parseInt(this.buffer);
	      if (port > Math.pow(2, 16) - 1) {
	        this.parseError = true;
	        return failure;
	      }
	      this.url.port = port === defaultPort(this.url.scheme) ? null : port;
	      this.buffer = "";
	    }
	    if (this.stateOverride) {
	      return false;
	    }
	    this.state = "path start";
	    --this.pointer;
	  } else {
	    this.parseError = true;
	    return failure;
	  }

	  return true;
	};

	const fileOtherwiseCodePoints = new Set([47, 92, 63, 35]);

	URLStateMachine.prototype["parse file"] = function parseFile(c) {
	  this.url.scheme = "file";

	  if (c === 47 || c === 92) {
	    if (c === 92) {
	      this.parseError = true;
	    }
	    this.state = "file slash";
	  } else if (this.base !== null && this.base.scheme === "file") {
	    if (isNaN(c)) {
	      this.url.host = this.base.host;
	      this.url.path = this.base.path.slice();
	      this.url.query = this.base.query;
	    } else if (c === 63) {
	      this.url.host = this.base.host;
	      this.url.path = this.base.path.slice();
	      this.url.query = "";
	      this.state = "query";
	    } else if (c === 35) {
	      this.url.host = this.base.host;
	      this.url.path = this.base.path.slice();
	      this.url.query = this.base.query;
	      this.url.fragment = "";
	      this.state = "fragment";
	    } else {
	      if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
	          !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) ||
	          (this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
	           !fileOtherwiseCodePoints.has(this.input[this.pointer + 2]))) {
	        this.url.host = this.base.host;
	        this.url.path = this.base.path.slice();
	        shortenPath(this.url);
	      } else {
	        this.parseError = true;
	      }

	      this.state = "path";
	      --this.pointer;
	    }
	  } else {
	    this.state = "path";
	    --this.pointer;
	  }

	  return true;
	};

	URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
	  if (c === 47 || c === 92) {
	    if (c === 92) {
	      this.parseError = true;
	    }
	    this.state = "file host";
	  } else {
	    if (this.base !== null && this.base.scheme === "file") {
	      if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
	        this.url.path.push(this.base.path[0]);
	      } else {
	        this.url.host = this.base.host;
	      }
	    }
	    this.state = "path";
	    --this.pointer;
	  }

	  return true;
	};

	URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
	  if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
	    --this.pointer;
	    if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
	      this.parseError = true;
	      this.state = "path";
	    } else if (this.buffer === "") {
	      this.url.host = "";
	      if (this.stateOverride) {
	        return false;
	      }
	      this.state = "path start";
	    } else {
	      let host = parseHost(this.buffer, isSpecial(this.url));
	      if (host === failure) {
	        return failure;
	      }
	      if (host === "localhost") {
	        host = "";
	      }
	      this.url.host = host;

	      if (this.stateOverride) {
	        return false;
	      }

	      this.buffer = "";
	      this.state = "path start";
	    }
	  } else {
	    this.buffer += cStr;
	  }

	  return true;
	};

	URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
	  if (isSpecial(this.url)) {
	    if (c === 92) {
	      this.parseError = true;
	    }
	    this.state = "path";

	    if (c !== 47 && c !== 92) {
	      --this.pointer;
	    }
	  } else if (!this.stateOverride && c === 63) {
	    this.url.query = "";
	    this.state = "query";
	  } else if (!this.stateOverride && c === 35) {
	    this.url.fragment = "";
	    this.state = "fragment";
	  } else if (c !== undefined) {
	    this.state = "path";
	    if (c !== 47) {
	      --this.pointer;
	    }
	  }

	  return true;
	};

	URLStateMachine.prototype["parse path"] = function parsePath(c) {
	  if (isNaN(c) || c === 47 || (isSpecial(this.url) && c === 92) ||
	      (!this.stateOverride && (c === 63 || c === 35))) {
	    if (isSpecial(this.url) && c === 92) {
	      this.parseError = true;
	    }

	    if (isDoubleDot(this.buffer)) {
	      shortenPath(this.url);
	      if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
	        this.url.path.push("");
	      }
	    } else if (isSingleDot(this.buffer) && c !== 47 &&
	               !(isSpecial(this.url) && c === 92)) {
	      this.url.path.push("");
	    } else if (!isSingleDot(this.buffer)) {
	      if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
	        if (this.url.host !== "" && this.url.host !== null) {
	          this.parseError = true;
	          this.url.host = "";
	        }
	        this.buffer = this.buffer[0] + ":";
	      }
	      this.url.path.push(this.buffer);
	    }
	    this.buffer = "";
	    if (this.url.scheme === "file" && (c === undefined || c === 63 || c === 35)) {
	      while (this.url.path.length > 1 && this.url.path[0] === "") {
	        this.parseError = true;
	        this.url.path.shift();
	      }
	    }
	    if (c === 63) {
	      this.url.query = "";
	      this.state = "query";
	    }
	    if (c === 35) {
	      this.url.fragment = "";
	      this.state = "fragment";
	    }
	  } else {
	    // TODO: If c is not a URL code point and not "%", parse error.

	    if (c === 37 &&
	      (!isASCIIHex(this.input[this.pointer + 1]) ||
	        !isASCIIHex(this.input[this.pointer + 2]))) {
	      this.parseError = true;
	    }

	    this.buffer += percentEncodeChar(c, isPathPercentEncode);
	  }

	  return true;
	};

	URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
	  if (c === 63) {
	    this.url.query = "";
	    this.state = "query";
	  } else if (c === 35) {
	    this.url.fragment = "";
	    this.state = "fragment";
	  } else {
	    // TODO: Add: not a URL code point
	    if (!isNaN(c) && c !== 37) {
	      this.parseError = true;
	    }

	    if (c === 37 &&
	        (!isASCIIHex(this.input[this.pointer + 1]) ||
	         !isASCIIHex(this.input[this.pointer + 2]))) {
	      this.parseError = true;
	    }

	    if (!isNaN(c)) {
	      this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
	    }
	  }

	  return true;
	};

	URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
	  if (isNaN(c) || (!this.stateOverride && c === 35)) {
	    if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
	      this.encodingOverride = "utf-8";
	    }

	    const buffer = new Buffer(this.buffer); // TODO: Use encoding override instead
	    for (let i = 0; i < buffer.length; ++i) {
	      if (buffer[i] < 0x21 || buffer[i] > 0x7E || buffer[i] === 0x22 || buffer[i] === 0x23 ||
	          buffer[i] === 0x3C || buffer[i] === 0x3E) {
	        this.url.query += percentEncode(buffer[i]);
	      } else {
	        this.url.query += String.fromCodePoint(buffer[i]);
	      }
	    }

	    this.buffer = "";
	    if (c === 35) {
	      this.url.fragment = "";
	      this.state = "fragment";
	    }
	  } else {
	    // TODO: If c is not a URL code point and not "%", parse error.
	    if (c === 37 &&
	      (!isASCIIHex(this.input[this.pointer + 1]) ||
	        !isASCIIHex(this.input[this.pointer + 2]))) {
	      this.parseError = true;
	    }

	    this.buffer += cStr;
	  }

	  return true;
	};

	URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
	  if (isNaN(c)) ; else if (c === 0x0) {
	    this.parseError = true;
	  } else {
	    // TODO: If c is not a URL code point and not "%", parse error.
	    if (c === 37 &&
	      (!isASCIIHex(this.input[this.pointer + 1]) ||
	        !isASCIIHex(this.input[this.pointer + 2]))) {
	      this.parseError = true;
	    }

	    this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
	  }

	  return true;
	};

	function serializeURL(url, excludeFragment) {
	  let output = url.scheme + ":";
	  if (url.host !== null) {
	    output += "//";

	    if (url.username !== "" || url.password !== "") {
	      output += url.username;
	      if (url.password !== "") {
	        output += ":" + url.password;
	      }
	      output += "@";
	    }

	    output += serializeHost(url.host);

	    if (url.port !== null) {
	      output += ":" + url.port;
	    }
	  } else if (url.host === null && url.scheme === "file") {
	    output += "//";
	  }

	  if (url.cannotBeABaseURL) {
	    output += url.path[0];
	  } else {
	    for (const string of url.path) {
	      output += "/" + string;
	    }
	  }

	  if (url.query !== null) {
	    output += "?" + url.query;
	  }

	  if (!excludeFragment && url.fragment !== null) {
	    output += "#" + url.fragment;
	  }

	  return output;
	}

	function serializeOrigin(tuple) {
	  let result = tuple.scheme + "://";
	  result += serializeHost(tuple.host);

	  if (tuple.port !== null) {
	    result += ":" + tuple.port;
	  }

	  return result;
	}

	module.exports.serializeURL = serializeURL;

	module.exports.serializeURLOrigin = function (url) {
	  // https://url.spec.whatwg.org/#concept-url-origin
	  switch (url.scheme) {
	    case "blob":
	      try {
	        return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));
	      } catch (e) {
	        // serializing an opaque origin returns "null"
	        return "null";
	      }
	    case "ftp":
	    case "gopher":
	    case "http":
	    case "https":
	    case "ws":
	    case "wss":
	      return serializeOrigin({
	        scheme: url.scheme,
	        host: url.host,
	        port: url.port
	      });
	    case "file":
	      // spec says "exercise to the reader", chrome says "file://"
	      return "file://";
	    default:
	      // serializing an opaque origin returns "null"
	      return "null";
	  }
	};

	module.exports.basicURLParse = function (input, options) {
	  if (options === undefined) {
	    options = {};
	  }

	  const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
	  if (usm.failure) {
	    return "failure";
	  }

	  return usm.url;
	};

	module.exports.setTheUsername = function (url, username) {
	  url.username = "";
	  const decoded = punycode.ucs2.decode(username);
	  for (let i = 0; i < decoded.length; ++i) {
	    url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
	  }
	};

	module.exports.setThePassword = function (url, password) {
	  url.password = "";
	  const decoded = punycode.ucs2.decode(password);
	  for (let i = 0; i < decoded.length; ++i) {
	    url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
	  }
	};

	module.exports.serializeHost = serializeHost;

	module.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;

	module.exports.serializeInteger = function (integer) {
	  return String(integer);
	};

	module.exports.parseURL = function (input, options) {
	  if (options === undefined) {
	    options = {};
	  }

	  // We don't handle blobs, so this just delegates:
	  return module.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
	}; 
} (urlStateMachine));

var urlStateMachineExports = urlStateMachine.exports;

const usm = urlStateMachineExports;

URLImpl.implementation = class URLImpl {
  constructor(constructorArgs) {
    const url = constructorArgs[0];
    const base = constructorArgs[1];

    let parsedBase = null;
    if (base !== undefined) {
      parsedBase = usm.basicURLParse(base);
      if (parsedBase === "failure") {
        throw new TypeError("Invalid base URL");
      }
    }

    const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
    if (parsedURL === "failure") {
      throw new TypeError("Invalid URL");
    }

    this._url = parsedURL;

    // TODO: query stuff
  }

  get href() {
    return usm.serializeURL(this._url);
  }

  set href(v) {
    const parsedURL = usm.basicURLParse(v);
    if (parsedURL === "failure") {
      throw new TypeError("Invalid URL");
    }

    this._url = parsedURL;
  }

  get origin() {
    return usm.serializeURLOrigin(this._url);
  }

  get protocol() {
    return this._url.scheme + ":";
  }

  set protocol(v) {
    usm.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" });
  }

  get username() {
    return this._url.username;
  }

  set username(v) {
    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
      return;
    }

    usm.setTheUsername(this._url, v);
  }

  get password() {
    return this._url.password;
  }

  set password(v) {
    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
      return;
    }

    usm.setThePassword(this._url, v);
  }

  get host() {
    const url = this._url;

    if (url.host === null) {
      return "";
    }

    if (url.port === null) {
      return usm.serializeHost(url.host);
    }

    return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
  }

  set host(v) {
    if (this._url.cannotBeABaseURL) {
      return;
    }

    usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
  }

  get hostname() {
    if (this._url.host === null) {
      return "";
    }

    return usm.serializeHost(this._url.host);
  }

  set hostname(v) {
    if (this._url.cannotBeABaseURL) {
      return;
    }

    usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
  }

  get port() {
    if (this._url.port === null) {
      return "";
    }

    return usm.serializeInteger(this._url.port);
  }

  set port(v) {
    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
      return;
    }

    if (v === "") {
      this._url.port = null;
    } else {
      usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
    }
  }

  get pathname() {
    if (this._url.cannotBeABaseURL) {
      return this._url.path[0];
    }

    if (this._url.path.length === 0) {
      return "";
    }

    return "/" + this._url.path.join("/");
  }

  set pathname(v) {
    if (this._url.cannotBeABaseURL) {
      return;
    }

    this._url.path = [];
    usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
  }

  get search() {
    if (this._url.query === null || this._url.query === "") {
      return "";
    }

    return "?" + this._url.query;
  }

  set search(v) {
    // TODO: query stuff

    const url = this._url;

    if (v === "") {
      url.query = null;
      return;
    }

    const input = v[0] === "?" ? v.substring(1) : v;
    url.query = "";
    usm.basicURLParse(input, { url, stateOverride: "query" });
  }

  get hash() {
    if (this._url.fragment === null || this._url.fragment === "") {
      return "";
    }

    return "#" + this._url.fragment;
  }

  set hash(v) {
    if (v === "") {
      this._url.fragment = null;
      return;
    }

    const input = v[0] === "#" ? v.substring(1) : v;
    this._url.fragment = "";
    usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
  }

  toJSON() {
    return this.href;
  }
};

(function (module) {

	const conversions = lib$1;
	const utils = utilsExports;
	const Impl = URLImpl;

	const impl = utils.implSymbol;

	function URL(url) {
	  if (!this || this[impl] || !(this instanceof URL)) {
	    throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
	  }
	  if (arguments.length < 1) {
	    throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
	  }
	  const args = [];
	  for (let i = 0; i < arguments.length && i < 2; ++i) {
	    args[i] = arguments[i];
	  }
	  args[0] = conversions["USVString"](args[0]);
	  if (args[1] !== undefined) {
	  args[1] = conversions["USVString"](args[1]);
	  }

	  module.exports.setup(this, args);
	}

	URL.prototype.toJSON = function toJSON() {
	  if (!this || !module.exports.is(this)) {
	    throw new TypeError("Illegal invocation");
	  }
	  const args = [];
	  for (let i = 0; i < arguments.length && i < 0; ++i) {
	    args[i] = arguments[i];
	  }
	  return this[impl].toJSON.apply(this[impl], args);
	};
	Object.defineProperty(URL.prototype, "href", {
	  get() {
	    return this[impl].href;
	  },
	  set(V) {
	    V = conversions["USVString"](V);
	    this[impl].href = V;
	  },
	  enumerable: true,
	  configurable: true
	});

	URL.prototype.toString = function () {
	  if (!this || !module.exports.is(this)) {
	    throw new TypeError("Illegal invocation");
	  }
	  return this.href;
	};

	Object.defineProperty(URL.prototype, "origin", {
	  get() {
	    return this[impl].origin;
	  },
	  enumerable: true,
	  configurable: true
	});

	Object.defineProperty(URL.prototype, "protocol", {
	  get() {
	    return this[impl].protocol;
	  },
	  set(V) {
	    V = conversions["USVString"](V);
	    this[impl].protocol = V;
	  },
	  enumerable: true,
	  configurable: true
	});

	Object.defineProperty(URL.prototype, "username", {
	  get() {
	    return this[impl].username;
	  },
	  set(V) {
	    V = conversions["USVString"](V);
	    this[impl].username = V;
	  },
	  enumerable: true,
	  configurable: true
	});

	Object.defineProperty(URL.prototype, "password", {
	  get() {
	    return this[impl].password;
	  },
	  set(V) {
	    V = conversions["USVString"](V);
	    this[impl].password = V;
	  },
	  enumerable: true,
	  configurable: true
	});

	Object.defineProperty(URL.prototype, "host", {
	  get() {
	    return this[impl].host;
	  },
	  set(V) {
	    V = conversions["USVString"](V);
	    this[impl].host = V;
	  },
	  enumerable: true,
	  configurable: true
	});

	Object.defineProperty(URL.prototype, "hostname", {
	  get() {
	    return this[impl].hostname;
	  },
	  set(V) {
	    V = conversions["USVString"](V);
	    this[impl].hostname = V;
	  },
	  enumerable: true,
	  configurable: true
	});

	Object.defineProperty(URL.prototype, "port", {
	  get() {
	    return this[impl].port;
	  },
	  set(V) {
	    V = conversions["USVString"](V);
	    this[impl].port = V;
	  },
	  enumerable: true,
	  configurable: true
	});

	Object.defineProperty(URL.prototype, "pathname", {
	  get() {
	    return this[impl].pathname;
	  },
	  set(V) {
	    V = conversions["USVString"](V);
	    this[impl].pathname = V;
	  },
	  enumerable: true,
	  configurable: true
	});

	Object.defineProperty(URL.prototype, "search", {
	  get() {
	    return this[impl].search;
	  },
	  set(V) {
	    V = conversions["USVString"](V);
	    this[impl].search = V;
	  },
	  enumerable: true,
	  configurable: true
	});

	Object.defineProperty(URL.prototype, "hash", {
	  get() {
	    return this[impl].hash;
	  },
	  set(V) {
	    V = conversions["USVString"](V);
	    this[impl].hash = V;
	  },
	  enumerable: true,
	  configurable: true
	});


	module.exports = {
	  is(obj) {
	    return !!obj && obj[impl] instanceof Impl.implementation;
	  },
	  create(constructorArgs, privateData) {
	    let obj = Object.create(URL.prototype);
	    this.setup(obj, constructorArgs, privateData);
	    return obj;
	  },
	  setup(obj, constructorArgs, privateData) {
	    if (!privateData) privateData = {};
	    privateData.wrapper = obj;

	    obj[impl] = new Impl.implementation(constructorArgs, privateData);
	    obj[impl][utils.wrapperSymbol] = obj;
	  },
	  interface: URL,
	  expose: {
	    Window: { URL: URL },
	    Worker: { URL: URL }
	  }
	}; 
} (URL$2));

var URLExports = URL$2.exports;

publicApi.URL = URLExports.interface;
publicApi.serializeURL = urlStateMachineExports.serializeURL;
publicApi.serializeURLOrigin = urlStateMachineExports.serializeURLOrigin;
publicApi.basicURLParse = urlStateMachineExports.basicURLParse;
publicApi.setTheUsername = urlStateMachineExports.setTheUsername;
publicApi.setThePassword = urlStateMachineExports.setThePassword;
publicApi.serializeHost = urlStateMachineExports.serializeHost;
publicApi.serializeInteger = urlStateMachineExports.serializeInteger;
publicApi.parseURL = urlStateMachineExports.parseURL;

// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js

// fix for "Readable" isn't a named export issue
const Readable = Stream.Readable;

const BUFFER = Symbol('buffer');
const TYPE = Symbol('type');

class Blob {
	constructor() {
		this[TYPE] = '';

		const blobParts = arguments[0];
		const options = arguments[1];

		const buffers = [];

		if (blobParts) {
			const a = blobParts;
			const length = Number(a.length);
			for (let i = 0; i < length; i++) {
				const element = a[i];
				let buffer;
				if (element instanceof Buffer) {
					buffer = element;
				} else if (ArrayBuffer.isView(element)) {
					buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
				} else if (element instanceof ArrayBuffer) {
					buffer = Buffer.from(element);
				} else if (element instanceof Blob) {
					buffer = element[BUFFER];
				} else {
					buffer = Buffer.from(typeof element === 'string' ? element : String(element));
				}
				buffers.push(buffer);
			}
		}

		this[BUFFER] = Buffer.concat(buffers);

		let type = options && options.type !== undefined && String(options.type).toLowerCase();
		if (type && !/[^\u0020-\u007E]/.test(type)) {
			this[TYPE] = type;
		}
	}
	get size() {
		return this[BUFFER].length;
	}
	get type() {
		return this[TYPE];
	}
	text() {
		return Promise.resolve(this[BUFFER].toString());
	}
	arrayBuffer() {
		const buf = this[BUFFER];
		const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
		return Promise.resolve(ab);
	}
	stream() {
		const readable = new Readable();
		readable._read = function () {};
		readable.push(this[BUFFER]);
		readable.push(null);
		return readable;
	}
	toString() {
		return '[object Blob]';
	}
	slice() {
		const size = this.size;

		const start = arguments[0];
		const end = arguments[1];
		let relativeStart, relativeEnd;
		if (start === undefined) {
			relativeStart = 0;
		} else if (start < 0) {
			relativeStart = Math.max(size + start, 0);
		} else {
			relativeStart = Math.min(start, size);
		}
		if (end === undefined) {
			relativeEnd = size;
		} else if (end < 0) {
			relativeEnd = Math.max(size + end, 0);
		} else {
			relativeEnd = Math.min(end, size);
		}
		const span = Math.max(relativeEnd - relativeStart, 0);

		const buffer = this[BUFFER];
		const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
		const blob = new Blob([], { type: arguments[2] });
		blob[BUFFER] = slicedBuffer;
		return blob;
	}
}

Object.defineProperties(Blob.prototype, {
	size: { enumerable: true },
	type: { enumerable: true },
	slice: { enumerable: true }
});

Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
	value: 'Blob',
	writable: false,
	enumerable: false,
	configurable: true
});

/**
 * fetch-error.js
 *
 * FetchError interface for operational errors
 */

/**
 * Create FetchError instance
 *
 * @param   String      message      Error message for human
 * @param   String      type         Error type for machine
 * @param   String      systemError  For Node.js system error
 * @return  FetchError
 */
function FetchError(message, type, systemError) {
  Error.call(this, message);

  this.message = message;
  this.type = type;

  // when err.type is `system`, err.code contains system error code
  if (systemError) {
    this.code = this.errno = systemError.code;
  }

  // hide custom error implementation details from end-users
  Error.captureStackTrace(this, this.constructor);
}

FetchError.prototype = Object.create(Error.prototype);
FetchError.prototype.constructor = FetchError;
FetchError.prototype.name = 'FetchError';

let convert;
try {
	convert = require('encoding').convert;
} catch (e) {}

const INTERNALS = Symbol('Body internals');

// fix an issue where "PassThrough" isn't a named export for node <10
const PassThrough = Stream.PassThrough;

/**
 * Body mixin
 *
 * Ref: https://fetch.spec.whatwg.org/#body
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
function Body(body) {
	var _this = this;

	var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	    _ref$size = _ref.size;

	let size = _ref$size === undefined ? 0 : _ref$size;
	var _ref$timeout = _ref.timeout;
	let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;

	if (body == null) {
		// body is undefined or null
		body = null;
	} else if (isURLSearchParams(body)) {
		// body is a URLSearchParams
		body = Buffer.from(body.toString());
	} else if (isBlob(body)) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
		// body is ArrayBuffer
		body = Buffer.from(body);
	} else if (ArrayBuffer.isView(body)) {
		// body is ArrayBufferView
		body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
	} else if (body instanceof Stream) ; else {
		// none of the above
		// coerce to string then buffer
		body = Buffer.from(String(body));
	}
	this[INTERNALS] = {
		body,
		disturbed: false,
		error: null
	};
	this.size = size;
	this.timeout = timeout;

	if (body instanceof Stream) {
		body.on('error', function (err) {
			const error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);
			_this[INTERNALS].error = error;
		});
	}
}

Body.prototype = {
	get body() {
		return this[INTERNALS].body;
	},

	get bodyUsed() {
		return this[INTERNALS].disturbed;
	},

	/**
  * Decode response as ArrayBuffer
  *
  * @return  Promise
  */
	arrayBuffer() {
		return consumeBody.call(this).then(function (buf) {
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
		});
	},

	/**
  * Return raw response as Blob
  *
  * @return Promise
  */
	blob() {
		let ct = this.headers && this.headers.get('content-type') || '';
		return consumeBody.call(this).then(function (buf) {
			return Object.assign(
			// Prevent copying
			new Blob([], {
				type: ct.toLowerCase()
			}), {
				[BUFFER]: buf
			});
		});
	},

	/**
  * Decode response as json
  *
  * @return  Promise
  */
	json() {
		var _this2 = this;

		return consumeBody.call(this).then(function (buffer) {
			try {
				return JSON.parse(buffer.toString());
			} catch (err) {
				return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));
			}
		});
	},

	/**
  * Decode response as text
  *
  * @return  Promise
  */
	text() {
		return consumeBody.call(this).then(function (buffer) {
			return buffer.toString();
		});
	},

	/**
  * Decode response as buffer (non-spec api)
  *
  * @return  Promise
  */
	buffer() {
		return consumeBody.call(this);
	},

	/**
  * Decode response as text, while automatically detecting the encoding and
  * trying to decode to UTF-8 (non-spec api)
  *
  * @return  Promise
  */
	textConverted() {
		var _this3 = this;

		return consumeBody.call(this).then(function (buffer) {
			return convertBody(buffer, _this3.headers);
		});
	}
};

// In browsers, all properties are enumerable.
Object.defineProperties(Body.prototype, {
	body: { enumerable: true },
	bodyUsed: { enumerable: true },
	arrayBuffer: { enumerable: true },
	blob: { enumerable: true },
	json: { enumerable: true },
	text: { enumerable: true }
});

Body.mixIn = function (proto) {
	for (const name of Object.getOwnPropertyNames(Body.prototype)) {
		// istanbul ignore else: future proof
		if (!(name in proto)) {
			const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
			Object.defineProperty(proto, name, desc);
		}
	}
};

/**
 * Consume and convert an entire Body to a Buffer.
 *
 * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
 *
 * @return  Promise
 */
function consumeBody() {
	var _this4 = this;

	if (this[INTERNALS].disturbed) {
		return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
	}

	this[INTERNALS].disturbed = true;

	if (this[INTERNALS].error) {
		return Body.Promise.reject(this[INTERNALS].error);
	}

	let body = this.body;

	// body is null
	if (body === null) {
		return Body.Promise.resolve(Buffer.alloc(0));
	}

	// body is blob
	if (isBlob(body)) {
		body = body.stream();
	}

	// body is buffer
	if (Buffer.isBuffer(body)) {
		return Body.Promise.resolve(body);
	}

	// istanbul ignore if: should never happen
	if (!(body instanceof Stream)) {
		return Body.Promise.resolve(Buffer.alloc(0));
	}

	// body is stream
	// get ready to actually consume the body
	let accum = [];
	let accumBytes = 0;
	let abort = false;

	return new Body.Promise(function (resolve, reject) {
		let resTimeout;

		// allow timeout on slow response body
		if (_this4.timeout) {
			resTimeout = setTimeout(function () {
				abort = true;
				reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));
			}, _this4.timeout);
		}

		// handle stream errors
		body.on('error', function (err) {
			if (err.name === 'AbortError') {
				// if the request was aborted, reject with this Error
				abort = true;
				reject(err);
			} else {
				// other errors, such as incorrect content-encoding
				reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));
			}
		});

		body.on('data', function (chunk) {
			if (abort || chunk === null) {
				return;
			}

			if (_this4.size && accumBytes + chunk.length > _this4.size) {
				abort = true;
				reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));
				return;
			}

			accumBytes += chunk.length;
			accum.push(chunk);
		});

		body.on('end', function () {
			if (abort) {
				return;
			}

			clearTimeout(resTimeout);

			try {
				resolve(Buffer.concat(accum, accumBytes));
			} catch (err) {
				// handle streams that have accumulated too much data (issue #414)
				reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));
			}
		});
	});
}

/**
 * Detect buffer encoding and convert to target encoding
 * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding
 *
 * @param   Buffer  buffer    Incoming buffer
 * @param   String  encoding  Target encoding
 * @return  String
 */
function convertBody(buffer, headers) {
	if (typeof convert !== 'function') {
		throw new Error('The package `encoding` must be installed to use the textConverted() function');
	}

	const ct = headers.get('content-type');
	let charset = 'utf-8';
	let res, str;

	// header
	if (ct) {
		res = /charset=([^;]*)/i.exec(ct);
	}

	// no charset in content type, peek at response body for at most 1024 bytes
	str = buffer.slice(0, 1024).toString();

	// html5
	if (!res && str) {
		res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
	}

	// html4
	if (!res && str) {
		res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
		if (!res) {
			res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
			if (res) {
				res.pop(); // drop last quote
			}
		}

		if (res) {
			res = /charset=(.*)/i.exec(res.pop());
		}
	}

	// xml
	if (!res && str) {
		res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
	}

	// found charset
	if (res) {
		charset = res.pop();

		// prevent decode issues when sites use incorrect encoding
		// ref: https://hsivonen.fi/encoding-menu/
		if (charset === 'gb2312' || charset === 'gbk') {
			charset = 'gb18030';
		}
	}

	// turn raw buffers into a single utf-8 buffer
	return convert(buffer, 'UTF-8', charset).toString();
}

/**
 * Detect a URLSearchParams object
 * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143
 *
 * @param   Object  obj     Object to detect by type or brand
 * @return  String
 */
function isURLSearchParams(obj) {
	// Duck-typing as a necessary condition.
	if (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {
		return false;
	}

	// Brand-checking and more duck-typing as optional condition.
	return obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';
}

/**
 * Check if `obj` is a W3C `Blob` object (which `File` inherits from)
 * @param  {*} obj
 * @return {boolean}
 */
function isBlob(obj) {
	return typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
}

/**
 * Clone body given Res/Req instance
 *
 * @param   Mixed  instance  Response or Request instance
 * @return  Mixed
 */
function clone(instance) {
	let p1, p2;
	let body = instance.body;

	// don't allow cloning a used body
	if (instance.bodyUsed) {
		throw new Error('cannot clone body after it is used');
	}

	// check that body is a stream and not form-data object
	// note: we can't clone the form-data object without having it as a dependency
	if (body instanceof Stream && typeof body.getBoundary !== 'function') {
		// tee instance body
		p1 = new PassThrough();
		p2 = new PassThrough();
		body.pipe(p1);
		body.pipe(p2);
		// set instance body to teed body and return the other teed body
		instance[INTERNALS].body = p1;
		body = p2;
	}

	return body;
}

/**
 * Performs the operation "extract a `Content-Type` value from |object|" as
 * specified in the specification:
 * https://fetch.spec.whatwg.org/#concept-bodyinit-extract
 *
 * This function assumes that instance.body is present.
 *
 * @param   Mixed  instance  Any options.body input
 */
function extractContentType(body) {
	if (body === null) {
		// body is null
		return null;
	} else if (typeof body === 'string') {
		// body is string
		return 'text/plain;charset=UTF-8';
	} else if (isURLSearchParams(body)) {
		// body is a URLSearchParams
		return 'application/x-www-form-urlencoded;charset=UTF-8';
	} else if (isBlob(body)) {
		// body is blob
		return body.type || null;
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		return null;
	} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
		// body is ArrayBuffer
		return null;
	} else if (ArrayBuffer.isView(body)) {
		// body is ArrayBufferView
		return null;
	} else if (typeof body.getBoundary === 'function') {
		// detect form data input from form-data module
		return `multipart/form-data;boundary=${body.getBoundary()}`;
	} else if (body instanceof Stream) {
		// body is stream
		// can't really do much about this
		return null;
	} else {
		// Body constructor defaults other things to string
		return 'text/plain;charset=UTF-8';
	}
}

/**
 * The Fetch Standard treats this as if "total bytes" is a property on the body.
 * For us, we have to explicitly get it with a function.
 *
 * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
 *
 * @param   Body    instance   Instance of Body
 * @return  Number?            Number of bytes, or null if not possible
 */
function getTotalBytes(instance) {
	const body = instance.body;


	if (body === null) {
		// body is null
		return 0;
	} else if (isBlob(body)) {
		return body.size;
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		return body.length;
	} else if (body && typeof body.getLengthSync === 'function') {
		// detect form data input from form-data module
		if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
		body.hasKnownLength && body.hasKnownLength()) {
			// 2.x
			return body.getLengthSync();
		}
		return null;
	} else {
		// body is stream
		return null;
	}
}

/**
 * Write a Body to a Node.js WritableStream (e.g. http.Request) object.
 *
 * @param   Body    instance   Instance of Body
 * @return  Void
 */
function writeToStream(dest, instance) {
	const body = instance.body;


	if (body === null) {
		// body is null
		dest.end();
	} else if (isBlob(body)) {
		body.stream().pipe(dest);
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		dest.write(body);
		dest.end();
	} else {
		// body is stream
		body.pipe(dest);
	}
}

// expose Promise
Body.Promise = global.Promise;

/**
 * headers.js
 *
 * Headers class offers convenient helpers
 */

const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;

function validateName(name) {
	name = `${name}`;
	if (invalidTokenRegex.test(name) || name === '') {
		throw new TypeError(`${name} is not a legal HTTP header name`);
	}
}

function validateValue(value) {
	value = `${value}`;
	if (invalidHeaderCharRegex.test(value)) {
		throw new TypeError(`${value} is not a legal HTTP header value`);
	}
}

/**
 * Find the key in the map object given a header name.
 *
 * Returns undefined if not found.
 *
 * @param   String  name  Header name
 * @return  String|Undefined
 */
function find(map, name) {
	name = name.toLowerCase();
	for (const key in map) {
		if (key.toLowerCase() === name) {
			return key;
		}
	}
	return undefined;
}

const MAP = Symbol('map');
let Headers$1 = class Headers {
	/**
  * Headers class
  *
  * @param   Object  headers  Response headers
  * @return  Void
  */
	constructor() {
		let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

		this[MAP] = Object.create(null);

		if (init instanceof Headers) {
			const rawHeaders = init.raw();
			const headerNames = Object.keys(rawHeaders);

			for (const headerName of headerNames) {
				for (const value of rawHeaders[headerName]) {
					this.append(headerName, value);
				}
			}

			return;
		}

		// We don't worry about converting prop to ByteString here as append()
		// will handle it.
		if (init == null) ; else if (typeof init === 'object') {
			const method = init[Symbol.iterator];
			if (method != null) {
				if (typeof method !== 'function') {
					throw new TypeError('Header pairs must be iterable');
				}

				// sequence<sequence<ByteString>>
				// Note: per spec we have to first exhaust the lists then process them
				const pairs = [];
				for (const pair of init) {
					if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {
						throw new TypeError('Each header pair must be iterable');
					}
					pairs.push(Array.from(pair));
				}

				for (const pair of pairs) {
					if (pair.length !== 2) {
						throw new TypeError('Each header pair must be a name/value tuple');
					}
					this.append(pair[0], pair[1]);
				}
			} else {
				// record<ByteString, ByteString>
				for (const key of Object.keys(init)) {
					const value = init[key];
					this.append(key, value);
				}
			}
		} else {
			throw new TypeError('Provided initializer must be an object');
		}
	}

	/**
  * Return combined header value given name
  *
  * @param   String  name  Header name
  * @return  Mixed
  */
	get(name) {
		name = `${name}`;
		validateName(name);
		const key = find(this[MAP], name);
		if (key === undefined) {
			return null;
		}

		return this[MAP][key].join(', ');
	}

	/**
  * Iterate over all headers
  *
  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
  * @param   Boolean   thisArg   `this` context for callback function
  * @return  Void
  */
	forEach(callback) {
		let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

		let pairs = getHeaders(this);
		let i = 0;
		while (i < pairs.length) {
			var _pairs$i = pairs[i];
			const name = _pairs$i[0],
			      value = _pairs$i[1];

			callback.call(thisArg, value, name, this);
			pairs = getHeaders(this);
			i++;
		}
	}

	/**
  * Overwrite header values given name
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */
	set(name, value) {
		name = `${name}`;
		value = `${value}`;
		validateName(name);
		validateValue(value);
		const key = find(this[MAP], name);
		this[MAP][key !== undefined ? key : name] = [value];
	}

	/**
  * Append a value onto existing header
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */
	append(name, value) {
		name = `${name}`;
		value = `${value}`;
		validateName(name);
		validateValue(value);
		const key = find(this[MAP], name);
		if (key !== undefined) {
			this[MAP][key].push(value);
		} else {
			this[MAP][name] = [value];
		}
	}

	/**
  * Check for header name existence
  *
  * @param   String   name  Header name
  * @return  Boolean
  */
	has(name) {
		name = `${name}`;
		validateName(name);
		return find(this[MAP], name) !== undefined;
	}

	/**
  * Delete all header values given name
  *
  * @param   String  name  Header name
  * @return  Void
  */
	delete(name) {
		name = `${name}`;
		validateName(name);
		const key = find(this[MAP], name);
		if (key !== undefined) {
			delete this[MAP][key];
		}
	}

	/**
  * Return raw headers (non-spec api)
  *
  * @return  Object
  */
	raw() {
		return this[MAP];
	}

	/**
  * Get an iterator on keys.
  *
  * @return  Iterator
  */
	keys() {
		return createHeadersIterator(this, 'key');
	}

	/**
  * Get an iterator on values.
  *
  * @return  Iterator
  */
	values() {
		return createHeadersIterator(this, 'value');
	}

	/**
  * Get an iterator on entries.
  *
  * This is the default iterator of the Headers object.
  *
  * @return  Iterator
  */
	[Symbol.iterator]() {
		return createHeadersIterator(this, 'key+value');
	}
};
Headers$1.prototype.entries = Headers$1.prototype[Symbol.iterator];

Object.defineProperty(Headers$1.prototype, Symbol.toStringTag, {
	value: 'Headers',
	writable: false,
	enumerable: false,
	configurable: true
});

Object.defineProperties(Headers$1.prototype, {
	get: { enumerable: true },
	forEach: { enumerable: true },
	set: { enumerable: true },
	append: { enumerable: true },
	has: { enumerable: true },
	delete: { enumerable: true },
	keys: { enumerable: true },
	values: { enumerable: true },
	entries: { enumerable: true }
});

function getHeaders(headers) {
	let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';

	const keys = Object.keys(headers[MAP]).sort();
	return keys.map(kind === 'key' ? function (k) {
		return k.toLowerCase();
	} : kind === 'value' ? function (k) {
		return headers[MAP][k].join(', ');
	} : function (k) {
		return [k.toLowerCase(), headers[MAP][k].join(', ')];
	});
}

const INTERNAL = Symbol('internal');

function createHeadersIterator(target, kind) {
	const iterator = Object.create(HeadersIteratorPrototype);
	iterator[INTERNAL] = {
		target,
		kind,
		index: 0
	};
	return iterator;
}

const HeadersIteratorPrototype = Object.setPrototypeOf({
	next() {
		// istanbul ignore if
		if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
			throw new TypeError('Value of `this` is not a HeadersIterator');
		}

		var _INTERNAL = this[INTERNAL];
		const target = _INTERNAL.target,
		      kind = _INTERNAL.kind,
		      index = _INTERNAL.index;

		const values = getHeaders(target, kind);
		const len = values.length;
		if (index >= len) {
			return {
				value: undefined,
				done: true
			};
		}

		this[INTERNAL].index = index + 1;

		return {
			value: values[index],
			done: false
		};
	}
}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));

Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
	value: 'HeadersIterator',
	writable: false,
	enumerable: false,
	configurable: true
});

/**
 * Export the Headers object in a form that Node.js can consume.
 *
 * @param   Headers  headers
 * @return  Object
 */
function exportNodeCompatibleHeaders(headers) {
	const obj = Object.assign({ __proto__: null }, headers[MAP]);

	// http.request() only supports string as Host header. This hack makes
	// specifying custom Host header possible.
	const hostHeaderKey = find(headers[MAP], 'Host');
	if (hostHeaderKey !== undefined) {
		obj[hostHeaderKey] = obj[hostHeaderKey][0];
	}

	return obj;
}

/**
 * Create a Headers object from an object of headers, ignoring those that do
 * not conform to HTTP grammar productions.
 *
 * @param   Object  obj  Object of headers
 * @return  Headers
 */
function createHeadersLenient(obj) {
	const headers = new Headers$1();
	for (const name of Object.keys(obj)) {
		if (invalidTokenRegex.test(name)) {
			continue;
		}
		if (Array.isArray(obj[name])) {
			for (const val of obj[name]) {
				if (invalidHeaderCharRegex.test(val)) {
					continue;
				}
				if (headers[MAP][name] === undefined) {
					headers[MAP][name] = [val];
				} else {
					headers[MAP][name].push(val);
				}
			}
		} else if (!invalidHeaderCharRegex.test(obj[name])) {
			headers[MAP][name] = [obj[name]];
		}
	}
	return headers;
}

const INTERNALS$1 = Symbol('Response internals');

// fix an issue where "STATUS_CODES" aren't a named export for node <10
const STATUS_CODES = http2.STATUS_CODES;

/**
 * Response class
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
let Response$1 = class Response {
	constructor() {
		let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
		let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		Body.call(this, body, opts);

		const status = opts.status || 200;
		const headers = new Headers$1(opts.headers);

		if (body != null && !headers.has('Content-Type')) {
			const contentType = extractContentType(body);
			if (contentType) {
				headers.append('Content-Type', contentType);
			}
		}

		this[INTERNALS$1] = {
			url: opts.url,
			status,
			statusText: opts.statusText || STATUS_CODES[status],
			headers,
			counter: opts.counter
		};
	}

	get url() {
		return this[INTERNALS$1].url || '';
	}

	get status() {
		return this[INTERNALS$1].status;
	}

	/**
  * Convenience property representing if the request ended normally
  */
	get ok() {
		return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
	}

	get redirected() {
		return this[INTERNALS$1].counter > 0;
	}

	get statusText() {
		return this[INTERNALS$1].statusText;
	}

	get headers() {
		return this[INTERNALS$1].headers;
	}

	/**
  * Clone this response
  *
  * @return  Response
  */
	clone() {
		return new Response(clone(this), {
			url: this.url,
			status: this.status,
			statusText: this.statusText,
			headers: this.headers,
			ok: this.ok,
			redirected: this.redirected
		});
	}
};

Body.mixIn(Response$1.prototype);

Object.defineProperties(Response$1.prototype, {
	url: { enumerable: true },
	status: { enumerable: true },
	ok: { enumerable: true },
	redirected: { enumerable: true },
	statusText: { enumerable: true },
	headers: { enumerable: true },
	clone: { enumerable: true }
});

Object.defineProperty(Response$1.prototype, Symbol.toStringTag, {
	value: 'Response',
	writable: false,
	enumerable: false,
	configurable: true
});

const INTERNALS$2 = Symbol('Request internals');
const URL$1 = Url.URL || publicApi.URL;

// fix an issue where "format", "parse" aren't a named export for node <10
const parse_url = Url.parse;
const format_url = Url.format;

/**
 * Wrapper around `new URL` to handle arbitrary URLs
 *
 * @param  {string} urlStr
 * @return {void}
 */
function parseURL(urlStr) {
	/*
 	Check whether the URL is absolute or not
 		Scheme: https://tools.ietf.org/html/rfc3986#section-3.1
 	Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3
 */
	if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
		urlStr = new URL$1(urlStr).toString();
	}

	// Fallback to old implementation for arbitrary URLs
	return parse_url(urlStr);
}

const streamDestructionSupported = 'destroy' in Stream.Readable.prototype;

/**
 * Check if a value is an instance of Request.
 *
 * @param   Mixed   input
 * @return  Boolean
 */
function isRequest(input) {
	return typeof input === 'object' && typeof input[INTERNALS$2] === 'object';
}

function isAbortSignal(signal) {
	const proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);
	return !!(proto && proto.constructor.name === 'AbortSignal');
}

/**
 * Request class
 *
 * @param   Mixed   input  Url or Request instance
 * @param   Object  init   Custom options
 * @return  Void
 */
let Request$1 = class Request {
	constructor(input) {
		let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		let parsedURL;

		// normalize input
		if (!isRequest(input)) {
			if (input && input.href) {
				// in order to support Node.js' Url objects; though WHATWG's URL objects
				// will fall into this branch also (since their `toString()` will return
				// `href` property anyway)
				parsedURL = parseURL(input.href);
			} else {
				// coerce input to a string before attempting to parse
				parsedURL = parseURL(`${input}`);
			}
			input = {};
		} else {
			parsedURL = parseURL(input.url);
		}

		let method = init.method || input.method || 'GET';
		method = method.toUpperCase();

		if ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {
			throw new TypeError('Request with GET/HEAD method cannot have body');
		}

		let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;

		Body.call(this, inputBody, {
			timeout: init.timeout || input.timeout || 0,
			size: init.size || input.size || 0
		});

		const headers = new Headers$1(init.headers || input.headers || {});

		if (inputBody != null && !headers.has('Content-Type')) {
			const contentType = extractContentType(inputBody);
			if (contentType) {
				headers.append('Content-Type', contentType);
			}
		}

		let signal = isRequest(input) ? input.signal : null;
		if ('signal' in init) signal = init.signal;

		if (signal != null && !isAbortSignal(signal)) {
			throw new TypeError('Expected signal to be an instanceof AbortSignal');
		}

		this[INTERNALS$2] = {
			method,
			redirect: init.redirect || input.redirect || 'follow',
			headers,
			parsedURL,
			signal
		};

		// node-fetch-only options
		this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
		this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;
		this.counter = init.counter || input.counter || 0;
		this.agent = init.agent || input.agent;
	}

	get method() {
		return this[INTERNALS$2].method;
	}

	get url() {
		return format_url(this[INTERNALS$2].parsedURL);
	}

	get headers() {
		return this[INTERNALS$2].headers;
	}

	get redirect() {
		return this[INTERNALS$2].redirect;
	}

	get signal() {
		return this[INTERNALS$2].signal;
	}

	/**
  * Clone this request
  *
  * @return  Request
  */
	clone() {
		return new Request(this);
	}
};

Body.mixIn(Request$1.prototype);

Object.defineProperty(Request$1.prototype, Symbol.toStringTag, {
	value: 'Request',
	writable: false,
	enumerable: false,
	configurable: true
});

Object.defineProperties(Request$1.prototype, {
	method: { enumerable: true },
	url: { enumerable: true },
	headers: { enumerable: true },
	redirect: { enumerable: true },
	clone: { enumerable: true },
	signal: { enumerable: true }
});

/**
 * Convert a Request to Node.js http request options.
 *
 * @param   Request  A Request instance
 * @return  Object   The options object to be passed to http.request
 */
function getNodeRequestOptions(request) {
	const parsedURL = request[INTERNALS$2].parsedURL;
	const headers = new Headers$1(request[INTERNALS$2].headers);

	// fetch step 1.3
	if (!headers.has('Accept')) {
		headers.set('Accept', '*/*');
	}

	// Basic fetch
	if (!parsedURL.protocol || !parsedURL.hostname) {
		throw new TypeError('Only absolute URLs are supported');
	}

	if (!/^https?:$/.test(parsedURL.protocol)) {
		throw new TypeError('Only HTTP(S) protocols are supported');
	}

	if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
		throw new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');
	}

	// HTTP-network-or-cache fetch steps 2.4-2.7
	let contentLengthValue = null;
	if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
		contentLengthValue = '0';
	}
	if (request.body != null) {
		const totalBytes = getTotalBytes(request);
		if (typeof totalBytes === 'number') {
			contentLengthValue = String(totalBytes);
		}
	}
	if (contentLengthValue) {
		headers.set('Content-Length', contentLengthValue);
	}

	// HTTP-network-or-cache fetch step 2.11
	if (!headers.has('User-Agent')) {
		headers.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');
	}

	// HTTP-network-or-cache fetch step 2.15
	if (request.compress && !headers.has('Accept-Encoding')) {
		headers.set('Accept-Encoding', 'gzip,deflate');
	}

	let agent = request.agent;
	if (typeof agent === 'function') {
		agent = agent(parsedURL);
	}

	// HTTP-network fetch step 4.2
	// chunked encoding is handled by Node.js

	return Object.assign({}, parsedURL, {
		method: request.method,
		headers: exportNodeCompatibleHeaders(headers),
		agent
	});
}

/**
 * abort-error.js
 *
 * AbortError interface for cancelled requests
 */

/**
 * Create AbortError instance
 *
 * @param   String      message      Error message for human
 * @return  AbortError
 */
function AbortError(message) {
  Error.call(this, message);

  this.type = 'aborted';
  this.message = message;

  // hide custom error implementation details from end-users
  Error.captureStackTrace(this, this.constructor);
}

AbortError.prototype = Object.create(Error.prototype);
AbortError.prototype.constructor = AbortError;
AbortError.prototype.name = 'AbortError';

const URL$1$1 = Url.URL || publicApi.URL;

// fix an issue where "PassThrough", "resolve" aren't a named export for node <10
const PassThrough$1 = Stream.PassThrough;

const isDomainOrSubdomain = function isDomainOrSubdomain(destination, original) {
	const orig = new URL$1$1(original).hostname;
	const dest = new URL$1$1(destination).hostname;

	return orig === dest || orig[orig.length - dest.length - 1] === '.' && orig.endsWith(dest);
};

/**
 * isSameProtocol reports whether the two provided URLs use the same protocol.
 *
 * Both domains must already be in canonical form.
 * @param {string|URL} original
 * @param {string|URL} destination
 */
const isSameProtocol = function isSameProtocol(destination, original) {
	const orig = new URL$1$1(original).protocol;
	const dest = new URL$1$1(destination).protocol;

	return orig === dest;
};

/**
 * Fetch function
 *
 * @param   Mixed    url   Absolute url or Request instance
 * @param   Object   opts  Fetch options
 * @return  Promise
 */
function fetch$1(url, opts) {

	// allow custom promise
	if (!fetch$1.Promise) {
		throw new Error('native promise missing, set fetch.Promise to your favorite alternative');
	}

	Body.Promise = fetch$1.Promise;

	// wrap http.request into fetch
	return new fetch$1.Promise(function (resolve, reject) {
		// build request object
		const request = new Request$1(url, opts);
		const options = getNodeRequestOptions(request);

		const send = (options.protocol === 'https:' ? https2 : http2).request;
		const signal = request.signal;

		let response = null;

		const abort = function abort() {
			let error = new AbortError('The user aborted a request.');
			reject(error);
			if (request.body && request.body instanceof Stream.Readable) {
				destroyStream(request.body, error);
			}
			if (!response || !response.body) return;
			response.body.emit('error', error);
		};

		if (signal && signal.aborted) {
			abort();
			return;
		}

		const abortAndFinalize = function abortAndFinalize() {
			abort();
			finalize();
		};

		// send request
		const req = send(options);
		let reqTimeout;

		if (signal) {
			signal.addEventListener('abort', abortAndFinalize);
		}

		function finalize() {
			req.abort();
			if (signal) signal.removeEventListener('abort', abortAndFinalize);
			clearTimeout(reqTimeout);
		}

		if (request.timeout) {
			req.once('socket', function (socket) {
				reqTimeout = setTimeout(function () {
					reject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));
					finalize();
				}, request.timeout);
			});
		}

		req.on('error', function (err) {
			reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));

			if (response && response.body) {
				destroyStream(response.body, err);
			}

			finalize();
		});

		fixResponseChunkedTransferBadEnding(req, function (err) {
			if (signal && signal.aborted) {
				return;
			}

			if (response && response.body) {
				destroyStream(response.body, err);
			}
		});

		/* c8 ignore next 18 */
		if (parseInt(process.version.substring(1)) < 14) {
			// Before Node.js 14, pipeline() does not fully support async iterators and does not always
			// properly handle when the socket close/end events are out of order.
			req.on('socket', function (s) {
				s.addListener('close', function (hadError) {
					// if a data listener is still present we didn't end cleanly
					const hasDataListener = s.listenerCount('data') > 0;

					// if end happened before close but the socket didn't emit an error, do it now
					if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
						const err = new Error('Premature close');
						err.code = 'ERR_STREAM_PREMATURE_CLOSE';
						response.body.emit('error', err);
					}
				});
			});
		}

		req.on('response', function (res) {
			clearTimeout(reqTimeout);

			const headers = createHeadersLenient(res.headers);

			// HTTP fetch step 5
			if (fetch$1.isRedirect(res.statusCode)) {
				// HTTP fetch step 5.2
				const location = headers.get('Location');

				// HTTP fetch step 5.3
				let locationURL = null;
				try {
					locationURL = location === null ? null : new URL$1$1(location, request.url).toString();
				} catch (err) {
					// error here can only be invalid URL in Location: header
					// do not throw when options.redirect == manual
					// let the user extract the errorneous redirect URL
					if (request.redirect !== 'manual') {
						reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));
						finalize();
						return;
					}
				}

				// HTTP fetch step 5.5
				switch (request.redirect) {
					case 'error':
						reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));
						finalize();
						return;
					case 'manual':
						// node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.
						if (locationURL !== null) {
							// handle corrupted header
							try {
								headers.set('Location', locationURL);
							} catch (err) {
								// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request
								reject(err);
							}
						}
						break;
					case 'follow':
						// HTTP-redirect fetch step 2
						if (locationURL === null) {
							break;
						}

						// HTTP-redirect fetch step 5
						if (request.counter >= request.follow) {
							reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));
							finalize();
							return;
						}

						// HTTP-redirect fetch step 6 (counter increment)
						// Create a new Request object.
						const requestOpts = {
							headers: new Headers$1(request.headers),
							follow: request.follow,
							counter: request.counter + 1,
							agent: request.agent,
							compress: request.compress,
							method: request.method,
							body: request.body,
							signal: request.signal,
							timeout: request.timeout,
							size: request.size
						};

						if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
							for (const name of ['authorization', 'www-authenticate', 'cookie', 'cookie2']) {
								requestOpts.headers.delete(name);
							}
						}

						// HTTP-redirect fetch step 9
						if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
							reject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));
							finalize();
							return;
						}

						// HTTP-redirect fetch step 11
						if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {
							requestOpts.method = 'GET';
							requestOpts.body = undefined;
							requestOpts.headers.delete('content-length');
						}

						// HTTP-redirect fetch step 15
						resolve(fetch$1(new Request$1(locationURL, requestOpts)));
						finalize();
						return;
				}
			}

			// prepare response
			res.once('end', function () {
				if (signal) signal.removeEventListener('abort', abortAndFinalize);
			});
			let body = res.pipe(new PassThrough$1());

			const response_options = {
				url: request.url,
				status: res.statusCode,
				statusText: res.statusMessage,
				headers: headers,
				size: request.size,
				timeout: request.timeout,
				counter: request.counter
			};

			// HTTP-network fetch step 12.1.1.3
			const codings = headers.get('Content-Encoding');

			// HTTP-network fetch step 12.1.1.4: handle content codings

			// in following scenarios we ignore compression support
			// 1. compression support is disabled
			// 2. HEAD request
			// 3. no Content-Encoding header
			// 4. no content response (204)
			// 5. content not modified response (304)
			if (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {
				response = new Response$1(body, response_options);
				resolve(response);
				return;
			}

			// For Node v6+
			// Be less strict when decoding compressed responses, since sometimes
			// servers send slightly invalid responses that are still accepted
			// by common browsers.
			// Always using Z_SYNC_FLUSH is what cURL does.
			const zlibOptions = {
				flush: zlib.Z_SYNC_FLUSH,
				finishFlush: zlib.Z_SYNC_FLUSH
			};

			// for gzip
			if (codings == 'gzip' || codings == 'x-gzip') {
				body = body.pipe(zlib.createGunzip(zlibOptions));
				response = new Response$1(body, response_options);
				resolve(response);
				return;
			}

			// for deflate
			if (codings == 'deflate' || codings == 'x-deflate') {
				// handle the infamous raw deflate response from old servers
				// a hack for old IIS and Apache servers
				const raw = res.pipe(new PassThrough$1());
				raw.once('data', function (chunk) {
					// see http://stackoverflow.com/questions/37519828
					if ((chunk[0] & 0x0F) === 0x08) {
						body = body.pipe(zlib.createInflate());
					} else {
						body = body.pipe(zlib.createInflateRaw());
					}
					response = new Response$1(body, response_options);
					resolve(response);
				});
				raw.on('end', function () {
					// some old IIS servers return zero-length OK deflate responses, so 'data' is never emitted.
					if (!response) {
						response = new Response$1(body, response_options);
						resolve(response);
					}
				});
				return;
			}

			// for br
			if (codings == 'br' && typeof zlib.createBrotliDecompress === 'function') {
				body = body.pipe(zlib.createBrotliDecompress());
				response = new Response$1(body, response_options);
				resolve(response);
				return;
			}

			// otherwise, use response as-is
			response = new Response$1(body, response_options);
			resolve(response);
		});

		writeToStream(req, request);
	});
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
	let socket;

	request.on('socket', function (s) {
		socket = s;
	});

	request.on('response', function (response) {
		const headers = response.headers;

		if (headers['transfer-encoding'] === 'chunked' && !headers['content-length']) {
			response.once('close', function (hadError) {
				// tests for socket presence, as in some situations the
				// the 'socket' event is not triggered for the request
				// (happens in deno), avoids `TypeError`
				// if a data listener is still present we didn't end cleanly
				const hasDataListener = socket && socket.listenerCount('data') > 0;

				if (hasDataListener && !hadError) {
					const err = new Error('Premature close');
					err.code = 'ERR_STREAM_PREMATURE_CLOSE';
					errorCallback(err);
				}
			});
		}
	});
}

function destroyStream(stream, err) {
	if (stream.destroy) {
		stream.destroy(err);
	} else {
		// node < 8
		stream.emit('error', err);
		stream.end();
	}
}

/**
 * Redirect code matching
 *
 * @param   Number   code  Status code
 * @return  Boolean
 */
fetch$1.isRedirect = function (code) {
	return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
};

// expose Promise
fetch$1.Promise = global.Promise;

var lib$3 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AbortError: AbortError,
    FetchError: FetchError,
    Headers: Headers$1,
    Request: Request$1,
    Response: Response$1,
    default: fetch$1
});

var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(lib$3);

(function (module, exports) {
	const nodeFetch = require$$0$1;
	const realFetch = nodeFetch.default || nodeFetch;

	const fetch = function (url, options) {
	  // Support schemaless URIs on the server for parity with the browser.
	  // Ex: //github.com/ -> https://github.com/
	  if (/^\/\//.test(url)) {
	    url = 'https:' + url;
	  }
	  return realFetch.call(this, url, options)
	};

	fetch.ponyfill = true;

	module.exports = exports = fetch;
	exports.fetch = fetch;
	exports.Headers = nodeFetch.Headers;
	exports.Request = nodeFetch.Request;
	exports.Response = nodeFetch.Response;

	// Needed for TypeScript consumers without esModuleInterop.
	exports.default = fetch; 
} (nodePonyfill, nodePonyfill.exports));

var nodePonyfillExports = nodePonyfill.exports;

(function (exports) {
	// This file exists to help normalize process.env amongst the backend
	// and frontend.  Many frontends (eg. Next, CRA) utilize webpack's DefinePlugin
	// along with prefixes, meaning we have to explicitly use the full `process.env.FOO`
	// string in order to read variables.
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.parseAsBoolean = exports.getResponse = exports.getFetch = exports.platformSupportsStreaming = exports.getPlatformName = exports.inngestHeaders = exports.allProcessEnv = exports.processEnv = exports.getEnvironmentName = exports.getMode = exports.Mode = exports.devServerHost = void 0;
	const version_js_1 = version;
	const consts_js_1 = consts;
	const strings_js_1 = strings;
	/**
	 * devServerHost returns the dev server host by searching for the INNGEST_DEVSERVER_URL
	 * environment variable (plus project prefixces for eg. react, such as REACT_APP_INNGEST_DEVSERVER_URL).
	 *
	 * If not found this returns undefined, indicating that the env var has not been set.
	 *
	 * @example devServerHost()
	 */
	const devServerHost = (env = (0, exports.allProcessEnv)()) => {
	    // devServerKeys are the env keys we search for to discover the dev server
	    // URL.  This includes the standard key first, then includes prefixed keys
	    // for use within common frameworks (eg. CRA, next).
	    //
	    // We have to fully write these using process.env as they're typically
	    // processed using webpack's DefinePlugin, which is dumb and does a straight
	    // text replacement instead of actually understanding the AST, despite webpack
	    // being fully capable of understanding the AST.
	    const prefixes = ["REACT_APP_", "NEXT_PUBLIC_"];
	    const keys = [consts_js_1.envKeys.InngestBaseUrl, consts_js_1.envKeys.InngestDevMode];
	    const values = keys.flatMap((key) => {
	        return prefixes.map((prefix) => {
	            return env[prefix + key];
	        });
	    });
	    return values.find((v) => {
	        if (!v) {
	            return;
	        }
	        try {
	            return Boolean(new URL(v));
	        }
	        catch (_a) {
	            // no-op
	        }
	    });
	};
	exports.devServerHost = devServerHost;
	const checkFns = ((checks) => checks)({
	    equals: (actual, expected) => actual === expected,
	    "starts with": (actual, expected) => { var _a; return expected ? (_a = actual === null || actual === void 0 ? void 0 : actual.startsWith(expected)) !== null && _a !== void 0 ? _a : false : false; },
	    "is truthy": (actual) => Boolean(actual),
	    "is truthy but not": (actual, expected) => Boolean(actual) && actual !== expected,
	});
	const prodChecks = [
	    ["CF_PAGES", "equals", "1"],
	    ["CONTEXT", "starts with", "prod"],
	    ["ENVIRONMENT", "starts with", "prod"],
	    ["NODE_ENV", "starts with", "prod"],
	    ["VERCEL_ENV", "starts with", "prod"],
	    ["DENO_DEPLOYMENT_ID", "is truthy"],
	    [consts_js_1.envKeys.VercelEnvKey, "is truthy but not", "development"],
	    [consts_js_1.envKeys.IsNetlify, "is truthy"],
	    [consts_js_1.envKeys.IsRender, "is truthy"],
	    [consts_js_1.envKeys.RailwayBranch, "is truthy"],
	    [consts_js_1.envKeys.IsCloudflarePages, "is truthy"],
	];
	class Mode {
	    constructor({ type, isExplicit, explicitDevUrl, env = (0, exports.allProcessEnv)(), }) {
	        this.env = env;
	        this.type = type;
	        this.isExplicit = isExplicit || Boolean(explicitDevUrl);
	        this.explicitDevUrl = explicitDevUrl;
	    }
	    get isDev() {
	        return this.type === "dev";
	    }
	    get isCloud() {
	        return this.type === "cloud";
	    }
	    get isInferred() {
	        return !this.isExplicit;
	    }
	    /**
	     * If we are explicitly in a particular mode, retrieve the URL that we are
	     * sure we should be using, not considering any environment variables or other
	     * influences.
	     */
	    getExplicitUrl(defaultCloudUrl) {
	        if (!this.isExplicit) {
	            return undefined;
	        }
	        if (this.explicitDevUrl) {
	            return this.explicitDevUrl.href;
	        }
	        if (this.isCloud) {
	            return defaultCloudUrl;
	        }
	        if (this.isDev) {
	            return consts_js_1.defaultDevServerHost;
	        }
	        return undefined;
	    }
	}
	exports.Mode = Mode;
	/**
	 * Returns the mode of the current environment, based off of either passed
	 * environment variables or `process.env`, or explicit settings.
	 */
	const getMode = ({ env = (0, exports.allProcessEnv)(), client, explicitMode, } = {}) => {
	    if (explicitMode) {
	        return new Mode({ type: explicitMode, isExplicit: true, env });
	    }
	    if (client === null || client === void 0 ? void 0 : client["mode"].isExplicit) {
	        return client["mode"];
	    }
	    if (consts_js_1.envKeys.InngestDevMode in env) {
	        if (typeof env[consts_js_1.envKeys.InngestDevMode] === "string") {
	            try {
	                const explicitDevUrl = new URL(env[consts_js_1.envKeys.InngestDevMode]);
	                return new Mode({ type: "dev", isExplicit: true, explicitDevUrl, env });
	            }
	            catch (_a) {
	                // no-op
	            }
	        }
	        const envIsDev = (0, exports.parseAsBoolean)(env[consts_js_1.envKeys.InngestDevMode]);
	        if (typeof envIsDev === "boolean") {
	            return new Mode({
	                type: envIsDev ? "dev" : "cloud",
	                isExplicit: true,
	                env,
	            });
	        }
	    }
	    const isProd = prodChecks.some(([key, checkKey, expected]) => {
	        return checkFns[checkKey]((0, strings_js_1.stringifyUnknown)(env[key]), expected);
	    });
	    return new Mode({ type: isProd ? "cloud" : "dev", isExplicit: false, env });
	};
	exports.getMode = getMode;
	/**
	 * getEnvironmentName returns the suspected branch name for this environment by
	 * searching through a set of common environment variables.
	 *
	 * This could be used to determine if we're on a branch deploy or not, though it
	 * should be noted that we don't know if this is the default branch or not.
	 */
	const getEnvironmentName = (env = (0, exports.allProcessEnv)()) => {
	    /**
	     * Order is important; more than one of these env vars may be set, so ensure
	     * that we check the most specific, most reliable env vars first.
	     */
	    return (env[consts_js_1.envKeys.InngestEnvironment] ||
	        env[consts_js_1.envKeys.BranchName] ||
	        env[consts_js_1.envKeys.VercelBranch] ||
	        env[consts_js_1.envKeys.NetlifyBranch] ||
	        env[consts_js_1.envKeys.CloudflarePagesBranch] ||
	        env[consts_js_1.envKeys.RenderBranch] ||
	        env[consts_js_1.envKeys.RailwayBranch]);
	};
	exports.getEnvironmentName = getEnvironmentName;
	const processEnv = (key) => {
	    return (0, exports.allProcessEnv)()[key];
	};
	exports.processEnv = processEnv;
	/**
	 * allProcessEnv returns the current process environment variables, or an empty
	 * object if they cannot be read, making sure we support environments other than
	 * Node such as Deno, too.
	 *
	 * Using this ensures we don't dangerously access `process.env` in environments
	 * where it may not be defined, such as Deno or the browser.
	 */
	const allProcessEnv = () => {
	    // Node, or Node-like environments
	    try {
	        // eslint-disable-next-line @inngest/internal/process-warn
	        if (process.env) {
	            // eslint-disable-next-line @inngest/internal/process-warn
	            return process.env;
	        }
	    }
	    catch (_err) {
	        // noop
	    }
	    // Deno
	    try {
	        const env = Deno.env.toObject();
	        if (env) {
	            return env;
	        }
	    }
	    catch (_err) {
	        // noop
	    }
	    // Netlify
	    try {
	        const env = Netlify.env.toObject();
	        if (env) {
	            return env;
	        }
	    }
	    catch (_err) {
	        // noop
	    }
	    return {};
	};
	exports.allProcessEnv = allProcessEnv;
	/**
	 * Generate a standardised set of headers based on input and environment
	 * variables.
	 *
	 *
	 */
	const inngestHeaders = (opts) => {
	    var _a;
	    const sdkVersion = `inngest-js:v${version_js_1.version}`;
	    const headers = {
	        "Content-Type": "application/json",
	        "User-Agent": sdkVersion,
	        [consts_js_1.headerKeys.SdkVersion]: sdkVersion,
	    };
	    if (opts === null || opts === void 0 ? void 0 : opts.framework) {
	        headers[consts_js_1.headerKeys.Framework] = opts.framework;
	    }
	    if (opts === null || opts === void 0 ? void 0 : opts.expectedServerKind) {
	        headers[consts_js_1.headerKeys.InngestExpectedServerKind] = opts.expectedServerKind;
	    }
	    const env = Object.assign(Object.assign({}, (0, exports.allProcessEnv)()), opts === null || opts === void 0 ? void 0 : opts.env);
	    const inngestEnv = (opts === null || opts === void 0 ? void 0 : opts.inngestEnv) || (0, exports.getEnvironmentName)(env);
	    if (inngestEnv) {
	        headers[consts_js_1.headerKeys.Environment] = inngestEnv;
	    }
	    const platform = (0, exports.getPlatformName)(env);
	    if (platform) {
	        headers[consts_js_1.headerKeys.Platform] = platform;
	    }
	    return Object.assign(Object.assign(Object.assign({}, headers), (_a = opts === null || opts === void 0 ? void 0 : opts.client) === null || _a === void 0 ? void 0 : _a["headers"]), opts === null || opts === void 0 ? void 0 : opts.extras);
	};
	exports.inngestHeaders = inngestHeaders;
	/**
	 * A set of checks that, given an environment, will return `true` if the current
	 * environment is running on the platform with the given name.
	 */
	const platformChecks = {
	    /**
	     * Vercel Edge Functions don't have access to environment variables unless
	     * they are explicitly referenced in the top level code, but they do have a
	     * global `EdgeRuntime` variable set that we can use to detect this.
	     */
	    vercel: (env) => env[consts_js_1.envKeys.IsVercel] === "1" || typeof EdgeRuntime === "string",
	    netlify: (env) => env[consts_js_1.envKeys.IsNetlify] === "true",
	    "cloudflare-pages": (env) => env[consts_js_1.envKeys.IsCloudflarePages] === "1",
	    render: (env) => env[consts_js_1.envKeys.IsRender] === "true",
	    railway: (env) => Boolean(env[consts_js_1.envKeys.RailwayEnvironment]),
	};
	/**
	 * A set of checks that, given an environment, will return `true` if the current
	 * environment and platform supports streaming responses back to Inngest.
	 *
	 * Streaming capability is both framework and platform-based. Frameworks are
	 * supported in serve handlers, and platforms are checked here.
	 *
	 * As such, this record declares which platforms we explicitly support for
	 * streaming and is used by {@link platformSupportsStreaming}.
	 */
	const streamingChecks = {
	    /**
	     * "Vercel supports streaming for Serverless Functions, Edge Functions, and
	     * React Server Components in Next.js projects."
	     *
	     * In practice, however, there are many reports of streaming not working as
	     * expected on Serverless Functions, so we resort to only allowing streaming
	     * for Edge Functions here.
	     *
	     * See {@link https://vercel.com/docs/frameworks/nextjs#streaming}
	     */
	    vercel: (_framework, _env) => typeof EdgeRuntime === "string",
	    "cloudflare-pages": () => true,
	};
	const getPlatformName = (env) => {
	    return Object.keys(platformChecks).find((key) => {
	        return platformChecks[key](env);
	    });
	};
	exports.getPlatformName = getPlatformName;
	/**
	 * Returns `true` if we believe the current environment supports streaming
	 * responses back to Inngest.
	 *
	 * We run a check directly related to the platform we believe we're running on,
	 * usually based on environment variables.
	 */
	const platformSupportsStreaming = (framework, env = (0, exports.allProcessEnv)()) => {
	    var _a, _b;
	    return ((_b = (_a = streamingChecks[(0, exports.getPlatformName)(env)]) === null || _a === void 0 ? void 0 : _a.call(streamingChecks, framework, env)) !== null && _b !== void 0 ? _b : false);
	};
	exports.platformSupportsStreaming = platformSupportsStreaming;
	/**
	 * A unique symbol used to mark a custom fetch implementation. We wrap the
	 * implementations to provide some extra control when handling errors.
	 */
	const CUSTOM_FETCH_MARKER = Symbol("Custom fetch implementation");
	/**
	 * Given a potential fetch function, return the fetch function to use based on
	 * this and the environment.
	 */
	const getFetch = (givenFetch) => {
	    /**
	     * If we've explicitly been given a fetch function, use that.
	     */
	    if (givenFetch) {
	        if (CUSTOM_FETCH_MARKER in givenFetch) {
	            return givenFetch;
	        }
	        /**
	         * We wrap the given fetch function to provide some extra control when
	         * handling errors.
	         */
	        const customFetch = async (...args) => {
	            var _a;
	            try {
	                return await givenFetch(...args);
	            }
	            catch (err) {
	                /**
	                 * Capture warnings that are not simple fetch failures and highlight
	                 * them for the user.
	                 *
	                 * We also use this opportunity to log the causing error, as code higher
	                 * up the stack will likely abstract this.
	                 */
	                if (!(err instanceof Error) ||
	                    !((_a = err.message) === null || _a === void 0 ? void 0 : _a.startsWith("fetch failed"))) {
	                    console.warn("A request failed when using a custom fetch implementation; this may be a misconfiguration. Make sure that your fetch client is correctly bound to the global scope.");
	                    console.error(err);
	                }
	                throw err;
	            }
	        };
	        /**
	         * Mark the custom fetch implementation so that we can identify it later, in
	         * addition to adding some runtime properties to it to make it seem as much
	         * like the original fetch as possible.
	         */
	        Object.defineProperties(customFetch, {
	            [CUSTOM_FETCH_MARKER]: {},
	            name: { value: givenFetch.name },
	            length: { value: givenFetch.length },
	        });
	        return customFetch;
	    }
	    /**
	     * Browser or Node 18+
	     */
	    try {
	        if (typeof globalThis !== "undefined" && "fetch" in globalThis) {
	            return fetch.bind(globalThis);
	        }
	    }
	    catch (err) {
	        // no-op
	    }
	    /**
	     * Existing polyfilled fetch
	     */
	    if (typeof fetch !== "undefined") {
	        return fetch;
	    }
	    /**
	     * Environments where fetch cannot be found and must be polyfilled
	     */
	    // eslint-disable-next-line @typescript-eslint/no-var-requires
	    return nodePonyfillExports;
	};
	exports.getFetch = getFetch;
	/**
	 * If `Response` isn't included in this environment, it's probably an earlier
	 * Node env that isn't already polyfilling. This function returns either the
	 * native `Response` or a polyfilled one.
	 */
	const getResponse = () => {
	    if (typeof Response !== "undefined") {
	        return Response;
	    }
	    // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-var-requires
	    return nodePonyfillExports.Response;
	};
	exports.getResponse = getResponse;
	/**
	 * Given an unknown value, try to parse it as a `boolean`. Useful for parsing
	 * environment variables that could be a selection of different values such as
	 * `"true"`, `"1"`.
	 *
	 * If the value could not be confidently parsed as a `boolean` or was seen to be
	 * `undefined`, this function returns `undefined`.
	 */
	const parseAsBoolean = (value) => {
	    if (typeof value === "boolean") {
	        return value;
	    }
	    if (typeof value === "number") {
	        return Boolean(value);
	    }
	    if (typeof value === "string") {
	        const trimmed = value.trim().toLowerCase();
	        if (trimmed === "undefined") {
	            return undefined;
	        }
	        if (["true", "1"].includes(trimmed)) {
	            return true;
	        }
	        return false;
	    }
	    return undefined;
	};
	exports.parseAsBoolean = parseAsBoolean;
	
} (env$3));

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.devServerHost = exports.devServerUrl = exports.devServerAvailable = void 0;
	const consts_js_1 = consts;
	const env_js_1 = env$3;
	/**
	 * Attempts to contact the dev server, returning a boolean indicating whether or
	 * not it was successful.
	 *
	 * @example devServerUrl(process.env[envKeys.DevServerUrl], "/your-path")
	 */
	const devServerAvailable = async (
	/**
	 * The host of the dev server. You should pass in an environment variable as
	 * this parameter.
	 */
	host = consts_js_1.defaultDevServerHost, 
	/**
	 * The fetch implementation to use to communicate with the dev server.
	 */
	fetch) => {
	    try {
	        const url = (0, exports.devServerUrl)(host, "/dev");
	        const result = await fetch(url.toString());
	        await result.json();
	        return true;
	    }
	    catch (e) {
	        return false;
	    }
	};
	exports.devServerAvailable = devServerAvailable;
	/**
	 * devServerUrl returns a full URL for the given path name.
	 *
	 * Because Cloudflare/V8 platforms don't allow process.env, you are expected
	 * to pass in the host from the dev server env key:
	 *
	 * @example devServerUrl(processEnv(envKeys.DevServerUrl), "/your-path")
	 * @example devServerUrl("http://localhost:8288/", "/your-path")
	 */
	const devServerUrl = (host = (0, exports.devServerHost)(), pathname = "") => {
	    return new URL(pathname, host.includes("://") ? host : `http://${host}`);
	};
	exports.devServerUrl = devServerUrl;
	/**
	 * devServerHost exports the development server's domain by inspecting env
	 * variables, or returns the default development server URL.
	 *
	 * This guarantees a specific URL as a string, as opposed to the env export
	 * which only returns a value of the env var is set.
	 */
	const devServerHost = () => (0, env_js_1.devServerHost)() || consts_js_1.defaultDevServerHost;
	exports.devServerHost = devServerHost;
	
} (devserver));

var net = {};

var __importDefault$1$1 = (net && net.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(net, "__esModule", { value: true });
net.fetchWithAuthFallback = fetchWithAuthFallback;
net.signDataWithKey = signDataWithKey;
const canonicalize_1 = __importDefault$1$1(canonicalize);
const hash_js_1 = hash;
/**
 * Send an HTTP request with the given signing key. If the response is a 401 or
 * 403, then try again with the fallback signing key
 */
async function fetchWithAuthFallback({ authToken, authTokenFallback, fetch, options, url, }) {
    let res = await fetch(url, Object.assign(Object.assign({}, options), { headers: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.headers), { Authorization: `Bearer ${authToken}` }) }));
    if ([401, 403].includes(res.status) && authTokenFallback) {
        res = await fetch(url, Object.assign(Object.assign({}, options), { headers: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.headers), { Authorization: `Bearer ${authTokenFallback}` }) }));
    }
    return res;
}
function signDataWithKey(data, signingKey, ts) {
    // Calculate the HMAC of the request body ourselves.
    // We make the assumption here that a stringified body is the same as the
    // raw bytes; it may be pertinent in the future to always parse, then
    // canonicalize the body to ensure it's consistent.
    const encoded = typeof data === "string" ? data : (0, canonicalize_1.default)(data);
    // Remove the `/signkey-[test|prod]-/` prefix from our signing key to calculate the HMAC.
    const key = signingKey.replace(/signkey-\w+-/, "");
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any
    const mac = (0, hash_js_1.hmac)(hash_js_1.sha256, key)
        .update(encoded)
        .update(ts)
        .digest("hex");
    return mac;
}

Object.defineProperty(api$1, "__esModule", { value: true });
api$1.InngestApi = void 0;
const zod_1$1$1 = lib$2;
const consts_js_1$1 = consts;
const devserver_js_1$1 = devserver;
const errors_js_1$1 = errors$2;
const net_js_1$1 = net;
const strings_js_1$2 = strings;
const types_js_1$1 = types$2;
const schema_js_1 = schema;
const realtimeSubscriptionTokenSchema = zod_1$1$1.z.object({
    jwt: zod_1$1$1.z.string(),
});
class InngestApi {
    constructor({ baseUrl, signingKey, signingKeyFallback, fetch, mode, }) {
        this.apiBaseUrl = baseUrl;
        this.signingKey = signingKey;
        this.signingKeyFallback = signingKeyFallback;
        this.fetch = fetch;
        this.mode = mode;
    }
    get hashedKey() {
        return (0, strings_js_1$2.hashSigningKey)(this.signingKey);
    }
    get hashedFallbackKey() {
        if (!this.signingKeyFallback) {
            return;
        }
        return (0, strings_js_1$2.hashSigningKey)(this.signingKeyFallback);
    }
    // set the signing key in case it was not instantiated previously
    setSigningKey(key) {
        if (typeof key === "string" && this.signingKey === "") {
            this.signingKey = key;
        }
    }
    setSigningKeyFallback(key) {
        if (typeof key === "string" && !this.signingKeyFallback) {
            this.signingKeyFallback = key;
        }
    }
    async getTargetUrl(path) {
        if (this.apiBaseUrl) {
            return new URL(path, this.apiBaseUrl);
        }
        let url = new URL(path, consts_js_1$1.defaultInngestApiBaseUrl);
        if (this.mode.isDev && this.mode.isInferred && !this.apiBaseUrl) {
            const devAvailable = await (0, devserver_js_1$1.devServerAvailable)(consts_js_1$1.defaultDevServerHost, this.fetch);
            if (devAvailable) {
                url = new URL(path, consts_js_1$1.defaultDevServerHost);
            }
        }
        return url;
    }
    async getRunSteps(runId, version) {
        return (0, net_js_1$1.fetchWithAuthFallback)({
            authToken: this.hashedKey,
            authTokenFallback: this.hashedFallbackKey,
            fetch: this.fetch,
            url: await this.getTargetUrl(`/v0/runs/${runId}/actions`),
        })
            .then(async (resp) => {
            const data = await resp.json();
            if (resp.ok) {
                return (0, types_js_1$1.ok)(schema_js_1.stepsSchemas[version].parse(data));
            }
            else {
                return (0, types_js_1$1.err)(schema_js_1.errorSchema.parse(data));
            }
        })
            .catch((error) => {
            return (0, types_js_1$1.err)({
                error: (0, errors_js_1$1.getErrorMessage)(error, "Unknown error retrieving step data"),
                status: 500,
            });
        });
    }
    async getRunBatch(runId) {
        return (0, net_js_1$1.fetchWithAuthFallback)({
            authToken: this.hashedKey,
            authTokenFallback: this.hashedFallbackKey,
            fetch: this.fetch,
            url: await this.getTargetUrl(`/v0/runs/${runId}/batch`),
        })
            .then(async (resp) => {
            const data = await resp.json();
            if (resp.ok) {
                return (0, types_js_1$1.ok)(schema_js_1.batchSchema.parse(data));
            }
            else {
                return (0, types_js_1$1.err)(schema_js_1.errorSchema.parse(data));
            }
        })
            .catch((error) => {
            return (0, types_js_1$1.err)({
                error: (0, errors_js_1$1.getErrorMessage)(error, "Unknown error retrieving event batch"),
                status: 500,
            });
        });
    }
    async publish(publishOptions, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    data) {
        // todo it may not be a "text/stream"
        const isStream = data instanceof ReadableStream;
        const url = await this.getTargetUrl("/v1/realtime/publish");
        url.searchParams.set("channel", publishOptions.channel || "");
        if (publishOptions.runId) {
            url.searchParams.set("run_id", publishOptions.runId);
        }
        publishOptions.topics.forEach((topic) => {
            url.searchParams.append("topic", topic);
        });
        return (0, net_js_1$1.fetchWithAuthFallback)({
            authToken: this.hashedKey,
            authTokenFallback: this.hashedFallbackKey,
            fetch: this.fetch,
            url,
            options: Object.assign({ method: "POST", body: isStream
                    ? data
                    : typeof data === "string"
                        ? data
                        : JSON.stringify(data), headers: {
                    "Content-Type": isStream ? "text/stream" : "application/json",
                } }, (isStream ? { duplex: "half" } : {})),
        })
            .then((res) => {
            if (!res.ok) {
                throw new Error(`Failed to publish event: ${res.status} ${res.statusText}`);
            }
            return (0, types_js_1$1.ok)(undefined);
        })
            .catch((error) => {
            return (0, types_js_1$1.err)({
                error: (0, errors_js_1$1.getErrorMessage)(error, "Unknown error publishing event"),
                status: 500,
            });
        });
    }
    async getSubscriptionToken(channel, topics) {
        const url = await this.getTargetUrl("/v1/realtime/token");
        const body = topics.map((topic) => ({
            channel,
            name: topic,
            kind: "run",
        }));
        return (0, net_js_1$1.fetchWithAuthFallback)({
            authToken: this.hashedKey,
            authTokenFallback: this.hashedFallbackKey,
            fetch: this.fetch,
            url,
            options: {
                method: "POST",
                body: JSON.stringify(body),
                headers: {
                    "Content-Type": "application/json",
                },
            },
        })
            .then(async (res) => {
            if (!res.ok) {
                throw new Error(`Failed to get subscription token: ${res.status} ${res.statusText} - ${await res.text()}`);
            }
            const data = realtimeSubscriptionTokenSchema.parse(await res.json());
            return data.jwt;
        })
            .catch((error) => {
            throw new Error((0, errors_js_1$1.getErrorMessage)(error, "Unknown error getting subscription token"));
        });
    }
}
api$1.InngestApi = InngestApi;

var logger = {};

Object.defineProperty(logger, "__esModule", { value: true });
logger.ProxyLogger = logger.DefaultLogger = void 0;
class DefaultLogger {
    info(...args) {
        console.info(...args);
    }
    warn(...args) {
        console.warn(...args);
    }
    error(...args) {
        console.error(...args);
    }
    debug(...args) {
        console.debug(...args);
    }
}
logger.DefaultLogger = DefaultLogger;
/**
 * ProxyLogger aims to provide a thin wrapper on user's provided logger.
 * It's expected to be turned on and off based on the function execution
 * context, so it doesn't result in duplicated logging.
 *
 * And also attempt to allow enough time for the logger to flush all logs.
 *
 * @public
 */
class ProxyLogger {
    constructor(logger) {
        this.enabled = false;
        this.logger = logger;
    }
    info(...args) {
        if (!this.enabled)
            return;
        this.logger.info(...args);
    }
    warn(...args) {
        if (!this.enabled)
            return;
        this.logger.warn(...args);
    }
    error(...args) {
        if (!this.enabled)
            return;
        this.logger.error(...args);
    }
    debug(...args) {
        // there are loggers that don't implement "debug" by default
        if (!this.enabled || !(typeof this.logger.debug === "function"))
            return;
        this.logger.debug(...args);
    }
    enable() {
        this.enabled = true;
    }
    disable() {
        this.enabled = false;
    }
    async flush() {
        // Allow 1s for the provided logger to handle flushing since the ones that do
        // flushing usually has some kind of timeout of up to 1s.
        //
        // TODO:
        // This should only happen when using a serverless environment because it's very
        // costly from the compute perspective.
        // server runtimes should just let the logger do their thing since most of them
        // should have already figured what to do in those environments, be it threading or
        // something else.
        if (this.logger.constructor.name !== DefaultLogger.name) {
            await new Promise((resolve) => {
                setTimeout(() => resolve(null), 1000);
            });
        }
    }
}
logger.ProxyLogger = ProxyLogger;

var crypto$1 = {};

Object.defineProperty(crypto$1, "__esModule", { value: true });
crypto$1.createEntropy = createEntropy;
/**
 * Create a cryptographically secure random value.
 *
 * @throws {Error} If the crypto module is not available.
 */
function createEntropy(byteLength) {
    const bytes = new Uint8Array(byteLength);
    // https://developer.mozilla.org/en-US/docs/Web/API/Crypto#browser_compatibility
    const { crypto } = globalThis;
    if (!crypto) {
        // This should only happen in Node <19.
        throw new Error("missing crypto module");
    }
    if (!crypto.getRandomValues) {
        throw new Error("missing crypto.getRandomValues");
    }
    crypto.getRandomValues(bytes);
    return bytes;
}

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.builtInMiddleware = exports.Inngest = void 0;
	const api_js_1 = api$1;
	const consts_js_1 = consts;
	const devserver_js_1 = devserver;
	const env_js_1 = env$3;
	const errors_js_1 = errors$2;
	const promises_js_1 = promises;
	const strings_js_1 = strings;
	const logger_js_1 = logger;
	const types_js_1 = types$2;
	const InngestFunction_js_1 = InngestFunction$1;
	const InngestMiddleware_js_1 = InngestMiddleware$1;
	const crypto_js_1 = crypto$1;
	/**
	 * A client used to interact with the Inngest API by sending or reacting to
	 * events.
	 *
	 * To provide event typing, see {@link EventSchemas}.
	 *
	 * ```ts
	 * const inngest = new Inngest({ id: "my-app" });
	 *
	 * // or to provide event typing too
	 * const inngest = new Inngest({
	 *   id: "my-app",
	 *   schemas: new EventSchemas().fromRecord<{
	 *     "app/user.created": {
	 *       data: { userId: string };
	 *     };
	 *   }>(),
	 * });
	 * ```
	 *
	 * @public
	 */
	class Inngest {
	    get apiBaseUrl() {
	        return this._apiBaseUrl;
	    }
	    get eventBaseUrl() {
	        return this._eventBaseUrl;
	    }
	    get env() {
	        var _a;
	        return (_a = this.headers[consts_js_1.headerKeys.Environment]) !== null && _a !== void 0 ? _a : null;
	    }
	    get appVersion() {
	        return this._appVersion;
	    }
	    /**
	     * A client used to interact with the Inngest API by sending or reacting to
	     * events.
	     *
	     * To provide event typing, see {@link EventSchemas}.
	     *
	     * ```ts
	     * const inngest = new Inngest({ name: "My App" });
	     *
	     * // or to provide event typing too
	     * const inngest = new Inngest({
	     *   name: "My App",
	     *   schemas: new EventSchemas().fromRecord<{
	     *     "app/user.created": {
	     *       data: { userId: string };
	     *     };
	     *   }>(),
	     * });
	     * ```
	     */
	    constructor(options) {
	        /**
	         * Inngest event key, used to send events to Inngest Cloud.
	         */
	        this.eventKey = "";
	        /**
	         * The absolute URL of the Inngest Cloud API.
	         */
	        this.sendEventUrl = new URL(`e/${this.eventKey}`, consts_js_1.defaultInngestEventBaseUrl);
	        this.localFns = [];
	        this.createFunction = (rawOptions, rawTrigger, handler) => {
	            const fn = this._createFunction(rawOptions, rawTrigger, handler);
	            this.localFns.push(fn);
	            return fn;
	        };
	        this._createFunction = (rawOptions, rawTrigger, handler) => {
	            const options = this.sanitizeOptions(rawOptions);
	            const triggers = this.sanitizeTriggers(rawTrigger);
	            return new InngestFunction_js_1.InngestFunction(this, Object.assign(Object.assign({}, options), { triggers }), handler);
	        };
	        this.options = options;
	        const { id, fetch, logger = new logger_js_1.DefaultLogger(), middleware, isDev, schemas, appVersion, } = this.options;
	        if (!id) {
	            // TODO PrettyError
	            throw new Error("An `id` must be passed to create an Inngest instance.");
	        }
	        this.id = id;
	        this._mode = (0, env_js_1.getMode)({
	            explicitMode: typeof isDev === "boolean" ? (isDev ? "dev" : "cloud") : undefined,
	        });
	        this.fetch = (0, env_js_1.getFetch)(fetch);
	        this.inngestApi = new api_js_1.InngestApi({
	            baseUrl: this.apiBaseUrl,
	            signingKey: (0, env_js_1.processEnv)(consts_js_1.envKeys.InngestSigningKey) || "",
	            signingKeyFallback: (0, env_js_1.processEnv)(consts_js_1.envKeys.InngestSigningKeyFallback),
	            fetch: this.fetch,
	            mode: this.mode,
	        });
	        this.schemas = schemas;
	        this.loadModeEnvVars();
	        this.logger = logger;
	        this.middleware = this.initializeMiddleware([
	            ...exports.builtInMiddleware,
	            ...(middleware || []),
	        ]);
	        this._appVersion = appVersion;
	    }
	    /**
	     * Set the environment variables for this client. This is useful if you are
	     * passed environment variables at runtime instead of as globals and need to
	     * update the client with those values as requests come in.
	     */
	    setEnvVars(env = (0, env_js_1.allProcessEnv)()) {
	        this.mode = (0, env_js_1.getMode)({ env, client: this });
	        return this;
	    }
	    loadModeEnvVars() {
	        this._apiBaseUrl =
	            this.options.baseUrl ||
	                this.mode["env"][consts_js_1.envKeys.InngestApiBaseUrl] ||
	                this.mode["env"][consts_js_1.envKeys.InngestBaseUrl] ||
	                this.mode.getExplicitUrl(consts_js_1.defaultInngestApiBaseUrl);
	        this._eventBaseUrl =
	            this.options.baseUrl ||
	                this.mode["env"][consts_js_1.envKeys.InngestEventApiBaseUrl] ||
	                this.mode["env"][consts_js_1.envKeys.InngestBaseUrl] ||
	                this.mode.getExplicitUrl(consts_js_1.defaultInngestEventBaseUrl);
	        this.setEventKey(this.options.eventKey || this.mode["env"][consts_js_1.envKeys.InngestEventKey] || "");
	        this.headers = (0, env_js_1.inngestHeaders)({
	            inngestEnv: this.options.env,
	            env: this.mode["env"],
	        });
	        this.inngestApi["mode"] = this.mode;
	        this.inngestApi["apiBaseUrl"] = this._apiBaseUrl;
	    }
	    /**
	     * Initialize all passed middleware, running the `register` function on each
	     * in sequence and returning the requested hook registrations.
	     */
	    async initializeMiddleware(middleware = [], opts) {
	        var _a;
	        /**
	         * Wait for the prefix stack to run first; do not trigger ours before this
	         * is complete.
	         */
	        const prefix = await ((_a = opts === null || opts === void 0 ? void 0 : opts.prefixStack) !== null && _a !== void 0 ? _a : []);
	        const stack = middleware.reduce(async (acc, m) => {
	            // Be explicit about waiting for the previous middleware to finish
	            const prev = await acc;
	            const next = await m.init(Object.assign({ client: this }, opts === null || opts === void 0 ? void 0 : opts.registerInput));
	            return [...prev, next];
	        }, Promise.resolve([]));
	        return [...prefix, ...(await stack)];
	    }
	    get mode() {
	        return this._mode;
	    }
	    set mode(m) {
	        this._mode = m;
	        this.loadModeEnvVars();
	    }
	    /**
	     * Given a response from Inngest, relay the error to the caller.
	     */
	    async getResponseError(response, rawBody, foundErr = "Unknown error") {
	        let errorMessage = foundErr;
	        if (errorMessage === "Unknown error") {
	            switch (response.status) {
	                case 401:
	                    errorMessage = "Event key Not Found";
	                    break;
	                case 400:
	                    errorMessage = "Cannot process event payload";
	                    break;
	                case 403:
	                    errorMessage = "Forbidden";
	                    break;
	                case 404:
	                    errorMessage = "Event key not found";
	                    break;
	                case 406:
	                    errorMessage = `${JSON.stringify(await rawBody)}`;
	                    break;
	                case 409:
	                case 412:
	                    errorMessage = "Event transformation failed";
	                    break;
	                case 413:
	                    errorMessage = "Event payload too large";
	                    break;
	                case 500:
	                    errorMessage = "Internal server error";
	                    break;
	                default:
	                    try {
	                        errorMessage = await response.text();
	                    }
	                    catch (err) {
	                        errorMessage = `${JSON.stringify(await rawBody)}`;
	                    }
	                    break;
	            }
	        }
	        return new Error(`Inngest API Error: ${response.status} ${errorMessage}`);
	    }
	    /**
	     * Set the event key for this instance of Inngest. This is useful if for some
	     * reason the key is not available at time of instantiation or present in the
	     * `INNGEST_EVENT_KEY` environment variable.
	     */
	    setEventKey(
	    /**
	     * Inngest event key, used to send events to Inngest Cloud. Use this is your
	     * key is for some reason not available at time of instantiation or present
	     * in the `INNGEST_EVENT_KEY` environment variable.
	     */
	    eventKey) {
	        this.eventKey = eventKey || consts_js_1.dummyEventKey;
	        this.sendEventUrl = new URL(`e/${this.eventKey}`, this.eventBaseUrl || consts_js_1.defaultInngestEventBaseUrl);
	    }
	    eventKeySet() {
	        return Boolean(this.eventKey) && this.eventKey !== consts_js_1.dummyEventKey;
	    }
	    /**
	     * Send one or many events to Inngest. Takes an entire payload (including
	     * name) as each input.
	     *
	     * ```ts
	     * await inngest.send({ name: "app/user.created", data: { id: 123 } });
	     * ```
	     *
	     * Returns a promise that will resolve if the event(s) were sent successfully,
	     * else throws with an error explaining what went wrong.
	     *
	     * If you wish to send an event with custom types (i.e. one that hasn't been
	     * generated), make sure to add it when creating your Inngest instance, like
	     * so:
	     *
	     * ```ts
	     * const inngest = new Inngest({
	     *   name: "My App",
	     *   schemas: new EventSchemas().fromRecord<{
	     *     "my/event": {
	     *       name: "my/event";
	     *       data: { bar: string };
	     *     };
	     *   }>(),
	     * });
	     * ```
	     */
	    async send(payload, options) {
	        const headers = Object.assign({}, ((options === null || options === void 0 ? void 0 : options.env) ? { [consts_js_1.headerKeys.Environment]: options.env } : {}));
	        return this._send({ payload, headers });
	    }
	    /**
	     * Internal method for sending an event, used to allow Inngest internals to
	     * further customize the request sent to an Inngest Server.
	     */
	    async _send({ payload, headers, }) {
	        var _a;
	        const nowMillis = new Date().getTime();
	        let maxAttempts = 5;
	        // Attempt to set the event ID seed header. If it fails then disable retries
	        // (but we still want to send the event).
	        try {
	            const entropy = (0, crypto_js_1.createEntropy)(10);
	            const entropyBase64 = Buffer.from(entropy).toString("base64");
	            headers = Object.assign(Object.assign({}, headers), { [consts_js_1.headerKeys.EventIdSeed]: `${nowMillis},${entropyBase64}` });
	        }
	        catch (err) {
	            let message = "Event-sending retries disabled";
	            if (err instanceof Error) {
	                message += `: ${err.message}`;
	            }
	            console.debug(message);
	            // Disable retries.
	            maxAttempts = 1;
	        }
	        const hooks = await (0, InngestMiddleware_js_1.getHookStack)(this.middleware, "onSendEvent", undefined, {
	            transformInput: (prev, output) => {
	                return Object.assign(Object.assign({}, prev), output);
	            },
	            transformOutput(prev, output) {
	                return {
	                    result: Object.assign(Object.assign({}, prev.result), output === null || output === void 0 ? void 0 : output.result),
	                };
	            },
	        });
	        let payloads = Array.isArray(payload)
	            ? payload
	            : payload
	                ? [payload]
	                : [];
	        const inputChanges = await ((_a = hooks.transformInput) === null || _a === void 0 ? void 0 : _a.call(hooks, {
	            payloads: [...payloads],
	        }));
	        if (inputChanges === null || inputChanges === void 0 ? void 0 : inputChanges.payloads) {
	            payloads = [...inputChanges.payloads];
	        }
	        // Ensure that we always add "ts" and "data" fields to events. "ts" is auto-
	        // filled by the event server so is safe, and adding here fixes Next.js
	        // server action cache issues.
	        payloads = payloads.map((p) => {
	            return Object.assign(Object.assign({}, p), { 
	                // Always generate an idempotency ID for an event for retries
	                id: p.id, ts: p.ts || nowMillis, 
	                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
	                data: p.data || {} });
	        });
	        const applyHookToOutput = async (arg) => {
	            var _a;
	            const hookOutput = await ((_a = hooks.transformOutput) === null || _a === void 0 ? void 0 : _a.call(hooks, arg));
	            return Object.assign(Object.assign({}, arg.result), hookOutput === null || hookOutput === void 0 ? void 0 : hookOutput.result);
	        };
	        /**
	         * It can be valid for a user to send an empty list of events; if this
	         * happens, show a warning that this may not be intended, but don't throw.
	         */
	        if (!payloads.length) {
	            console.warn((0, errors_js_1.prettyError)({
	                type: "warn",
	                whatHappened: "`inngest.send()` called with no events",
	                reassurance: "This is not an error, but you may not have intended to do this.",
	                consequences: "The returned promise will resolve, but no events have been sent to Inngest.",
	                stack: true,
	            }));
	            return await applyHookToOutput({ result: { ids: [] } });
	        }
	        // When sending events, check if the dev server is available.  If so, use the
	        // dev server.
	        let url = this.sendEventUrl.href;
	        /**
	         * If in prod mode and key is not present, fail now.
	         */
	        if (this.mode.isCloud && !this.eventKeySet()) {
	            throw new Error((0, errors_js_1.prettyError)({
	                whatHappened: "Failed to send event",
	                consequences: "Your event or events were not sent to Inngest.",
	                why: "We couldn't find an event key to use to send events to Inngest.",
	                toFixNow: errors_js_1.fixEventKeyMissingSteps,
	            }));
	        }
	        /**
	         * If dev mode has been inferred, try to hit the dev server first to see if
	         * it exists. If it does, use it, otherwise fall back to whatever server we
	         * have configured.
	         *
	         * `INNGEST_BASE_URL` is used to set both dev server and prod URLs, so if a
	         * user has set this it means they have already chosen a URL to hit.
	         */
	        if (this.mode.isDev && this.mode.isInferred && !this.eventBaseUrl) {
	            const devAvailable = await (0, devserver_js_1.devServerAvailable)(consts_js_1.defaultDevServerHost, this.fetch);
	            if (devAvailable) {
	                url = (0, devserver_js_1.devServerUrl)(consts_js_1.defaultDevServerHost, `e/${this.eventKey}`).href;
	            }
	        }
	        const body = await (0, promises_js_1.retryWithBackoff)(async () => {
	            let rawBody;
	            let body;
	            // We don't need to do fallback auth here because this uses event keys and
	            // not signing keys
	            const response = await this.fetch(url, {
	                method: "POST",
	                body: (0, strings_js_1.stringify)(payloads),
	                headers: Object.assign(Object.assign({}, this.headers), headers),
	            });
	            try {
	                rawBody = await response.json();
	                body = await types_js_1.sendEventResponseSchema.parseAsync(rawBody);
	            }
	            catch (err) {
	                throw await this.getResponseError(response, rawBody);
	            }
	            if (body.status !== 200 || body.error) {
	                throw await this.getResponseError(response, rawBody, body.error);
	            }
	            return body;
	        }, {
	            maxAttempts,
	            baseDelay: 100,
	        });
	        return await applyHookToOutput({ result: { ids: body.ids } });
	    }
	    get funcs() {
	        return this.localFns;
	    }
	    /**
	     * Runtime-only validation.
	     */
	    sanitizeOptions(options) {
	        if (Object.prototype.hasOwnProperty.call(options, "fns")) {
	            // v2 -> v3 migration warning
	            console.warn(`${consts_js_1.logPrefix} InngestFunction: \`fns\` option has been deprecated in v3; use \`middleware\` instead. See https://www.inngest.com/docs/sdk/migration`);
	        }
	        if (typeof options === "string") {
	            // v2 -> v3 runtime migraton warning
	            console.warn(`${consts_js_1.logPrefix} InngestFunction: Creating a function with a string as the first argument has been deprecated in v3; pass an object instead. See https://www.inngest.com/docs/sdk/migration`);
	            return { id: options };
	        }
	        return options;
	    }
	    /**
	     * Runtime-only validation.
	     */
	    sanitizeTriggers(triggers) {
	        if (typeof triggers === "string") {
	            // v2 -> v3 migration warning
	            console.warn(`${consts_js_1.logPrefix} InngestFunction: Creating a function with a string as the second argument has been deprecated in v3; pass an object instead. See https://www.inngest.com/docs/sdk/migration`);
	            return [{ event: triggers }];
	        }
	        if (!Array.isArray(triggers)) {
	            return [triggers];
	        }
	        return triggers;
	    }
	}
	exports.Inngest = Inngest;
	/**
	 * Default middleware that is included in every client, placed after the user's
	 * middleware on the client but before function-level middleware.
	 *
	 * It is defined here to ensure that comments are included in the generated TS
	 * definitions. Without this, we infer the stack of built-in middleware without
	 * comments, losing a lot of value.
	 *
	 * If this is moved, please ensure that using this package in another project
	 * can correctly access comments on mutated input and output.
	 *
	 * This return pattern mimics the output of a `satisfies` suffix; it's used as
	 * we support versions of TypeScript prior to the introduction of `satisfies`.
	 */
	exports.builtInMiddleware = ((m) => m)([
	    new InngestMiddleware_js_1.InngestMiddleware({
	        name: "Inngest: Logger",
	        init({ client }) {
	            return {
	                onFunctionRun(arg) {
	                    const { ctx } = arg;
	                    const metadata = {
	                        runID: ctx.runId,
	                        eventName: ctx.event.name,
	                        functionName: arg.fn.name,
	                    };
	                    let providedLogger = client["logger"];
	                    // create a child logger if the provided logger has child logger implementation
	                    try {
	                        if ("child" in providedLogger) {
	                            providedLogger = providedLogger.child(metadata);
	                        }
	                    }
	                    catch (err) {
	                        console.error('failed to create "childLogger" with error: ', err);
	                        // no-op
	                    }
	                    const logger = new logger_js_1.ProxyLogger(providedLogger);
	                    return {
	                        transformInput() {
	                            return {
	                                ctx: {
	                                    /**
	                                     * The passed in logger from the user.
	                                     * Defaults to a console logger if not provided.
	                                     */
	                                    logger: logger,
	                                },
	                            };
	                        },
	                        beforeExecution() {
	                            logger.enable();
	                        },
	                        transformOutput({ result: { error } }) {
	                            if (error) {
	                                logger.error(error);
	                            }
	                        },
	                        async beforeResponse() {
	                            await logger.flush();
	                        },
	                    };
	                },
	            };
	        },
	    }),
	]);
	
} (Inngest$1));

var InngestCommHandler$1 = {};

var ServerTiming$1 = {};

Object.defineProperty(ServerTiming$1, "__esModule", { value: true });
ServerTiming$1.ServerTiming = void 0;
const promises_js_1$1 = promises;
/**
 * A class to manage timing functions and arbitrary periods of time before
 * generating a `Server-Timing` header for use in HTTP responses.
 *
 * This is a very simple implementation that does not support nested timings or
 * fractions of a millisecond.
 */
class ServerTiming {
    constructor() {
        this.timings = {};
    }
    /**
     * Start a timing. Returns a function that, when called, will stop the timing
     * and add it to the header.
     */
    start(name, description) {
        if (!this.timings[name]) {
            this.timings[name] = {
                description: description !== null && description !== void 0 ? description : "",
                timers: [],
            };
        }
        const index = this.timings[name].timers.push({ start: Date.now() }) - 1;
        return () => {
            const target = this.timings[name];
            if (!target) {
                return console.warn(`Timing "${name}" does not exist`);
            }
            const timer = target.timers[index];
            if (!timer) {
                return console.warn(`Timer ${index} for timing "${name}" does not exist`);
            }
            timer.end = Date.now();
        };
    }
    /**
     * Add a piece of arbitrary, untimed information to the header. Common use
     * cases would be cache misses.
     *
     * @example
     * ```
     * timer.append("cache", "miss");
     * ```
     */
    append(key, value) {
        this.timings[key] = {
            description: value,
            timers: [],
        };
    }
    /**
     * Wrap a function in a timing. The timing will be stopped and added to the
     * header when the function resolves or rejects.
     *
     * The return value of the function will be returned from this function.
     */
    async wrap(name, fn, description) {
        const stop = this.start(name, description);
        try {
            return (await (0, promises_js_1$1.runAsPromise)(fn));
        }
        finally {
            stop();
        }
    }
    /**
     * Generate the `Server-Timing` header.
     */
    getHeader() {
        const entries = Object.entries(this.timings).reduce((acc, [name, { description, timers }]) => {
            /**
             * Ignore timers that had no end.
             */
            const hasTimersWithEnd = timers.some((timer) => timer.end);
            if (!hasTimersWithEnd) {
                return acc;
            }
            const dur = timers.reduce((acc, { start, end }) => {
                if (!start || !end)
                    return acc;
                return acc + (end - start);
            }, 0);
            const entry = [
                name,
                description ? `desc="${description}"` : "",
                dur ? `dur=${dur}` : "",
            ]
                .filter(Boolean)
                .join(";");
            return [...acc, entry];
        }, []);
        return entries.join(", ");
    }
}
ServerTiming$1.ServerTiming = ServerTiming;

var _enum = {};

Object.defineProperty(_enum, "__esModule", { value: true });
_enum.enumFromValue = void 0;
/**
 * Returns the value of an enum from a string value.
 *
 * If the value given is not a value from the enum, `undefined` is returned.
 */
const enumFromValue = (enumType, value) => {
    if (Object.values(enumType).includes(value)) {
        return value;
    }
};
_enum.enumFromValue = enumFromValue;

var stream = {};

Object.defineProperty(stream, "__esModule", { value: true });
stream.createStream = void 0;
const strings_js_1$1 = strings;
/**
 * Creates a {@link ReadableStream} that sends a `value` every `interval`
 * milliseconds as a heartbeat, intended to keep a stream open.
 *
 * Returns the `stream` itself and a `finalize` function that can be used to
 * close the stream and send a final value.
 */
const createStream = (opts) => {
    var _a, _b;
    /**
     * We need to resolve this promise with both the stream and the `finalize`
     * function, but having them both instantiated synchronously is difficult, as
     * we need access to the stream's internals too.
     *
     * We create this cheeky deferred promise to grab the internal `finalize`
     * value. Be warned that simpler solutions may appear to compile, but fail at
     * runtime due to variables not being assigned; make sure to test your code!
     */
    let passFinalize;
    const finalizeP = new Promise((resolve) => {
        passFinalize = resolve;
    });
    const interval = (_a = opts === null || opts === void 0 ? void 0 : opts.interval) !== null && _a !== void 0 ? _a : 3000;
    const value = (_b = opts === null || opts === void 0 ? void 0 : opts.value) !== null && _b !== void 0 ? _b : " ";
    // eslint-disable-next-line @typescript-eslint/no-misused-promises, no-async-promise-executor
    return new Promise(async (resolve, reject) => {
        try {
            const stream = new ReadableStream({
                start(controller) {
                    const encoder = new TextEncoder();
                    const heartbeat = setInterval(() => {
                        controller.enqueue(encoder.encode(value));
                    }, interval);
                    const finalize = (data) => {
                        clearInterval(heartbeat);
                        // `data` may be a `Promise`. If it is, we need to wait for it to
                        // resolve before sending it. To support this elegantly we'll always
                        // assume it's a promise and handle that case.
                        void Promise.resolve(data).then((resolvedData) => {
                            controller.enqueue(encoder.encode((0, strings_js_1$1.stringify)(resolvedData)));
                            controller.close();
                        });
                    };
                    passFinalize(finalize);
                },
            });
            resolve({ stream, finalize: await finalizeP });
        }
        catch (err) {
            reject(err);
        }
    });
};
stream.createStream = createStream;

var __classPrivateFieldGet$1 = (InngestCommHandler$1 && InngestCommHandler$1.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault$8 = (InngestCommHandler$1 && InngestCommHandler$1.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _RequestSignature_instances, _RequestSignature_verifySignature;
Object.defineProperty(InngestCommHandler$1, "__esModule", { value: true });
InngestCommHandler$1.InngestCommHandler = void 0;
const debug_1$3 = __importDefault$8(srcExports);
const zod_1$5 = lib$2;
const ServerTiming_js_1 = ServerTiming$1;
const consts_js_1 = consts;
const devserver_js_1 = devserver;
const enum_js_1 = _enum;
const env_js_1 = env$3;
const errors_js_1 = errors$2;
const functions_js_1 = functions;
const net_js_1 = net;
const promises_js_1 = promises;
const stream_js_1 = stream;
const strings_js_1 = strings;
const types_js_1 = types$2;
const version_js_1 = version;
const InngestExecution_js_1 = InngestExecution$1;
/**
 * A schema for the response from Inngest when registering.
 */
const registerResSchema = zod_1$5.z.object({
    status: zod_1$5.z.number().default(200),
    skipped: zod_1$5.z.boolean().optional().default(false),
    modified: zod_1$5.z.boolean().optional().default(false),
    error: zod_1$5.z.string().default("Successfully registered"),
});
/**
 * `InngestCommHandler` is a class for handling incoming requests from Inngest (or
 * Inngest's tooling such as the dev server or CLI) and taking appropriate
 * action for any served functions.
 *
 * All handlers (Next.js, RedwoodJS, Remix, Deno Fresh, etc.) are created using
 * this class; the exposed `serve` function will - most commonly - create an
 * instance of `InngestCommHandler` and then return `instance.createHandler()`.
 *
 * See individual parameter details for more information, or see the
 * source code for an existing handler, e.g.
 * {@link https://github.com/inngest/inngest-js/blob/main/src/next.ts}
 *
 * @example
 * ```
 * // my-custom-handler.ts
 * import {
 *   InngestCommHandler,
 *   type ServeHandlerOptions,
 * } from "./components/InngestCommHandler";
 *
 * export const serve = (options: ServeHandlerOptions) => {
 *   const handler = new InngestCommHandler({
 *     frameworkName: "my-custom-handler",
 *     ...options,
 *     handler: (req: Request) => {
 *       return {
 *         body: () => req.json(),
 *         headers: (key) => req.headers.get(key),
 *         method: () => req.method,
 *         url: () => new URL(req.url, `https://${req.headers.get("host") || ""}`),
 *         transformResponse: ({ body, status, headers }) => {
 *           return new Response(body, { status, headers });
 *         },
 *       };
 *     },
 *   });
 *
 *   return handler.createHandler();
 * };
 * ```
 *
 * @public
 */
class InngestCommHandler {
    constructor(options) {
        var _a;
        /**
         * A private collection of functions that are being served. This map is used
         * to find and register functions when interacting with Inngest Cloud.
         */
        this.fns = {};
        this.env = (0, env_js_1.allProcessEnv)();
        // Set input options directly so we can reference them later
        this._options = options;
        /**
         * v2 -> v3 migration error.
         *
         * If a serve handler is passed a client as the first argument, it'll be
         * spread in to these options. We should be able to detect this by picking
         * up a unique property on the object.
         */
        if (Object.prototype.hasOwnProperty.call(options, "eventKey")) {
            throw new Error(`${consts_js_1.logPrefix} You've passed an Inngest client as the first argument to your serve handler. This is no longer supported in v3; please pass the Inngest client as the \`client\` property of an options object instead. See https://www.inngest.com/docs/sdk/migration`);
        }
        this.frameworkName = options.frameworkName;
        this.client = options.client;
        if (options.id) {
            console.warn(`${consts_js_1.logPrefix} The \`id\` serve option is deprecated and will be removed in v4`);
        }
        this.id = options.id || this.client.id;
        this.handler = options.handler;
        /**
         * Provide a hidden option to allow expired signatures to be accepted during
         * testing.
         */
        this.allowExpiredSignatures = Boolean(
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, prefer-rest-params
        (_a = arguments["0"]) === null || _a === void 0 ? void 0 : _a.__testingAllowExpiredSignatures);
        // Ensure we filter any undefined functions in case of missing imports.
        this.rawFns = options.functions.filter(Boolean);
        if (this.rawFns.length !== options.functions.length) {
            // TODO PrettyError
            console.warn(`Some functions passed to serve() are undefined and misconfigured.  Please check your imports.`);
        }
        this.fns = this.rawFns.reduce((acc, fn) => {
            const configs = fn["getConfig"]({
                baseUrl: new URL("https://example.com"),
                appPrefix: this.id,
            });
            const fns = configs.reduce((acc, { id }, index) => {
                return Object.assign(Object.assign({}, acc), { [id]: { fn, onFailure: Boolean(index) } });
            }, {});
            configs.forEach(({ id }) => {
                if (acc[id]) {
                    // TODO PrettyError
                    throw new Error(`Duplicate function ID "${id}"; please change a function's name or provide an explicit ID to avoid conflicts.`);
                }
            });
            return Object.assign(Object.assign({}, acc), fns);
        }, {});
        this.inngestRegisterUrl = new URL("/fn/register", this.apiBaseUrl);
        this.signingKey = options.signingKey;
        this.signingKeyFallback = options.signingKeyFallback;
        this._serveHost = options.serveHost || this.env[consts_js_1.envKeys.InngestServeHost];
        this._servePath = options.servePath || this.env[consts_js_1.envKeys.InngestServePath];
        this.skipSignatureValidation = options.skipSignatureValidation || false;
        const defaultLogLevel = "info";
        this.logLevel = zod_1$5.z
            .enum(types_js_1.logLevels)
            .default(defaultLogLevel)
            .catch((ctx) => {
            this.log("warn", `Unknown log level passed: ${String(ctx.input)}; defaulting to ${defaultLogLevel}`);
            return defaultLogLevel;
        })
            .parse(options.logLevel || this.env[consts_js_1.envKeys.InngestLogLevel]);
        if (this.logLevel === "debug") {
            /**
             * `debug` is an old library; sometimes its runtime detection doesn't work
             * for newer pairings of framework/runtime.
             *
             * One silly symptom of this is that `Debug()` returns an anonymous
             * function with no extra properties instead of a `Debugger` instance if
             * the wrong code is consumed following a bad detection. This results in
             * the following `.enable()` call failing, so we just try carefully to
             * enable it here.
             */
            if (debug_1$3.default.enable && typeof debug_1$3.default.enable === "function") {
                debug_1$3.default.enable(`${consts_js_1.debugPrefix}:*`);
            }
        }
        const defaultStreamingOption = false;
        this.streaming = zod_1$5.z
            .union([zod_1$5.z.enum(["allow", "force"]), zod_1$5.z.literal(false)])
            .default(defaultStreamingOption)
            .catch((ctx) => {
            this.log("warn", `Unknown streaming option passed: ${String(ctx.input)}; defaulting to ${String(defaultStreamingOption)}`);
            return defaultStreamingOption;
        })
            .parse(options.streaming || this.env[consts_js_1.envKeys.InngestStreaming]);
        this.fetch = options.fetch ? (0, env_js_1.getFetch)(options.fetch) : this.client["fetch"];
    }
    /**
     * Get the API base URL for the Inngest API.
     *
     * This is a getter to encourage checking the environment for the API base URL
     * each time it's accessed, as it may change during execution.
     */
    get apiBaseUrl() {
        return (this._options.baseUrl ||
            this.env[consts_js_1.envKeys.InngestApiBaseUrl] ||
            this.env[consts_js_1.envKeys.InngestBaseUrl] ||
            this.client.apiBaseUrl ||
            consts_js_1.defaultInngestApiBaseUrl);
    }
    /**
     * Get the event API base URL for the Inngest API.
     *
     * This is a getter to encourage checking the environment for the event API
     * base URL each time it's accessed, as it may change during execution.
     */
    get eventApiBaseUrl() {
        return (this._options.baseUrl ||
            this.env[consts_js_1.envKeys.InngestEventApiBaseUrl] ||
            this.env[consts_js_1.envKeys.InngestBaseUrl] ||
            this.client.eventBaseUrl ||
            consts_js_1.defaultInngestEventBaseUrl);
    }
    /**
     * The host used to access the Inngest serve endpoint, e.g.:
     *
     *     "https://myapp.com"
     *
     * By default, the library will try to infer this using request details such
     * as the "Host" header and request path, but sometimes this isn't possible
     * (e.g. when running in a more controlled environments such as AWS Lambda or
     * when dealing with proxies/redirects).
     *
     * Provide the custom hostname here to ensure that the path is reported
     * correctly when registering functions with Inngest.
     *
     * To also provide a custom path, use `servePath`.
     */
    get serveHost() {
        return this._serveHost || this.env[consts_js_1.envKeys.InngestServeHost];
    }
    /**
     * The path to the Inngest serve endpoint. e.g.:
     *
     *     "/some/long/path/to/inngest/endpoint"
     *
     * By default, the library will try to infer this using request details such
     * as the "Host" header and request path, but sometimes this isn't possible
     * (e.g. when running in a more controlled environments such as AWS Lambda or
     * when dealing with proxies/redirects).
     *
     * Provide the custom path (excluding the hostname) here to ensure that the
     * path is reported correctly when registering functions with Inngest.
     *
     * To also provide a custom hostname, use `serveHost`.
     *
     * This is a getter to encourage checking the environment for the serve path
     * each time it's accessed, as it may change during execution.
     */
    get servePath() {
        return this._servePath || this.env[consts_js_1.envKeys.InngestServePath];
    }
    get hashedEventKey() {
        if (!this.client["eventKey"] || this.client["eventKey"] === consts_js_1.dummyEventKey) {
            return undefined;
        }
        return (0, strings_js_1.hashEventKey)(this.client["eventKey"]);
    }
    // hashedSigningKey creates a sha256 checksum of the signing key with the
    // same signing key prefix.
    get hashedSigningKey() {
        if (!this.signingKey) {
            return undefined;
        }
        return (0, strings_js_1.hashSigningKey)(this.signingKey);
    }
    get hashedSigningKeyFallback() {
        if (!this.signingKeyFallback) {
            return undefined;
        }
        return (0, strings_js_1.hashSigningKey)(this.signingKeyFallback);
    }
    /**
     * Returns a `boolean` representing whether this handler will stream responses
     * or not. Takes into account the user's preference and the platform's
     * capabilities.
     */
    async shouldStream(actions) {
        const rawProbe = await actions.queryStringWithDefaults("testing for probe", consts_js_1.queryKeys.Probe);
        if (rawProbe !== undefined) {
            return false;
        }
        // We must be able to stream responses to continue.
        if (!actions.transformStreamingResponse) {
            return false;
        }
        // If the user has forced streaming, we should always stream.
        if (this.streaming === "force") {
            return true;
        }
        // If the user has allowed streaming, we should stream if the platform
        // supports it.
        return (this.streaming === "allow" &&
            (0, env_js_1.platformSupportsStreaming)(this.frameworkName, this.env));
    }
    /**
     * `createHandler` should be used to return a type-equivalent version of the
     * `handler` specified during instantiation.
     *
     * @example
     * ```
     * // my-custom-handler.ts
     * import {
     *   InngestCommHandler,
     *   type ServeHandlerOptions,
     * } from "./components/InngestCommHandler";
     *
     * export const serve = (options: ServeHandlerOptions) => {
     *   const handler = new InngestCommHandler({
     *     frameworkName: "my-custom-handler",
     *     ...options,
     *     handler: (req: Request) => {
     *       return {
     *         body: () => req.json(),
     *         headers: (key) => req.headers.get(key),
     *         method: () => req.method,
     *         url: () => new URL(req.url, `https://${req.headers.get("host") || ""}`),
     *         transformResponse: ({ body, status, headers }) => {
     *           return new Response(body, { status, headers });
     *         },
     *       };
     *     },
     *   });
     *
     *   return handler.createHandler();
     * };
     * ```
     */
    createHandler() {
        const handler = async (...args) => {
            var _a, _b;
            const timer = new ServerTiming_js_1.ServerTiming();
            /**
             * Used for testing, allow setting action overrides externally when
             * calling the handler. Always search the final argument.
             */
            const lastArg = args[args.length - 1];
            const actionOverrides = typeof lastArg === "object" &&
                lastArg !== null &&
                "actionOverrides" in lastArg &&
                typeof lastArg["actionOverrides"] === "object" &&
                lastArg["actionOverrides"] !== null
                ? lastArg["actionOverrides"]
                : {};
            /**
             * We purposefully `await` the handler, as it could be either sync or
             * async.
             */
            const rawActions = Object.assign(Object.assign({}, (await timer
                .wrap("handler", () => this.handler(...args))
                .catch((0, errors_js_1.rethrowError)("Serve handler failed to run")))), actionOverrides);
            /**
             * Map over every `action` in `rawActions` and create a new `actions`
             * object where each function is safely promisified with each access
             * requiring a reason.
             *
             * This helps us provide high quality errors about what's going wrong for
             * each access without having to wrap every access in a try/catch.
             */
            const promisifiedActions = Object.entries(rawActions).reduce((acc, [key, value]) => {
                if (typeof value !== "function") {
                    return acc;
                }
                return Object.assign(Object.assign({}, acc), { [key]: (reason, ...args) => {
                        const errMessage = [
                            `Failed calling \`${key}\` from serve handler`,
                            reason,
                        ]
                            .filter(Boolean)
                            .join(" when ");
                        const fn = () => value(...args);
                        return (0, promises_js_1.runAsPromise)(fn)
                            .catch((0, errors_js_1.rethrowError)(errMessage))
                            .catch((err) => {
                            this.log("error", err);
                            throw err;
                        });
                    } });
            }, {});
            /**
             * Mapped promisified handlers from userland `serve()` function mixed in
             * with some helpers.
             */
            const actions = Object.assign(Object.assign(Object.assign({}, promisifiedActions), { queryStringWithDefaults: async (reason, key) => {
                    var _a;
                    const url = await actions.url(reason);
                    const ret = (await ((_a = actions.queryString) === null || _a === void 0 ? void 0 : _a.call(actions, reason, key, url))) ||
                        url.searchParams.get(key) ||
                        undefined;
                    return ret;
                } }), actionOverrides);
            const [env, expectedServerKind] = await Promise.all([
                (_a = actions.env) === null || _a === void 0 ? void 0 : _a.call(actions, "starting to handle request"),
                actions.headers("checking expected server kind", consts_js_1.headerKeys.InngestServerKind),
            ]);
            // Always make sure to merge whatever env we've been given with
            // `process.env`; some platforms may not provide all the necessary
            // environment variables or may use two sources.
            this.env = Object.assign(Object.assign({}, (0, env_js_1.allProcessEnv)()), env);
            const getInngestHeaders = () => (0, env_js_1.inngestHeaders)({
                env: this.env,
                framework: this.frameworkName,
                client: this.client,
                expectedServerKind: expectedServerKind || undefined,
                extras: {
                    "Server-Timing": timer.getHeader(),
                },
            });
            const assumedMode = (0, env_js_1.getMode)({ env: this.env, client: this.client });
            if (assumedMode.isExplicit) {
                this._mode = assumedMode;
            }
            else {
                const serveIsProd = await ((_b = actions.isProduction) === null || _b === void 0 ? void 0 : _b.call(actions, "starting to handle request"));
                if (typeof serveIsProd === "boolean") {
                    this._mode = new env_js_1.Mode({
                        type: serveIsProd ? "cloud" : "dev",
                        isExplicit: false,
                    });
                }
                else {
                    this._mode = assumedMode;
                }
            }
            this.upsertKeysFromEnv();
            const methodP = actions.method("starting to handle request");
            const headerPromises = [
                consts_js_1.headerKeys.TraceParent,
                consts_js_1.headerKeys.TraceState,
            ].map(async (header) => {
                const value = await actions.headers(`fetching ${header} for forwarding`, header);
                return { header, value };
            });
            const contentLength = await actions
                .headers("checking signature for request", consts_js_1.headerKeys.ContentLength)
                .then((value) => {
                if (!value) {
                    return undefined;
                }
                return parseInt(value, 10);
            });
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            const [signature, method, body] = await Promise.all([
                actions
                    .headers("checking signature for request", consts_js_1.headerKeys.Signature)
                    .then((headerSignature) => {
                    return headerSignature !== null && headerSignature !== void 0 ? headerSignature : undefined;
                }),
                methodP,
                methodP.then((method) => {
                    if (method === "POST" || method === "PUT") {
                        if (!contentLength) {
                            // Return empty string because req.json() will throw an error.
                            return "";
                        }
                        return actions.body(`checking body for request signing as method is ${method}`);
                    }
                    return "";
                }),
            ]);
            const signatureValidation = this.validateSignature(signature, body);
            const headersToForwardP = Promise.all(headerPromises).then((fetchedHeaders) => {
                return fetchedHeaders.reduce((acc, { header, value }) => {
                    if (value) {
                        acc[header] = value;
                    }
                    return acc;
                }, {});
            });
            const actionRes = timer.wrap("action", () => this.handleAction({
                actions,
                timer,
                getInngestHeaders,
                reqArgs: args,
                signatureValidation,
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                body,
                method,
                headers: headersToForwardP,
            }));
            /**
             * Prepares an action response by merging returned data to provide
             * trailing information such as `Server-Timing` headers.
             *
             * It should always prioritize the headers returned by the action, as they
             * may contain important information such as `Content-Type`.
             */
            const prepareActionRes = async (res) => {
                var _a;
                const headers = Object.assign(Object.assign(Object.assign(Object.assign({}, getInngestHeaders()), (await headersToForwardP)), res.headers), (res.version === null
                    ? {}
                    : {
                        [consts_js_1.headerKeys.RequestVersion]: ((_a = res.version) !== null && _a !== void 0 ? _a : InngestExecution_js_1.PREFERRED_EXECUTION_VERSION).toString(),
                    }));
                let signature;
                try {
                    signature = await signatureValidation.then((result) => {
                        if (!result.success || !result.keyUsed) {
                            return undefined;
                        }
                        return this.getResponseSignature(result.keyUsed, res.body);
                    });
                }
                catch (err) {
                    // If we fail to sign, retun a 500 with the error.
                    return Object.assign(Object.assign({}, res), { headers, body: (0, strings_js_1.stringify)((0, errors_js_1.serializeError)(err)), status: 500 });
                }
                if (signature) {
                    headers[consts_js_1.headerKeys.Signature] = signature;
                }
                return Object.assign(Object.assign({}, res), { headers });
            };
            if (await this.shouldStream(actions)) {
                const method = await actions.method("starting streaming response");
                if (method === "POST") {
                    const { stream, finalize } = await (0, stream_js_1.createStream)();
                    /**
                     * Errors are handled by `handleAction` here to ensure that an
                     * appropriate response is always given.
                     */
                    void actionRes.then((res) => {
                        return finalize(prepareActionRes(res));
                    });
                    return timer.wrap("res", () => {
                        var _a;
                        return (_a = actions.transformStreamingResponse) === null || _a === void 0 ? void 0 : _a.call(actions, "starting streaming response", {
                            status: 201,
                            headers: getInngestHeaders(),
                            body: stream,
                            version: null,
                        });
                    });
                }
            }
            return timer.wrap("res", async () => {
                return actionRes.then(prepareActionRes).then((actionRes) => {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                    return actions.transformResponse("sending back response", actionRes);
                });
            });
        };
        /**
         * Some platforms check (at runtime) the length of the function being used
         * to handle an endpoint. If this is a variadic function, it will fail that
         * check.
         *
         * Therefore, we expect the arguments accepted to be the same length as the
         * `handler` function passed internally.
         *
         * We also set a name to avoid a common useless name in tracing such as
         * `"anonymous"` or `"bound function"`.
         *
         * https://github.com/getsentry/sentry-javascript/issues/3284
         */
        Object.defineProperties(handler, {
            name: {
                value: "InngestHandler",
            },
            length: {
                value: this.handler.length,
            },
        });
        return handler;
    }
    get mode() {
        return this._mode;
    }
    set mode(m) {
        this._mode = m;
        if (m) {
            this.client["mode"] = m;
        }
    }
    /**
     * Given a set of functions to check if an action is available from the
     * instance's handler, enact any action that is found.
     *
     * This method can fetch varying payloads of data, but ultimately is the place
     * where _decisions_ are made regarding functionality.
     *
     * For example, if we find that we should be viewing the UI, this function
     * will decide whether the UI should be visible based on the payload it has
     * found (e.g. env vars, options, etc).
     */
    async handleAction({ actions, timer, getInngestHeaders, reqArgs, signatureValidation, body, method, headers, }) {
        var _a;
        // This is when the request body is completely missing; it does not
        // include an empty body. This commonly happens when the HTTP framework
        // doesn't have body parsing middleware.
        const isMissingBody = body === undefined;
        try {
            let url = await actions.url("starting to handle request");
            if (method === "POST") {
                if (isMissingBody) {
                    this.log("error", "Missing body when executing, possibly due to missing request body middleware");
                    return {
                        status: 500,
                        headers: {
                            "Content-Type": "application/json",
                        },
                        body: (0, strings_js_1.stringify)((0, errors_js_1.serializeError)(new Error("Missing request body when executing, possibly due to missing request body middleware"))),
                        version: undefined,
                    };
                }
                const validationResult = await signatureValidation;
                if (!validationResult.success) {
                    return {
                        status: 401,
                        headers: {
                            "Content-Type": "application/json",
                        },
                        body: (0, strings_js_1.stringify)((0, errors_js_1.serializeError)(validationResult.err)),
                        version: undefined,
                    };
                }
                const rawProbe = await actions.queryStringWithDefaults("testing for probe", consts_js_1.queryKeys.Probe);
                if (rawProbe) {
                    const probe = (0, enum_js_1.enumFromValue)(consts_js_1.probe, rawProbe);
                    if (!probe) {
                        // If we're here, we've received a probe that we don't recognize.
                        // Fail.
                        return {
                            status: 400,
                            headers: {
                                "Content-Type": "application/json",
                            },
                            body: (0, strings_js_1.stringify)((0, errors_js_1.serializeError)(new Error(`Unknown probe "${rawProbe}"`))),
                            version: undefined,
                        };
                    }
                    // Provide actions for every probe available.
                    const probeActions = {
                        [consts_js_1.probe.Trust]: () => ({
                            status: 200,
                            headers: {
                                "Content-Type": "application/json",
                            },
                            body: "",
                            version: undefined,
                        }),
                    };
                    return probeActions[probe]();
                }
                const fnId = await actions.queryStringWithDefaults("processing run request", consts_js_1.queryKeys.FnId);
                if (!fnId) {
                    // TODO PrettyError
                    throw new Error("No function ID found in request");
                }
                const stepId = (await actions.queryStringWithDefaults("processing run request", consts_js_1.queryKeys.StepId)) || null;
                const { version, result } = this.runStep({
                    functionId: fnId,
                    data: body,
                    stepId,
                    timer,
                    reqArgs,
                    headers: await headers,
                });
                const stepOutput = await result;
                /**
                 * Functions can return `undefined`, but we'll always convert this to
                 * `null`, as this is appropriately serializable by JSON.
                 */
                const opDataUndefinedToNull = (op) => {
                    op.data = (0, functions_js_1.undefinedToNull)(op.data);
                    return op;
                };
                const resultHandlers = {
                    "function-rejected": (result) => {
                        return {
                            status: result.retriable ? 500 : 400,
                            headers: Object.assign({ "Content-Type": "application/json", [consts_js_1.headerKeys.NoRetry]: result.retriable ? "false" : "true" }, (typeof result.retriable === "string"
                                ? { [consts_js_1.headerKeys.RetryAfter]: result.retriable }
                                : {})),
                            body: (0, strings_js_1.stringify)((0, functions_js_1.undefinedToNull)(result.error)),
                            version,
                        };
                    },
                    "function-resolved": (result) => {
                        return {
                            status: 200,
                            headers: {
                                "Content-Type": "application/json",
                            },
                            body: (0, strings_js_1.stringify)((0, functions_js_1.undefinedToNull)(result.data)),
                            version,
                        };
                    },
                    "step-not-found": (result) => {
                        return {
                            status: 500,
                            headers: {
                                "Content-Type": "application/json",
                                [consts_js_1.headerKeys.NoRetry]: "false",
                            },
                            body: (0, strings_js_1.stringify)({
                                error: `Could not find step "${result.step.displayName || result.step.id}" to run; timed out`,
                            }),
                            version,
                        };
                    },
                    "step-ran": (result) => {
                        const step = opDataUndefinedToNull(result.step);
                        return {
                            status: 206,
                            headers: Object.assign({ "Content-Type": "application/json" }, (typeof result.retriable !== "undefined"
                                ? Object.assign({ [consts_js_1.headerKeys.NoRetry]: result.retriable ? "false" : "true" }, (typeof result.retriable === "string"
                                    ? { [consts_js_1.headerKeys.RetryAfter]: result.retriable }
                                    : {})) : {})),
                            body: (0, strings_js_1.stringify)([step]),
                            version,
                        };
                    },
                    "steps-found": (result) => {
                        const steps = result.steps.map(opDataUndefinedToNull);
                        return {
                            status: 206,
                            headers: {
                                "Content-Type": "application/json",
                            },
                            body: (0, strings_js_1.stringify)(steps),
                            version,
                        };
                    },
                };
                const handler = resultHandlers[stepOutput.type];
                try {
                    return await handler(stepOutput);
                }
                catch (err) {
                    this.log("error", "Error handling execution result", err);
                    throw err;
                }
            }
            // TODO: This feels hacky, so we should probably make it not hacky.
            const env = (_a = getInngestHeaders()[consts_js_1.headerKeys.Environment]) !== null && _a !== void 0 ? _a : null;
            if (method === "GET") {
                return {
                    status: 200,
                    body: (0, strings_js_1.stringify)(await this.introspectionBody({
                        actions,
                        env,
                        signatureValidation,
                        url,
                    })),
                    headers: {
                        "Content-Type": "application/json",
                    },
                    version: undefined,
                };
            }
            if (method === "PUT") {
                const [deployId, inBandSyncRequested] = await Promise.all([
                    actions
                        .queryStringWithDefaults("processing deployment request", consts_js_1.queryKeys.DeployId)
                        .then((deployId) => {
                        return deployId === "undefined" ? undefined : deployId;
                    }),
                    Promise.resolve((0, env_js_1.parseAsBoolean)(this.env[consts_js_1.envKeys.InngestAllowInBandSync]))
                        .then((allowInBandSync) => {
                        if (allowInBandSync !== undefined && !allowInBandSync) {
                            return consts_js_1.syncKind.OutOfBand;
                        }
                        return actions.headers("processing deployment request", consts_js_1.headerKeys.InngestSyncKind);
                    })
                        .then((kind) => {
                        return kind === consts_js_1.syncKind.InBand;
                    }),
                ]);
                if (inBandSyncRequested) {
                    if (isMissingBody) {
                        this.log("error", "Missing body when syncing, possibly due to missing request body middleware");
                        return {
                            status: 500,
                            headers: {
                                "Content-Type": "application/json",
                            },
                            body: (0, strings_js_1.stringify)((0, errors_js_1.serializeError)(new Error("Missing request body when syncing, possibly due to missing request body middleware"))),
                            version: undefined,
                        };
                    }
                    // Validation can be successful if we're in dev mode and did not
                    // actually validate a key. In this case, also check that we did indeed
                    // use a particular key to validate.
                    const sigCheck = await signatureValidation;
                    if (!sigCheck.success) {
                        return {
                            status: 401,
                            body: (0, strings_js_1.stringify)({
                                code: "sig_verification_failed",
                            }),
                            headers: {
                                "Content-Type": "application/json",
                            },
                            version: undefined,
                        };
                    }
                    const res = types_js_1.inBandSyncRequestBodySchema.safeParse(body);
                    if (!res.success) {
                        return {
                            status: 400,
                            body: (0, strings_js_1.stringify)({
                                code: "invalid_request",
                                message: res.error.message,
                            }),
                            headers: {
                                "Content-Type": "application/json",
                            },
                            version: undefined,
                        };
                    }
                    // We can trust the URL here because it's coming from
                    // signature-verified request.
                    url = this.reqUrl(new URL(res.data.url));
                    // This should be an in-band sync
                    const respBody = await this.inBandRegisterBody({
                        actions,
                        deployId,
                        env,
                        signatureValidation,
                        url,
                    });
                    return {
                        status: 200,
                        body: (0, strings_js_1.stringify)(respBody),
                        headers: {
                            "Content-Type": "application/json",
                            [consts_js_1.headerKeys.InngestSyncKind]: consts_js_1.syncKind.InBand,
                        },
                        version: undefined,
                    };
                }
                // If we're here, this is a legacy out-of-band sync
                const { status, message, modified } = await this.register(this.reqUrl(url), deployId, getInngestHeaders);
                return {
                    status,
                    body: (0, strings_js_1.stringify)({ message, modified }),
                    headers: {
                        "Content-Type": "application/json",
                        [consts_js_1.headerKeys.InngestSyncKind]: consts_js_1.syncKind.OutOfBand,
                    },
                    version: undefined,
                };
            }
        }
        catch (err) {
            return {
                status: 500,
                body: (0, strings_js_1.stringify)(Object.assign({ type: "internal" }, (0, errors_js_1.serializeError)(err))),
                headers: {
                    "Content-Type": "application/json",
                },
                version: undefined,
            };
        }
        return {
            status: 405,
            body: JSON.stringify({
                message: "No action found; request was likely not POST, PUT, or GET",
                mode: this._mode,
            }),
            headers: {},
            version: undefined,
        };
    }
    runStep({ functionId, stepId, data, timer, reqArgs, headers, }) {
        var _a, _b;
        const fn = this.fns[functionId];
        if (!fn) {
            // TODO PrettyError
            throw new Error(`Could not find function with ID "${functionId}"`);
        }
        const immediateFnData = (0, functions_js_1.parseFnData)(data);
        let { version } = immediateFnData;
        // Handle opting in to optimized parallelism in v3.
        if (version === InngestExecution_js_1.ExecutionVersion.V1 &&
            ((_b = (_a = fn.fn)["shouldOptimizeParallelism"]) === null || _b === void 0 ? void 0 : _b.call(_a))) {
            version = InngestExecution_js_1.ExecutionVersion.V2;
        }
        const result = (0, promises_js_1.runAsPromise)(async () => {
            const anyFnData = await (0, functions_js_1.fetchAllFnData)({
                data: immediateFnData,
                api: this.client["inngestApi"],
                version,
            });
            if (!anyFnData.ok) {
                throw new Error(anyFnData.error);
            }
            const executionStarters = ((s) => s)({
                [InngestExecution_js_1.ExecutionVersion.V0]: ({ event, events, steps, ctx, version }) => {
                    var _a, _b, _c;
                    const stepState = Object.entries(steps !== null && steps !== void 0 ? steps : {}).reduce((acc, [id, data]) => {
                        return Object.assign(Object.assign({}, acc), { 
                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                            [id]: { id, data } });
                    }, {});
                    return {
                        version,
                        partialOptions: {
                            runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || "",
                            data: {
                                event: event,
                                events: events,
                                runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || "",
                                attempt: (_a = ctx === null || ctx === void 0 ? void 0 : ctx.attempt) !== null && _a !== void 0 ? _a : 0,
                            },
                            stepState,
                            requestedRunStep: stepId === "step" ? undefined : stepId || undefined,
                            timer,
                            isFailureHandler: fn.onFailure,
                            stepCompletionOrder: (_c = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.stack) === null || _b === void 0 ? void 0 : _b.stack) !== null && _c !== void 0 ? _c : [],
                            reqArgs,
                            headers,
                        },
                    };
                },
                [InngestExecution_js_1.ExecutionVersion.V1]: ({ event, events, steps, ctx, version }) => {
                    var _a, _b, _c;
                    const stepState = Object.entries(steps !== null && steps !== void 0 ? steps : {}).reduce((acc, [id, result]) => {
                        return Object.assign(Object.assign({}, acc), { [id]: result.type === "data"
                                ? // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                                    { id, data: result.data }
                                : result.type === "input"
                                    ? // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                                        { id, input: result.input }
                                    : { id, error: result.error } });
                    }, {});
                    return {
                        version,
                        partialOptions: {
                            runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || "",
                            data: {
                                event: event,
                                events: events,
                                runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || "",
                                attempt: (_a = ctx === null || ctx === void 0 ? void 0 : ctx.attempt) !== null && _a !== void 0 ? _a : 0,
                            },
                            stepState,
                            requestedRunStep: stepId === "step" ? undefined : stepId || undefined,
                            timer,
                            isFailureHandler: fn.onFailure,
                            disableImmediateExecution: ctx === null || ctx === void 0 ? void 0 : ctx.disable_immediate_execution,
                            stepCompletionOrder: (_c = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.stack) === null || _b === void 0 ? void 0 : _b.stack) !== null && _c !== void 0 ? _c : [],
                            reqArgs,
                            headers,
                        },
                    };
                },
                [InngestExecution_js_1.ExecutionVersion.V2]: ({ event, events, steps, ctx, version }) => {
                    var _a, _b, _c;
                    const stepState = Object.entries(steps !== null && steps !== void 0 ? steps : {}).reduce((acc, [id, result]) => {
                        return Object.assign(Object.assign({}, acc), { [id]: result.type === "data"
                                ? // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                                    { id, data: result.data }
                                : result.type === "input"
                                    ? // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                                        { id, input: result.input }
                                    : { id, error: result.error } });
                    }, {});
                    return {
                        version,
                        partialOptions: {
                            runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || "",
                            data: {
                                event: event,
                                events: events,
                                runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || "",
                                attempt: (_a = ctx === null || ctx === void 0 ? void 0 : ctx.attempt) !== null && _a !== void 0 ? _a : 0,
                            },
                            stepState,
                            requestedRunStep: stepId === "step" ? undefined : stepId || undefined,
                            timer,
                            isFailureHandler: fn.onFailure,
                            disableImmediateExecution: ctx === null || ctx === void 0 ? void 0 : ctx.disable_immediate_execution,
                            stepCompletionOrder: (_c = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.stack) === null || _b === void 0 ? void 0 : _b.stack) !== null && _c !== void 0 ? _c : [],
                            reqArgs,
                            headers,
                        },
                    };
                },
            });
            const executionOptions = await executionStarters[version](anyFnData.value);
            return fn.fn["createExecution"](executionOptions).start();
        });
        return { version, result };
    }
    configs(url) {
        const configs = Object.values(this.rawFns).reduce((acc, fn) => [
            ...acc,
            ...fn["getConfig"]({ baseUrl: url, appPrefix: this.id }),
        ], []);
        for (const config of configs) {
            const check = types_js_1.functionConfigSchema.safeParse(config);
            if (!check.success) {
                const errors = check.error.errors.map((err) => err.message).join("; ");
                this.log("warn", `Config invalid for function "${config.id}" : ${errors}`);
            }
        }
        return configs;
    }
    /**
     * Return an Inngest serve endpoint URL given a potential `path` and `host`.
     *
     * Will automatically use the `serveHost` and `servePath` if they have been
     * set when registering.
     */
    reqUrl(url) {
        let ret = new URL(url);
        const serveHost = this.serveHost || this.env[consts_js_1.envKeys.InngestServeHost];
        const servePath = this.servePath || this.env[consts_js_1.envKeys.InngestServePath];
        if (servePath) {
            ret.pathname = servePath;
        }
        if (serveHost) {
            ret = new URL(ret.pathname + ret.search, serveHost);
        }
        return ret;
    }
    registerBody({ url, deployId, }) {
        const body = {
            url: url.href,
            deployType: "ping",
            framework: this.frameworkName,
            appName: this.id,
            functions: this.configs(url),
            sdk: `js:v${version_js_1.version}`,
            v: "0.1",
            deployId: deployId || undefined,
            capabilities: {
                trust_probe: "v1",
                connect: "v1",
            },
            appVersion: this.client.appVersion,
        };
        return body;
    }
    async inBandRegisterBody({ actions, deployId, env, signatureValidation, url, }) {
        const registerBody = this.registerBody({ deployId, url });
        const introspectionBody = await this.introspectionBody({
            actions,
            env,
            signatureValidation,
            url,
        });
        const body = {
            app_id: this.id,
            appVersion: this.client.appVersion,
            capabilities: registerBody.capabilities,
            env,
            framework: registerBody.framework,
            functions: registerBody.functions,
            inspection: introspectionBody,
            platform: (0, env_js_1.getPlatformName)(Object.assign(Object.assign({}, (0, env_js_1.allProcessEnv)()), this.env)),
            sdk_author: "inngest",
            sdk_language: "",
            sdk_version: "",
            sdk: registerBody.sdk,
            url: registerBody.url,
        };
        if (introspectionBody.authentication_succeeded) {
            body.sdk_language = introspectionBody.sdk_language;
            body.sdk_version = introspectionBody.sdk_version;
        }
        return body;
    }
    async introspectionBody({ actions, env, signatureValidation, url, }) {
        var _a, _b, _c, _d, _e;
        const registerBody = this.registerBody({
            url: this.reqUrl(url),
            deployId: null,
        });
        if (!this._mode) {
            throw new Error("No mode set; cannot introspect without mode");
        }
        let introspection = {
            authentication_succeeded: null,
            extra: {
                is_mode_explicit: this._mode.isExplicit,
            },
            has_event_key: this.client["eventKeySet"](),
            has_signing_key: Boolean(this.signingKey),
            function_count: registerBody.functions.length,
            mode: this._mode.type,
            schema_version: "2024-05-24",
        };
        // Only allow authenticated introspection in Cloud mode, since Dev mode skips
        // signature validation
        if (this._mode.type === "cloud") {
            try {
                const validationResult = await signatureValidation;
                if (!validationResult.success) {
                    throw new Error("Signature validation failed");
                }
                introspection = Object.assign(Object.assign({}, introspection), { authentication_succeeded: true, api_origin: this.apiBaseUrl, app_id: this.id, capabilities: {
                        trust_probe: "v1",
                        connect: "v1",
                    }, env, event_api_origin: this.eventApiBaseUrl, event_key_hash: (_a = this.hashedEventKey) !== null && _a !== void 0 ? _a : null, extra: Object.assign(Object.assign({}, introspection.extra), { is_streaming: await this.shouldStream(actions) }), framework: this.frameworkName, sdk_language: "js", sdk_version: version_js_1.version, serve_origin: (_b = this.serveHost) !== null && _b !== void 0 ? _b : null, serve_path: (_c = this.servePath) !== null && _c !== void 0 ? _c : null, signing_key_fallback_hash: (_d = this.hashedSigningKeyFallback) !== null && _d !== void 0 ? _d : null, signing_key_hash: (_e = this.hashedSigningKey) !== null && _e !== void 0 ? _e : null });
            }
            catch (_f) {
                // Swallow signature validation error since we'll just return the
                // unauthenticated introspection
                introspection = Object.assign(Object.assign({}, introspection), { authentication_succeeded: false });
            }
        }
        return introspection;
    }
    async register(url, deployId, getHeaders) {
        var _a;
        const body = this.registerBody({ url, deployId });
        let res;
        // Whenever we register, we check to see if the dev server is up.  This
        // is a noop and returns false in production. Clone the URL object to avoid
        // mutating the property between requests.
        let registerURL = new URL(this.inngestRegisterUrl.href);
        const inferredDevMode = this._mode && this._mode.isInferred && this._mode.isDev;
        if (inferredDevMode) {
            const host = (0, env_js_1.devServerHost)(this.env);
            const hasDevServer = await (0, devserver_js_1.devServerAvailable)(host, this.fetch);
            if (hasDevServer) {
                registerURL = (0, devserver_js_1.devServerUrl)(host, "/fn/register");
            }
        }
        else if ((_a = this._mode) === null || _a === void 0 ? void 0 : _a.explicitDevUrl) {
            registerURL = (0, devserver_js_1.devServerUrl)(this._mode.explicitDevUrl.href, "/fn/register");
        }
        if (deployId) {
            registerURL.searchParams.set(consts_js_1.queryKeys.DeployId, deployId);
        }
        try {
            res = await (0, net_js_1.fetchWithAuthFallback)({
                authToken: this.hashedSigningKey,
                authTokenFallback: this.hashedSigningKeyFallback,
                fetch: this.fetch,
                url: registerURL.href,
                options: {
                    method: "POST",
                    body: (0, strings_js_1.stringify)(body),
                    headers: Object.assign(Object.assign({}, getHeaders()), { [consts_js_1.headerKeys.InngestSyncKind]: consts_js_1.syncKind.OutOfBand }),
                    redirect: "follow",
                },
            });
        }
        catch (err) {
            this.log("error", err);
            return {
                status: 500,
                message: `Failed to register${err instanceof Error ? `; ${err.message}` : ""}`,
                modified: false,
            };
        }
        const raw = await res.text();
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        let data = {};
        try {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            data = JSON.parse(raw);
        }
        catch (err) {
            this.log("warn", "Couldn't unpack register response:", err);
            let message = "Failed to register";
            if (err instanceof Error) {
                message += `; ${err.message}`;
            }
            message += `; status code: ${res.status}`;
            return {
                status: 500,
                message,
                modified: false,
            };
        }
        let status;
        let error;
        let skipped;
        let modified;
        try {
            ({ status, error, skipped, modified } = registerResSchema.parse(data));
        }
        catch (err) {
            this.log("warn", "Invalid register response schema:", err);
            let message = "Failed to register";
            if (err instanceof Error) {
                message += `; ${err.message}`;
            }
            message += `; status code: ${res.status}`;
            return {
                status: 500,
                message,
                modified: false,
            };
        }
        // The dev server polls this endpoint to register functions every few
        // seconds, but we only want to log that we've registered functions if
        // the function definitions change.  Therefore, we compare the body sent
        // during registration with the body of the current functions and refuse
        // to register if the functions are the same.
        if (!skipped) {
            this.log("debug", "registered inngest functions:", res.status, res.statusText, data);
        }
        return { status, message: error, modified };
    }
    /**
     * Given an environment, upsert any missing keys. This is useful in
     * situations where environment variables are passed directly to handlers or
     * are otherwise difficult to access during initialization.
     */
    upsertKeysFromEnv() {
        if (this.env[consts_js_1.envKeys.InngestSigningKey]) {
            if (!this.signingKey) {
                this.signingKey = String(this.env[consts_js_1.envKeys.InngestSigningKey]);
            }
            this.client["inngestApi"].setSigningKey(this.signingKey);
        }
        if (this.env[consts_js_1.envKeys.InngestSigningKeyFallback]) {
            if (!this.signingKeyFallback) {
                this.signingKeyFallback = String(this.env[consts_js_1.envKeys.InngestSigningKeyFallback]);
            }
            this.client["inngestApi"].setSigningKeyFallback(this.signingKeyFallback);
        }
        if (!this.client["eventKeySet"]() && this.env[consts_js_1.envKeys.InngestEventKey]) {
            this.client.setEventKey(String(this.env[consts_js_1.envKeys.InngestEventKey]));
        }
        // v2 -> v3 migration warnings
        if (this.env[consts_js_1.envKeys.InngestDevServerUrl]) {
            this.log("warn", `Use of ${consts_js_1.envKeys.InngestDevServerUrl} has been deprecated in v3; please use ${consts_js_1.envKeys.InngestBaseUrl} instead. See https://www.inngest.com/docs/sdk/migration`);
        }
    }
    /**
     * Validate the signature of a request and return the signing key used to
     * validate it.
     */
    // eslint-disable-next-line @typescript-eslint/require-await
    async validateSignature(sig, body) {
        try {
            // Skip signature validation if requested (used by connect)
            if (this.skipSignatureValidation) {
                return { success: true, keyUsed: "" };
            }
            // Never validate signatures outside of prod. Make sure to check the mode
            // exists here instead of using nullish coalescing to confirm that the check
            // has been completed.
            if (this._mode && !this._mode.isCloud) {
                return { success: true, keyUsed: "" };
            }
            // If we're here, we're in production; lack of a signing key is an error.
            if (!this.signingKey) {
                // TODO PrettyError
                throw new Error(`No signing key found in client options or ${consts_js_1.envKeys.InngestSigningKey} env var. Find your keys at https://app.inngest.com/secrets`);
            }
            // If we're here, we're in production; lack of a req signature is an error.
            if (!sig) {
                // TODO PrettyError
                throw new Error(`No ${consts_js_1.headerKeys.Signature} provided`);
            }
            // Validate the signature
            return {
                success: true,
                keyUsed: new RequestSignature(sig).verifySignature({
                    body,
                    allowExpiredSignatures: this.allowExpiredSignatures,
                    signingKey: this.signingKey,
                    signingKeyFallback: this.signingKeyFallback,
                }),
            };
        }
        catch (err) {
            return { success: false, err: err };
        }
    }
    getResponseSignature(key, body) {
        const now = Date.now();
        const mac = (0, net_js_1.signDataWithKey)(body, key, now.toString());
        return `t=${now}&s=${mac}`;
    }
    /**
     * Log to stdout/stderr if the log level is set to include the given level.
     * The default log level is `"info"`.
     *
     * This is an abstraction over `console.log` and will try to use the correct
     * method for the given log level.  For example, `log("error", "foo")` will
     * call `console.error("foo")`.
     */
    log(level, ...args) {
        const logLevels = [
            "debug",
            "info",
            "warn",
            "error",
            "fatal",
            "silent",
        ];
        const logLevelSetting = logLevels.indexOf(this.logLevel);
        const currentLevel = logLevels.indexOf(level);
        if (currentLevel >= logLevelSetting) {
            let logger = console.log;
            if (Object.prototype.hasOwnProperty.call(console, level)) {
                logger = console[level];
            }
            logger(`${consts_js_1.logPrefix} ${level} -`, ...args);
        }
    }
}
InngestCommHandler$1.InngestCommHandler = InngestCommHandler;
class RequestSignature {
    constructor(sig) {
        _RequestSignature_instances.add(this);
        const params = new URLSearchParams(sig);
        this.timestamp = params.get("t") || "";
        this.signature = params.get("s") || "";
        if (!this.timestamp || !this.signature) {
            // TODO PrettyError
            throw new Error(`Invalid ${consts_js_1.headerKeys.Signature} provided`);
        }
    }
    hasExpired(allowExpiredSignatures) {
        if (allowExpiredSignatures) {
            return false;
        }
        const delta = Date.now() - new Date(parseInt(this.timestamp) * 1000).valueOf();
        return delta > 1000 * 60 * 5;
    }
    verifySignature({ body, signingKey, signingKeyFallback, allowExpiredSignatures, }) {
        try {
            __classPrivateFieldGet$1(this, _RequestSignature_instances, "m", _RequestSignature_verifySignature).call(this, { body, signingKey, allowExpiredSignatures });
            return signingKey;
        }
        catch (err) {
            if (!signingKeyFallback) {
                throw err;
            }
            __classPrivateFieldGet$1(this, _RequestSignature_instances, "m", _RequestSignature_verifySignature).call(this, {
                body,
                signingKey: signingKeyFallback,
                allowExpiredSignatures,
            });
            return signingKeyFallback;
        }
    }
}
_RequestSignature_instances = new WeakSet(), _RequestSignature_verifySignature = function _RequestSignature_verifySignature({ body, signingKey, allowExpiredSignatures, }) {
    if (this.hasExpired(allowExpiredSignatures)) {
        // TODO PrettyError
        throw new Error("Signature has expired");
    }
    const mac = (0, net_js_1.signDataWithKey)(body, signingKey, this.timestamp);
    if (mac !== this.signature) {
        // TODO PrettyError
        throw new Error("Invalid signature");
    }
};

var dependencyInjection = {};

Object.defineProperty(dependencyInjection, "__esModule", { value: true });
dependencyInjection.dependencyInjectionMiddleware = void 0;
const InngestMiddleware_js_1 = InngestMiddleware$1;
/**
 * Adds properties to the function input for every function created using this
 * app.
 */
// We can use `const` here yet due to TS constraints.
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const dependencyInjectionMiddleware = (
/**
 * The context to inject into the function input.
 */
ctx) => {
    return new InngestMiddleware_js_1.InngestMiddleware({
        name: "Inngest: Dependency Injection",
        init() {
            return {
                onFunctionRun() {
                    return {
                        transformInput() {
                            return {
                                ctx,
                            };
                        },
                    };
                },
            };
        },
    });
};
dependencyInjection.dependencyInjectionMiddleware = dependencyInjectionMiddleware;

(function (exports) {
	/**
	 * The primary entrypoint for the Inngest SDK. This provides all the necessary
	 * exports to create, run, and trigger Inngest functions.
	 *
	 * Typical usage involves creating a new Inngest client with `Inngest`, and then
	 * using the client to create functions, middleware, and other tools.
	 *
	 * See {@link https://www.inngest.com/docs} for more information.
	 *
	 * @example Create an Inngest client
	 * ```ts
	 * const inngest = new Inngest({
	 *   id: "my-app-id",
	 * });
	 * ```
	 *
	 * @example Create an Inngest function
	 * ```ts
	 * const myFn = inngest.createFunction({
	 *  id: "my-function",
	 * }, {
	 *   event: "user/created",
	 * }, async ({ event, step }) => {
	 *   console.log("User created:", event.data);
	 * });
	 * ```
	 *
	 * @example Send an event
	 * ```ts
	 * await inngest.send({
	 *   name: "user/created",
	 *   data: {
	 *     id: "123",
	 *   },
	 * });
	 * ```
	 *
	 * @module
	 */
	var __createBinding = (inngest$1 && inngest$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (inngest$1 && inngest$1.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.version = exports.ProxyLogger = exports.dependencyInjectionMiddleware = exports.slugify = exports.queryKeys = exports.internalEvents = exports.headerKeys = exports.StepError = exports.RetryAfterError = exports.NonRetriableError = exports.InngestMiddleware = exports.referenceFunction = exports.InngestCommHandler = exports.Inngest = exports.EventSchemas = void 0;
	__exportStar(dist$1, exports);
	var EventSchemas_js_1 = EventSchemas$1;
	Object.defineProperty(exports, "EventSchemas", { enumerable: true, get: function () { return EventSchemas_js_1.EventSchemas; } });
	var Fetch_js_1 = Fetch;
	Object.defineProperty(exports, "fetch", { enumerable: true, get: function () { return Fetch_js_1.fetch; } });
	var Inngest_js_1 = Inngest$1;
	Object.defineProperty(exports, "Inngest", { enumerable: true, get: function () { return Inngest_js_1.Inngest; } });
	var InngestCommHandler_js_1 = InngestCommHandler$1;
	Object.defineProperty(exports, "InngestCommHandler", { enumerable: true, get: function () { return InngestCommHandler_js_1.InngestCommHandler; } });
	var InngestFunctionReference_js_1 = InngestFunctionReference$1;
	Object.defineProperty(exports, "referenceFunction", { enumerable: true, get: function () { return InngestFunctionReference_js_1.referenceFunction; } });
	var InngestMiddleware_js_1 = InngestMiddleware$1;
	Object.defineProperty(exports, "InngestMiddleware", { enumerable: true, get: function () { return InngestMiddleware_js_1.InngestMiddleware; } });
	var NonRetriableError_js_1 = NonRetriableError$1;
	Object.defineProperty(exports, "NonRetriableError", { enumerable: true, get: function () { return NonRetriableError_js_1.NonRetriableError; } });
	var RetryAfterError_js_1 = RetryAfterError$1;
	Object.defineProperty(exports, "RetryAfterError", { enumerable: true, get: function () { return RetryAfterError_js_1.RetryAfterError; } });
	var StepError_js_1 = StepError$1;
	Object.defineProperty(exports, "StepError", { enumerable: true, get: function () { return StepError_js_1.StepError; } });
	var consts_js_1 = consts;
	Object.defineProperty(exports, "headerKeys", { enumerable: true, get: function () { return consts_js_1.headerKeys; } });
	Object.defineProperty(exports, "internalEvents", { enumerable: true, get: function () { return consts_js_1.internalEvents; } });
	Object.defineProperty(exports, "queryKeys", { enumerable: true, get: function () { return consts_js_1.queryKeys; } });
	var strings_js_1 = strings;
	Object.defineProperty(exports, "slugify", { enumerable: true, get: function () { return strings_js_1.slugify; } });
	var dependencyInjection_js_1 = dependencyInjection;
	Object.defineProperty(exports, "dependencyInjectionMiddleware", { enumerable: true, get: function () { return dependencyInjection_js_1.dependencyInjectionMiddleware; } });
	var logger_js_1 = logger;
	Object.defineProperty(exports, "ProxyLogger", { enumerable: true, get: function () { return logger_js_1.ProxyLogger; } });
	var version_js_1 = version;
	Object.defineProperty(exports, "version", { enumerable: true, get: function () { return version_js_1.version; } });
	
} (inngest$1));

var lib = {};

var external = {};

var errors = {};

var en = {};

var util$1 = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getParsedType = exports.ZodParsedType = exports.objectUtil = exports.util = void 0;
	var util;
	(function (util) {
	    util.assertEqual = (val) => val;
	    function assertIs(_arg) { }
	    util.assertIs = assertIs;
	    function assertNever(_x) {
	        throw new Error();
	    }
	    util.assertNever = assertNever;
	    util.arrayToEnum = (items) => {
	        const obj = {};
	        for (const item of items) {
	            obj[item] = item;
	        }
	        return obj;
	    };
	    util.getValidEnumValues = (obj) => {
	        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
	        const filtered = {};
	        for (const k of validKeys) {
	            filtered[k] = obj[k];
	        }
	        return util.objectValues(filtered);
	    };
	    util.objectValues = (obj) => {
	        return util.objectKeys(obj).map(function (e) {
	            return obj[e];
	        });
	    };
	    util.objectKeys = typeof Object.keys === "function" // eslint-disable-line ban/ban
	        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban
	        : (object) => {
	            const keys = [];
	            for (const key in object) {
	                if (Object.prototype.hasOwnProperty.call(object, key)) {
	                    keys.push(key);
	                }
	            }
	            return keys;
	        };
	    util.find = (arr, checker) => {
	        for (const item of arr) {
	            if (checker(item))
	                return item;
	        }
	        return undefined;
	    };
	    util.isInteger = typeof Number.isInteger === "function"
	        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban
	        : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
	    function joinValues(array, separator = " | ") {
	        return array
	            .map((val) => (typeof val === "string" ? `'${val}'` : val))
	            .join(separator);
	    }
	    util.joinValues = joinValues;
	    util.jsonStringifyReplacer = (_, value) => {
	        if (typeof value === "bigint") {
	            return value.toString();
	        }
	        return value;
	    };
	})(util || (exports.util = util = {}));
	var objectUtil;
	(function (objectUtil) {
	    objectUtil.mergeShapes = (first, second) => {
	        return {
	            ...first,
	            ...second, // second overwrites first
	        };
	    };
	})(objectUtil || (exports.objectUtil = objectUtil = {}));
	exports.ZodParsedType = util.arrayToEnum([
	    "string",
	    "nan",
	    "number",
	    "integer",
	    "float",
	    "boolean",
	    "date",
	    "bigint",
	    "symbol",
	    "function",
	    "undefined",
	    "null",
	    "array",
	    "object",
	    "unknown",
	    "promise",
	    "void",
	    "never",
	    "map",
	    "set",
	]);
	const getParsedType = (data) => {
	    const t = typeof data;
	    switch (t) {
	        case "undefined":
	            return exports.ZodParsedType.undefined;
	        case "string":
	            return exports.ZodParsedType.string;
	        case "number":
	            return isNaN(data) ? exports.ZodParsedType.nan : exports.ZodParsedType.number;
	        case "boolean":
	            return exports.ZodParsedType.boolean;
	        case "function":
	            return exports.ZodParsedType.function;
	        case "bigint":
	            return exports.ZodParsedType.bigint;
	        case "symbol":
	            return exports.ZodParsedType.symbol;
	        case "object":
	            if (Array.isArray(data)) {
	                return exports.ZodParsedType.array;
	            }
	            if (data === null) {
	                return exports.ZodParsedType.null;
	            }
	            if (data.then &&
	                typeof data.then === "function" &&
	                data.catch &&
	                typeof data.catch === "function") {
	                return exports.ZodParsedType.promise;
	            }
	            if (typeof Map !== "undefined" && data instanceof Map) {
	                return exports.ZodParsedType.map;
	            }
	            if (typeof Set !== "undefined" && data instanceof Set) {
	                return exports.ZodParsedType.set;
	            }
	            if (typeof Date !== "undefined" && data instanceof Date) {
	                return exports.ZodParsedType.date;
	            }
	            return exports.ZodParsedType.object;
	        default:
	            return exports.ZodParsedType.unknown;
	    }
	};
	exports.getParsedType = getParsedType; 
} (util$1));

var ZodError$1 = {};

Object.defineProperty(ZodError$1, "__esModule", { value: true });
ZodError$1.ZodError = ZodError$1.quotelessJson = ZodError$1.ZodIssueCode = void 0;
const util_1$2 = util$1;
ZodError$1.ZodIssueCode = util_1$2.util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite",
]);
const quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
};
ZodError$1.quotelessJson = quotelessJson;
class ZodError extends Error {
    get errors() {
        return this.issues;
    }
    constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
            this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
            this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
            // eslint-disable-next-line ban/ban
            Object.setPrototypeOf(this, actualProto);
        }
        else {
            this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
    }
    format(_mapper) {
        const mapper = _mapper ||
            function (issue) {
                return issue.message;
            };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
            for (const issue of error.issues) {
                if (issue.code === "invalid_union") {
                    issue.unionErrors.map(processError);
                }
                else if (issue.code === "invalid_return_type") {
                    processError(issue.returnTypeError);
                }
                else if (issue.code === "invalid_arguments") {
                    processError(issue.argumentsError);
                }
                else if (issue.path.length === 0) {
                    fieldErrors._errors.push(mapper(issue));
                }
                else {
                    let curr = fieldErrors;
                    let i = 0;
                    while (i < issue.path.length) {
                        const el = issue.path[i];
                        const terminal = i === issue.path.length - 1;
                        if (!terminal) {
                            curr[el] = curr[el] || { _errors: [] };
                            // if (typeof el === "string") {
                            //   curr[el] = curr[el] || { _errors: [] };
                            // } else if (typeof el === "number") {
                            //   const errorArray: any = [];
                            //   errorArray._errors = [];
                            //   curr[el] = curr[el] || errorArray;
                            // }
                        }
                        else {
                            curr[el] = curr[el] || { _errors: [] };
                            curr[el]._errors.push(mapper(issue));
                        }
                        curr = curr[el];
                        i++;
                    }
                }
            }
        };
        processError(this);
        return fieldErrors;
    }
    static assert(value) {
        if (!(value instanceof ZodError)) {
            throw new Error(`Not a ZodError: ${value}`);
        }
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, util_1$2.util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
            if (sub.path.length > 0) {
                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
                fieldErrors[sub.path[0]].push(mapper(sub));
            }
            else {
                formErrors.push(mapper(sub));
            }
        }
        return { formErrors, fieldErrors };
    }
    get formErrors() {
        return this.flatten();
    }
}
ZodError$1.ZodError = ZodError;
ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
};

Object.defineProperty(en, "__esModule", { value: true });
const util_1$1$1 = util$1;
const ZodError_1$1 = ZodError$1;
const errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
        case ZodError_1$1.ZodIssueCode.invalid_type:
            if (issue.received === util_1$1$1.ZodParsedType.undefined) {
                message = "Required";
            }
            else {
                message = `Expected ${issue.expected}, received ${issue.received}`;
            }
            break;
        case ZodError_1$1.ZodIssueCode.invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_1$1$1.util.jsonStringifyReplacer)}`;
            break;
        case ZodError_1$1.ZodIssueCode.unrecognized_keys:
            message = `Unrecognized key(s) in object: ${util_1$1$1.util.joinValues(issue.keys, ", ")}`;
            break;
        case ZodError_1$1.ZodIssueCode.invalid_union:
            message = `Invalid input`;
            break;
        case ZodError_1$1.ZodIssueCode.invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${util_1$1$1.util.joinValues(issue.options)}`;
            break;
        case ZodError_1$1.ZodIssueCode.invalid_enum_value:
            message = `Invalid enum value. Expected ${util_1$1$1.util.joinValues(issue.options)}, received '${issue.received}'`;
            break;
        case ZodError_1$1.ZodIssueCode.invalid_arguments:
            message = `Invalid function arguments`;
            break;
        case ZodError_1$1.ZodIssueCode.invalid_return_type:
            message = `Invalid function return type`;
            break;
        case ZodError_1$1.ZodIssueCode.invalid_date:
            message = `Invalid date`;
            break;
        case ZodError_1$1.ZodIssueCode.invalid_string:
            if (typeof issue.validation === "object") {
                if ("includes" in issue.validation) {
                    message = `Invalid input: must include "${issue.validation.includes}"`;
                    if (typeof issue.validation.position === "number") {
                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                    }
                }
                else if ("startsWith" in issue.validation) {
                    message = `Invalid input: must start with "${issue.validation.startsWith}"`;
                }
                else if ("endsWith" in issue.validation) {
                    message = `Invalid input: must end with "${issue.validation.endsWith}"`;
                }
                else {
                    util_1$1$1.util.assertNever(issue.validation);
                }
            }
            else if (issue.validation !== "regex") {
                message = `Invalid ${issue.validation}`;
            }
            else {
                message = "Invalid";
            }
            break;
        case ZodError_1$1.ZodIssueCode.too_small:
            if (issue.type === "array")
                message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be ${issue.exact
                    ? `exactly equal to `
                    : issue.inclusive
                        ? `greater than or equal to `
                        : `greater than `}${issue.minimum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact
                    ? `exactly equal to `
                    : issue.inclusive
                        ? `greater than or equal to `
                        : `greater than `}${new Date(Number(issue.minimum))}`;
            else
                message = "Invalid input";
            break;
        case ZodError_1$1.ZodIssueCode.too_big:
            if (issue.type === "array")
                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `less than or equal to`
                        : `less than`} ${issue.maximum}`;
            else if (issue.type === "bigint")
                message = `BigInt must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `less than or equal to`
                        : `less than`} ${issue.maximum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `smaller than or equal to`
                        : `smaller than`} ${new Date(Number(issue.maximum))}`;
            else
                message = "Invalid input";
            break;
        case ZodError_1$1.ZodIssueCode.custom:
            message = `Invalid input`;
            break;
        case ZodError_1$1.ZodIssueCode.invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
        case ZodError_1$1.ZodIssueCode.not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
        case ZodError_1$1.ZodIssueCode.not_finite:
            message = "Number must be finite";
            break;
        default:
            message = _ctx.defaultError;
            util_1$1$1.util.assertNever(issue);
    }
    return { message };
};
en.default = errorMap;

var __importDefault$1 = (errors && errors.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(errors, "__esModule", { value: true });
errors.getErrorMap = errors.setErrorMap = errors.defaultErrorMap = void 0;
const en_1 = __importDefault$1(en);
errors.defaultErrorMap = en_1.default;
let overrideErrorMap = en_1.default;
function setErrorMap(map) {
    overrideErrorMap = map;
}
errors.setErrorMap = setErrorMap;
function getErrorMap() {
    return overrideErrorMap;
}
errors.getErrorMap = getErrorMap;

var parseUtil = {};

(function (exports) {
	var __importDefault = (parseUtil && parseUtil.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isAsync = exports.isValid = exports.isDirty = exports.isAborted = exports.OK = exports.DIRTY = exports.INVALID = exports.ParseStatus = exports.addIssueToContext = exports.EMPTY_PATH = exports.makeIssue = void 0;
	const errors_1 = errors;
	const en_1 = __importDefault(en);
	const makeIssue = (params) => {
	    const { data, path, errorMaps, issueData } = params;
	    const fullPath = [...path, ...(issueData.path || [])];
	    const fullIssue = {
	        ...issueData,
	        path: fullPath,
	    };
	    if (issueData.message !== undefined) {
	        return {
	            ...issueData,
	            path: fullPath,
	            message: issueData.message,
	        };
	    }
	    let errorMessage = "";
	    const maps = errorMaps
	        .filter((m) => !!m)
	        .slice()
	        .reverse();
	    for (const map of maps) {
	        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
	    }
	    return {
	        ...issueData,
	        path: fullPath,
	        message: errorMessage,
	    };
	};
	exports.makeIssue = makeIssue;
	exports.EMPTY_PATH = [];
	function addIssueToContext(ctx, issueData) {
	    const overrideMap = (0, errors_1.getErrorMap)();
	    const issue = (0, exports.makeIssue)({
	        issueData: issueData,
	        data: ctx.data,
	        path: ctx.path,
	        errorMaps: [
	            ctx.common.contextualErrorMap, // contextual error map is first priority
	            ctx.schemaErrorMap, // then schema-bound map if available
	            overrideMap, // then global override map
	            overrideMap === en_1.default ? undefined : en_1.default, // then global default map
	        ].filter((x) => !!x),
	    });
	    ctx.common.issues.push(issue);
	}
	exports.addIssueToContext = addIssueToContext;
	class ParseStatus {
	    constructor() {
	        this.value = "valid";
	    }
	    dirty() {
	        if (this.value === "valid")
	            this.value = "dirty";
	    }
	    abort() {
	        if (this.value !== "aborted")
	            this.value = "aborted";
	    }
	    static mergeArray(status, results) {
	        const arrayValue = [];
	        for (const s of results) {
	            if (s.status === "aborted")
	                return exports.INVALID;
	            if (s.status === "dirty")
	                status.dirty();
	            arrayValue.push(s.value);
	        }
	        return { status: status.value, value: arrayValue };
	    }
	    static async mergeObjectAsync(status, pairs) {
	        const syncPairs = [];
	        for (const pair of pairs) {
	            const key = await pair.key;
	            const value = await pair.value;
	            syncPairs.push({
	                key,
	                value,
	            });
	        }
	        return ParseStatus.mergeObjectSync(status, syncPairs);
	    }
	    static mergeObjectSync(status, pairs) {
	        const finalObject = {};
	        for (const pair of pairs) {
	            const { key, value } = pair;
	            if (key.status === "aborted")
	                return exports.INVALID;
	            if (value.status === "aborted")
	                return exports.INVALID;
	            if (key.status === "dirty")
	                status.dirty();
	            if (value.status === "dirty")
	                status.dirty();
	            if (key.value !== "__proto__" &&
	                (typeof value.value !== "undefined" || pair.alwaysSet)) {
	                finalObject[key.value] = value.value;
	            }
	        }
	        return { status: status.value, value: finalObject };
	    }
	}
	exports.ParseStatus = ParseStatus;
	exports.INVALID = Object.freeze({
	    status: "aborted",
	});
	const DIRTY = (value) => ({ status: "dirty", value });
	exports.DIRTY = DIRTY;
	const OK = (value) => ({ status: "valid", value });
	exports.OK = OK;
	const isAborted = (x) => x.status === "aborted";
	exports.isAborted = isAborted;
	const isDirty = (x) => x.status === "dirty";
	exports.isDirty = isDirty;
	const isValid = (x) => x.status === "valid";
	exports.isValid = isValid;
	const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
	exports.isAsync = isAsync; 
} (parseUtil));

var typeAliases = {};

Object.defineProperty(typeAliases, "__esModule", { value: true });

var types$1 = {};

var errorUtil$1 = {};

Object.defineProperty(errorUtil$1, "__esModule", { value: true });
errorUtil$1.errorUtil = void 0;
var errorUtil;
(function (errorUtil) {
    errorUtil.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil$1.errorUtil = errorUtil = {}));

var __classPrivateFieldGet = (types$1 && types$1.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (types$1 && types$1.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _ZodEnum_cache, _ZodNativeEnum_cache;
Object.defineProperty(types$1, "__esModule", { value: true });
types$1.boolean = types$1.bigint = types$1.array = types$1.any = types$1.coerce = types$1.ZodFirstPartyTypeKind = types$1.late = types$1.ZodSchema = types$1.Schema = types$1.custom = types$1.ZodReadonly = types$1.ZodPipeline = types$1.ZodBranded = types$1.BRAND = types$1.ZodNaN = types$1.ZodCatch = types$1.ZodDefault = types$1.ZodNullable = types$1.ZodOptional = types$1.ZodTransformer = types$1.ZodEffects = types$1.ZodPromise = types$1.ZodNativeEnum = types$1.ZodEnum = types$1.ZodLiteral = types$1.ZodLazy = types$1.ZodFunction = types$1.ZodSet = types$1.ZodMap = types$1.ZodRecord = types$1.ZodTuple = types$1.ZodIntersection = types$1.ZodDiscriminatedUnion = types$1.ZodUnion = types$1.ZodObject = types$1.ZodArray = types$1.ZodVoid = types$1.ZodNever = types$1.ZodUnknown = types$1.ZodAny = types$1.ZodNull = types$1.ZodUndefined = types$1.ZodSymbol = types$1.ZodDate = types$1.ZodBoolean = types$1.ZodBigInt = types$1.ZodNumber = types$1.ZodString = types$1.datetimeRegex = types$1.ZodType = void 0;
types$1.NEVER = types$1.void = types$1.unknown = types$1.union = types$1.undefined = types$1.tuple = types$1.transformer = types$1.symbol = types$1.string = types$1.strictObject = types$1.set = types$1.record = types$1.promise = types$1.preprocess = types$1.pipeline = types$1.ostring = types$1.optional = types$1.onumber = types$1.oboolean = types$1.object = types$1.number = types$1.nullable = types$1.null = types$1.never = types$1.nativeEnum = types$1.nan = types$1.map = types$1.literal = types$1.lazy = types$1.intersection = types$1.instanceof = types$1.function = types$1.enum = types$1.effect = types$1.discriminatedUnion = types$1.date = void 0;
const errors_1 = errors;
const errorUtil_1 = errorUtil$1;
const parseUtil_1 = parseUtil;
const util_1$3 = util$1;
const ZodError_1 = ZodError$1;
class ParseInputLazyPath {
    constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
    }
    get path() {
        if (!this._cachedPath.length) {
            if (this._key instanceof Array) {
                this._cachedPath.push(...this._path, ...this._key);
            }
            else {
                this._cachedPath.push(...this._path, this._key);
            }
        }
        return this._cachedPath;
    }
}
const handleResult = (ctx, result) => {
    if ((0, parseUtil_1.isValid)(result)) {
        return { success: true, data: result.value };
    }
    else {
        if (!ctx.common.issues.length) {
            throw new Error("Validation failed but no issues detected.");
        }
        return {
            success: false,
            get error() {
                if (this._error)
                    return this._error;
                const error = new ZodError_1.ZodError(ctx.common.issues);
                this._error = error;
                return this._error;
            },
        };
    }
};
function processCreateParams(params) {
    if (!params)
        return {};
    const { errorMap, invalid_type_error, required_error, description } = params;
    if (errorMap && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap)
        return { errorMap: errorMap, description };
    const customMap = (iss, ctx) => {
        var _a, _b;
        const { message } = params;
        if (iss.code === "invalid_enum_value") {
            return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
        }
        if (typeof ctx.data === "undefined") {
            return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
        }
        if (iss.code !== "invalid_type")
            return { message: ctx.defaultError };
        return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
    };
    return { errorMap: customMap, description };
}
class ZodType {
    get description() {
        return this._def.description;
    }
    _getType(input) {
        return (0, util_1$3.getParsedType)(input.data);
    }
    _getOrReturnCtx(input, ctx) {
        return (ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: (0, util_1$3.getParsedType)(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent,
        });
    }
    _processInputParams(input) {
        return {
            status: new parseUtil_1.ParseStatus(),
            ctx: {
                common: input.parent.common,
                data: input.data,
                parsedType: (0, util_1$3.getParsedType)(input.data),
                schemaErrorMap: this._def.errorMap,
                path: input.path,
                parent: input.parent,
            },
        };
    }
    _parseSync(input) {
        const result = this._parse(input);
        if ((0, parseUtil_1.isAsync)(result)) {
            throw new Error("Synchronous parse encountered promise.");
        }
        return result;
    }
    _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
    }
    parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    safeParse(data, params) {
        var _a;
        const ctx = {
            common: {
                issues: [],
                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: (0, util_1$3.getParsedType)(data),
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
    }
    "~validate"(data) {
        var _a, _b;
        const ctx = {
            common: {
                issues: [],
                async: !!this["~standard"].async,
            },
            path: [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: (0, util_1$3.getParsedType)(data),
        };
        if (!this["~standard"].async) {
            try {
                const result = this._parseSync({ data, path: [], parent: ctx });
                return (0, parseUtil_1.isValid)(result)
                    ? {
                        value: result.value,
                    }
                    : {
                        issues: ctx.common.issues,
                    };
            }
            catch (err) {
                if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
                    this["~standard"].async = true;
                }
                ctx.common = {
                    issues: [],
                    async: true,
                };
            }
        }
        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => (0, parseUtil_1.isValid)(result)
            ? {
                value: result.value,
            }
            : {
                issues: ctx.common.issues,
            });
    }
    async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    async safeParseAsync(data, params) {
        const ctx = {
            common: {
                issues: [],
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
                async: true,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: (0, util_1$3.getParsedType)(data),
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await ((0, parseUtil_1.isAsync)(maybeAsyncResult)
            ? maybeAsyncResult
            : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
    }
    refine(check, message) {
        const getIssueProperties = (val) => {
            if (typeof message === "string" || typeof message === "undefined") {
                return { message };
            }
            else if (typeof message === "function") {
                return message(val);
            }
            else {
                return message;
            }
        };
        return this._refinement((val, ctx) => {
            const result = check(val);
            const setError = () => ctx.addIssue({
                code: ZodError_1.ZodIssueCode.custom,
                ...getIssueProperties(val),
            });
            if (typeof Promise !== "undefined" && result instanceof Promise) {
                return result.then((data) => {
                    if (!data) {
                        setError();
                        return false;
                    }
                    else {
                        return true;
                    }
                });
            }
            if (!result) {
                setError();
                return false;
            }
            else {
                return true;
            }
        });
    }
    refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
            if (!check(val)) {
                ctx.addIssue(typeof refinementData === "function"
                    ? refinementData(val, ctx)
                    : refinementData);
                return false;
            }
            else {
                return true;
            }
        });
    }
    _refinement(refinement) {
        return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind$1.ZodEffects,
            effect: { type: "refinement", refinement },
        });
    }
    superRefine(refinement) {
        return this._refinement(refinement);
    }
    constructor(def) {
        /** Alias of safeParseAsync */
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
        this["~standard"] = {
            version: 1,
            vendor: "zod",
            validate: (data) => this["~validate"](data),
        };
    }
    optional() {
        return ZodOptional$1.create(this, this._def);
    }
    nullable() {
        return ZodNullable.create(this, this._def);
    }
    nullish() {
        return this.nullable().optional();
    }
    array() {
        return ZodArray.create(this);
    }
    promise() {
        return ZodPromise.create(this, this._def);
    }
    or(option) {
        return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
        return new ZodEffects({
            ...processCreateParams(this._def),
            schema: this,
            typeName: ZodFirstPartyTypeKind$1.ZodEffects,
            effect: { type: "transform", transform },
        });
    }
    default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
            ...processCreateParams(this._def),
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: ZodFirstPartyTypeKind$1.ZodDefault,
        });
    }
    brand() {
        return new ZodBranded({
            typeName: ZodFirstPartyTypeKind$1.ZodBranded,
            type: this,
            ...processCreateParams(this._def),
        });
    }
    catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
            ...processCreateParams(this._def),
            innerType: this,
            catchValue: catchValueFunc,
            typeName: ZodFirstPartyTypeKind$1.ZodCatch,
        });
    }
    describe(description) {
        const This = this.constructor;
        return new This({
            ...this._def,
            description,
        });
    }
    pipe(target) {
        return ZodPipeline.create(this, target);
    }
    readonly() {
        return ZodReadonly.create(this);
    }
    isOptional() {
        return this.safeParse(undefined).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
}
types$1.ZodType = ZodType;
types$1.Schema = ZodType;
types$1.ZodSchema = ZodType;
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
// const uuidRegex =
//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
// from https://stackoverflow.com/a/46181/1550155
// old version: too slow, didn't support unicode
// const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
//old email regex
// const emailRegex = /^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@((?!-)([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{1,})[^-<>()[\].,;:\s@"]$/i;
// eslint-disable-next-line
// const emailRegex =
//   /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
// const emailRegex =
//   /^[a-zA-Z0-9\.\!\#\$\%\&\'\*\+\/\=\?\^\_\`\{\|\}\~\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
// const emailRegex =
//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
// const emailRegex =
//   /^[a-z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\.[a-z0-9\-]+)*$/i;
// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex$1;
// faster, simpler, safer
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
// const ipv6Regex =
// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
// https://base64.guru/standards/base64url
const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
// simple
// const dateRegexSource = `\\d{4}-\\d{2}-\\d{2}`;
// no leap year validation
// const dateRegexSource = `\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\d|2\\d))`;
// with leap year validation
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
    let secondsRegexSource = `[0-5]\\d`;
    if (args.precision) {
        secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
    }
    else if (args.precision == null) {
        secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
    }
    const secondsQuantifier = args.precision ? "+" : "?"; // require seconds if precision is nonzero
    return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
    return new RegExp(`^${timeRegexSource(args)}$`);
}
// Adapted from https://stackoverflow.com/a/3143231
function datetimeRegex(args) {
    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset)
        opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex = `${regex}(${opts.join("|")})`;
    return new RegExp(`^${regex}$`);
}
types$1.datetimeRegex = datetimeRegex;
function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
        return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
        return true;
    }
    return false;
}
function isValidJWT(jwt, alg) {
    if (!jwtRegex.test(jwt))
        return false;
    try {
        const [header] = jwt.split(".");
        // Convert base64url to base64
        const base64 = header
            .replace(/-/g, "+")
            .replace(/_/g, "/")
            .padEnd(header.length + ((4 - (header.length % 4)) % 4), "=");
        const decoded = JSON.parse(atob(base64));
        if (typeof decoded !== "object" || decoded === null)
            return false;
        if (!decoded.typ || !decoded.alg)
            return false;
        if (alg && decoded.alg !== alg)
            return false;
        return true;
    }
    catch (_a) {
        return false;
    }
}
function isValidCidr(ip, version) {
    if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
        return true;
    }
    if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
        return true;
    }
    return false;
}
class ZodString extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1$3.ZodParsedType.string) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1$3.ZodParsedType.string,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        const status = new parseUtil_1.ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.length < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.length > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "length") {
                const tooBig = input.data.length > check.value;
                const tooSmall = input.data.length < check.value;
                if (tooBig || tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    if (tooBig) {
                        (0, parseUtil_1.addIssueToContext)(ctx, {
                            code: ZodError_1.ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message,
                        });
                    }
                    else if (tooSmall) {
                        (0, parseUtil_1.addIssueToContext)(ctx, {
                            code: ZodError_1.ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message,
                        });
                    }
                    status.dirty();
                }
            }
            else if (check.kind === "email") {
                if (!emailRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "email",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "emoji") {
                if (!emojiRegex$1) {
                    emojiRegex$1 = new RegExp(_emojiRegex, "u");
                }
                if (!emojiRegex$1.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "emoji",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "uuid") {
                if (!uuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "uuid",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "nanoid") {
                if (!nanoidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "nanoid",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid") {
                if (!cuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "cuid",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid2") {
                if (!cuid2Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "cuid2",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "ulid") {
                if (!ulidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "ulid",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "url") {
                try {
                    new URL(input.data);
                }
                catch (_a) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "url",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "regex") {
                check.regex.lastIndex = 0;
                const testResult = check.regex.test(input.data);
                if (!testResult) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "regex",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "trim") {
                input.data = input.data.trim();
            }
            else if (check.kind === "includes") {
                if (!input.data.includes(check.value, check.position)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        validation: { includes: check.value, position: check.position },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "toLowerCase") {
                input.data = input.data.toLowerCase();
            }
            else if (check.kind === "toUpperCase") {
                input.data = input.data.toUpperCase();
            }
            else if (check.kind === "startsWith") {
                if (!input.data.startsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        validation: { startsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "endsWith") {
                if (!input.data.endsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        validation: { endsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "datetime") {
                const regex = datetimeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        validation: "datetime",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "date") {
                const regex = dateRegex;
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        validation: "date",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "time") {
                const regex = timeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        validation: "time",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "duration") {
                if (!durationRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "duration",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "ip") {
                if (!isValidIP(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "ip",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "jwt") {
                if (!isValidJWT(input.data, check.alg)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "jwt",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cidr") {
                if (!isValidCidr(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "cidr",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "base64") {
                if (!base64Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "base64",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "base64url") {
                if (!base64urlRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        validation: "base64url",
                        code: ZodError_1.ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util_1$3.util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
        return this.refinement((data) => regex.test(data), {
            validation,
            code: ZodError_1.ZodIssueCode.invalid_string,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    _addCheck(check) {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    email(message) {
        return this._addCheck({ kind: "email", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    url(message) {
        return this._addCheck({ kind: "url", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    nanoid(message) {
        return this._addCheck({ kind: "nanoid", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    base64(message) {
        return this._addCheck({ kind: "base64", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    base64url(message) {
        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames
        return this._addCheck({
            kind: "base64url",
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    jwt(options) {
        return this._addCheck({ kind: "jwt", ...errorUtil_1.errorUtil.errToObj(options) });
    }
    ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil_1.errorUtil.errToObj(options) });
    }
    cidr(options) {
        return this._addCheck({ kind: "cidr", ...errorUtil_1.errorUtil.errToObj(options) });
    }
    datetime(options) {
        var _a, _b;
        if (typeof options === "string") {
            return this._addCheck({
                kind: "datetime",
                precision: null,
                offset: false,
                local: false,
                message: options,
            });
        }
        return this._addCheck({
            kind: "datetime",
            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
            local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
            ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
        });
    }
    date(message) {
        return this._addCheck({ kind: "date", message });
    }
    time(options) {
        if (typeof options === "string") {
            return this._addCheck({
                kind: "time",
                precision: null,
                message: options,
            });
        }
        return this._addCheck({
            kind: "time",
            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
            ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
        });
    }
    duration(message) {
        return this._addCheck({ kind: "duration", ...errorUtil_1.errorUtil.errToObj(message) });
    }
    regex(regex, message) {
        return this._addCheck({
            kind: "regex",
            regex: regex,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    includes(value, options) {
        return this._addCheck({
            kind: "includes",
            value: value,
            position: options === null || options === void 0 ? void 0 : options.position,
            ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
        });
    }
    startsWith(value, message) {
        return this._addCheck({
            kind: "startsWith",
            value: value,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    endsWith(value, message) {
        return this._addCheck({
            kind: "endsWith",
            value: value,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    min(minLength, message) {
        return this._addCheck({
            kind: "min",
            value: minLength,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    max(maxLength, message) {
        return this._addCheck({
            kind: "max",
            value: maxLength,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    length(len, message) {
        return this._addCheck({
            kind: "length",
            value: len,
            ...errorUtil_1.errorUtil.errToObj(message),
        });
    }
    /**
     * Equivalent to `.min(1)`
     */
    nonempty(message) {
        return this.min(1, errorUtil_1.errorUtil.errToObj(message));
    }
    trim() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "trim" }],
        });
    }
    toLowerCase() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "toLowerCase" }],
        });
    }
    toUpperCase() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "toUpperCase" }],
        });
    }
    get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isDate() {
        return !!this._def.checks.find((ch) => ch.kind === "date");
    }
    get isTime() {
        return !!this._def.checks.find((ch) => ch.kind === "time");
    }
    get isDuration() {
        return !!this._def.checks.find((ch) => ch.kind === "duration");
    }
    get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isNANOID() {
        return !!this._def.checks.find((ch) => ch.kind === "nanoid");
    }
    get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get isCIDR() {
        return !!this._def.checks.find((ch) => ch.kind === "cidr");
    }
    get isBase64() {
        return !!this._def.checks.find((ch) => ch.kind === "base64");
    }
    get isBase64url() {
        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames
        return !!this._def.checks.find((ch) => ch.kind === "base64url");
    }
    get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
}
types$1.ZodString = ZodString;
ZodString.create = (params) => {
    var _a;
    return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind$1.ZodString,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params),
    });
};
// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return (valInt % stepInt) / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
    }
    _parse(input) {
        if (this._def.coerce) {
            input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1$3.ZodParsedType.number) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1$3.ZodParsedType.number,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        let ctx = undefined;
        const status = new parseUtil_1.ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "int") {
                if (!util_1$3.util.isInteger(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.invalid_type,
                        expected: "integer",
                        received: "float",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "min") {
                const tooSmall = check.inclusive
                    ? input.data < check.value
                    : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive
                    ? input.data > check.value
                    : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (floatSafeRemainder(input.data, check.value) !== 0) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "finite") {
                if (!Number.isFinite(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.not_finite,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util_1$3.util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodNumber({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil_1.errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodNumber({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    int(message) {
        return this._addCheck({
            kind: "int",
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value: value,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    finite(message) {
        return this._addCheck({
            kind: "finite",
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    safe(message) {
        return this._addCheck({
            kind: "min",
            inclusive: true,
            value: Number.MIN_SAFE_INTEGER,
            message: errorUtil_1.errorUtil.toString(message),
        })._addCheck({
            kind: "max",
            inclusive: true,
            value: Number.MAX_SAFE_INTEGER,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
    get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" ||
            (ch.kind === "multipleOf" && util_1$3.util.isInteger(ch.value)));
    }
    get isFinite() {
        let max = null, min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "finite" ||
                ch.kind === "int" ||
                ch.kind === "multipleOf") {
                return true;
            }
            else if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
            else if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return Number.isFinite(min) && Number.isFinite(max);
    }
}
types$1.ZodNumber = ZodNumber;
ZodNumber.create = (params) => {
    return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind$1.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params),
    });
};
class ZodBigInt extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
    }
    _parse(input) {
        if (this._def.coerce) {
            try {
                input.data = BigInt(input.data);
            }
            catch (_a) {
                return this._getInvalidInput(input);
            }
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1$3.ZodParsedType.bigint) {
            return this._getInvalidInput(input);
        }
        let ctx = undefined;
        const status = new parseUtil_1.ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                const tooSmall = check.inclusive
                    ? input.data < check.value
                    : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_small,
                        type: "bigint",
                        minimum: check.value,
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive
                    ? input.data > check.value
                    : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_big,
                        type: "bigint",
                        maximum: check.value,
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (input.data % check.value !== BigInt(0)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util_1$3.util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    _getInvalidInput(input) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1$3.ZodParsedType.bigint,
            received: ctx.parsedType,
        });
        return parseUtil_1.INVALID;
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodBigInt({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil_1.errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodBigInt({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value,
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
}
types$1.ZodBigInt = ZodBigInt;
ZodBigInt.create = (params) => {
    var _a;
    return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind$1.ZodBigInt,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params),
    });
};
class ZodBoolean extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1$3.ZodParsedType.boolean) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1$3.ZodParsedType.boolean,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
}
types$1.ZodBoolean = ZodBoolean;
ZodBoolean.create = (params) => {
    return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind$1.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params),
    });
};
class ZodDate extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1$3.ZodParsedType.date) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1$3.ZodParsedType.date,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        if (isNaN(input.data.getTime())) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_date,
            });
            return parseUtil_1.INVALID;
        }
        const status = new parseUtil_1.ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.getTime() < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_small,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        minimum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.getTime() > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.too_big,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        maximum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            }
            else {
                util_1$3.util.assertNever(check);
            }
        }
        return {
            status: status.value,
            value: new Date(input.data.getTime()),
        };
    }
    _addCheck(check) {
        return new ZodDate({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    min(minDate, message) {
        return this._addCheck({
            kind: "min",
            value: minDate.getTime(),
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    max(maxDate, message) {
        return this._addCheck({
            kind: "max",
            value: maxDate.getTime(),
            message: errorUtil_1.errorUtil.toString(message),
        });
    }
    get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min != null ? new Date(min) : null;
    }
    get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max != null ? new Date(max) : null;
    }
}
types$1.ZodDate = ZodDate;
ZodDate.create = (params) => {
    return new ZodDate({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: ZodFirstPartyTypeKind$1.ZodDate,
        ...processCreateParams(params),
    });
};
class ZodSymbol extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1$3.ZodParsedType.symbol) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1$3.ZodParsedType.symbol,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
}
types$1.ZodSymbol = ZodSymbol;
ZodSymbol.create = (params) => {
    return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind$1.ZodSymbol,
        ...processCreateParams(params),
    });
};
class ZodUndefined extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1$3.ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1$3.ZodParsedType.undefined,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
}
types$1.ZodUndefined = ZodUndefined;
ZodUndefined.create = (params) => {
    return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind$1.ZodUndefined,
        ...processCreateParams(params),
    });
};
class ZodNull extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1$3.ZodParsedType.null) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1$3.ZodParsedType.null,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
}
types$1.ZodNull = ZodNull;
ZodNull.create = (params) => {
    return new ZodNull({
        typeName: ZodFirstPartyTypeKind$1.ZodNull,
        ...processCreateParams(params),
    });
};
class ZodAny extends ZodType {
    constructor() {
        super(...arguments);
        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
        this._any = true;
    }
    _parse(input) {
        return (0, parseUtil_1.OK)(input.data);
    }
}
types$1.ZodAny = ZodAny;
ZodAny.create = (params) => {
    return new ZodAny({
        typeName: ZodFirstPartyTypeKind$1.ZodAny,
        ...processCreateParams(params),
    });
};
class ZodUnknown extends ZodType {
    constructor() {
        super(...arguments);
        // required
        this._unknown = true;
    }
    _parse(input) {
        return (0, parseUtil_1.OK)(input.data);
    }
}
types$1.ZodUnknown = ZodUnknown;
ZodUnknown.create = (params) => {
    return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind$1.ZodUnknown,
        ...processCreateParams(params),
    });
};
class ZodNever extends ZodType {
    _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1$3.ZodParsedType.never,
            received: ctx.parsedType,
        });
        return parseUtil_1.INVALID;
    }
}
types$1.ZodNever = ZodNever;
ZodNever.create = (params) => {
    return new ZodNever({
        typeName: ZodFirstPartyTypeKind$1.ZodNever,
        ...processCreateParams(params),
    });
};
class ZodVoid extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1$3.ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1$3.ZodParsedType.void,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
}
types$1.ZodVoid = ZodVoid;
ZodVoid.create = (params) => {
    return new ZodVoid({
        typeName: ZodFirstPartyTypeKind$1.ZodVoid,
        ...processCreateParams(params),
    });
};
class ZodArray extends ZodType {
    _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== util_1$3.ZodParsedType.array) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1$3.ZodParsedType.array,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        if (def.exactLength !== null) {
            const tooBig = ctx.data.length > def.exactLength.value;
            const tooSmall = ctx.data.length < def.exactLength.value;
            if (tooBig || tooSmall) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: tooBig ? ZodError_1.ZodIssueCode.too_big : ZodError_1.ZodIssueCode.too_small,
                    minimum: (tooSmall ? def.exactLength.value : undefined),
                    maximum: (tooBig ? def.exactLength.value : undefined),
                    type: "array",
                    inclusive: true,
                    exact: true,
                    message: def.exactLength.message,
                });
                status.dirty();
            }
        }
        if (def.minLength !== null) {
            if (ctx.data.length < def.minLength.value) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: ZodError_1.ZodIssueCode.too_small,
                    minimum: def.minLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.minLength.message,
                });
                status.dirty();
            }
        }
        if (def.maxLength !== null) {
            if (ctx.data.length > def.maxLength.value) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: ZodError_1.ZodIssueCode.too_big,
                    maximum: def.maxLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.maxLength.message,
                });
                status.dirty();
            }
        }
        if (ctx.common.async) {
            return Promise.all([...ctx.data].map((item, i) => {
                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
            })).then((result) => {
                return parseUtil_1.ParseStatus.mergeArray(status, result);
            });
        }
        const result = [...ctx.data].map((item, i) => {
            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return parseUtil_1.ParseStatus.mergeArray(status, result);
    }
    get element() {
        return this._def.type;
    }
    min(minLength, message) {
        return new ZodArray({
            ...this._def,
            minLength: { value: minLength, message: errorUtil_1.errorUtil.toString(message) },
        });
    }
    max(maxLength, message) {
        return new ZodArray({
            ...this._def,
            maxLength: { value: maxLength, message: errorUtil_1.errorUtil.toString(message) },
        });
    }
    length(len, message) {
        return new ZodArray({
            ...this._def,
            exactLength: { value: len, message: errorUtil_1.errorUtil.toString(message) },
        });
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
types$1.ZodArray = ZodArray;
ZodArray.create = (schema, params) => {
    return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind$1.ZodArray,
        ...processCreateParams(params),
    });
};
function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
        const newShape = {};
        for (const key in schema.shape) {
            const fieldSchema = schema.shape[key];
            newShape[key] = ZodOptional$1.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
            ...schema._def,
            shape: () => newShape,
        });
    }
    else if (schema instanceof ZodArray) {
        return new ZodArray({
            ...schema._def,
            type: deepPartialify(schema.element),
        });
    }
    else if (schema instanceof ZodOptional$1) {
        return ZodOptional$1.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodTuple) {
        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    }
    else {
        return schema;
    }
}
class ZodObject extends ZodType {
    constructor() {
        super(...arguments);
        this._cached = null;
        /**
         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
         * If you want to pass through unknown properties, use `.passthrough()` instead.
         */
        this.nonstrict = this.passthrough;
        // extend<
        //   Augmentation extends ZodRawShape,
        //   NewOutput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
        //       ? Augmentation[k]["_output"]
        //       : k extends keyof Output
        //       ? Output[k]
        //       : never;
        //   }>,
        //   NewInput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
        //       ? Augmentation[k]["_input"]
        //       : k extends keyof Input
        //       ? Input[k]
        //       : never;
        //   }>
        // >(
        //   augmentation: Augmentation
        // ): ZodObject<
        //   extendShape<T, Augmentation>,
        //   UnknownKeys,
        //   Catchall,
        //   NewOutput,
        //   NewInput
        // > {
        //   return new ZodObject({
        //     ...this._def,
        //     shape: () => ({
        //       ...this._def.shape(),
        //       ...augmentation,
        //     }),
        //   }) as any;
        // }
        /**
         * @deprecated Use `.extend` instead
         *  */
        this.augment = this.extend;
    }
    _getCached() {
        if (this._cached !== null)
            return this._cached;
        const shape = this._def.shape();
        const keys = util_1$3.util.objectKeys(shape);
        return (this._cached = { shape, keys });
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1$3.ZodParsedType.object) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1$3.ZodParsedType.object,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever &&
            this._def.unknownKeys === "strip")) {
            for (const key in ctx.data) {
                if (!shapeKeys.includes(key)) {
                    extraKeys.push(key);
                }
            }
        }
        const pairs = [];
        for (const key of shapeKeys) {
            const keyValidator = shape[key];
            const value = ctx.data[key];
            pairs.push({
                key: { status: "valid", value: key },
                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                alwaysSet: key in ctx.data,
            });
        }
        if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") {
                for (const key of extraKeys) {
                    pairs.push({
                        key: { status: "valid", value: key },
                        value: { status: "valid", value: ctx.data[key] },
                    });
                }
            }
            else if (unknownKeys === "strict") {
                if (extraKeys.length > 0) {
                    (0, parseUtil_1.addIssueToContext)(ctx, {
                        code: ZodError_1.ZodIssueCode.unrecognized_keys,
                        keys: extraKeys,
                    });
                    status.dirty();
                }
            }
            else if (unknownKeys === "strip") ;
            else {
                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
            }
        }
        else {
            // run catchall validation
            const catchall = this._def.catchall;
            for (const key of extraKeys) {
                const value = ctx.data[key];
                pairs.push({
                    key: { status: "valid", value: key },
                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)
                    ),
                    alwaysSet: key in ctx.data,
                });
            }
        }
        if (ctx.common.async) {
            return Promise.resolve()
                .then(async () => {
                const syncPairs = [];
                for (const pair of pairs) {
                    const key = await pair.key;
                    const value = await pair.value;
                    syncPairs.push({
                        key,
                        value,
                        alwaysSet: pair.alwaysSet,
                    });
                }
                return syncPairs;
            })
                .then((syncPairs) => {
                return parseUtil_1.ParseStatus.mergeObjectSync(status, syncPairs);
            });
        }
        else {
            return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get shape() {
        return this._def.shape();
    }
    strict(message) {
        return new ZodObject({
            ...this._def,
            unknownKeys: "strict",
            ...(message !== undefined
                ? {
                    errorMap: (issue, ctx) => {
                        var _a, _b, _c, _d;
                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
                        if (issue.code === "unrecognized_keys")
                            return {
                                message: (_d = errorUtil_1.errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,
                            };
                        return {
                            message: defaultError,
                        };
                    },
                }
                : {}),
        });
    }
    strip() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "strip",
        });
    }
    passthrough() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "passthrough",
        });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
        return new ZodObject({
            ...this._def,
            shape: () => ({
                ...this._def.shape(),
                ...augmentation,
            }),
        });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
        const merged = new ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: () => ({
                ...this._def.shape(),
                ...merging._def.shape(),
            }),
            typeName: ZodFirstPartyTypeKind$1.ZodObject,
        });
        return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
        return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
        return new ZodObject({
            ...this._def,
            catchall: index,
        });
    }
    pick(mask) {
        const shape = {};
        util_1$3.util.objectKeys(mask).forEach((key) => {
            if (mask[key] && this.shape[key]) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    omit(mask) {
        const shape = {};
        util_1$3.util.objectKeys(this.shape).forEach((key) => {
            if (!mask[key]) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    /**
     * @deprecated
     */
    deepPartial() {
        return deepPartialify(this);
    }
    partial(mask) {
        const newShape = {};
        util_1$3.util.objectKeys(this.shape).forEach((key) => {
            const fieldSchema = this.shape[key];
            if (mask && !mask[key]) {
                newShape[key] = fieldSchema;
            }
            else {
                newShape[key] = fieldSchema.optional();
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    required(mask) {
        const newShape = {};
        util_1$3.util.objectKeys(this.shape).forEach((key) => {
            if (mask && !mask[key]) {
                newShape[key] = this.shape[key];
            }
            else {
                const fieldSchema = this.shape[key];
                let newField = fieldSchema;
                while (newField instanceof ZodOptional$1) {
                    newField = newField._def.innerType;
                }
                newShape[key] = newField;
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    keyof() {
        return createZodEnum(util_1$3.util.objectKeys(this.shape));
    }
}
types$1.ZodObject = ZodObject;
ZodObject.create = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind$1.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind$1.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind$1.ZodObject,
        ...processCreateParams(params),
    });
};
class ZodUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
            // return first issue-free validation if it exists
            for (const result of results) {
                if (result.result.status === "valid") {
                    return result.result;
                }
            }
            for (const result of results) {
                if (result.result.status === "dirty") {
                    // add issues from dirty option
                    ctx.common.issues.push(...result.ctx.common.issues);
                    return result.result;
                }
            }
            // return invalid
            const unionErrors = results.map((result) => new ZodError_1.ZodError(result.ctx.common.issues));
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_union,
                unionErrors,
            });
            return parseUtil_1.INVALID;
        }
        if (ctx.common.async) {
            return Promise.all(options.map(async (option) => {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                return {
                    result: await option._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: childCtx,
                    }),
                    ctx: childCtx,
                };
            })).then(handleResults);
        }
        else {
            let dirty = undefined;
            const issues = [];
            for (const option of options) {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                const result = option._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: childCtx,
                });
                if (result.status === "valid") {
                    return result;
                }
                else if (result.status === "dirty" && !dirty) {
                    dirty = { result, ctx: childCtx };
                }
                if (childCtx.common.issues.length) {
                    issues.push(childCtx.common.issues);
                }
            }
            if (dirty) {
                ctx.common.issues.push(...dirty.ctx.common.issues);
                return dirty.result;
            }
            const unionErrors = issues.map((issues) => new ZodError_1.ZodError(issues));
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_union,
                unionErrors,
            });
            return parseUtil_1.INVALID;
        }
    }
    get options() {
        return this._def.options;
    }
}
types$1.ZodUnion = ZodUnion;
ZodUnion.create = (types, params) => {
    return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind$1.ZodUnion,
        ...processCreateParams(params),
    });
};
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
//////////                                 //////////
//////////      ZodDiscriminatedUnion      //////////
//////////                                 //////////
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
const getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
    }
    else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
    }
    else if (type instanceof ZodLiteral) {
        return [type.value];
    }
    else if (type instanceof ZodEnum) {
        return type.options;
    }
    else if (type instanceof ZodNativeEnum) {
        // eslint-disable-next-line ban/ban
        return util_1$3.util.objectValues(type.enum);
    }
    else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
    }
    else if (type instanceof ZodUndefined) {
        return [undefined];
    }
    else if (type instanceof ZodNull) {
        return [null];
    }
    else if (type instanceof ZodOptional$1) {
        return [undefined, ...getDiscriminator(type.unwrap())];
    }
    else if (type instanceof ZodNullable) {
        return [null, ...getDiscriminator(type.unwrap())];
    }
    else if (type instanceof ZodBranded) {
        return getDiscriminator(type.unwrap());
    }
    else if (type instanceof ZodReadonly) {
        return getDiscriminator(type.unwrap());
    }
    else if (type instanceof ZodCatch) {
        return getDiscriminator(type._def.innerType);
    }
    else {
        return [];
    }
};
class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1$3.ZodParsedType.object) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1$3.ZodParsedType.object,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [discriminator],
            });
            return parseUtil_1.INVALID;
        }
        if (ctx.common.async) {
            return option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
        else {
            return option._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get options() {
        return this._def.options;
    }
    get optionsMap() {
        return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
        // Get all the valid discriminator values
        const optionsMap = new Map();
        // try {
        for (const type of options) {
            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
            if (!discriminatorValues.length) {
                throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
            }
            for (const value of discriminatorValues) {
                if (optionsMap.has(value)) {
                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                }
                optionsMap.set(value, type);
            }
        }
        return new ZodDiscriminatedUnion({
            typeName: ZodFirstPartyTypeKind$1.ZodDiscriminatedUnion,
            discriminator,
            options,
            optionsMap,
            ...processCreateParams(params),
        });
    }
}
types$1.ZodDiscriminatedUnion = ZodDiscriminatedUnion;
function mergeValues(a, b) {
    const aType = (0, util_1$3.getParsedType)(a);
    const bType = (0, util_1$3.getParsedType)(b);
    if (a === b) {
        return { valid: true, data: a };
    }
    else if (aType === util_1$3.ZodParsedType.object && bType === util_1$3.ZodParsedType.object) {
        const bKeys = util_1$3.util.objectKeys(b);
        const sharedKeys = util_1$3.util
            .objectKeys(a)
            .filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
            const sharedValue = mergeValues(a[key], b[key]);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
    }
    else if (aType === util_1$3.ZodParsedType.array && bType === util_1$3.ZodParsedType.array) {
        if (a.length !== b.length) {
            return { valid: false };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
            const itemA = a[index];
            const itemB = b[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
    }
    else if (aType === util_1$3.ZodParsedType.date &&
        bType === util_1$3.ZodParsedType.date &&
        +a === +b) {
        return { valid: true, data: a };
    }
    else {
        return { valid: false };
    }
}
class ZodIntersection extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
            if ((0, parseUtil_1.isAborted)(parsedLeft) || (0, parseUtil_1.isAborted)(parsedRight)) {
                return parseUtil_1.INVALID;
            }
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: ZodError_1.ZodIssueCode.invalid_intersection_types,
                });
                return parseUtil_1.INVALID;
            }
            if ((0, parseUtil_1.isDirty)(parsedLeft) || (0, parseUtil_1.isDirty)(parsedRight)) {
                status.dirty();
            }
            return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
            return Promise.all([
                this._def.left._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
                this._def.right._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
            ]).then(([left, right]) => handleParsed(left, right));
        }
        else {
            return handleParsed(this._def.left._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }), this._def.right._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }));
        }
    }
}
types$1.ZodIntersection = ZodIntersection;
ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
        left: left,
        right: right,
        typeName: ZodFirstPartyTypeKind$1.ZodIntersection,
        ...processCreateParams(params),
    });
};
class ZodTuple extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1$3.ZodParsedType.array) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1$3.ZodParsedType.array,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                minimum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array",
            });
            return parseUtil_1.INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                maximum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array",
            });
            status.dirty();
        }
        const items = [...ctx.data]
            .map((item, itemIndex) => {
            const schema = this._def.items[itemIndex] || this._def.rest;
            if (!schema)
                return null;
            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        })
            .filter((x) => !!x); // filter nulls
        if (ctx.common.async) {
            return Promise.all(items).then((results) => {
                return parseUtil_1.ParseStatus.mergeArray(status, results);
            });
        }
        else {
            return parseUtil_1.ParseStatus.mergeArray(status, items);
        }
    }
    get items() {
        return this._def.items;
    }
    rest(rest) {
        return new ZodTuple({
            ...this._def,
            rest,
        });
    }
}
types$1.ZodTuple = ZodTuple;
ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind$1.ZodTuple,
        rest: null,
        ...processCreateParams(params),
    });
};
class ZodRecord extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1$3.ZodParsedType.object) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1$3.ZodParsedType.object,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
            pairs.push({
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
                alwaysSet: key in ctx.data,
            });
        }
        if (ctx.common.async) {
            return parseUtil_1.ParseStatus.mergeObjectAsync(status, pairs);
        }
        else {
            return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get element() {
        return this._def.valueType;
    }
    static create(first, second, third) {
        if (second instanceof ZodType) {
            return new ZodRecord({
                keyType: first,
                valueType: second,
                typeName: ZodFirstPartyTypeKind$1.ZodRecord,
                ...processCreateParams(third),
            });
        }
        return new ZodRecord({
            keyType: ZodString.create(),
            valueType: first,
            typeName: ZodFirstPartyTypeKind$1.ZodRecord,
            ...processCreateParams(second),
        });
    }
}
types$1.ZodRecord = ZodRecord;
class ZodMap extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1$3.ZodParsedType.map) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1$3.ZodParsedType.map,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
            return {
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"])),
            };
        });
        if (ctx.common.async) {
            const finalMap = new Map();
            return Promise.resolve().then(async () => {
                for (const pair of pairs) {
                    const key = await pair.key;
                    const value = await pair.value;
                    if (key.status === "aborted" || value.status === "aborted") {
                        return parseUtil_1.INVALID;
                    }
                    if (key.status === "dirty" || value.status === "dirty") {
                        status.dirty();
                    }
                    finalMap.set(key.value, value.value);
                }
                return { status: status.value, value: finalMap };
            });
        }
        else {
            const finalMap = new Map();
            for (const pair of pairs) {
                const key = pair.key;
                const value = pair.value;
                if (key.status === "aborted" || value.status === "aborted") {
                    return parseUtil_1.INVALID;
                }
                if (key.status === "dirty" || value.status === "dirty") {
                    status.dirty();
                }
                finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
        }
    }
}
types$1.ZodMap = ZodMap;
ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind$1.ZodMap,
        ...processCreateParams(params),
    });
};
class ZodSet extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1$3.ZodParsedType.set) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1$3.ZodParsedType.set,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
            if (ctx.data.size < def.minSize.value) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: ZodError_1.ZodIssueCode.too_small,
                    minimum: def.minSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.minSize.message,
                });
                status.dirty();
            }
        }
        if (def.maxSize !== null) {
            if (ctx.data.size > def.maxSize.value) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                    code: ZodError_1.ZodIssueCode.too_big,
                    maximum: def.maxSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.maxSize.message,
                });
                status.dirty();
            }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements) {
            const parsedSet = new Set();
            for (const element of elements) {
                if (element.status === "aborted")
                    return parseUtil_1.INVALID;
                if (element.status === "dirty")
                    status.dirty();
                parsedSet.add(element.value);
            }
            return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
            return Promise.all(elements).then((elements) => finalizeSet(elements));
        }
        else {
            return finalizeSet(elements);
        }
    }
    min(minSize, message) {
        return new ZodSet({
            ...this._def,
            minSize: { value: minSize, message: errorUtil_1.errorUtil.toString(message) },
        });
    }
    max(maxSize, message) {
        return new ZodSet({
            ...this._def,
            maxSize: { value: maxSize, message: errorUtil_1.errorUtil.toString(message) },
        });
    }
    size(size, message) {
        return this.min(size, message).max(size, message);
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
types$1.ZodSet = ZodSet;
ZodSet.create = (valueType, params) => {
    return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind$1.ZodSet,
        ...processCreateParams(params),
    });
};
class ZodFunction extends ZodType {
    constructor() {
        super(...arguments);
        this.validate = this.implement;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1$3.ZodParsedType.function) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1$3.ZodParsedType.function,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        function makeArgsIssue(args, error) {
            return (0, parseUtil_1.makeIssue)({
                data: args,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    (0, errors_1.getErrorMap)(),
                    errors_1.defaultErrorMap,
                ].filter((x) => !!x),
                issueData: {
                    code: ZodError_1.ZodIssueCode.invalid_arguments,
                    argumentsError: error,
                },
            });
        }
        function makeReturnsIssue(returns, error) {
            return (0, parseUtil_1.makeIssue)({
                data: returns,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    (0, errors_1.getErrorMap)(),
                    errors_1.defaultErrorMap,
                ].filter((x) => !!x),
                issueData: {
                    code: ZodError_1.ZodIssueCode.invalid_return_type,
                    returnTypeError: error,
                },
            });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
            // Would love a way to avoid disabling this rule, but we need
            // an alias (using an arrow function was what caused 2651).
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const me = this;
            return (0, parseUtil_1.OK)(async function (...args) {
                const error = new ZodError_1.ZodError([]);
                const parsedArgs = await me._def.args
                    .parseAsync(args, params)
                    .catch((e) => {
                    error.addIssue(makeArgsIssue(args, e));
                    throw error;
                });
                const result = await Reflect.apply(fn, this, parsedArgs);
                const parsedReturns = await me._def.returns._def.type
                    .parseAsync(result, params)
                    .catch((e) => {
                    error.addIssue(makeReturnsIssue(result, e));
                    throw error;
                });
                return parsedReturns;
            });
        }
        else {
            // Would love a way to avoid disabling this rule, but we need
            // an alias (using an arrow function was what caused 2651).
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const me = this;
            return (0, parseUtil_1.OK)(function (...args) {
                const parsedArgs = me._def.args.safeParse(args, params);
                if (!parsedArgs.success) {
                    throw new ZodError_1.ZodError([makeArgsIssue(args, parsedArgs.error)]);
                }
                const result = Reflect.apply(fn, this, parsedArgs.data);
                const parsedReturns = me._def.returns.safeParse(result, params);
                if (!parsedReturns.success) {
                    throw new ZodError_1.ZodError([makeReturnsIssue(result, parsedReturns.error)]);
                }
                return parsedReturns.data;
            });
        }
    }
    parameters() {
        return this._def.args;
    }
    returnType() {
        return this._def.returns;
    }
    args(...items) {
        return new ZodFunction({
            ...this._def,
            args: ZodTuple.create(items).rest(ZodUnknown.create()),
        });
    }
    returns(returnType) {
        return new ZodFunction({
            ...this._def,
            returns: returnType,
        });
    }
    implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    static create(args, returns, params) {
        return new ZodFunction({
            args: (args
                ? args
                : ZodTuple.create([]).rest(ZodUnknown.create())),
            returns: returns || ZodUnknown.create(),
            typeName: ZodFirstPartyTypeKind$1.ZodFunction,
            ...processCreateParams(params),
        });
    }
}
types$1.ZodFunction = ZodFunction;
class ZodLazy extends ZodType {
    get schema() {
        return this._def.getter();
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
}
types$1.ZodLazy = ZodLazy;
ZodLazy.create = (getter, params) => {
    return new ZodLazy({
        getter: getter,
        typeName: ZodFirstPartyTypeKind$1.ZodLazy,
        ...processCreateParams(params),
    });
};
class ZodLiteral extends ZodType {
    _parse(input) {
        if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                received: ctx.data,
                code: ZodError_1.ZodIssueCode.invalid_literal,
                expected: this._def.value,
            });
            return parseUtil_1.INVALID;
        }
        return { status: "valid", value: input.data };
    }
    get value() {
        return this._def.value;
    }
}
types$1.ZodLiteral = ZodLiteral;
ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
        value: value,
        typeName: ZodFirstPartyTypeKind$1.ZodLiteral,
        ...processCreateParams(params),
    });
};
function createZodEnum(values, params) {
    return new ZodEnum({
        values,
        typeName: ZodFirstPartyTypeKind$1.ZodEnum,
        ...processCreateParams(params),
    });
}
class ZodEnum extends ZodType {
    constructor() {
        super(...arguments);
        _ZodEnum_cache.set(this, void 0);
    }
    _parse(input) {
        if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            (0, parseUtil_1.addIssueToContext)(ctx, {
                expected: util_1$3.util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodError_1.ZodIssueCode.invalid_type,
            });
            return parseUtil_1.INVALID;
        }
        if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
            __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
        }
        if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            (0, parseUtil_1.addIssueToContext)(ctx, {
                received: ctx.data,
                code: ZodError_1.ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    extract(values, newDef = this._def) {
        return ZodEnum.create(values, {
            ...this._def,
            ...newDef,
        });
    }
    exclude(values, newDef = this._def) {
        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
            ...this._def,
            ...newDef,
        });
    }
}
types$1.ZodEnum = ZodEnum;
_ZodEnum_cache = new WeakMap();
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
    constructor() {
        super(...arguments);
        _ZodNativeEnum_cache.set(this, void 0);
    }
    _parse(input) {
        const nativeEnumValues = util_1$3.util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== util_1$3.ZodParsedType.string &&
            ctx.parsedType !== util_1$3.ZodParsedType.number) {
            const expectedValues = util_1$3.util.objectValues(nativeEnumValues);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                expected: util_1$3.util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodError_1.ZodIssueCode.invalid_type,
            });
            return parseUtil_1.INVALID;
        }
        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
            __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util_1$3.util.getValidEnumValues(this._def.values)), "f");
        }
        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
            const expectedValues = util_1$3.util.objectValues(nativeEnumValues);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                received: ctx.data,
                code: ZodError_1.ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
    }
    get enum() {
        return this._def.values;
    }
}
types$1.ZodNativeEnum = ZodNativeEnum;
_ZodNativeEnum_cache = new WeakMap();
ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
        values: values,
        typeName: ZodFirstPartyTypeKind$1.ZodNativeEnum,
        ...processCreateParams(params),
    });
};
class ZodPromise extends ZodType {
    unwrap() {
        return this._def.type;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1$3.ZodParsedType.promise &&
            ctx.common.async === false) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1$3.ZodParsedType.promise,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        const promisified = ctx.parsedType === util_1$3.ZodParsedType.promise
            ? ctx.data
            : Promise.resolve(ctx.data);
        return (0, parseUtil_1.OK)(promisified.then((data) => {
            return this._def.type.parseAsync(data, {
                path: ctx.path,
                errorMap: ctx.common.contextualErrorMap,
            });
        }));
    }
}
types$1.ZodPromise = ZodPromise;
ZodPromise.create = (schema, params) => {
    return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind$1.ZodPromise,
        ...processCreateParams(params),
    });
};
class ZodEffects extends ZodType {
    innerType() {
        return this._def.schema;
    }
    sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind$1.ZodEffects
            ? this._def.schema.sourceType()
            : this._def.schema;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
            addIssue: (arg) => {
                (0, parseUtil_1.addIssueToContext)(ctx, arg);
                if (arg.fatal) {
                    status.abort();
                }
                else {
                    status.dirty();
                }
            },
            get path() {
                return ctx.path;
            },
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data, checkCtx);
            if (ctx.common.async) {
                return Promise.resolve(processed).then(async (processed) => {
                    if (status.value === "aborted")
                        return parseUtil_1.INVALID;
                    const result = await this._def.schema._parseAsync({
                        data: processed,
                        path: ctx.path,
                        parent: ctx,
                    });
                    if (result.status === "aborted")
                        return parseUtil_1.INVALID;
                    if (result.status === "dirty")
                        return (0, parseUtil_1.DIRTY)(result.value);
                    if (status.value === "dirty")
                        return (0, parseUtil_1.DIRTY)(result.value);
                    return result;
                });
            }
            else {
                if (status.value === "aborted")
                    return parseUtil_1.INVALID;
                const result = this._def.schema._parseSync({
                    data: processed,
                    path: ctx.path,
                    parent: ctx,
                });
                if (result.status === "aborted")
                    return parseUtil_1.INVALID;
                if (result.status === "dirty")
                    return (0, parseUtil_1.DIRTY)(result.value);
                if (status.value === "dirty")
                    return (0, parseUtil_1.DIRTY)(result.value);
                return result;
            }
        }
        if (effect.type === "refinement") {
            const executeRefinement = (acc) => {
                const result = effect.refinement(acc, checkCtx);
                if (ctx.common.async) {
                    return Promise.resolve(result);
                }
                if (result instanceof Promise) {
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                }
                return acc;
            };
            if (ctx.common.async === false) {
                const inner = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inner.status === "aborted")
                    return parseUtil_1.INVALID;
                if (inner.status === "dirty")
                    status.dirty();
                // return value is ignored
                executeRefinement(inner.value);
                return { status: status.value, value: inner.value };
            }
            else {
                return this._def.schema
                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                    .then((inner) => {
                    if (inner.status === "aborted")
                        return parseUtil_1.INVALID;
                    if (inner.status === "dirty")
                        status.dirty();
                    return executeRefinement(inner.value).then(() => {
                        return { status: status.value, value: inner.value };
                    });
                });
            }
        }
        if (effect.type === "transform") {
            if (ctx.common.async === false) {
                const base = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (!(0, parseUtil_1.isValid)(base))
                    return base;
                const result = effect.transform(base.value, checkCtx);
                if (result instanceof Promise) {
                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
                }
                return { status: status.value, value: result };
            }
            else {
                return this._def.schema
                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                    .then((base) => {
                    if (!(0, parseUtil_1.isValid)(base))
                        return base;
                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
                });
            }
        }
        util_1$3.util.assertNever(effect);
    }
}
types$1.ZodEffects = ZodEffects;
types$1.ZodTransformer = ZodEffects;
ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind$1.ZodEffects,
        effect,
        ...processCreateParams(params),
    });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind$1.ZodEffects,
        ...processCreateParams(params),
    });
};
let ZodOptional$1 = class ZodOptional extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === util_1$3.ZodParsedType.undefined) {
            return (0, parseUtil_1.OK)(undefined);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
};
types$1.ZodOptional = ZodOptional$1;
ZodOptional$1.create = (type, params) => {
    return new ZodOptional$1({
        innerType: type,
        typeName: ZodFirstPartyTypeKind$1.ZodOptional,
        ...processCreateParams(params),
    });
};
class ZodNullable extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === util_1$3.ZodParsedType.null) {
            return (0, parseUtil_1.OK)(null);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
types$1.ZodNullable = ZodNullable;
ZodNullable.create = (type, params) => {
    return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind$1.ZodNullable,
        ...processCreateParams(params),
    });
};
class ZodDefault extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === util_1$3.ZodParsedType.undefined) {
            data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
}
types$1.ZodDefault = ZodDefault;
ZodDefault.create = (type, params) => {
    return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind$1.ZodDefault,
        defaultValue: typeof params.default === "function"
            ? params.default
            : () => params.default,
        ...processCreateParams(params),
    });
};
class ZodCatch extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        // newCtx is used to not collect issues from inner types in ctx
        const newCtx = {
            ...ctx,
            common: {
                ...ctx.common,
                issues: [],
            },
        };
        const result = this._def.innerType._parse({
            data: newCtx.data,
            path: newCtx.path,
            parent: {
                ...newCtx,
            },
        });
        if ((0, parseUtil_1.isAsync)(result)) {
            return result.then((result) => {
                return {
                    status: "valid",
                    value: result.status === "valid"
                        ? result.value
                        : this._def.catchValue({
                            get error() {
                                return new ZodError_1.ZodError(newCtx.common.issues);
                            },
                            input: newCtx.data,
                        }),
                };
            });
        }
        else {
            return {
                status: "valid",
                value: result.status === "valid"
                    ? result.value
                    : this._def.catchValue({
                        get error() {
                            return new ZodError_1.ZodError(newCtx.common.issues);
                        },
                        input: newCtx.data,
                    }),
            };
        }
    }
    removeCatch() {
        return this._def.innerType;
    }
}
types$1.ZodCatch = ZodCatch;
ZodCatch.create = (type, params) => {
    return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind$1.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params),
    });
};
class ZodNaN extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1$3.ZodParsedType.nan) {
            const ctx = this._getOrReturnCtx(input);
            (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: util_1$3.ZodParsedType.nan,
                received: ctx.parsedType,
            });
            return parseUtil_1.INVALID;
        }
        return { status: "valid", value: input.data };
    }
}
types$1.ZodNaN = ZodNaN;
ZodNaN.create = (params) => {
    return new ZodNaN({
        typeName: ZodFirstPartyTypeKind$1.ZodNaN,
        ...processCreateParams(params),
    });
};
types$1.BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    unwrap() {
        return this._def.type;
    }
}
types$1.ZodBranded = ZodBranded;
class ZodPipeline extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
            const handleAsync = async () => {
                const inResult = await this._def.in._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inResult.status === "aborted")
                    return parseUtil_1.INVALID;
                if (inResult.status === "dirty") {
                    status.dirty();
                    return (0, parseUtil_1.DIRTY)(inResult.value);
                }
                else {
                    return this._def.out._parseAsync({
                        data: inResult.value,
                        path: ctx.path,
                        parent: ctx,
                    });
                }
            };
            return handleAsync();
        }
        else {
            const inResult = this._def.in._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
            if (inResult.status === "aborted")
                return parseUtil_1.INVALID;
            if (inResult.status === "dirty") {
                status.dirty();
                return {
                    status: "dirty",
                    value: inResult.value,
                };
            }
            else {
                return this._def.out._parseSync({
                    data: inResult.value,
                    path: ctx.path,
                    parent: ctx,
                });
            }
        }
    }
    static create(a, b) {
        return new ZodPipeline({
            in: a,
            out: b,
            typeName: ZodFirstPartyTypeKind$1.ZodPipeline,
        });
    }
}
types$1.ZodPipeline = ZodPipeline;
class ZodReadonly extends ZodType {
    _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze = (data) => {
            if ((0, parseUtil_1.isValid)(data)) {
                data.value = Object.freeze(data.value);
            }
            return data;
        };
        return (0, parseUtil_1.isAsync)(result)
            ? result.then((data) => freeze(data))
            : freeze(result);
    }
    unwrap() {
        return this._def.innerType;
    }
}
types$1.ZodReadonly = ZodReadonly;
ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind$1.ZodReadonly,
        ...processCreateParams(params),
    });
};
////////////////////////////////////////
////////////////////////////////////////
//////////                    //////////
//////////      z.custom      //////////
//////////                    //////////
////////////////////////////////////////
////////////////////////////////////////
function cleanParams(params, data) {
    const p = typeof params === "function"
        ? params(data)
        : typeof params === "string"
            ? { message: params }
            : params;
    const p2 = typeof p === "string" ? { message: p } : p;
    return p2;
}
function custom(check, _params = {}, 
/**
 * @deprecated
 *
 * Pass `fatal` into the params object instead:
 *
 * ```ts
 * z.string().custom((val) => val.length > 5, { fatal: false })
 * ```
 *
 */
fatal) {
    if (check)
        return ZodAny.create().superRefine((data, ctx) => {
            var _a, _b;
            const r = check(data);
            if (r instanceof Promise) {
                return r.then((r) => {
                    var _a, _b;
                    if (!r) {
                        const params = cleanParams(_params, data);
                        const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
                        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
                    }
                });
            }
            if (!r) {
                const params = cleanParams(_params, data);
                const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
                ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
            }
            return;
        });
    return ZodAny.create();
}
types$1.custom = custom;
types$1.late = {
    object: ZodObject.lazycreate,
};
var ZodFirstPartyTypeKind$1;
(function (ZodFirstPartyTypeKind) {
    ZodFirstPartyTypeKind["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind$1 || (types$1.ZodFirstPartyTypeKind = ZodFirstPartyTypeKind$1 = {}));
const instanceOfType = (
// const instanceOfType = <T extends new (...args: any[]) => any>(
cls, params = {
    message: `Input not instance of ${cls.name}`,
}) => custom((data) => data instanceof cls, params);
types$1.instanceof = instanceOfType;
const stringType = ZodString.create;
types$1.string = stringType;
const numberType = ZodNumber.create;
types$1.number = numberType;
const nanType = ZodNaN.create;
types$1.nan = nanType;
const bigIntType = ZodBigInt.create;
types$1.bigint = bigIntType;
const booleanType = ZodBoolean.create;
types$1.boolean = booleanType;
const dateType = ZodDate.create;
types$1.date = dateType;
const symbolType = ZodSymbol.create;
types$1.symbol = symbolType;
const undefinedType = ZodUndefined.create;
types$1.undefined = undefinedType;
const nullType = ZodNull.create;
types$1.null = nullType;
const anyType = ZodAny.create;
types$1.any = anyType;
const unknownType = ZodUnknown.create;
types$1.unknown = unknownType;
const neverType = ZodNever.create;
types$1.never = neverType;
const voidType = ZodVoid.create;
types$1.void = voidType;
const arrayType = ZodArray.create;
types$1.array = arrayType;
const objectType = ZodObject.create;
types$1.object = objectType;
const strictObjectType = ZodObject.strictCreate;
types$1.strictObject = strictObjectType;
const unionType = ZodUnion.create;
types$1.union = unionType;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
types$1.discriminatedUnion = discriminatedUnionType;
const intersectionType = ZodIntersection.create;
types$1.intersection = intersectionType;
const tupleType = ZodTuple.create;
types$1.tuple = tupleType;
const recordType = ZodRecord.create;
types$1.record = recordType;
const mapType = ZodMap.create;
types$1.map = mapType;
const setType = ZodSet.create;
types$1.set = setType;
const functionType = ZodFunction.create;
types$1.function = functionType;
const lazyType = ZodLazy.create;
types$1.lazy = lazyType;
const literalType = ZodLiteral.create;
types$1.literal = literalType;
const enumType = ZodEnum.create;
types$1.enum = enumType;
const nativeEnumType = ZodNativeEnum.create;
types$1.nativeEnum = nativeEnumType;
const promiseType = ZodPromise.create;
types$1.promise = promiseType;
const effectsType = ZodEffects.create;
types$1.effect = effectsType;
types$1.transformer = effectsType;
const optionalType = ZodOptional$1.create;
types$1.optional = optionalType;
const nullableType = ZodNullable.create;
types$1.nullable = nullableType;
const preprocessType = ZodEffects.createWithPreprocess;
types$1.preprocess = preprocessType;
const pipelineType = ZodPipeline.create;
types$1.pipeline = pipelineType;
const ostring = () => stringType().optional();
types$1.ostring = ostring;
const onumber = () => numberType().optional();
types$1.onumber = onumber;
const oboolean = () => booleanType().optional();
types$1.oboolean = oboolean;
types$1.coerce = {
    string: ((arg) => ZodString.create({ ...arg, coerce: true })),
    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),
    boolean: ((arg) => ZodBoolean.create({
        ...arg,
        coerce: true,
    })),
    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),
    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),
};
types$1.NEVER = parseUtil_1.INVALID;

(function (exports) {
	var __createBinding = (external && external.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (external && external.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar(errors, exports);
	__exportStar(parseUtil, exports);
	__exportStar(typeAliases, exports);
	__exportStar(util$1, exports);
	__exportStar(types$1, exports);
	__exportStar(ZodError$1, exports); 
} (external));

(function (exports) {
	var __createBinding = (lib && lib.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (lib && lib.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (lib && lib.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __exportStar = (lib && lib.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.z = void 0;
	const z = __importStar(external);
	exports.z = z;
	__exportStar(external, exports);
	exports.default = z; 
} (lib));

var dist = {};

var channel = {};

var topic$1 = {};

Object.defineProperty(topic$1, "__esModule", { value: true });
topic$1.TopicDefinitionImpl = topic$1.topic = void 0;
/**
 * TODO
 */
const topic = (
/**
 * TODO
 */
id) => {
    return new TopicDefinitionImpl(id);
};
topic$1.topic = topic;
class TopicDefinitionImpl {
    name;
    #schema;
    constructor(name, schema) {
        this.name = name;
        this.#schema = schema;
    }
    type() {
        return this;
    }
    schema(schema) {
        return new TopicDefinitionImpl(this.name, schema);
    }
    getSchema() {
        return this.#schema;
    }
}
topic$1.TopicDefinitionImpl = TopicDefinitionImpl;

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.typeOnlyChannel = exports.channel = void 0;
	const topic_1 = topic$1;
	/**
	 * TODO
	 */
	const channel = (
	/**
	 * TODO
	 */
	id) => {
	    // eslint-disable-next-line prefer-const, @typescript-eslint/no-explicit-any
	    let channelDefinition;
	    const topics = {};
	    const builder = (...args) => {
	        const finalId = typeof id === "string" ? id : id(...args);
	        const topicsFns = Object.entries(topics).reduce((acc, [name, topic]) => {
	            acc[name] = createTopicFn(finalId, topic);
	            return acc;
	        }, {});
	        const channel = {
	            name: finalId,
	            topics,
	            ...topicsFns,
	        };
	        return channel;
	    };
	    const extras = {
	        topics,
	        addTopic: (topic) => {
	            topics[topic.name] = topic;
	            return channelDefinition;
	        },
	    };
	    channelDefinition = Object.assign(builder, extras);
	    return channelDefinition;
	};
	exports.channel = channel;
	/**
	 * TODO
	 */
	const typeOnlyChannel = (
	/**
	 * TODO
	 */
	id) => {
	    const blankChannel = {
	        ...(0, exports.channel)(id),
	        topics: new Proxy({}, {
	            get: (target, prop) => {
	                if (prop in target) {
	                    return target[prop];
	                }
	                if (typeof prop === "string") {
	                    return (0, topic_1.topic)(prop);
	                }
	            },
	        }),
	    };
	    const ch = new Proxy(blankChannel, {
	        get: (target, prop) => {
	            if (prop in target) {
	                return target[prop];
	            }
	            if (typeof prop === "string") {
	                return createTopicFn(id, (0, topic_1.topic)(prop));
	            }
	        },
	    });
	    return ch;
	};
	exports.typeOnlyChannel = typeOnlyChannel;
	const createTopicFn = (channelId, topic) => {
	    return async (data) => {
	        const schema = topic.getSchema();
	        if (schema) {
	            try {
	                await schema["~standard"].validate(data);
	            }
	            catch (err) {
	                console.error(`Failed schema validation for channel "${channelId}" topic "${topic.name}":`, err);
	                throw new Error("Failed schema validation");
	            }
	        }
	        return {
	            channel: channelId,
	            topic: topic.name,
	            data,
	        };
	    };
	};
	
} (channel));

var middleware = {};

var experimental = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getAsyncCtx = void 0;
	var als_js_1 = als;
	Object.defineProperty(exports, "getAsyncCtx", { enumerable: true, get: function () { return als_js_1.getAsyncCtx; } });
	
} (experimental));

Object.defineProperty(middleware, "__esModule", { value: true });
middleware.realtimeMiddleware = void 0;
const inngest_1 = inngest$1;
const experimental_1 = experimental;
const realtimeMiddleware$1 = () => {
    return new inngest_1.InngestMiddleware({
        name: "publish",
        init({ client }) {
            return {
                onFunctionRun({ ctx: { runId } }) {
                    return {
                        transformInput({ ctx: { step } }) {
                            const publish = async (input) => {
                                const { topic, channel, data } = await input;
                                const store = await (0, experimental_1.getAsyncCtx)();
                                if (!store) {
                                    throw new Error("No ALS found, but is required for running `publish()`");
                                }
                                const publishOpts = {
                                    topics: [topic],
                                    channel,
                                    runId,
                                };
                                const action = async () => {
                                    const result = await client["inngestApi"].publish(publishOpts, data);
                                    if (!result.ok) {
                                        throw new Error(`Failed to publish event: ${result.error?.error}`);
                                    }
                                };
                                return (store.executingStep
                                    ? action()
                                    : step.run(`publish:${publishOpts.channel}`, action)).then(() => {
                                    // Always return the data passed in to the `publish` call.
                                    return data;
                                });
                            };
                            return {
                                ctx: {
                                    /**
                                     * TODO
                                     */
                                    publish,
                                },
                            };
                        },
                    };
                },
            };
        },
    });
};
middleware.realtimeMiddleware = realtimeMiddleware$1;

var subscribe$1 = {};

var helpers = {};

var env$1 = {};

Object.defineProperty(env$1, "__esModule", { value: true });
env$1.getEnvVar = void 0;
/**
 * The environment variables that we wish to access in the environment.
 *
 * Due to the way that some environment variables are exposed across different
 * runtimes and bundling tools, we need to be careful about how we access them.
 *
 * The most basic annoyance is that environment variables are exposed in
 * different locations (e.g. `process.env`, `Deno.env`, `Netlify.env`,
 * `import.meta.env`).
 *
 * Bundling can be more disruptive though, where some will literally
 * find/replace `process.env.MY_VAR` with the value of `MY_VAR` at build time,
 * which requires us to ensure that the full env var is used in code instead of
 * dynamically building it.
 */
const env$2 = (() => {
    try {
        // Nodeish, including Vite
        if (process.env) {
            return {
                INNGEST_DEV: process.env.INNGEST_DEV ??
                    process.env.NEXT_PUBLIC_INNGEST_DEV ??
                    process.env.REACT_APP_INNGEST_DEV ??
                    process.env.NUXT_PUBLIC_INNGEST_DEV ??
                    process.env.VUE_APP_INNGEST_DEV ??
                    process.env.VITE_INNGEST_DEV,
                NODE_ENV: process.env.NODE_ENV ??
                    process.env.NEXT_PUBLIC_NODE_ENV ??
                    process.env.REACT_APP_NODE_ENV ??
                    process.env.NUXT_PUBLIC_NODE_ENV ??
                    process.env.VUE_APP_NODE_ENV ??
                    process.env.VITE_NODE_ENV ??
                    process.env.VITE_MODE,
                INNGEST_BASE_URL: process.env.INNGEST_BASE_URL ??
                    process.env.NEXT_PUBLIC_INNGEST_BASE_URL ??
                    process.env.REACT_APP_INNGEST_BASE_URL ??
                    process.env.NUXT_PUBLIC_INNGEST_BASE_URL ??
                    process.env.VUE_APP_INNGEST_BASE_URL ??
                    process.env.VITE_INNGEST_BASE_URL,
                INNGEST_API_BASE_URL: process.env.INNGEST_API_BASE_URL ??
                    process.env.NEXT_PUBLIC_INNGEST_API_BASE_URL ??
                    process.env.REACT_APP_INNGEST_API_BASE_URL ??
                    process.env.NUXT_PUBLIC_INNGEST_API_BASE_URL ??
                    process.env.VUE_APP_INNGEST_API_BASE_URL ??
                    process.env.VITE_INNGEST_API_BASE_URL,
                INNGEST_SIGNING_KEY: process.env.INNGEST_SIGNING_KEY,
                INNGEST_SIGNING_KEY_FALLBACK: process.env.INNGEST_SIGNING_KEY_FALLBACK,
            };
        }
    }
    catch {
        // noop
    }
    // Deno
    try {
        const denoEnv = Deno.env.toObject();
        if (denoEnv) {
            return {
                INNGEST_DEV: denoEnv.INNGEST_DEV,
                NODE_ENV: denoEnv.NODE_ENV,
                INNGEST_BASE_URL: denoEnv.INNGEST_BASE_URL,
                INNGEST_API_BASE_URL: denoEnv.INNGEST_API_BASE_URL,
                INNGEST_SIGNING_KEY: denoEnv.INNGEST_SIGNING_KEY,
                INNGEST_SIGNING_KEY_FALLBACK: denoEnv.INNGEST_SIGNING_KEY_FALLBACK,
            };
        }
    }
    catch {
        // noop
    }
    // Netlify
    try {
        const netlifyEnv = Netlify.env.toObject();
        if (netlifyEnv) {
            return {
                INNGEST_DEV: netlifyEnv.INNGEST_DEV,
                NODE_ENV: netlifyEnv.NODE_ENV,
                INNGEST_BASE_URL: netlifyEnv.INNGEST_BASE_URL,
                INNGEST_API_BASE_URL: netlifyEnv.INNGEST_API_BASE_URL,
                INNGEST_SIGNING_KEY: netlifyEnv.INNGEST_SIGNING_KEY,
                INNGEST_SIGNING_KEY_FALLBACK: netlifyEnv.INNGEST_SIGNING_KEY_FALLBACK,
            };
        }
    }
    catch {
        // noop
    }
})();
/**
 * Given a `key`, get the environment variable under that key.
 */
const getEnvVar = (key) => {
    return env$2?.[key];
};
env$1.getEnvVar = getEnvVar;

var TokenSubscription$1 = {};

var api = {};

var util = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.parseAsBoolean = exports.createDeferredPromise = void 0;
	exports.fetchWithAuthFallback = fetchWithAuthFallback;
	/**
	 * Creates and returns Promise that can be resolved or rejected with the
	 * returned `resolve` and `reject` functions.
	 *
	 * Resolving or rejecting the function will return a new set of Promise control
	 * functions. These can be ignored if the original Promise is all that's needed.
	 */
	const createDeferredPromise = () => {
	    let resolve;
	    let reject;
	    const promise = new Promise((_resolve, _reject) => {
	        resolve = (value) => {
	            _resolve(value);
	            return (0, exports.createDeferredPromise)();
	        };
	        reject = (reason) => {
	            _reject(reason);
	            return (0, exports.createDeferredPromise)();
	        };
	    });
	    return { promise, resolve: resolve, reject: reject };
	};
	exports.createDeferredPromise = createDeferredPromise;
	/**
	 * Send an HTTP request with the given signing key. If the response is a 401 or
	 * 403, then try again with the fallback signing key
	 */
	async function fetchWithAuthFallback({ authToken, authTokenFallback, fetch, options, url, }) {
	    let res = await fetch(url, {
	        ...options,
	        headers: {
	            ...options?.headers,
	            ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),
	        },
	    });
	    if ([401, 403].includes(res.status) && authTokenFallback) {
	        res = await fetch(url, {
	            ...options,
	            headers: {
	                ...options?.headers,
	                Authorization: `Bearer ${authTokenFallback}`,
	            },
	        });
	    }
	    return res;
	}
	/**
	 * Given an unknown value, try to parse it as a `boolean`. Useful for parsing
	 * environment variables that could be a selection of different values such as
	 * `"true"`, `"1"`.
	 *
	 * If the value could not be confidently parsed as a `boolean` or was seen to be
	 * `undefined`, this function returns `undefined`.
	 */
	const parseAsBoolean = (value) => {
	    if (typeof value === "boolean") {
	        return value;
	    }
	    if (typeof value === "number") {
	        return Boolean(value);
	    }
	    if (typeof value === "string") {
	        const trimmed = value.trim().toLowerCase();
	        if (trimmed === "undefined") {
	            return undefined;
	        }
	        if (["true", "1"].includes(trimmed)) {
	            return true;
	        }
	        return false;
	    }
	    return undefined;
	};
	exports.parseAsBoolean = parseAsBoolean;
	
} (util));

Object.defineProperty(api, "__esModule", { value: true });
api.api = void 0;
const zod_1$1 = lib;
const env_1$2 = env$1;
const util_1$1 = util;
const tokenSchema = zod_1$1.z.object({ jwt: zod_1$1.z.string() });
api.api = {
    async getSubscriptionToken({ channel, topics, signingKey, signingKeyFallback, apiBaseUrl, }) {
        let url;
        const path = "/v1/realtime/token";
        const inputBaseUrl = apiBaseUrl ||
            (0, env_1$2.getEnvVar)("INNGEST_BASE_URL") ||
            (0, env_1$2.getEnvVar)("INNGEST_API_BASE_URL");
        const devEnvVar = (0, env_1$2.getEnvVar)("INNGEST_DEV");
        if (inputBaseUrl) {
            url = new URL(path, inputBaseUrl);
        }
        else if (devEnvVar) {
            try {
                const devUrl = new URL(devEnvVar);
                url = new URL(path, devUrl);
            }
            catch {
                if ((0, util_1$1.parseAsBoolean)(devEnvVar)) {
                    url = new URL(path, "http://localhost:8288/");
                }
                else {
                    url = new URL(path, "https://api.inngest.com/");
                }
            }
        }
        else {
            url = new URL(path, (0, env_1$2.getEnvVar)("NODE_ENV") === "production"
                ? "https://api.inngest.com/"
                : "http://localhost:8288/");
        }
        const body = topics.map((topic) => ({
            channel,
            name: topic,
            kind: "run",
        }));
        const res = await (0, util_1$1.fetchWithAuthFallback)({
            authToken: signingKey,
            authTokenFallback: signingKeyFallback,
            fetch,
            url,
            options: {
                method: "POST",
                body: JSON.stringify(body),
                headers: {
                    "Content-Type": "application/json",
                },
            },
        });
        if (!res.ok) {
            throw new Error(`Failed to get subscription token: ${res.status} ${res.statusText} - ${await res.text()}`);
        }
        const data = await res.json();
        return tokenSchema.parse(data).jwt;
    },
};

var types = {};

Object.defineProperty(types, "__esModule", { value: true });
types.Realtime = void 0;
const zod_1 = lib;
var Realtime;
(function (Realtime) {
    Realtime.messageSchema = zod_1.z
        .object({
        channel: zod_1.z.string().optional(),
        topic: zod_1.z.string().optional(),
        data: zod_1.z.any(),
        run_id: zod_1.z.string().optional(),
        fn_id: zod_1.z.string().optional(),
        created_at: zod_1.z
            .string()
            .optional()
            .transform((v) => (v ? new Date(v) : undefined)),
        env_id: zod_1.z.string().optional(),
        stream_id: zod_1.z.string().optional(),
        kind: zod_1.z.enum([
            "step",
            "run",
            "data",
            "ping",
            "pong",
            "closing",
            "event",
            "sub",
            "unsub",
            "datastream-start",
            "datastream-end",
            "chunk",
        ]),
    })
        .transform(({ data, ...rest }) => {
        return {
            ...rest,
            data: data ?? undefined,
        };
    });
})(Realtime || (types.Realtime = Realtime = {}));

var StreamFanout$1 = {};

Object.defineProperty(StreamFanout$1, "__esModule", { value: true });
StreamFanout$1.StreamFanout = void 0;
/**
 * TODO
 */
class StreamFanout {
    #writers = new Set();
    /**
     * TODO
     */
    createStream(
    /**
     * TODO
     */
    transform) {
        const { readable, writable } = new TransformStream({
            transform: (chunk, controller) => {
                controller.enqueue(transform ? transform(chunk) : chunk);
            },
        });
        const writer = writable.getWriter();
        this.#writers.add(writer);
        // Eagerly remove the writer is the stream is closed
        writer.closed
            .catch(() => { }) // Suppress unhandled promise rejection to avoid noisy logs
            .finally(() => {
            this.#writers.delete(writer);
        });
        return readable;
    }
    /**
     * TODO
     */
    write(
    /**
     * TODO
     */
    chunk) {
        for (const writer of this.#writers) {
            writer.ready
                .then(() => writer.write(chunk))
                // Dereference the writer if we fail, as this means it's closed
                .catch(() => this.#writers.delete(writer));
        }
    }
    /**
     * TODO
     */
    close() {
        for (const writer of this.#writers) {
            try {
                writer.close();
            }
            catch {
                // Ignore errors, as we are closing the stream and the writer may
                // already be closed, especially if the stream is closed before the
                // writer is closed or if the stream is cancelled.
            }
        }
        this.#writers.clear();
    }
    /**
     * TODO
     */
    size() {
        return this.#writers.size;
    }
}
StreamFanout$1.StreamFanout = StreamFanout;

var __importDefault = (TokenSubscription$1 && TokenSubscription$1.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(TokenSubscription$1, "__esModule", { value: true });
TokenSubscription$1.TokenSubscription = void 0;
const debug_1 = __importDefault(srcExports);
const api_1 = api;
const env_1$1 = env$1;
const topic_1 = topic$1;
const types_1 = types;
const util_1 = util;
const StreamFanout_1 = StreamFanout$1;
/**
 * TODO
 */
class TokenSubscription {
    token;
    #apiBaseUrl;
    #channelId;
    #debug = (0, debug_1.default)("inngest:realtime");
    #encoder = new TextEncoder();
    #fanout = new StreamFanout_1.StreamFanout();
    #running = false;
    #topics;
    #ws = null;
    #signingKey;
    #signingKeyFallback;
    /**
     * This is a map that tracks stream IDs to their corresponding streams and
     * controllers.
     */
    #chunkStreams = new Map();
    constructor(
    /**
     * TODO
     */
    token, apiBaseUrl, signingKey, signingKeyFallback) {
        this.token = token;
        this.#apiBaseUrl = apiBaseUrl;
        this.#signingKey = signingKey;
        this.#signingKeyFallback = signingKeyFallback;
        if (typeof token.channel === "string") {
            this.#channelId = token.channel;
            this.#topics = this.token.topics.reduce((acc, name) => {
                acc.set(name, (0, topic_1.topic)(name));
                return acc;
            }, new Map());
        }
        else {
            this.#channelId = token.channel.name;
            this.#topics = this.token.topics.reduce((acc, name) => {
                acc.set(name, token.channel.topics[name] ?? (0, topic_1.topic)(name));
                return acc;
            }, new Map());
        }
    }
    async getWsUrl(token) {
        let url;
        const path = "/v1/realtime/connect";
        const devEnvVar = (0, env_1$1.getEnvVar)("INNGEST_DEV");
        if (this.#apiBaseUrl) {
            url = new URL(path, this.#apiBaseUrl);
        }
        else if (devEnvVar) {
            try {
                const devUrl = new URL(devEnvVar);
                url = new URL(path, devUrl);
            }
            catch {
                if ((0, util_1.parseAsBoolean)(devEnvVar)) {
                    url = new URL(path, "http://localhost:8288/");
                }
                else {
                    url = new URL(path, "https://api.inngest.com/");
                }
            }
        }
        else {
            url = new URL(path, (0, env_1$1.getEnvVar)("NODE_ENV") === "production"
                ? "https://api.inngest.com/"
                : "http://localhost:8288/");
        }
        url.protocol = url.protocol === "http:" ? "ws:" : "wss:";
        url.searchParams.set("token", token);
        return url;
    }
    /**
     * TODO
     */
    async connect() {
        this.#debug(`Establishing connection to channel "${this.#channelId}" with topics ${JSON.stringify([...this.#topics.keys()])}...`);
        if (typeof WebSocket === "undefined") {
            throw new Error("WebSockets not supported in current environment");
        }
        let key = this.token.key;
        if (!key) {
            this.#debug("No subscription token key passed; attempting to retrieve one automatically...");
            key = (await this.lazilyGetSubscriptionToken({
                ...this.token,
                signingKey: this.#signingKey,
                signingKeyFallback: this.#signingKeyFallback,
            })).key;
            if (!key) {
                throw new Error("No subscription token key passed and failed to retrieve one automatically");
            }
        }
        const ret = (0, util_1.createDeferredPromise)();
        try {
            this.#ws = new WebSocket(await this.getWsUrl(key));
            this.#ws.onopen = () => {
                this.#debug("WebSocket connection established");
                ret.resolve();
            };
            this.#ws.onmessage = async (event) => {
                const parseRes = await types_1.Realtime.messageSchema.safeParseAsync(JSON.parse(event.data));
                if (!parseRes.success) {
                    this.#debug("Received invalid message:", parseRes.error);
                    return;
                }
                const msg = parseRes.data;
                if (!this.#running) {
                    this.#debug(`Received message on channel "${msg.channel}" for topic "${msg.topic}" but stream is closed`);
                }
                switch (msg.kind) {
                    case "data": {
                        if (!msg.channel) {
                            this.#debug(`Received message on channel "${msg.channel}" with no channel`);
                            return;
                        }
                        if (!msg.topic) {
                            this.#debug(`Received message on channel "${msg.channel}" with no topic`);
                            return;
                        }
                        const topic = this.#topics.get(msg.topic);
                        if (!topic) {
                            this.#debug(`Received message on channel "${msg.channel}" for unknown topic "${msg.topic}"`);
                            return;
                        }
                        const schema = topic.getSchema();
                        if (schema) {
                            const validateRes = await schema["~standard"].validate(msg.data);
                            if (validateRes.issues) {
                                console.error(`Received message on channel "${msg.channel}" for topic "${msg.topic}" that failed schema validation:`, validateRes.issues);
                                return;
                            }
                            msg.data = validateRes.value;
                        }
                        this.#debug(`Received message on channel "${msg.channel}" for topic "${msg.topic}":`, msg.data);
                        return this.#fanout.write({
                            channel: msg.channel,
                            topic: msg.topic,
                            data: msg.data,
                            fnId: msg.fn_id,
                            createdAt: msg.created_at || new Date(),
                            runId: msg.run_id,
                            kind: "data",
                            envId: msg.env_id,
                        });
                    }
                    case "datastream-start": {
                        if (!msg.channel) {
                            this.#debug(`Received message on channel "${msg.channel}" with no channel`);
                            return;
                        }
                        if (!msg.topic) {
                            this.#debug(`Received message on channel "${msg.channel}" with no topic`);
                            return;
                        }
                        const streamId = msg.data;
                        if (typeof streamId !== "string" || !streamId) {
                            this.#debug(`Received message on channel "${msg.channel}" with no stream ID`);
                            return;
                        }
                        // `data` is a stream ID that we'll start receiving chunks with
                        if (this.#chunkStreams.has(streamId)) {
                            this.#debug(`Received message on channel "${msg.channel}" to create stream ID "${streamId}" that already exists`);
                            return;
                        }
                        const stream = new ReadableStream({
                            start: (controller) => {
                                this.#chunkStreams.set(streamId, { stream, controller });
                            },
                            cancel: () => {
                                this.#chunkStreams.delete(streamId);
                            },
                        });
                        this.#debug(`Created stream ID "${streamId}" on channel "${msg.channel}"`);
                        return this.#fanout.write({
                            channel: msg.channel,
                            topic: msg.topic,
                            kind: "datastream-start",
                            data: streamId,
                            streamId,
                            fnId: msg.fn_id,
                            runId: msg.run_id,
                            stream,
                        });
                    }
                    case "datastream-end": {
                        if (!msg.channel) {
                            this.#debug(`Received message on channel "${msg.channel}" with no channel`);
                            return;
                        }
                        if (!msg.topic) {
                            this.#debug(`Received message on channel "${msg.channel}" with no topic`);
                            return;
                        }
                        const streamId = msg.data;
                        if (typeof streamId !== "string" || !streamId) {
                            this.#debug(`Received message on channel "${msg.channel}" with no stream ID`);
                            return;
                        }
                        // `data` is a stream ID that we'll stop receiving chunks with
                        const stream = this.#chunkStreams.get(streamId);
                        if (!stream) {
                            this.#debug(`Received message on channel "${msg.channel}" to close stream ID "${streamId}" that doesn't exist`);
                            return;
                        }
                        stream.controller.close();
                        this.#chunkStreams.delete(streamId);
                        this.#debug(`Closed stream ID "${streamId}" on channel "${msg.channel}"`);
                        return this.#fanout.write({
                            channel: msg.channel,
                            topic: msg.topic,
                            kind: "datastream-end",
                            data: streamId,
                            streamId,
                            fnId: msg.fn_id,
                            runId: msg.run_id,
                            stream: stream.stream,
                        });
                    }
                    case "chunk": {
                        if (!msg.channel) {
                            this.#debug(`Received message on channel "${msg.channel}" with no channel`);
                            return;
                        }
                        if (!msg.topic) {
                            this.#debug(`Received message on channel "${msg.channel}" with no topic`);
                            return;
                        }
                        // `stream_id` is the ID of the stream we're receiving chunks for
                        if (!msg.stream_id) {
                            this.#debug(`Received message on channel "${msg.channel}" with no stream ID`);
                            return;
                        }
                        const stream = this.#chunkStreams.get(msg.stream_id);
                        if (!stream) {
                            this.#debug(`Received message on channel "${msg.channel}" for unknown stream ID "${msg.stream_id}"`);
                            return;
                        }
                        this.#debug(`Received chunk on channel "${msg.channel}" for stream ID "${msg.stream_id}":`, msg.data);
                        stream.controller.enqueue(msg.data);
                        return this.#fanout.write({
                            channel: msg.channel,
                            topic: msg.topic,
                            kind: "chunk",
                            data: msg.data,
                            streamId: msg.stream_id,
                            fnId: msg.fn_id,
                            runId: msg.run_id,
                            stream: stream.stream,
                        });
                    }
                    default: {
                        this.#debug(`Received message on channel "${msg.channel}" with unhandled kind "${msg.kind}"`);
                        return;
                    }
                }
            };
            this.#ws.onerror = (event) => {
                console.error("WebSocket error observed:", event);
                ret.reject(event);
            };
            this.#ws.onclose = (event) => {
                this.#debug("WebSocket closed:", event.reason);
                this.close();
            };
            this.#running = true;
        }
        catch (err) {
            ret.reject(err);
        }
        return ret.promise;
    }
    /**
     * TODO
     */
    async lazilyGetSubscriptionToken(
    /**
     * TODO
     */
    args) {
        const channelId = typeof args.channel === "string" ? args.channel : args.channel.name;
        if (!channelId) {
            throw new Error("Channel ID is required to create a subscription token");
        }
        const key = await api_1.api.getSubscriptionToken({
            channel: channelId,
            topics: args.topics,
            signingKey: args.signingKey,
            signingKeyFallback: args.signingKeyFallback,
            apiBaseUrl: this.#apiBaseUrl,
        });
        const token = {
            channel: channelId,
            topics: args.topics,
            key,
        };
        return token;
    }
    /**
     * TODO
     */
    close(
    /**
     * TODO
     */
    reason = "Userland closed connection") {
        if (!this.#running) {
            return;
        }
        this.#debug("close() called; closing connection...");
        this.#running = false;
        this.#ws?.close(1000, reason);
        this.#debug(`Closing ${this.#fanout.size()} streams...`);
        this.#fanout.close();
    }
    /**
     * TODO
     */
    getJsonStream() {
        return this.#fanout.createStream();
    }
    /**
     * TODO
     */
    getEncodedStream() {
        return this.#fanout.createStream((chunk) => {
            return this.#encoder.encode(`${JSON.stringify(chunk)}\n`);
        });
    }
    /**
     * TODO
     */
    useCallback(callback, stream = this.getJsonStream()) {
        void (async () => {
            // Explicitly get and manage the reader so that we can manually release
            // the lock if anything goes wrong or we're done with it.
            const reader = stream.getReader();
            try {
                while (this.#running) {
                    const { done, value } = await reader.read();
                    if (done || !this.#running)
                        break;
                    callback(value);
                }
            }
            finally {
                reader.releaseLock();
            }
        })();
    }
}
TokenSubscription$1.TokenSubscription = TokenSubscription;

Object.defineProperty(helpers, "__esModule", { value: true });
helpers.getSubscriptionToken = helpers.subscribe = void 0;
const env_1 = env$1;
const TokenSubscription_1 = TokenSubscription$1;
/**
 * TODO
 */
const subscribe = async (
/**
 * TODO
 */
token, 
/**
 * TODO
 */
callback) => {
    const app = token.app;
    const api = app?.["inngestApi"];
    // Allow users to specify public env vars for the target URLs, but do not
    // allow this for signing keys, as they should never be on a client.
    const maybeApiBaseUrl = app?.apiBaseUrl ||
        (0, env_1.getEnvVar)("INNGEST_BASE_URL") ||
        (0, env_1.getEnvVar)("INNGEST_API_BASE_URL");
    const maybeSigningKey = api?.["signingKey"] || (0, env_1.getEnvVar)("INNGEST_SIGNING_KEY");
    const maybeSigningKeyFallback = api?.["signingKeyFallback"] || (0, env_1.getEnvVar)("INNGEST_SIGNING_KEY_FALLBACK");
    const subscription = new TokenSubscription_1.TokenSubscription(token, maybeApiBaseUrl, maybeSigningKey, maybeSigningKeyFallback);
    const retStream = subscription.getJsonStream();
    const callbackStream = subscription.getJsonStream();
    await subscription.connect();
    const extras = {
        getJsonStream: () => subscription.getJsonStream(),
        getEncodedStream: () => subscription.getEncodedStream(),
    };
    if (callback) {
        subscription.useCallback(callback, callbackStream);
    }
    else {
        callbackStream.cancel("Not needed");
    }
    return Object.assign(retStream, extras);
};
helpers.subscribe = subscribe;
/**
 * TODO
 */
const getSubscriptionToken = async (
/**
 * TODO
 */
app, 
/**
 * TODO
 */
args) => {
    const channelId = typeof args.channel === "string" ? args.channel : args.channel.name;
    if (!channelId) {
        throw new Error("Channel ID is required to create a subscription token");
    }
    const key = await app["inngestApi"].getSubscriptionToken(channelId, args.topics);
    const token = {
        channel: channelId,
        topics: args.topics,
        key,
    };
    return token;
};
helpers.getSubscriptionToken = getSubscriptionToken;

(function (exports) {
	var __createBinding = (subscribe$1 && subscribe$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (subscribe$1 && subscribe$1.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar(helpers, exports);
	
} (subscribe$1));

(function (exports) {
	var __createBinding = (dist && dist.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (dist && dist.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar(channel, exports);
	__exportStar(middleware, exports);
	__exportStar(subscribe$1, exports);
	__exportStar(topic$1, exports);
	__exportStar(types, exports);
	
} (dist));

// src/runtime-context/index.ts
var RuntimeContext = class {
  registry = /* @__PURE__ */ new Map();
  constructor(iterable) {
    this.registry = new Map(iterable);
  }
  /**
   * set a value with strict typing if `Values` is a Record and the key exists in it.
   */
  set(key, value) {
    this.registry.set(key, value);
  }
  /**
   * Get a value with its type
   */
  get(key) {
    return this.registry.get(key);
  }
  /**
   * Check if a key exists in the container
   */
  has(key) {
    return this.registry.has(key);
  }
  /**
   * Delete a value by key
   */
  delete(key) {
    return this.registry.delete(key);
  }
  /**
   * Clear all values from the container
   */
  clear() {
    this.registry.clear();
  }
  /**
   * Get all keys in the container
   */
  keys() {
    return this.registry.keys();
  }
  /**
   * Get all values in the container
   */
  values() {
    return this.registry.values();
  }
  /**
   * Get all entries in the container
   */
  entries() {
    return this.registry.entries();
  }
  /**
   * Get the size of the container
   */
  size() {
    return this.registry.size;
  }
  /**
   * Execute a function for each entry in the container
   */
  forEach(callbackfn) {
    this.registry.forEach(callbackfn);
  }
};

// src/errors/ai-sdk-error.ts
var marker$1 = "vercel.ai.error";
var symbol$1 = Symbol.for(marker$1);
var _a$1$1;
var _AISDKError = class _AISDKError extends Error {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: name14,
    message,
    cause
  }) {
    super(message);
    this[_a$1$1] = true;
    this.name = name14;
    this.cause = cause;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(error) {
    return _AISDKError.hasMarker(error, marker$1);
  }
  static hasMarker(error, marker15) {
    const markerSymbol = Symbol.for(marker15);
    return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;
  }
};
_a$1$1 = symbol$1;
var AISDKError = _AISDKError;

// src/errors/api-call-error.ts
var name$1 = "AI_APICallError";
var marker2$1 = `vercel.ai.error.${name$1}`;
var symbol2$1 = Symbol.for(marker2$1);
var _a2$1;
var APICallError = class extends AISDKError {
  constructor({
    message,
    url,
    requestBodyValues,
    statusCode,
    responseHeaders,
    responseBody,
    cause,
    isRetryable = statusCode != null && (statusCode === 408 || // request timeout
    statusCode === 409 || // conflict
    statusCode === 429 || // too many requests
    statusCode >= 500),
    // server error
    data
  }) {
    super({ name: name$1, message, cause });
    this[_a2$1] = true;
    this.url = url;
    this.requestBodyValues = requestBodyValues;
    this.statusCode = statusCode;
    this.responseHeaders = responseHeaders;
    this.responseBody = responseBody;
    this.isRetryable = isRetryable;
    this.data = data;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker2$1);
  }
};
_a2$1 = symbol2$1;

// src/errors/get-error-message.ts
function getErrorMessage$1(error) {
  if (error == null) {
    return "unknown error";
  }
  if (typeof error === "string") {
    return error;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return JSON.stringify(error);
}

// src/errors/invalid-argument-error.ts
var name3 = "AI_InvalidArgumentError";
var marker4$1 = `vercel.ai.error.${name3}`;
var symbol4$1 = Symbol.for(marker4$1);
var _a4$1;
var InvalidArgumentError$1 = class InvalidArgumentError extends AISDKError {
  constructor({
    message,
    cause,
    argument
  }) {
    super({ name: name3, message, cause });
    this[_a4$1] = true;
    this.argument = argument;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker4$1);
  }
};
_a4$1 = symbol4$1;

// src/errors/invalid-prompt-error.ts
var name4$1 = "AI_InvalidPromptError";
var marker5$1 = `vercel.ai.error.${name4$1}`;
var symbol5$1 = Symbol.for(marker5$1);
var _a5$1;
var InvalidPromptError = class extends AISDKError {
  constructor({
    prompt,
    message,
    cause
  }) {
    super({ name: name4$1, message: `Invalid prompt: ${message}`, cause });
    this[_a5$1] = true;
    this.prompt = prompt;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker5$1);
  }
};
_a5$1 = symbol5$1;

// src/errors/json-parse-error.ts
var name6$1 = "AI_JSONParseError";
var marker7$1 = `vercel.ai.error.${name6$1}`;
var symbol7$1 = Symbol.for(marker7$1);
var _a7$1;
var JSONParseError = class extends AISDKError {
  constructor({ text, cause }) {
    super({
      name: name6$1,
      message: `JSON parsing failed: Text: ${text}.
Error message: ${getErrorMessage$1(cause)}`,
      cause
    });
    this[_a7$1] = true;
    this.text = text;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker7$1);
  }
};
_a7$1 = symbol7$1;

// src/errors/type-validation-error.ts
var name12$1 = "AI_TypeValidationError";
var marker13$1 = `vercel.ai.error.${name12$1}`;
var symbol13$1 = Symbol.for(marker13$1);
var _a13$1;
var _TypeValidationError = class _TypeValidationError extends AISDKError {
  constructor({ value, cause }) {
    super({
      name: name12$1,
      message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage$1(cause)}`,
      cause
    });
    this[_a13$1] = true;
    this.value = value;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker13$1);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value,
    cause
  }) {
    return _TypeValidationError.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError({ value, cause });
  }
};
_a13$1 = symbol13$1;
var TypeValidationError = _TypeValidationError;

// src/errors/unsupported-functionality-error.ts
var name13$1 = "AI_UnsupportedFunctionalityError";
var marker14$1 = `vercel.ai.error.${name13$1}`;
var symbol14$1 = Symbol.for(marker14$1);
var _a14$1;
var UnsupportedFunctionalityError = class extends AISDKError {
  constructor({
    functionality,
    message = `'${functionality}' functionality not supported.`
  }) {
    super({ name: name13$1, message });
    this[_a14$1] = true;
    this.functionality = functionality;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker14$1);
  }
};
_a14$1 = symbol14$1;

// src/json-value/is-json.ts
function isJSONValue(value) {
  if (value === null || typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    return true;
  }
  if (Array.isArray(value)) {
    return value.every(isJSONValue);
  }
  if (typeof value === "object") {
    return Object.entries(value).every(
      ([key, val]) => typeof key === "string" && isJSONValue(val)
    );
  }
  return false;
}
function isJSONArray(value) {
  return Array.isArray(value) && value.every(isJSONValue);
}
function isJSONObject(value) {
  return value != null && typeof value === "object" && Object.entries(value).every(
    ([key, val]) => typeof key === "string" && isJSONValue(val)
  );
}

// This alphabet uses `A-Za-z0-9_-` symbols.
// The order of characters is optimized for better gzip and brotli compression.
// References to the same file (works both for gzip and brotli):
// `'use`, `andom`, and `rict'`
// References to the brotli default dictionary:
// `-26T`, `1983`, `40px`, `75px`, `bush`, `jack`, `mind`, `very`, and `wolf`
let urlAlphabet =
  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';

let customAlphabet = (alphabet, defaultSize = 21) => {
  return (size = defaultSize) => {
    let id = '';
    // A compact alternative for `for (var i = 0; i < step; i++)`.
    let i = size | 0;
    while (i--) {
      // `| 0` is more compact and faster than `Math.floor()`.
      id += alphabet[(Math.random() * alphabet.length) | 0];
    }
    return id
  }
};

let nanoid = (size = 21) => {
  let id = '';
  // A compact alternative for `for (var i = 0; i < step; i++)`.
  let i = size | 0;
  while (i--) {
    // `| 0` is more compact and faster than `Math.floor()`.
    id += urlAlphabet[(Math.random() * 64) | 0];
  }
  return id
};

var nonSecure = { nanoid, customAlphabet };

var secureJsonParse = {exports: {}};

const hasBuffer = typeof Buffer !== 'undefined';
const suspectProtoRx = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;
const suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;

function _parse (text, reviver, options) {
  // Normalize arguments
  if (options == null) {
    if (reviver !== null && typeof reviver === 'object') {
      options = reviver;
      reviver = undefined;
    }
  }

  if (hasBuffer && Buffer.isBuffer(text)) {
    text = text.toString();
  }

  // BOM checker
  if (text && text.charCodeAt(0) === 0xFEFF) {
    text = text.slice(1);
  }

  // Parse normally, allowing exceptions
  const obj = JSON.parse(text, reviver);

  // Ignore null and non-objects
  if (obj === null || typeof obj !== 'object') {
    return obj
  }

  const protoAction = (options && options.protoAction) || 'error';
  const constructorAction = (options && options.constructorAction) || 'error';

  // options: 'error' (default) / 'remove' / 'ignore'
  if (protoAction === 'ignore' && constructorAction === 'ignore') {
    return obj
  }

  if (protoAction !== 'ignore' && constructorAction !== 'ignore') {
    if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {
      return obj
    }
  } else if (protoAction !== 'ignore' && constructorAction === 'ignore') {
    if (suspectProtoRx.test(text) === false) {
      return obj
    }
  } else {
    if (suspectConstructorRx.test(text) === false) {
      return obj
    }
  }

  // Scan result for proto keys
  return filter(obj, { protoAction, constructorAction, safe: options && options.safe })
}

function filter (obj, { protoAction = 'error', constructorAction = 'error', safe } = {}) {
  let next = [obj];

  while (next.length) {
    const nodes = next;
    next = [];

    for (const node of nodes) {
      if (protoAction !== 'ignore' && Object.prototype.hasOwnProperty.call(node, '__proto__')) { // Avoid calling node.hasOwnProperty directly
        if (safe === true) {
          return null
        } else if (protoAction === 'error') {
          throw new SyntaxError('Object contains forbidden prototype property')
        }

        delete node.__proto__; // eslint-disable-line no-proto
      }

      if (constructorAction !== 'ignore' &&
          Object.prototype.hasOwnProperty.call(node, 'constructor') &&
          Object.prototype.hasOwnProperty.call(node.constructor, 'prototype')) { // Avoid calling node.hasOwnProperty directly
        if (safe === true) {
          return null
        } else if (constructorAction === 'error') {
          throw new SyntaxError('Object contains forbidden prototype property')
        }

        delete node.constructor;
      }

      for (const key in node) {
        const value = node[key];
        if (value && typeof value === 'object') {
          next.push(value);
        }
      }
    }
  }
  return obj
}

function parse (text, reviver, options) {
  const stackTraceLimit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  try {
    return _parse(text, reviver, options)
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
}

function safeParse (text, reviver) {
  const stackTraceLimit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  try {
    return _parse(text, reviver, { safe: true })
  } catch (_e) {
    return null
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
}

secureJsonParse.exports = parse;
secureJsonParse.exports.default = parse;
secureJsonParse.exports.parse = parse;
secureJsonParse.exports.safeParse = safeParse;
secureJsonParse.exports.scan = filter;

var secureJsonParseExports = secureJsonParse.exports;
var SecureJSON = /*@__PURE__*/getDefaultExportFromCjs(secureJsonParseExports);

// src/combine-headers.ts

// src/convert-async-iterator-to-readable-stream.ts
function convertAsyncIteratorToReadableStream(iterator) {
  return new ReadableStream({
    /**
     * Called when the consumer wants to pull more data from the stream.
     *
     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.
     * @returns {Promise<void>}
     */
    async pull(controller) {
      try {
        const { value, done } = await iterator.next();
        if (done) {
          controller.close();
        } else {
          controller.enqueue(value);
        }
      } catch (error) {
        controller.error(error);
      }
    },
    /**
     * Called when the consumer cancels the stream.
     */
    cancel() {
    }
  });
}

// src/delay.ts
async function delay$1(delayInMs) {
  return delayInMs == null ? Promise.resolve() : new Promise((resolve2) => setTimeout(resolve2, delayInMs));
}
var createIdGenerator = ({
  prefix,
  size: defaultSize = 16,
  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator = "-"
} = {}) => {
  const generator = nonSecure.customAlphabet(alphabet, defaultSize);
  if (prefix == null) {
    return generator;
  }
  if (alphabet.includes(separator)) {
    throw new InvalidArgumentError$1({
      argument: "separator",
      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
    });
  }
  return (size) => `${prefix}${separator}${generator(size)}`;
};
var generateId = createIdGenerator();

// src/get-error-message.ts
function getErrorMessage(error) {
  if (error == null) {
    return "unknown error";
  }
  if (typeof error === "string") {
    return error;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return JSON.stringify(error);
}

// src/is-abort-error.ts
function isAbortError(error) {
  return error instanceof Error && (error.name === "AbortError" || error.name === "TimeoutError");
}

// src/validator.ts
var validatorSymbol = Symbol.for("vercel.ai.validator");
function validator(validate) {
  return { [validatorSymbol]: true, validate };
}
function isValidator(value) {
  return typeof value === "object" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && "validate" in value;
}
function asValidator(value) {
  return isValidator(value) ? value : zodValidator(value);
}
function zodValidator(zodSchema) {
  return validator((value) => {
    const result = zodSchema.safeParse(value);
    return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
  });
}
function safeValidateTypes({
  value,
  schema
}) {
  const validator2 = asValidator(schema);
  try {
    if (validator2.validate == null) {
      return { success: true, value };
    }
    const result = validator2.validate(value);
    if (result.success) {
      return result;
    }
    return {
      success: false,
      error: TypeValidationError.wrap({ value, cause: result.error })
    };
  } catch (error) {
    return {
      success: false,
      error: TypeValidationError.wrap({ value, cause: error })
    };
  }
}
function safeParseJSON({
  text,
  schema
}) {
  try {
    const value = SecureJSON.parse(text);
    if (schema == null) {
      return { success: true, value, rawValue: value };
    }
    const validationResult = safeValidateTypes({ value, schema });
    return validationResult.success ? { ...validationResult, rawValue: value } : validationResult;
  } catch (error) {
    return {
      success: false,
      error: JSONParseError.isInstance(error) ? error : new JSONParseError({ text, cause: error })
    };
  }
}

// src/uint8-utils.ts
var { btoa, atob: atob$1 } = globalThis;
function convertBase64ToUint8Array(base64String) {
  const base64Url = base64String.replace(/-/g, "+").replace(/_/g, "/");
  const latin1string = atob$1(base64Url);
  return Uint8Array.from(latin1string, (byte) => byte.codePointAt(0));
}
function convertUint8ArrayToBase64(array) {
  let latin1string = "";
  for (let i = 0; i < array.length; i++) {
    latin1string += String.fromCodePoint(array[i]);
  }
  return btoa(latin1string);
}

const ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
const defaultOptions = {
    name: undefined,
    $refStrategy: "root",
    basePath: ["#"],
    effectStrategy: "input",
    pipeStrategy: "all",
    dateStrategy: "format:date-time",
    mapStrategy: "entries",
    removeAdditionalStrategy: "passthrough",
    allowedAdditionalProperties: true,
    rejectedAdditionalProperties: false,
    definitionPath: "definitions",
    target: "jsonSchema7",
    strictUnions: false,
    definitions: {},
    errorMessages: false,
    markdownDescription: false,
    patternStrategy: "escape",
    applyRegexFlags: false,
    emailStrategy: "format:email",
    base64Strategy: "contentEncoding:base64",
    nameStrategy: "ref",
};
const getDefaultOptions = (options) => (typeof options === "string"
    ? {
        ...defaultOptions,
        name: options,
    }
    : {
        ...defaultOptions,
        ...options,
    });

const getRefs = (options) => {
    const _options = getDefaultOptions(options);
    const currentPath = _options.name !== undefined
        ? [..._options.basePath, _options.definitionPath, _options.name]
        : _options.basePath;
    return {
        ..._options,
        currentPath: currentPath,
        propertyPath: undefined,
        seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [
            def._def,
            {
                def: def._def,
                path: [..._options.basePath, _options.definitionPath, name],
                // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
                jsonSchema: undefined,
            },
        ])),
    };
};

function addErrorMessage(res, key, errorMessage, refs) {
    if (!refs?.errorMessages)
        return;
    if (errorMessage) {
        res.errorMessage = {
            ...res.errorMessage,
            [key]: errorMessage,
        };
    }
}
function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
    res[key] = value;
    addErrorMessage(res, key, errorMessage, refs);
}

function parseAnyDef() {
    return {};
}

function parseArrayDef(def, refs) {
    const res = {
        type: "array",
    };
    if (def.type?._def &&
        def.type?._def?.typeName !== lib.ZodFirstPartyTypeKind.ZodAny) {
        res.items = parseDef(def.type._def, {
            ...refs,
            currentPath: [...refs.currentPath, "items"],
        });
    }
    if (def.minLength) {
        setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
    }
    if (def.maxLength) {
        setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
    }
    if (def.exactLength) {
        setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
        setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
    }
    return res;
}

function parseBigintDef(def, refs) {
    const res = {
        type: "integer",
        format: "int64",
    };
    if (!def.checks)
        return res;
    for (const check of def.checks) {
        switch (check.kind) {
            case "min":
                if (refs.target === "jsonSchema7") {
                    if (check.inclusive) {
                        setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
                    }
                    else {
                        setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
                    }
                }
                else {
                    if (!check.inclusive) {
                        res.exclusiveMinimum = true;
                    }
                    setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
                }
                break;
            case "max":
                if (refs.target === "jsonSchema7") {
                    if (check.inclusive) {
                        setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
                    }
                    else {
                        setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
                    }
                }
                else {
                    if (!check.inclusive) {
                        res.exclusiveMaximum = true;
                    }
                    setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
                }
                break;
            case "multipleOf":
                setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
                break;
        }
    }
    return res;
}

function parseBooleanDef() {
    return {
        type: "boolean",
    };
}

function parseBrandedDef(_def, refs) {
    return parseDef(_def.type._def, refs);
}

const parseCatchDef = (def, refs) => {
    return parseDef(def.innerType._def, refs);
};

function parseDateDef(def, refs, overrideDateStrategy) {
    const strategy = overrideDateStrategy ?? refs.dateStrategy;
    if (Array.isArray(strategy)) {
        return {
            anyOf: strategy.map((item, i) => parseDateDef(def, refs, item)),
        };
    }
    switch (strategy) {
        case "string":
        case "format:date-time":
            return {
                type: "string",
                format: "date-time",
            };
        case "format:date":
            return {
                type: "string",
                format: "date",
            };
        case "integer":
            return integerDateParser(def, refs);
    }
}
const integerDateParser = (def, refs) => {
    const res = {
        type: "integer",
        format: "unix-time",
    };
    if (refs.target === "openApi3") {
        return res;
    }
    for (const check of def.checks) {
        switch (check.kind) {
            case "min":
                setResponseValueAndErrors(res, "minimum", check.value, // This is in milliseconds
                check.message, refs);
                break;
            case "max":
                setResponseValueAndErrors(res, "maximum", check.value, // This is in milliseconds
                check.message, refs);
                break;
        }
    }
    return res;
};

function parseDefaultDef(_def, refs) {
    return {
        ...parseDef(_def.innerType._def, refs),
        default: _def.defaultValue(),
    };
}

function parseEffectsDef(_def, refs) {
    return refs.effectStrategy === "input"
        ? parseDef(_def.schema._def, refs)
        : {};
}

function parseEnumDef(def) {
    return {
        type: "string",
        enum: Array.from(def.values),
    };
}

const isJsonSchema7AllOfType = (type) => {
    if ("type" in type && type.type === "string")
        return false;
    return "allOf" in type;
};
function parseIntersectionDef(def, refs) {
    const allOf = [
        parseDef(def.left._def, {
            ...refs,
            currentPath: [...refs.currentPath, "allOf", "0"],
        }),
        parseDef(def.right._def, {
            ...refs,
            currentPath: [...refs.currentPath, "allOf", "1"],
        }),
    ].filter((x) => !!x);
    let unevaluatedProperties = refs.target === "jsonSchema2019-09"
        ? { unevaluatedProperties: false }
        : undefined;
    const mergedAllOf = [];
    // If either of the schemas is an allOf, merge them into a single allOf
    allOf.forEach((schema) => {
        if (isJsonSchema7AllOfType(schema)) {
            mergedAllOf.push(...schema.allOf);
            if (schema.unevaluatedProperties === undefined) {
                // If one of the schemas has no unevaluatedProperties set,
                // the merged schema should also have no unevaluatedProperties set
                unevaluatedProperties = undefined;
            }
        }
        else {
            let nestedSchema = schema;
            if ("additionalProperties" in schema &&
                schema.additionalProperties === false) {
                const { additionalProperties, ...rest } = schema;
                nestedSchema = rest;
            }
            else {
                // As soon as one of the schemas has additionalProperties set not to false, we allow unevaluatedProperties
                unevaluatedProperties = undefined;
            }
            mergedAllOf.push(nestedSchema);
        }
    });
    return mergedAllOf.length
        ? {
            allOf: mergedAllOf,
            ...unevaluatedProperties,
        }
        : undefined;
}

function parseLiteralDef(def, refs) {
    const parsedType = typeof def.value;
    if (parsedType !== "bigint" &&
        parsedType !== "number" &&
        parsedType !== "boolean" &&
        parsedType !== "string") {
        return {
            type: Array.isArray(def.value) ? "array" : "object",
        };
    }
    if (refs.target === "openApi3") {
        return {
            type: parsedType === "bigint" ? "integer" : parsedType,
            enum: [def.value],
        };
    }
    return {
        type: parsedType === "bigint" ? "integer" : parsedType,
        const: def.value,
    };
}

let emojiRegex = undefined;
/**
 * Generated from the regular expressions found here as of 2024-05-22:
 * https://github.com/colinhacks/zod/blob/master/src/types.ts.
 *
 * Expressions with /i flag have been changed accordingly.
 */
const zodPatterns = {
    /**
     * `c` was changed to `[cC]` to replicate /i flag
     */
    cuid: /^[cC][^\s-]{8,}$/,
    cuid2: /^[0-9a-z]+$/,
    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
    /**
     * `a-z` was added to replicate /i flag
     */
    email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
    /**
     * Constructed a valid Unicode RegExp
     *
     * Lazily instantiate since this type of regex isn't supported
     * in all envs (e.g. React Native).
     *
     * See:
     * https://github.com/colinhacks/zod/issues/2433
     * Fix in Zod:
     * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
     */
    emoji: () => {
        if (emojiRegex === undefined) {
            emojiRegex = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
        }
        return emojiRegex;
    },
    /**
     * Unused
     */
    uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
    /**
     * Unused
     */
    ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
    /**
     * Unused
     */
    ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
    ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
    base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
    nanoid: /^[a-zA-Z0-9_-]{21}$/,
    jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,
};
function parseStringDef(def, refs) {
    const res = {
        type: "string",
    };
    if (def.checks) {
        for (const check of def.checks) {
            switch (check.kind) {
                case "min":
                    setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number"
                        ? Math.max(res.minLength, check.value)
                        : check.value, check.message, refs);
                    break;
                case "max":
                    setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number"
                        ? Math.min(res.maxLength, check.value)
                        : check.value, check.message, refs);
                    break;
                case "email":
                    switch (refs.emailStrategy) {
                        case "format:email":
                            addFormat(res, "email", check.message, refs);
                            break;
                        case "format:idn-email":
                            addFormat(res, "idn-email", check.message, refs);
                            break;
                        case "pattern:zod":
                            addPattern(res, zodPatterns.email, check.message, refs);
                            break;
                    }
                    break;
                case "url":
                    addFormat(res, "uri", check.message, refs);
                    break;
                case "uuid":
                    addFormat(res, "uuid", check.message, refs);
                    break;
                case "regex":
                    addPattern(res, check.regex, check.message, refs);
                    break;
                case "cuid":
                    addPattern(res, zodPatterns.cuid, check.message, refs);
                    break;
                case "cuid2":
                    addPattern(res, zodPatterns.cuid2, check.message, refs);
                    break;
                case "startsWith":
                    addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);
                    break;
                case "endsWith":
                    addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);
                    break;
                case "datetime":
                    addFormat(res, "date-time", check.message, refs);
                    break;
                case "date":
                    addFormat(res, "date", check.message, refs);
                    break;
                case "time":
                    addFormat(res, "time", check.message, refs);
                    break;
                case "duration":
                    addFormat(res, "duration", check.message, refs);
                    break;
                case "length":
                    setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number"
                        ? Math.max(res.minLength, check.value)
                        : check.value, check.message, refs);
                    setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number"
                        ? Math.min(res.maxLength, check.value)
                        : check.value, check.message, refs);
                    break;
                case "includes": {
                    addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);
                    break;
                }
                case "ip": {
                    if (check.version !== "v6") {
                        addFormat(res, "ipv4", check.message, refs);
                    }
                    if (check.version !== "v4") {
                        addFormat(res, "ipv6", check.message, refs);
                    }
                    break;
                }
                case "base64url":
                    addPattern(res, zodPatterns.base64url, check.message, refs);
                    break;
                case "jwt":
                    addPattern(res, zodPatterns.jwt, check.message, refs);
                    break;
                case "cidr": {
                    if (check.version !== "v6") {
                        addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);
                    }
                    if (check.version !== "v4") {
                        addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);
                    }
                    break;
                }
                case "emoji":
                    addPattern(res, zodPatterns.emoji(), check.message, refs);
                    break;
                case "ulid": {
                    addPattern(res, zodPatterns.ulid, check.message, refs);
                    break;
                }
                case "base64": {
                    switch (refs.base64Strategy) {
                        case "format:binary": {
                            addFormat(res, "binary", check.message, refs);
                            break;
                        }
                        case "contentEncoding:base64": {
                            setResponseValueAndErrors(res, "contentEncoding", "base64", check.message, refs);
                            break;
                        }
                        case "pattern:zod": {
                            addPattern(res, zodPatterns.base64, check.message, refs);
                            break;
                        }
                    }
                    break;
                }
                case "nanoid": {
                    addPattern(res, zodPatterns.nanoid, check.message, refs);
                }
            }
        }
    }
    return res;
}
function escapeLiteralCheckValue(literal, refs) {
    return refs.patternStrategy === "escape"
        ? escapeNonAlphaNumeric(literal)
        : literal;
}
const ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric(source) {
    let result = "";
    for (let i = 0; i < source.length; i++) {
        if (!ALPHA_NUMERIC.has(source[i])) {
            result += "\\";
        }
        result += source[i];
    }
    return result;
}
// Adds a "format" keyword to the schema. If a format exists, both formats will be joined in an allOf-node, along with subsequent ones.
function addFormat(schema, value, message, refs) {
    if (schema.format || schema.anyOf?.some((x) => x.format)) {
        if (!schema.anyOf) {
            schema.anyOf = [];
        }
        if (schema.format) {
            schema.anyOf.push({
                format: schema.format,
                ...(schema.errorMessage &&
                    refs.errorMessages && {
                    errorMessage: { format: schema.errorMessage.format },
                }),
            });
            delete schema.format;
            if (schema.errorMessage) {
                delete schema.errorMessage.format;
                if (Object.keys(schema.errorMessage).length === 0) {
                    delete schema.errorMessage;
                }
            }
        }
        schema.anyOf.push({
            format: value,
            ...(message &&
                refs.errorMessages && { errorMessage: { format: message } }),
        });
    }
    else {
        setResponseValueAndErrors(schema, "format", value, message, refs);
    }
}
// Adds a "pattern" keyword to the schema. If a pattern exists, both patterns will be joined in an allOf-node, along with subsequent ones.
function addPattern(schema, regex, message, refs) {
    if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {
        if (!schema.allOf) {
            schema.allOf = [];
        }
        if (schema.pattern) {
            schema.allOf.push({
                pattern: schema.pattern,
                ...(schema.errorMessage &&
                    refs.errorMessages && {
                    errorMessage: { pattern: schema.errorMessage.pattern },
                }),
            });
            delete schema.pattern;
            if (schema.errorMessage) {
                delete schema.errorMessage.pattern;
                if (Object.keys(schema.errorMessage).length === 0) {
                    delete schema.errorMessage;
                }
            }
        }
        schema.allOf.push({
            pattern: stringifyRegExpWithFlags(regex, refs),
            ...(message &&
                refs.errorMessages && { errorMessage: { pattern: message } }),
        });
    }
    else {
        setResponseValueAndErrors(schema, "pattern", stringifyRegExpWithFlags(regex, refs), message, refs);
    }
}
// Mutate z.string.regex() in a best attempt to accommodate for regex flags when applyRegexFlags is true
function stringifyRegExpWithFlags(regex, refs) {
    if (!refs.applyRegexFlags || !regex.flags) {
        return regex.source;
    }
    // Currently handled flags
    const flags = {
        i: regex.flags.includes("i"),
        m: regex.flags.includes("m"),
        s: regex.flags.includes("s"), // `.` matches newlines
    };
    // The general principle here is to step through each character, one at a time, applying mutations as flags require. We keep track when the current character is escaped, and when it's inside a group /like [this]/ or (also) a range like /[a-z]/. The following is fairly brittle imperative code; edit at your peril!
    const source = flags.i ? regex.source.toLowerCase() : regex.source;
    let pattern = "";
    let isEscaped = false;
    let inCharGroup = false;
    let inCharRange = false;
    for (let i = 0; i < source.length; i++) {
        if (isEscaped) {
            pattern += source[i];
            isEscaped = false;
            continue;
        }
        if (flags.i) {
            if (inCharGroup) {
                if (source[i].match(/[a-z]/)) {
                    if (inCharRange) {
                        pattern += source[i];
                        pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
                        inCharRange = false;
                    }
                    else if (source[i + 1] === "-" && source[i + 2]?.match(/[a-z]/)) {
                        pattern += source[i];
                        inCharRange = true;
                    }
                    else {
                        pattern += `${source[i]}${source[i].toUpperCase()}`;
                    }
                    continue;
                }
            }
            else if (source[i].match(/[a-z]/)) {
                pattern += `[${source[i]}${source[i].toUpperCase()}]`;
                continue;
            }
        }
        if (flags.m) {
            if (source[i] === "^") {
                pattern += `(^|(?<=[\r\n]))`;
                continue;
            }
            else if (source[i] === "$") {
                pattern += `($|(?=[\r\n]))`;
                continue;
            }
        }
        if (flags.s && source[i] === ".") {
            pattern += inCharGroup ? `${source[i]}\r\n` : `[${source[i]}\r\n]`;
            continue;
        }
        pattern += source[i];
        if (source[i] === "\\") {
            isEscaped = true;
        }
        else if (inCharGroup && source[i] === "]") {
            inCharGroup = false;
        }
        else if (!inCharGroup && source[i] === "[") {
            inCharGroup = true;
        }
    }
    return pattern;
}

function parseRecordDef(def, refs) {
    if (refs.target === "openAi") {
        console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
    }
    if (refs.target === "openApi3" &&
        def.keyType?._def.typeName === lib.ZodFirstPartyTypeKind.ZodEnum) {
        return {
            type: "object",
            required: def.keyType._def.values,
            properties: def.keyType._def.values.reduce((acc, key) => ({
                ...acc,
                [key]: parseDef(def.valueType._def, {
                    ...refs,
                    currentPath: [...refs.currentPath, "properties", key],
                }) ?? {},
            }), {}),
            additionalProperties: refs.rejectedAdditionalProperties,
        };
    }
    const schema = {
        type: "object",
        additionalProperties: parseDef(def.valueType._def, {
            ...refs,
            currentPath: [...refs.currentPath, "additionalProperties"],
        }) ?? refs.allowedAdditionalProperties,
    };
    if (refs.target === "openApi3") {
        return schema;
    }
    if (def.keyType?._def.typeName === lib.ZodFirstPartyTypeKind.ZodString &&
        def.keyType._def.checks?.length) {
        const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
        return {
            ...schema,
            propertyNames: keyType,
        };
    }
    else if (def.keyType?._def.typeName === lib.ZodFirstPartyTypeKind.ZodEnum) {
        return {
            ...schema,
            propertyNames: {
                enum: def.keyType._def.values,
            },
        };
    }
    else if (def.keyType?._def.typeName === lib.ZodFirstPartyTypeKind.ZodBranded &&
        def.keyType._def.type._def.typeName === lib.ZodFirstPartyTypeKind.ZodString &&
        def.keyType._def.type._def.checks?.length) {
        const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);
        return {
            ...schema,
            propertyNames: keyType,
        };
    }
    return schema;
}

function parseMapDef(def, refs) {
    if (refs.mapStrategy === "record") {
        return parseRecordDef(def, refs);
    }
    const keys = parseDef(def.keyType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", "items", "0"],
    }) || {};
    const values = parseDef(def.valueType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", "items", "1"],
    }) || {};
    return {
        type: "array",
        maxItems: 125,
        items: {
            type: "array",
            items: [keys, values],
            minItems: 2,
            maxItems: 2,
        },
    };
}

function parseNativeEnumDef(def) {
    const object = def.values;
    const actualKeys = Object.keys(def.values).filter((key) => {
        return typeof object[object[key]] !== "number";
    });
    const actualValues = actualKeys.map((key) => object[key]);
    const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
    return {
        type: parsedTypes.length === 1
            ? parsedTypes[0] === "string"
                ? "string"
                : "number"
            : ["string", "number"],
        enum: actualValues,
    };
}

function parseNeverDef() {
    return {
        not: {},
    };
}

function parseNullDef(refs) {
    return refs.target === "openApi3"
        ? {
            enum: ["null"],
            nullable: true,
        }
        : {
            type: "null",
        };
}

const primitiveMappings = {
    ZodString: "string",
    ZodNumber: "number",
    ZodBigInt: "integer",
    ZodBoolean: "boolean",
    ZodNull: "null",
};
function parseUnionDef(def, refs) {
    if (refs.target === "openApi3")
        return asAnyOf(def, refs);
    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
    // This blocks tries to look ahead a bit to produce nicer looking schemas with type array instead of anyOf.
    if (options.every((x) => x._def.typeName in primitiveMappings &&
        (!x._def.checks || !x._def.checks.length))) {
        // all types in union are primitive and lack checks, so might as well squash into {type: [...]}
        const types = options.reduce((types, x) => {
            const type = primitiveMappings[x._def.typeName]; //Can be safely casted due to row 43
            return type && !types.includes(type) ? [...types, type] : types;
        }, []);
        return {
            type: types.length > 1 ? types : types[0],
        };
    }
    else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
        // all options literals
        const types = options.reduce((acc, x) => {
            const type = typeof x._def.value;
            switch (type) {
                case "string":
                case "number":
                case "boolean":
                    return [...acc, type];
                case "bigint":
                    return [...acc, "integer"];
                case "object":
                    if (x._def.value === null)
                        return [...acc, "null"];
                case "symbol":
                case "undefined":
                case "function":
                default:
                    return acc;
            }
        }, []);
        if (types.length === options.length) {
            // all the literals are primitive, as far as null can be considered primitive
            const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
            return {
                type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
                enum: options.reduce((acc, x) => {
                    return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
                }, []),
            };
        }
    }
    else if (options.every((x) => x._def.typeName === "ZodEnum")) {
        return {
            type: "string",
            enum: options.reduce((acc, x) => [
                ...acc,
                ...x._def.values.filter((x) => !acc.includes(x)),
            ], []),
        };
    }
    return asAnyOf(def, refs);
}
const asAnyOf = (def, refs) => {
    const anyOf = (def.options instanceof Map
        ? Array.from(def.options.values())
        : def.options)
        .map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "anyOf", `${i}`],
    }))
        .filter((x) => !!x &&
        (!refs.strictUnions ||
            (typeof x === "object" && Object.keys(x).length > 0)));
    return anyOf.length ? { anyOf } : undefined;
};

function parseNullableDef(def, refs) {
    if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) &&
        (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
        if (refs.target === "openApi3") {
            return {
                type: primitiveMappings[def.innerType._def.typeName],
                nullable: true,
            };
        }
        return {
            type: [
                primitiveMappings[def.innerType._def.typeName],
                "null",
            ],
        };
    }
    if (refs.target === "openApi3") {
        const base = parseDef(def.innerType._def, {
            ...refs,
            currentPath: [...refs.currentPath],
        });
        if (base && "$ref" in base)
            return { allOf: [base], nullable: true };
        return base && { ...base, nullable: true };
    }
    const base = parseDef(def.innerType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "anyOf", "0"],
    });
    return base && { anyOf: [base, { type: "null" }] };
}

function parseNumberDef(def, refs) {
    const res = {
        type: "number",
    };
    if (!def.checks)
        return res;
    for (const check of def.checks) {
        switch (check.kind) {
            case "int":
                res.type = "integer";
                addErrorMessage(res, "type", check.message, refs);
                break;
            case "min":
                if (refs.target === "jsonSchema7") {
                    if (check.inclusive) {
                        setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
                    }
                    else {
                        setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
                    }
                }
                else {
                    if (!check.inclusive) {
                        res.exclusiveMinimum = true;
                    }
                    setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
                }
                break;
            case "max":
                if (refs.target === "jsonSchema7") {
                    if (check.inclusive) {
                        setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
                    }
                    else {
                        setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
                    }
                }
                else {
                    if (!check.inclusive) {
                        res.exclusiveMaximum = true;
                    }
                    setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
                }
                break;
            case "multipleOf":
                setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
                break;
        }
    }
    return res;
}

function parseObjectDef(def, refs) {
    const forceOptionalIntoNullable = refs.target === "openAi";
    const result = {
        type: "object",
        properties: {},
    };
    const required = [];
    const shape = def.shape();
    for (const propName in shape) {
        let propDef = shape[propName];
        if (propDef === undefined || propDef._def === undefined) {
            continue;
        }
        let propOptional = safeIsOptional(propDef);
        if (propOptional && forceOptionalIntoNullable) {
            if (propDef instanceof lib.ZodOptional) {
                propDef = propDef._def.innerType;
            }
            if (!propDef.isNullable()) {
                propDef = propDef.nullable();
            }
            propOptional = false;
        }
        const parsedDef = parseDef(propDef._def, {
            ...refs,
            currentPath: [...refs.currentPath, "properties", propName],
            propertyPath: [...refs.currentPath, "properties", propName],
        });
        if (parsedDef === undefined) {
            continue;
        }
        result.properties[propName] = parsedDef;
        if (!propOptional) {
            required.push(propName);
        }
    }
    if (required.length) {
        result.required = required;
    }
    const additionalProperties = decideAdditionalProperties(def, refs);
    if (additionalProperties !== undefined) {
        result.additionalProperties = additionalProperties;
    }
    return result;
}
function decideAdditionalProperties(def, refs) {
    if (def.catchall._def.typeName !== "ZodNever") {
        return parseDef(def.catchall._def, {
            ...refs,
            currentPath: [...refs.currentPath, "additionalProperties"],
        });
    }
    switch (def.unknownKeys) {
        case "passthrough":
            return refs.allowedAdditionalProperties;
        case "strict":
            return refs.rejectedAdditionalProperties;
        case "strip":
            return refs.removeAdditionalStrategy === "strict"
                ? refs.allowedAdditionalProperties
                : refs.rejectedAdditionalProperties;
    }
}
function safeIsOptional(schema) {
    try {
        return schema.isOptional();
    }
    catch {
        return true;
    }
}

const parseOptionalDef = (def, refs) => {
    if (refs.currentPath.toString() === refs.propertyPath?.toString()) {
        return parseDef(def.innerType._def, refs);
    }
    const innerSchema = parseDef(def.innerType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "anyOf", "1"],
    });
    return innerSchema
        ? {
            anyOf: [
                {
                    not: {},
                },
                innerSchema,
            ],
        }
        : {};
};

const parsePipelineDef = (def, refs) => {
    if (refs.pipeStrategy === "input") {
        return parseDef(def.in._def, refs);
    }
    else if (refs.pipeStrategy === "output") {
        return parseDef(def.out._def, refs);
    }
    const a = parseDef(def.in._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", "0"],
    });
    const b = parseDef(def.out._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"],
    });
    return {
        allOf: [a, b].filter((x) => x !== undefined),
    };
};

function parsePromiseDef(def, refs) {
    return parseDef(def.type._def, refs);
}

function parseSetDef(def, refs) {
    const items = parseDef(def.valueType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items"],
    });
    const schema = {
        type: "array",
        uniqueItems: true,
        items,
    };
    if (def.minSize) {
        setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
    }
    if (def.maxSize) {
        setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
    }
    return schema;
}

function parseTupleDef(def, refs) {
    if (def.rest) {
        return {
            type: "array",
            minItems: def.items.length,
            items: def.items
                .map((x, i) => parseDef(x._def, {
                ...refs,
                currentPath: [...refs.currentPath, "items", `${i}`],
            }))
                .reduce((acc, x) => (x === undefined ? acc : [...acc, x]), []),
            additionalItems: parseDef(def.rest._def, {
                ...refs,
                currentPath: [...refs.currentPath, "additionalItems"],
            }),
        };
    }
    else {
        return {
            type: "array",
            minItems: def.items.length,
            maxItems: def.items.length,
            items: def.items
                .map((x, i) => parseDef(x._def, {
                ...refs,
                currentPath: [...refs.currentPath, "items", `${i}`],
            }))
                .reduce((acc, x) => (x === undefined ? acc : [...acc, x]), []),
        };
    }
}

function parseUndefinedDef() {
    return {
        not: {},
    };
}

function parseUnknownDef() {
    return {};
}

const parseReadonlyDef = (def, refs) => {
    return parseDef(def.innerType._def, refs);
};

const selectParser$1 = (def, typeName, refs) => {
    switch (typeName) {
        case lib.ZodFirstPartyTypeKind.ZodString:
            return parseStringDef(def, refs);
        case lib.ZodFirstPartyTypeKind.ZodNumber:
            return parseNumberDef(def, refs);
        case lib.ZodFirstPartyTypeKind.ZodObject:
            return parseObjectDef(def, refs);
        case lib.ZodFirstPartyTypeKind.ZodBigInt:
            return parseBigintDef(def, refs);
        case lib.ZodFirstPartyTypeKind.ZodBoolean:
            return parseBooleanDef();
        case lib.ZodFirstPartyTypeKind.ZodDate:
            return parseDateDef(def, refs);
        case lib.ZodFirstPartyTypeKind.ZodUndefined:
            return parseUndefinedDef();
        case lib.ZodFirstPartyTypeKind.ZodNull:
            return parseNullDef(refs);
        case lib.ZodFirstPartyTypeKind.ZodArray:
            return parseArrayDef(def, refs);
        case lib.ZodFirstPartyTypeKind.ZodUnion:
        case lib.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
            return parseUnionDef(def, refs);
        case lib.ZodFirstPartyTypeKind.ZodIntersection:
            return parseIntersectionDef(def, refs);
        case lib.ZodFirstPartyTypeKind.ZodTuple:
            return parseTupleDef(def, refs);
        case lib.ZodFirstPartyTypeKind.ZodRecord:
            return parseRecordDef(def, refs);
        case lib.ZodFirstPartyTypeKind.ZodLiteral:
            return parseLiteralDef(def, refs);
        case lib.ZodFirstPartyTypeKind.ZodEnum:
            return parseEnumDef(def);
        case lib.ZodFirstPartyTypeKind.ZodNativeEnum:
            return parseNativeEnumDef(def);
        case lib.ZodFirstPartyTypeKind.ZodNullable:
            return parseNullableDef(def, refs);
        case lib.ZodFirstPartyTypeKind.ZodOptional:
            return parseOptionalDef(def, refs);
        case lib.ZodFirstPartyTypeKind.ZodMap:
            return parseMapDef(def, refs);
        case lib.ZodFirstPartyTypeKind.ZodSet:
            return parseSetDef(def, refs);
        case lib.ZodFirstPartyTypeKind.ZodLazy:
            return () => def.getter()._def;
        case lib.ZodFirstPartyTypeKind.ZodPromise:
            return parsePromiseDef(def, refs);
        case lib.ZodFirstPartyTypeKind.ZodNaN:
        case lib.ZodFirstPartyTypeKind.ZodNever:
            return parseNeverDef();
        case lib.ZodFirstPartyTypeKind.ZodEffects:
            return parseEffectsDef(def, refs);
        case lib.ZodFirstPartyTypeKind.ZodAny:
            return parseAnyDef();
        case lib.ZodFirstPartyTypeKind.ZodUnknown:
            return parseUnknownDef();
        case lib.ZodFirstPartyTypeKind.ZodDefault:
            return parseDefaultDef(def, refs);
        case lib.ZodFirstPartyTypeKind.ZodBranded:
            return parseBrandedDef(def, refs);
        case lib.ZodFirstPartyTypeKind.ZodReadonly:
            return parseReadonlyDef(def, refs);
        case lib.ZodFirstPartyTypeKind.ZodCatch:
            return parseCatchDef(def, refs);
        case lib.ZodFirstPartyTypeKind.ZodPipeline:
            return parsePipelineDef(def, refs);
        case lib.ZodFirstPartyTypeKind.ZodFunction:
        case lib.ZodFirstPartyTypeKind.ZodVoid:
        case lib.ZodFirstPartyTypeKind.ZodSymbol:
            return undefined;
        default:
            /* c8 ignore next */
            return ((_) => undefined)();
    }
};

function parseDef(def, refs, forceResolution = false) {
    const seenItem = refs.seen.get(def);
    if (refs.override) {
        const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
        if (overrideResult !== ignoreOverride) {
            return overrideResult;
        }
    }
    if (seenItem && !forceResolution) {
        const seenSchema = get$ref(seenItem, refs);
        if (seenSchema !== undefined) {
            return seenSchema;
        }
    }
    const newItem = { def, path: refs.currentPath, jsonSchema: undefined };
    refs.seen.set(def, newItem);
    const jsonSchemaOrGetter = selectParser$1(def, def.typeName, refs);
    // If the return was a function, then the inner definition needs to be extracted before a call to parseDef (recursive)
    const jsonSchema = typeof jsonSchemaOrGetter === "function"
        ? parseDef(jsonSchemaOrGetter(), refs)
        : jsonSchemaOrGetter;
    if (jsonSchema) {
        addMeta(def, refs, jsonSchema);
    }
    if (refs.postProcess) {
        const postProcessResult = refs.postProcess(jsonSchema, def, refs);
        newItem.jsonSchema = jsonSchema;
        return postProcessResult;
    }
    newItem.jsonSchema = jsonSchema;
    return jsonSchema;
}
const get$ref = (item, refs) => {
    switch (refs.$refStrategy) {
        case "root":
            return { $ref: item.path.join("/") };
        case "relative":
            return { $ref: getRelativePath(refs.currentPath, item.path) };
        case "none":
        case "seen": {
            if (item.path.length < refs.currentPath.length &&
                item.path.every((value, index) => refs.currentPath[index] === value)) {
                console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
                return {};
            }
            return refs.$refStrategy === "seen" ? {} : undefined;
        }
    }
};
const getRelativePath = (pathA, pathB) => {
    let i = 0;
    for (; i < pathA.length && i < pathB.length; i++) {
        if (pathA[i] !== pathB[i])
            break;
    }
    return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};
const addMeta = (def, refs, jsonSchema) => {
    if (def.description) {
        jsonSchema.description = def.description;
        if (refs.markdownDescription) {
            jsonSchema.markdownDescription = def.description;
        }
    }
    return jsonSchema;
};

const zodToJsonSchema = (schema, options) => {
    const refs = getRefs(options);
    const definitions = typeof options === "object" && options.definitions
        ? Object.entries(options.definitions).reduce((acc, [name, schema]) => ({
            ...acc,
            [name]: parseDef(schema._def, {
                ...refs,
                currentPath: [...refs.basePath, refs.definitionPath, name],
            }, true) ?? {},
        }), {})
        : undefined;
    const name = typeof options === "string"
        ? options
        : options?.nameStrategy === "title"
            ? undefined
            : options?.name;
    const main = parseDef(schema._def, name === undefined
        ? refs
        : {
            ...refs,
            currentPath: [...refs.basePath, refs.definitionPath, name],
        }, false) ?? {};
    const title = typeof options === "object" &&
        options.name !== undefined &&
        options.nameStrategy === "title"
        ? options.name
        : undefined;
    if (title !== undefined) {
        main.title = title;
    }
    const combined = name === undefined
        ? definitions
            ? {
                ...main,
                [refs.definitionPath]: definitions,
            }
            : main
        : {
            $ref: [
                ...(refs.$refStrategy === "relative" ? [] : refs.basePath),
                refs.definitionPath,
                name,
            ].join("/"),
            [refs.definitionPath]: {
                ...definitions,
                [name]: main,
            },
        };
    if (refs.target === "jsonSchema7") {
        combined.$schema = "http://json-schema.org/draft-07/schema#";
    }
    else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi") {
        combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
    }
    if (refs.target === "openAi" &&
        ("anyOf" in combined ||
            "oneOf" in combined ||
            "allOf" in combined ||
            ("type" in combined && Array.isArray(combined.type)))) {
        console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
    }
    return combined;
};

// src/index.ts

// src/fix-json.ts
function fixJson(input) {
  const stack = ["ROOT"];
  let lastValidIndex = -1;
  let literalStart = null;
  function processValueStart(char, i, swapState) {
    {
      switch (char) {
        case '"': {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_STRING");
          break;
        }
        case "f":
        case "t":
        case "n": {
          lastValidIndex = i;
          literalStart = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_LITERAL");
          break;
        }
        case "-": {
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_NUMBER");
          break;
        }
        case "{": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_OBJECT_START");
          break;
        }
        case "[": {
          lastValidIndex = i;
          stack.pop();
          stack.push(swapState);
          stack.push("INSIDE_ARRAY_START");
          break;
        }
      }
    }
  }
  function processAfterObjectValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_OBJECT_AFTER_COMMA");
        break;
      }
      case "}": {
        lastValidIndex = i;
        stack.pop();
        break;
      }
    }
  }
  function processAfterArrayValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_ARRAY_AFTER_COMMA");
        break;
      }
      case "]": {
        lastValidIndex = i;
        stack.pop();
        break;
      }
    }
  }
  for (let i = 0; i < input.length; i++) {
    const char = input[i];
    const currentState = stack[stack.length - 1];
    switch (currentState) {
      case "ROOT":
        processValueStart(char, i, "FINISH");
        break;
      case "INSIDE_OBJECT_START": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
          case "}": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_COMMA": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_KEY": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_AFTER_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_KEY": {
        switch (char) {
          case ":": {
            stack.pop();
            stack.push("INSIDE_OBJECT_BEFORE_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_BEFORE_VALUE": {
        processValueStart(char, i, "INSIDE_OBJECT_AFTER_VALUE");
        break;
      }
      case "INSIDE_OBJECT_AFTER_VALUE": {
        processAfterObjectValue(char, i);
        break;
      }
      case "INSIDE_STRING": {
        switch (char) {
          case '"': {
            stack.pop();
            lastValidIndex = i;
            break;
          }
          case "\\": {
            stack.push("INSIDE_STRING_ESCAPE");
            break;
          }
          default: {
            lastValidIndex = i;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_START": {
        switch (char) {
          case "]": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_VALUE": {
        switch (char) {
          case ",": {
            stack.pop();
            stack.push("INSIDE_ARRAY_AFTER_COMMA");
            break;
          }
          case "]": {
            lastValidIndex = i;
            stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_COMMA": {
        processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
        break;
      }
      case "INSIDE_STRING_ESCAPE": {
        stack.pop();
        lastValidIndex = i;
        break;
      }
      case "INSIDE_NUMBER": {
        switch (char) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            lastValidIndex = i;
            break;
          }
          case "e":
          case "E":
          case "-":
          case ".": {
            break;
          }
          case ",": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "}": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "]": {
            stack.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            break;
          }
          default: {
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, i + 1);
        if (!"false".startsWith(partialLiteral) && !"true".startsWith(partialLiteral) && !"null".startsWith(partialLiteral)) {
          stack.pop();
          if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
            processAfterObjectValue(char, i);
          } else if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
            processAfterArrayValue(char, i);
          }
        } else {
          lastValidIndex = i;
        }
        break;
      }
    }
  }
  let result = input.slice(0, lastValidIndex + 1);
  for (let i = stack.length - 1; i >= 0; i--) {
    const state = stack[i];
    switch (state) {
      case "INSIDE_STRING": {
        result += '"';
        break;
      }
      case "INSIDE_OBJECT_KEY":
      case "INSIDE_OBJECT_AFTER_KEY":
      case "INSIDE_OBJECT_AFTER_COMMA":
      case "INSIDE_OBJECT_START":
      case "INSIDE_OBJECT_BEFORE_VALUE":
      case "INSIDE_OBJECT_AFTER_VALUE": {
        result += "}";
        break;
      }
      case "INSIDE_ARRAY_START":
      case "INSIDE_ARRAY_AFTER_COMMA":
      case "INSIDE_ARRAY_AFTER_VALUE": {
        result += "]";
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, input.length);
        if ("true".startsWith(partialLiteral)) {
          result += "true".slice(partialLiteral.length);
        } else if ("false".startsWith(partialLiteral)) {
          result += "false".slice(partialLiteral.length);
        } else if ("null".startsWith(partialLiteral)) {
          result += "null".slice(partialLiteral.length);
        }
      }
    }
  }
  return result;
}

// src/parse-partial-json.ts
function parsePartialJson(jsonText) {
  if (jsonText === void 0) {
    return { value: void 0, state: "undefined-input" };
  }
  let result = safeParseJSON({ text: jsonText });
  if (result.success) {
    return { value: result.value, state: "successful-parse" };
  }
  result = safeParseJSON({ text: fixJson(jsonText) });
  if (result.success) {
    return { value: result.value, state: "repaired-parse" };
  }
  return { value: void 0, state: "failed-parse" };
}

// src/data-stream-parts.ts
var textStreamPart2 = {
  code: "0",
  name: "text",
  parse: (value) => {
    if (typeof value !== "string") {
      throw new Error('"text" parts expect a string value.');
    }
    return { type: "text", value };
  }
};
var dataStreamPart = {
  code: "2",
  name: "data",
  parse: (value) => {
    if (!Array.isArray(value)) {
      throw new Error('"data" parts expect an array value.');
    }
    return { type: "data", value };
  }
};
var errorStreamPart2 = {
  code: "3",
  name: "error",
  parse: (value) => {
    if (typeof value !== "string") {
      throw new Error('"error" parts expect a string value.');
    }
    return { type: "error", value };
  }
};
var messageAnnotationsStreamPart = {
  code: "8",
  name: "message_annotations",
  parse: (value) => {
    if (!Array.isArray(value)) {
      throw new Error('"message_annotations" parts expect an array value.');
    }
    return { type: "message_annotations", value };
  }
};
var toolCallStreamPart = {
  code: "9",
  name: "tool_call",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("toolName" in value) || typeof value.toolName !== "string" || !("args" in value) || typeof value.args !== "object") {
      throw new Error(
        '"tool_call" parts expect an object with a "toolCallId", "toolName", and "args" property.'
      );
    }
    return {
      type: "tool_call",
      value
    };
  }
};
var toolResultStreamPart = {
  code: "a",
  name: "tool_result",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("result" in value)) {
      throw new Error(
        '"tool_result" parts expect an object with a "toolCallId" and a "result" property.'
      );
    }
    return {
      type: "tool_result",
      value
    };
  }
};
var toolCallStreamingStartStreamPart = {
  code: "b",
  name: "tool_call_streaming_start",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("toolName" in value) || typeof value.toolName !== "string") {
      throw new Error(
        '"tool_call_streaming_start" parts expect an object with a "toolCallId" and "toolName" property.'
      );
    }
    return {
      type: "tool_call_streaming_start",
      value
    };
  }
};
var toolCallDeltaStreamPart = {
  code: "c",
  name: "tool_call_delta",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("argsTextDelta" in value) || typeof value.argsTextDelta !== "string") {
      throw new Error(
        '"tool_call_delta" parts expect an object with a "toolCallId" and "argsTextDelta" property.'
      );
    }
    return {
      type: "tool_call_delta",
      value
    };
  }
};
var finishMessageStreamPart = {
  code: "d",
  name: "finish_message",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("finishReason" in value) || typeof value.finishReason !== "string") {
      throw new Error(
        '"finish_message" parts expect an object with a "finishReason" property.'
      );
    }
    const result = {
      finishReason: value.finishReason
    };
    if ("usage" in value && value.usage != null && typeof value.usage === "object" && "promptTokens" in value.usage && "completionTokens" in value.usage) {
      result.usage = {
        promptTokens: typeof value.usage.promptTokens === "number" ? value.usage.promptTokens : Number.NaN,
        completionTokens: typeof value.usage.completionTokens === "number" ? value.usage.completionTokens : Number.NaN
      };
    }
    return {
      type: "finish_message",
      value: result
    };
  }
};
var finishStepStreamPart = {
  code: "e",
  name: "finish_step",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("finishReason" in value) || typeof value.finishReason !== "string") {
      throw new Error(
        '"finish_step" parts expect an object with a "finishReason" property.'
      );
    }
    const result = {
      finishReason: value.finishReason,
      isContinued: false
    };
    if ("usage" in value && value.usage != null && typeof value.usage === "object" && "promptTokens" in value.usage && "completionTokens" in value.usage) {
      result.usage = {
        promptTokens: typeof value.usage.promptTokens === "number" ? value.usage.promptTokens : Number.NaN,
        completionTokens: typeof value.usage.completionTokens === "number" ? value.usage.completionTokens : Number.NaN
      };
    }
    if ("isContinued" in value && typeof value.isContinued === "boolean") {
      result.isContinued = value.isContinued;
    }
    return {
      type: "finish_step",
      value: result
    };
  }
};
var startStepStreamPart = {
  code: "f",
  name: "start_step",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("messageId" in value) || typeof value.messageId !== "string") {
      throw new Error(
        '"start_step" parts expect an object with an "id" property.'
      );
    }
    return {
      type: "start_step",
      value: {
        messageId: value.messageId
      }
    };
  }
};
var reasoningStreamPart = {
  code: "g",
  name: "reasoning",
  parse: (value) => {
    if (typeof value !== "string") {
      throw new Error('"reasoning" parts expect a string value.');
    }
    return { type: "reasoning", value };
  }
};
var sourcePart = {
  code: "h",
  name: "source",
  parse: (value) => {
    if (value == null || typeof value !== "object") {
      throw new Error('"source" parts expect a Source object.');
    }
    return {
      type: "source",
      value
    };
  }
};
var redactedReasoningStreamPart = {
  code: "i",
  name: "redacted_reasoning",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("data" in value) || typeof value.data !== "string") {
      throw new Error(
        '"redacted_reasoning" parts expect an object with a "data" property.'
      );
    }
    return { type: "redacted_reasoning", value: { data: value.data } };
  }
};
var reasoningSignatureStreamPart = {
  code: "j",
  name: "reasoning_signature",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("signature" in value) || typeof value.signature !== "string") {
      throw new Error(
        '"reasoning_signature" parts expect an object with a "signature" property.'
      );
    }
    return {
      type: "reasoning_signature",
      value: { signature: value.signature }
    };
  }
};
var fileStreamPart = {
  code: "k",
  name: "file",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("data" in value) || typeof value.data !== "string" || !("mimeType" in value) || typeof value.mimeType !== "string") {
      throw new Error(
        '"file" parts expect an object with a "data" and "mimeType" property.'
      );
    }
    return { type: "file", value };
  }
};
var dataStreamParts = [
  textStreamPart2,
  dataStreamPart,
  errorStreamPart2,
  messageAnnotationsStreamPart,
  toolCallStreamPart,
  toolResultStreamPart,
  toolCallStreamingStartStreamPart,
  toolCallDeltaStreamPart,
  finishMessageStreamPart,
  finishStepStreamPart,
  startStepStreamPart,
  reasoningStreamPart,
  sourcePart,
  redactedReasoningStreamPart,
  reasoningSignatureStreamPart,
  fileStreamPart
];
Object.fromEntries(
  dataStreamParts.map((part) => [part.code, part])
);
Object.fromEntries(
  dataStreamParts.map((part) => [part.name, part.code])
);
function formatDataStreamPart(type, value) {
  const streamPart = dataStreamParts.find((part) => part.name === type);
  if (!streamPart) {
    throw new Error(`Invalid stream part type: ${type}`);
  }
  return `${streamPart.code}:${JSON.stringify(value)}
`;
}

// src/is-deep-equal-data.ts
function isDeepEqualData(obj1, obj2) {
  if (obj1 === obj2)
    return true;
  if (obj1 == null || obj2 == null)
    return false;
  if (typeof obj1 !== "object" && typeof obj2 !== "object")
    return obj1 === obj2;
  if (obj1.constructor !== obj2.constructor)
    return false;
  if (obj1 instanceof Date && obj2 instanceof Date) {
    return obj1.getTime() === obj2.getTime();
  }
  if (Array.isArray(obj1)) {
    if (obj1.length !== obj2.length)
      return false;
    for (let i = 0; i < obj1.length; i++) {
      if (!isDeepEqualData(obj1[i], obj2[i]))
        return false;
    }
    return true;
  }
  const keys1 = Object.keys(obj1);
  const keys2 = Object.keys(obj2);
  if (keys1.length !== keys2.length)
    return false;
  for (const key of keys1) {
    if (!keys2.includes(key))
      return false;
    if (!isDeepEqualData(obj1[key], obj2[key]))
      return false;
  }
  return true;
}
function zodSchema(zodSchema2, options) {
  var _a;
  const useReferences = (_a = void 0 ) != null ? _a : false;
  return jsonSchema(
    zodToJsonSchema(zodSchema2, {
      $refStrategy: useReferences ? "root" : "none",
      target: "jsonSchema7"
      // note: openai mode breaks various gemini conversions
    }),
    {
      validate: (value) => {
        const result = zodSchema2.safeParse(value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }
    }
  );
}

// src/schema.ts
var schemaSymbol = Symbol.for("vercel.ai.schema");
function jsonSchema(jsonSchema2, {
  validate
} = {}) {
  return {
    [schemaSymbol]: true,
    _type: void 0,
    // should never be used directly
    [validatorSymbol]: true,
    jsonSchema: jsonSchema2,
    validate
  };
}
function isSchema(value) {
  return typeof value === "object" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && "jsonSchema" in value && "validate" in value;
}
function asSchema(schema) {
  return isSchema(schema) ? schema : zodSchema(schema);
}

var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name17 in all)
    __defProp(target, name17, { get: all[name17], enumerable: true });
};

// core/util/prepare-response-headers.ts
function prepareResponseHeaders(headers, {
  contentType,
  dataStreamVersion
}) {
  const responseHeaders = new Headers(headers != null ? headers : {});
  if (!responseHeaders.has("Content-Type")) {
    responseHeaders.set("Content-Type", contentType);
  }
  if (dataStreamVersion !== void 0) {
    responseHeaders.set("X-Vercel-AI-Data-Stream", dataStreamVersion);
  }
  return responseHeaders;
}

// core/util/prepare-outgoing-http-headers.ts
function prepareOutgoingHttpHeaders(headers, {
  contentType,
  dataStreamVersion
}) {
  const outgoingHeaders = {};
  if (headers != null) {
    for (const [key, value] of Object.entries(headers)) {
      outgoingHeaders[key] = value;
    }
  }
  if (outgoingHeaders["Content-Type"] == null) {
    outgoingHeaders["Content-Type"] = contentType;
  }
  if (dataStreamVersion !== void 0) {
    outgoingHeaders["X-Vercel-AI-Data-Stream"] = dataStreamVersion;
  }
  return outgoingHeaders;
}

// core/util/write-to-server-response.ts
function writeToServerResponse({
  response,
  status,
  statusText,
  headers,
  stream
}) {
  response.writeHead(status != null ? status : 200, statusText, headers);
  const reader = stream.getReader();
  const read = async () => {
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done)
          break;
        response.write(value);
      }
    } catch (error) {
      throw error;
    } finally {
      response.end();
    }
  };
  read();
}
var name = "AI_InvalidArgumentError";
var marker = `vercel.ai.error.${name}`;
var symbol = Symbol.for(marker);
var _a$2;
var InvalidArgumentError = class extends AISDKError {
  constructor({
    parameter,
    value,
    message
  }) {
    super({
      name,
      message: `Invalid argument for parameter ${parameter}: ${message}`
    });
    this[_a$2] = true;
    this.parameter = parameter;
    this.value = value;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker);
  }
};
_a$2 = symbol;
var name2 = "AI_RetryError";
var marker2 = `vercel.ai.error.${name2}`;
var symbol2 = Symbol.for(marker2);
var _a2;
var RetryError = class extends AISDKError {
  constructor({
    message,
    reason,
    errors
  }) {
    super({ name: name2, message });
    this[_a2] = true;
    this.reason = reason;
    this.errors = errors;
    this.lastError = errors[errors.length - 1];
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker2);
  }
};
_a2 = symbol2;

// util/retry-with-exponential-backoff.ts
var retryWithExponentialBackoff = ({
  maxRetries = 2,
  initialDelayInMs = 2e3,
  backoffFactor = 2
} = {}) => async (f) => _retryWithExponentialBackoff(f, {
  maxRetries,
  delayInMs: initialDelayInMs,
  backoffFactor
});
async function _retryWithExponentialBackoff(f, {
  maxRetries,
  delayInMs,
  backoffFactor
}, errors = []) {
  try {
    return await f();
  } catch (error) {
    if (isAbortError(error)) {
      throw error;
    }
    if (maxRetries === 0) {
      throw error;
    }
    const errorMessage = getErrorMessage(error);
    const newErrors = [...errors, error];
    const tryNumber = newErrors.length;
    if (tryNumber > maxRetries) {
      throw new RetryError({
        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,
        reason: "maxRetriesExceeded",
        errors: newErrors
      });
    }
    if (error instanceof Error && APICallError.isInstance(error) && error.isRetryable === true && tryNumber <= maxRetries) {
      await delay$1(delayInMs);
      return _retryWithExponentialBackoff(
        f,
        { maxRetries, delayInMs: backoffFactor * delayInMs, backoffFactor },
        newErrors
      );
    }
    if (tryNumber === 1) {
      throw error;
    }
    throw new RetryError({
      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,
      reason: "errorNotRetryable",
      errors: newErrors
    });
  }
}

// core/prompt/prepare-retries.ts
function prepareRetries({
  maxRetries
}) {
  if (maxRetries != null) {
    if (!Number.isInteger(maxRetries)) {
      throw new InvalidArgumentError({
        parameter: "maxRetries",
        value: maxRetries,
        message: "maxRetries must be an integer"
      });
    }
    if (maxRetries < 0) {
      throw new InvalidArgumentError({
        parameter: "maxRetries",
        value: maxRetries,
        message: "maxRetries must be >= 0"
      });
    }
  }
  const maxRetriesResult = maxRetries != null ? maxRetries : 2;
  return {
    maxRetries: maxRetriesResult,
    retry: retryWithExponentialBackoff({ maxRetries: maxRetriesResult })
  };
}

// core/telemetry/assemble-operation-name.ts
function assembleOperationName({
  operationId,
  telemetry
}) {
  return {
    // standardized operation and resource name:
    "operation.name": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : ""}`,
    "resource.name": telemetry == null ? void 0 : telemetry.functionId,
    // detailed, AI SDK specific data:
    "ai.operationId": operationId,
    "ai.telemetry.functionId": telemetry == null ? void 0 : telemetry.functionId
  };
}

// core/telemetry/get-base-telemetry-attributes.ts
function getBaseTelemetryAttributes({
  model,
  settings,
  telemetry,
  headers
}) {
  var _a17;
  return {
    "ai.model.provider": model.provider,
    "ai.model.id": model.modelId,
    // settings:
    ...Object.entries(settings).reduce((attributes, [key, value]) => {
      attributes[`ai.settings.${key}`] = value;
      return attributes;
    }, {}),
    // add metadata as attributes:
    ...Object.entries((_a17 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a17 : {}).reduce(
      (attributes, [key, value]) => {
        attributes[`ai.telemetry.metadata.${key}`] = value;
        return attributes;
      },
      {}
    ),
    // request headers
    ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value]) => {
      if (value !== void 0) {
        attributes[`ai.request.headers.${key}`] = value;
      }
      return attributes;
    }, {})
  };
}

// core/telemetry/noop-tracer.ts
var noopTracer = {
  startSpan() {
    return noopSpan;
  },
  startActiveSpan(name17, arg1, arg2, arg3) {
    if (typeof arg1 === "function") {
      return arg1(noopSpan);
    }
    if (typeof arg2 === "function") {
      return arg2(noopSpan);
    }
    if (typeof arg3 === "function") {
      return arg3(noopSpan);
    }
  }
};
var noopSpan = {
  spanContext() {
    return noopSpanContext;
  },
  setAttribute() {
    return this;
  },
  setAttributes() {
    return this;
  },
  addEvent() {
    return this;
  },
  addLink() {
    return this;
  },
  addLinks() {
    return this;
  },
  setStatus() {
    return this;
  },
  updateName() {
    return this;
  },
  end() {
    return this;
  },
  isRecording() {
    return false;
  },
  recordException() {
    return this;
  }
};
var noopSpanContext = {
  traceId: "",
  spanId: "",
  traceFlags: 0
};

// core/telemetry/get-tracer.ts
function getTracer({
  isEnabled = false,
  tracer
} = {}) {
  if (!isEnabled) {
    return noopTracer;
  }
  if (tracer) {
    return tracer;
  }
  return trace.getTracer("ai");
}
function recordSpan({
  name: name17,
  tracer,
  attributes,
  fn,
  endWhenDone = true
}) {
  return tracer.startActiveSpan(name17, { attributes }, async (span) => {
    try {
      const result = await fn(span);
      if (endWhenDone) {
        span.end();
      }
      return result;
    } catch (error) {
      try {
        if (error instanceof Error) {
          span.recordException({
            name: error.name,
            message: error.message,
            stack: error.stack
          });
          span.setStatus({
            code: SpanStatusCode.ERROR,
            message: error.message
          });
        } else {
          span.setStatus({ code: SpanStatusCode.ERROR });
        }
      } finally {
        span.end();
      }
      throw error;
    }
  });
}

// core/telemetry/select-telemetry-attributes.ts
function selectTelemetryAttributes({
  telemetry,
  attributes
}) {
  if ((telemetry == null ? void 0 : telemetry.isEnabled) !== true) {
    return {};
  }
  return Object.entries(attributes).reduce((attributes2, [key, value]) => {
    if (value === void 0) {
      return attributes2;
    }
    if (typeof value === "object" && "input" in value && typeof value.input === "function") {
      if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {
        return attributes2;
      }
      const result = value.input();
      return result === void 0 ? attributes2 : { ...attributes2, [key]: result };
    }
    if (typeof value === "object" && "output" in value && typeof value.output === "function") {
      if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {
        return attributes2;
      }
      const result = value.output();
      return result === void 0 ? attributes2 : { ...attributes2, [key]: result };
    }
    return { ...attributes2, [key]: value };
  }, {});
}
var DefaultGeneratedFile = class {
  constructor({
    data,
    mimeType
  }) {
    const isUint8Array = data instanceof Uint8Array;
    this.base64Data = isUint8Array ? void 0 : data;
    this.uint8ArrayData = isUint8Array ? data : void 0;
    this.mimeType = mimeType;
  }
  // lazy conversion with caching to avoid unnecessary conversion overhead:
  get base64() {
    if (this.base64Data == null) {
      this.base64Data = convertUint8ArrayToBase64(this.uint8ArrayData);
    }
    return this.base64Data;
  }
  // lazy conversion with caching to avoid unnecessary conversion overhead:
  get uint8Array() {
    if (this.uint8ArrayData == null) {
      this.uint8ArrayData = convertBase64ToUint8Array(this.base64Data);
    }
    return this.uint8ArrayData;
  }
};
var DefaultGeneratedFileWithType = class extends DefaultGeneratedFile {
  constructor(options) {
    super(options);
    this.type = "file";
  }
};
var imageMimeTypeSignatures = [
  {
    mimeType: "image/gif",
    bytesPrefix: [71, 73, 70],
    base64Prefix: "R0lG"
  },
  {
    mimeType: "image/png",
    bytesPrefix: [137, 80, 78, 71],
    base64Prefix: "iVBORw"
  },
  {
    mimeType: "image/jpeg",
    bytesPrefix: [255, 216],
    base64Prefix: "/9j/"
  },
  {
    mimeType: "image/webp",
    bytesPrefix: [82, 73, 70, 70],
    base64Prefix: "UklGRg"
  },
  {
    mimeType: "image/bmp",
    bytesPrefix: [66, 77],
    base64Prefix: "Qk"
  },
  {
    mimeType: "image/tiff",
    bytesPrefix: [73, 73, 42, 0],
    base64Prefix: "SUkqAA"
  },
  {
    mimeType: "image/tiff",
    bytesPrefix: [77, 77, 0, 42],
    base64Prefix: "TU0AKg"
  },
  {
    mimeType: "image/avif",
    bytesPrefix: [
      0,
      0,
      0,
      32,
      102,
      116,
      121,
      112,
      97,
      118,
      105,
      102
    ],
    base64Prefix: "AAAAIGZ0eXBhdmlm"
  },
  {
    mimeType: "image/heic",
    bytesPrefix: [
      0,
      0,
      0,
      32,
      102,
      116,
      121,
      112,
      104,
      101,
      105,
      99
    ],
    base64Prefix: "AAAAIGZ0eXBoZWlj"
  }
];
var stripID3 = (data) => {
  const bytes = typeof data === "string" ? convertBase64ToUint8Array(data) : data;
  const id3Size = (bytes[6] & 127) << 21 | (bytes[7] & 127) << 14 | (bytes[8] & 127) << 7 | bytes[9] & 127;
  return bytes.slice(id3Size + 10);
};
function stripID3TagsIfPresent(data) {
  const hasId3 = typeof data === "string" && data.startsWith("SUQz") || typeof data !== "string" && data.length > 10 && data[0] === 73 && // 'I'
  data[1] === 68 && // 'D'
  data[2] === 51;
  return hasId3 ? stripID3(data) : data;
}
function detectMimeType({
  data,
  signatures
}) {
  const processedData = stripID3TagsIfPresent(data);
  for (const signature of signatures) {
    if (typeof processedData === "string" ? processedData.startsWith(signature.base64Prefix) : processedData.length >= signature.bytesPrefix.length && signature.bytesPrefix.every(
      (byte, index) => processedData[index] === byte
    )) {
      return signature.mimeType;
    }
  }
  return void 0;
}
var name4 = "AI_NoObjectGeneratedError";
var marker4 = `vercel.ai.error.${name4}`;
var symbol4 = Symbol.for(marker4);
var _a4;
var NoObjectGeneratedError = class extends AISDKError {
  constructor({
    message = "No object generated.",
    cause,
    text: text2,
    response,
    usage,
    finishReason
  }) {
    super({ name: name4, message, cause });
    this[_a4] = true;
    this.text = text2;
    this.response = response;
    this.usage = usage;
    this.finishReason = finishReason;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker4);
  }
};
_a4 = symbol4;
var name5 = "AI_DownloadError";
var marker5 = `vercel.ai.error.${name5}`;
var symbol5 = Symbol.for(marker5);
var _a5;
var DownloadError = class extends AISDKError {
  constructor({
    url,
    statusCode,
    statusText,
    cause,
    message = cause == null ? `Failed to download ${url}: ${statusCode} ${statusText}` : `Failed to download ${url}: ${cause}`
  }) {
    super({ name: name5, message, cause });
    this[_a5] = true;
    this.url = url;
    this.statusCode = statusCode;
    this.statusText = statusText;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker5);
  }
};
_a5 = symbol5;

// util/download.ts
async function download({ url }) {
  var _a17;
  const urlText = url.toString();
  try {
    const response = await fetch(urlText);
    if (!response.ok) {
      throw new DownloadError({
        url: urlText,
        statusCode: response.status,
        statusText: response.statusText
      });
    }
    return {
      data: new Uint8Array(await response.arrayBuffer()),
      mimeType: (_a17 = response.headers.get("content-type")) != null ? _a17 : void 0
    };
  } catch (error) {
    if (DownloadError.isInstance(error)) {
      throw error;
    }
    throw new DownloadError({ url: urlText, cause: error });
  }
}
var name6 = "AI_InvalidDataContentError";
var marker6 = `vercel.ai.error.${name6}`;
var symbol6 = Symbol.for(marker6);
var _a6;
var InvalidDataContentError = class extends AISDKError {
  constructor({
    content,
    cause,
    message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.`
  }) {
    super({ name: name6, message, cause });
    this[_a6] = true;
    this.content = content;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker6);
  }
};
_a6 = symbol6;
var dataContentSchema = lib.z.union([
  lib.z.string(),
  lib.z.instanceof(Uint8Array),
  lib.z.instanceof(ArrayBuffer),
  lib.z.custom(
    // Buffer might not be available in some environments such as CloudFlare:
    (value) => {
      var _a17, _b;
      return (_b = (_a17 = globalThis.Buffer) == null ? void 0 : _a17.isBuffer(value)) != null ? _b : false;
    },
    { message: "Must be a Buffer" }
  )
]);
function convertDataContentToBase64String(content) {
  if (typeof content === "string") {
    return content;
  }
  if (content instanceof ArrayBuffer) {
    return convertUint8ArrayToBase64(new Uint8Array(content));
  }
  return convertUint8ArrayToBase64(content);
}
function convertDataContentToUint8Array(content) {
  if (content instanceof Uint8Array) {
    return content;
  }
  if (typeof content === "string") {
    try {
      return convertBase64ToUint8Array(content);
    } catch (error) {
      throw new InvalidDataContentError({
        message: "Invalid data content. Content string is not a base64-encoded media.",
        content,
        cause: error
      });
    }
  }
  if (content instanceof ArrayBuffer) {
    return new Uint8Array(content);
  }
  throw new InvalidDataContentError({ content });
}
function convertUint8ArrayToText(uint8Array) {
  try {
    return new TextDecoder().decode(uint8Array);
  } catch (error) {
    throw new Error("Error decoding Uint8Array to text");
  }
}
var name7 = "AI_InvalidMessageRoleError";
var marker7 = `vercel.ai.error.${name7}`;
var symbol7 = Symbol.for(marker7);
var _a7;
var InvalidMessageRoleError = class extends AISDKError {
  constructor({
    role,
    message = `Invalid message role: '${role}'. Must be one of: "system", "user", "assistant", "tool".`
  }) {
    super({ name: name7, message });
    this[_a7] = true;
    this.role = role;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker7);
  }
};
_a7 = symbol7;

// core/prompt/split-data-url.ts
function splitDataUrl(dataUrl) {
  try {
    const [header, base64Content] = dataUrl.split(",");
    return {
      mimeType: header.split(";")[0].split(":")[1],
      base64Content
    };
  } catch (error) {
    return {
      mimeType: void 0,
      base64Content: void 0
    };
  }
}

// core/prompt/convert-to-language-model-prompt.ts
async function convertToLanguageModelPrompt({
  prompt,
  modelSupportsImageUrls = true,
  modelSupportsUrl = () => false,
  downloadImplementation = download
}) {
  const downloadedAssets = await downloadAssets(
    prompt.messages,
    downloadImplementation,
    modelSupportsImageUrls,
    modelSupportsUrl
  );
  return [
    ...prompt.system != null ? [{ role: "system", content: prompt.system }] : [],
    ...prompt.messages.map(
      (message) => convertToLanguageModelMessage(message, downloadedAssets)
    )
  ];
}
function convertToLanguageModelMessage(message, downloadedAssets) {
  var _a17, _b, _c, _d, _e, _f;
  const role = message.role;
  switch (role) {
    case "system": {
      return {
        role: "system",
        content: message.content,
        providerMetadata: (_a17 = message.providerOptions) != null ? _a17 : message.experimental_providerMetadata
      };
    }
    case "user": {
      if (typeof message.content === "string") {
        return {
          role: "user",
          content: [{ type: "text", text: message.content }],
          providerMetadata: (_b = message.providerOptions) != null ? _b : message.experimental_providerMetadata
        };
      }
      return {
        role: "user",
        content: message.content.map((part) => convertPartToLanguageModelPart(part, downloadedAssets)).filter((part) => part.type !== "text" || part.text !== ""),
        providerMetadata: (_c = message.providerOptions) != null ? _c : message.experimental_providerMetadata
      };
    }
    case "assistant": {
      if (typeof message.content === "string") {
        return {
          role: "assistant",
          content: [{ type: "text", text: message.content }],
          providerMetadata: (_d = message.providerOptions) != null ? _d : message.experimental_providerMetadata
        };
      }
      return {
        role: "assistant",
        content: message.content.filter(
          // remove empty text parts:
          (part) => part.type !== "text" || part.text !== ""
        ).map((part) => {
          var _a18;
          const providerOptions = (_a18 = part.providerOptions) != null ? _a18 : part.experimental_providerMetadata;
          switch (part.type) {
            case "file": {
              return {
                type: "file",
                data: part.data instanceof URL ? part.data : convertDataContentToBase64String(part.data),
                filename: part.filename,
                mimeType: part.mimeType,
                providerMetadata: providerOptions
              };
            }
            case "reasoning": {
              return {
                type: "reasoning",
                text: part.text,
                signature: part.signature,
                providerMetadata: providerOptions
              };
            }
            case "redacted-reasoning": {
              return {
                type: "redacted-reasoning",
                data: part.data,
                providerMetadata: providerOptions
              };
            }
            case "text": {
              return {
                type: "text",
                text: part.text,
                providerMetadata: providerOptions
              };
            }
            case "tool-call": {
              return {
                type: "tool-call",
                toolCallId: part.toolCallId,
                toolName: part.toolName,
                args: part.args,
                providerMetadata: providerOptions
              };
            }
          }
        }),
        providerMetadata: (_e = message.providerOptions) != null ? _e : message.experimental_providerMetadata
      };
    }
    case "tool": {
      return {
        role: "tool",
        content: message.content.map((part) => {
          var _a18;
          return {
            type: "tool-result",
            toolCallId: part.toolCallId,
            toolName: part.toolName,
            result: part.result,
            content: part.experimental_content,
            isError: part.isError,
            providerMetadata: (_a18 = part.providerOptions) != null ? _a18 : part.experimental_providerMetadata
          };
        }),
        providerMetadata: (_f = message.providerOptions) != null ? _f : message.experimental_providerMetadata
      };
    }
    default: {
      const _exhaustiveCheck = role;
      throw new InvalidMessageRoleError({ role: _exhaustiveCheck });
    }
  }
}
async function downloadAssets(messages, downloadImplementation, modelSupportsImageUrls, modelSupportsUrl) {
  const urls = messages.filter((message) => message.role === "user").map((message) => message.content).filter(
    (content) => Array.isArray(content)
  ).flat().filter(
    (part) => part.type === "image" || part.type === "file"
  ).filter(
    (part) => !(part.type === "image" && modelSupportsImageUrls === true)
  ).map((part) => part.type === "image" ? part.image : part.data).map(
    (part) => (
      // support string urls:
      typeof part === "string" && (part.startsWith("http:") || part.startsWith("https:")) ? new URL(part) : part
    )
  ).filter((image) => image instanceof URL).filter((url) => !modelSupportsUrl(url));
  const downloadedImages = await Promise.all(
    urls.map(async (url) => ({
      url,
      data: await downloadImplementation({ url })
    }))
  );
  return Object.fromEntries(
    downloadedImages.map(({ url, data }) => [url.toString(), data])
  );
}
function convertPartToLanguageModelPart(part, downloadedAssets) {
  var _a17, _b, _c, _d;
  if (part.type === "text") {
    return {
      type: "text",
      text: part.text,
      providerMetadata: (_a17 = part.providerOptions) != null ? _a17 : part.experimental_providerMetadata
    };
  }
  let mimeType = part.mimeType;
  let data;
  let content;
  let normalizedData;
  const type = part.type;
  switch (type) {
    case "image":
      data = part.image;
      break;
    case "file":
      data = part.data;
      break;
    default:
      throw new Error(`Unsupported part type: ${type}`);
  }
  try {
    content = typeof data === "string" ? new URL(data) : data;
  } catch (error) {
    content = data;
  }
  if (content instanceof URL) {
    if (content.protocol === "data:") {
      const { mimeType: dataUrlMimeType, base64Content } = splitDataUrl(
        content.toString()
      );
      if (dataUrlMimeType == null || base64Content == null) {
        throw new Error(`Invalid data URL format in part ${type}`);
      }
      mimeType = dataUrlMimeType;
      normalizedData = convertDataContentToUint8Array(base64Content);
    } else {
      const downloadedFile = downloadedAssets[content.toString()];
      if (downloadedFile) {
        normalizedData = downloadedFile.data;
        mimeType != null ? mimeType : mimeType = downloadedFile.mimeType;
      } else {
        normalizedData = content;
      }
    }
  } else {
    normalizedData = convertDataContentToUint8Array(content);
  }
  switch (type) {
    case "image": {
      if (normalizedData instanceof Uint8Array) {
        mimeType = (_b = detectMimeType({
          data: normalizedData,
          signatures: imageMimeTypeSignatures
        })) != null ? _b : mimeType;
      }
      return {
        type: "image",
        image: normalizedData,
        mimeType,
        providerMetadata: (_c = part.providerOptions) != null ? _c : part.experimental_providerMetadata
      };
    }
    case "file": {
      if (mimeType == null) {
        throw new Error(`Mime type is missing for file part`);
      }
      return {
        type: "file",
        data: normalizedData instanceof Uint8Array ? convertDataContentToBase64String(normalizedData) : normalizedData,
        filename: part.filename,
        mimeType,
        providerMetadata: (_d = part.providerOptions) != null ? _d : part.experimental_providerMetadata
      };
    }
  }
}

// core/prompt/prepare-call-settings.ts
function prepareCallSettings({
  maxTokens,
  temperature,
  topP,
  topK,
  presencePenalty,
  frequencyPenalty,
  stopSequences,
  seed
}) {
  if (maxTokens != null) {
    if (!Number.isInteger(maxTokens)) {
      throw new InvalidArgumentError({
        parameter: "maxTokens",
        value: maxTokens,
        message: "maxTokens must be an integer"
      });
    }
    if (maxTokens < 1) {
      throw new InvalidArgumentError({
        parameter: "maxTokens",
        value: maxTokens,
        message: "maxTokens must be >= 1"
      });
    }
  }
  if (temperature != null) {
    if (typeof temperature !== "number") {
      throw new InvalidArgumentError({
        parameter: "temperature",
        value: temperature,
        message: "temperature must be a number"
      });
    }
  }
  if (topP != null) {
    if (typeof topP !== "number") {
      throw new InvalidArgumentError({
        parameter: "topP",
        value: topP,
        message: "topP must be a number"
      });
    }
  }
  if (topK != null) {
    if (typeof topK !== "number") {
      throw new InvalidArgumentError({
        parameter: "topK",
        value: topK,
        message: "topK must be a number"
      });
    }
  }
  if (presencePenalty != null) {
    if (typeof presencePenalty !== "number") {
      throw new InvalidArgumentError({
        parameter: "presencePenalty",
        value: presencePenalty,
        message: "presencePenalty must be a number"
      });
    }
  }
  if (frequencyPenalty != null) {
    if (typeof frequencyPenalty !== "number") {
      throw new InvalidArgumentError({
        parameter: "frequencyPenalty",
        value: frequencyPenalty,
        message: "frequencyPenalty must be a number"
      });
    }
  }
  if (seed != null) {
    if (!Number.isInteger(seed)) {
      throw new InvalidArgumentError({
        parameter: "seed",
        value: seed,
        message: "seed must be an integer"
      });
    }
  }
  return {
    maxTokens,
    // TODO v5 remove default 0 for temperature
    temperature: temperature != null ? temperature : 0,
    topP,
    topK,
    presencePenalty,
    frequencyPenalty,
    stopSequences: stopSequences != null && stopSequences.length > 0 ? stopSequences : void 0,
    seed
  };
}

// core/prompt/attachments-to-parts.ts
function attachmentsToParts(attachments) {
  var _a17, _b, _c;
  const parts = [];
  for (const attachment of attachments) {
    let url;
    try {
      url = new URL(attachment.url);
    } catch (error) {
      throw new Error(`Invalid URL: ${attachment.url}`);
    }
    switch (url.protocol) {
      case "http:":
      case "https:": {
        if ((_a17 = attachment.contentType) == null ? void 0 : _a17.startsWith("image/")) {
          parts.push({ type: "image", image: url });
        } else {
          if (!attachment.contentType) {
            throw new Error(
              "If the attachment is not an image, it must specify a content type"
            );
          }
          parts.push({
            type: "file",
            data: url,
            mimeType: attachment.contentType
          });
        }
        break;
      }
      case "data:": {
        let header;
        let base64Content;
        let mimeType;
        try {
          [header, base64Content] = attachment.url.split(",");
          mimeType = header.split(";")[0].split(":")[1];
        } catch (error) {
          throw new Error(`Error processing data URL: ${attachment.url}`);
        }
        if (mimeType == null || base64Content == null) {
          throw new Error(`Invalid data URL format: ${attachment.url}`);
        }
        if ((_b = attachment.contentType) == null ? void 0 : _b.startsWith("image/")) {
          parts.push({
            type: "image",
            image: convertDataContentToUint8Array(base64Content)
          });
        } else if ((_c = attachment.contentType) == null ? void 0 : _c.startsWith("text/")) {
          parts.push({
            type: "text",
            text: convertUint8ArrayToText(
              convertDataContentToUint8Array(base64Content)
            )
          });
        } else {
          if (!attachment.contentType) {
            throw new Error(
              "If the attachment is not an image or text, it must specify a content type"
            );
          }
          parts.push({
            type: "file",
            data: base64Content,
            mimeType: attachment.contentType
          });
        }
        break;
      }
      default: {
        throw new Error(`Unsupported URL protocol: ${url.protocol}`);
      }
    }
  }
  return parts;
}
var name8 = "AI_MessageConversionError";
var marker8 = `vercel.ai.error.${name8}`;
var symbol8 = Symbol.for(marker8);
var _a8;
var MessageConversionError = class extends AISDKError {
  constructor({
    originalMessage,
    message
  }) {
    super({ name: name8, message });
    this[_a8] = true;
    this.originalMessage = originalMessage;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker8);
  }
};
_a8 = symbol8;

// core/prompt/convert-to-core-messages.ts
function convertToCoreMessages(messages, options) {
  var _a17, _b;
  const tools = (_a17 = options == null ? void 0 : options.tools) != null ? _a17 : {};
  const coreMessages = [];
  for (let i = 0; i < messages.length; i++) {
    const message = messages[i];
    const isLastMessage = i === messages.length - 1;
    const { role, content, experimental_attachments } = message;
    switch (role) {
      case "system": {
        coreMessages.push({
          role: "system",
          content
        });
        break;
      }
      case "user": {
        if (message.parts == null) {
          coreMessages.push({
            role: "user",
            content: experimental_attachments ? [
              { type: "text", text: content },
              ...attachmentsToParts(experimental_attachments)
            ] : content
          });
        } else {
          const textParts = message.parts.filter((part) => part.type === "text").map((part) => ({
            type: "text",
            text: part.text
          }));
          coreMessages.push({
            role: "user",
            content: experimental_attachments ? [...textParts, ...attachmentsToParts(experimental_attachments)] : textParts
          });
        }
        break;
      }
      case "assistant": {
        if (message.parts != null) {
          let processBlock2 = function() {
            const content2 = [];
            for (const part of block) {
              switch (part.type) {
                case "file":
                case "text": {
                  content2.push(part);
                  break;
                }
                case "reasoning": {
                  for (const detail of part.details) {
                    switch (detail.type) {
                      case "text":
                        content2.push({
                          type: "reasoning",
                          text: detail.text,
                          signature: detail.signature
                        });
                        break;
                      case "redacted":
                        content2.push({
                          type: "redacted-reasoning",
                          data: detail.data
                        });
                        break;
                    }
                  }
                  break;
                }
                case "tool-invocation":
                  content2.push({
                    type: "tool-call",
                    toolCallId: part.toolInvocation.toolCallId,
                    toolName: part.toolInvocation.toolName,
                    args: part.toolInvocation.args
                  });
                  break;
                default: {
                  const _exhaustiveCheck = part;
                  throw new Error(`Unsupported part: ${_exhaustiveCheck}`);
                }
              }
            }
            coreMessages.push({
              role: "assistant",
              content: content2
            });
            const stepInvocations = block.filter(
              (part) => part.type === "tool-invocation"
            ).map((part) => part.toolInvocation);
            if (stepInvocations.length > 0) {
              coreMessages.push({
                role: "tool",
                content: stepInvocations.map(
                  (toolInvocation) => {
                    if (!("result" in toolInvocation)) {
                      throw new MessageConversionError({
                        originalMessage: message,
                        message: "ToolInvocation must have a result: " + JSON.stringify(toolInvocation)
                      });
                    }
                    const { toolCallId, toolName, result } = toolInvocation;
                    const tool2 = tools[toolName];
                    return (tool2 == null ? void 0 : tool2.experimental_toToolResultContent) != null ? {
                      type: "tool-result",
                      toolCallId,
                      toolName,
                      result: tool2.experimental_toToolResultContent(result),
                      experimental_content: tool2.experimental_toToolResultContent(result)
                    } : {
                      type: "tool-result",
                      toolCallId,
                      toolName,
                      result
                    };
                  }
                )
              });
            }
            block = [];
            blockHasToolInvocations = false;
            currentStep++;
          };
          let currentStep = 0;
          let blockHasToolInvocations = false;
          let block = [];
          for (const part of message.parts) {
            switch (part.type) {
              case "text": {
                if (blockHasToolInvocations) {
                  processBlock2();
                }
                block.push(part);
                break;
              }
              case "file":
              case "reasoning": {
                block.push(part);
                break;
              }
              case "tool-invocation": {
                if (((_b = part.toolInvocation.step) != null ? _b : 0) !== currentStep) {
                  processBlock2();
                }
                block.push(part);
                blockHasToolInvocations = true;
                break;
              }
            }
          }
          processBlock2();
          break;
        }
        const toolInvocations = message.toolInvocations;
        if (toolInvocations == null || toolInvocations.length === 0) {
          coreMessages.push({ role: "assistant", content });
          break;
        }
        const maxStep = toolInvocations.reduce((max, toolInvocation) => {
          var _a18;
          return Math.max(max, (_a18 = toolInvocation.step) != null ? _a18 : 0);
        }, 0);
        for (let i2 = 0; i2 <= maxStep; i2++) {
          const stepInvocations = toolInvocations.filter(
            (toolInvocation) => {
              var _a18;
              return ((_a18 = toolInvocation.step) != null ? _a18 : 0) === i2;
            }
          );
          if (stepInvocations.length === 0) {
            continue;
          }
          coreMessages.push({
            role: "assistant",
            content: [
              ...isLastMessage && content && i2 === 0 ? [{ type: "text", text: content }] : [],
              ...stepInvocations.map(
                ({ toolCallId, toolName, args }) => ({
                  type: "tool-call",
                  toolCallId,
                  toolName,
                  args
                })
              )
            ]
          });
          coreMessages.push({
            role: "tool",
            content: stepInvocations.map((toolInvocation) => {
              if (!("result" in toolInvocation)) {
                throw new MessageConversionError({
                  originalMessage: message,
                  message: "ToolInvocation must have a result: " + JSON.stringify(toolInvocation)
                });
              }
              const { toolCallId, toolName, result } = toolInvocation;
              const tool2 = tools[toolName];
              return (tool2 == null ? void 0 : tool2.experimental_toToolResultContent) != null ? {
                type: "tool-result",
                toolCallId,
                toolName,
                result: tool2.experimental_toToolResultContent(result),
                experimental_content: tool2.experimental_toToolResultContent(result)
              } : {
                type: "tool-result",
                toolCallId,
                toolName,
                result
              };
            })
          });
        }
        if (content && !isLastMessage) {
          coreMessages.push({ role: "assistant", content });
        }
        break;
      }
      case "data": {
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new MessageConversionError({
          originalMessage: message,
          message: `Unsupported role: ${_exhaustiveCheck}`
        });
      }
    }
  }
  return coreMessages;
}
var jsonValueSchema = lib.z.lazy(
  () => lib.z.union([
    lib.z.null(),
    lib.z.string(),
    lib.z.number(),
    lib.z.boolean(),
    lib.z.record(lib.z.string(), jsonValueSchema),
    lib.z.array(jsonValueSchema)
  ])
);

// core/types/provider-metadata.ts
var providerMetadataSchema = lib.z.record(
  lib.z.string(),
  lib.z.record(lib.z.string(), jsonValueSchema)
);
var toolResultContentSchema = lib.z.array(
  lib.z.union([
    lib.z.object({ type: lib.z.literal("text"), text: lib.z.string() }),
    lib.z.object({
      type: lib.z.literal("image"),
      data: lib.z.string(),
      mimeType: lib.z.string().optional()
    })
  ])
);

// core/prompt/content-part.ts
var textPartSchema = lib.z.object({
  type: lib.z.literal("text"),
  text: lib.z.string(),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var imagePartSchema = lib.z.object({
  type: lib.z.literal("image"),
  image: lib.z.union([dataContentSchema, lib.z.instanceof(URL)]),
  mimeType: lib.z.string().optional(),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var filePartSchema = lib.z.object({
  type: lib.z.literal("file"),
  data: lib.z.union([dataContentSchema, lib.z.instanceof(URL)]),
  filename: lib.z.string().optional(),
  mimeType: lib.z.string(),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var reasoningPartSchema = lib.z.object({
  type: lib.z.literal("reasoning"),
  text: lib.z.string(),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var redactedReasoningPartSchema = lib.z.object({
  type: lib.z.literal("redacted-reasoning"),
  data: lib.z.string(),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var toolCallPartSchema = lib.z.object({
  type: lib.z.literal("tool-call"),
  toolCallId: lib.z.string(),
  toolName: lib.z.string(),
  args: lib.z.unknown(),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var toolResultPartSchema = lib.z.object({
  type: lib.z.literal("tool-result"),
  toolCallId: lib.z.string(),
  toolName: lib.z.string(),
  result: lib.z.unknown(),
  content: toolResultContentSchema.optional(),
  isError: lib.z.boolean().optional(),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});

// core/prompt/message.ts
var coreSystemMessageSchema = lib.z.object({
  role: lib.z.literal("system"),
  content: lib.z.string(),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var coreUserMessageSchema = lib.z.object({
  role: lib.z.literal("user"),
  content: lib.z.union([
    lib.z.string(),
    lib.z.array(lib.z.union([textPartSchema, imagePartSchema, filePartSchema]))
  ]),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var coreAssistantMessageSchema = lib.z.object({
  role: lib.z.literal("assistant"),
  content: lib.z.union([
    lib.z.string(),
    lib.z.array(
      lib.z.union([
        textPartSchema,
        filePartSchema,
        reasoningPartSchema,
        redactedReasoningPartSchema,
        toolCallPartSchema
      ])
    )
  ]),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var coreToolMessageSchema = lib.z.object({
  role: lib.z.literal("tool"),
  content: lib.z.array(toolResultPartSchema),
  providerOptions: providerMetadataSchema.optional(),
  experimental_providerMetadata: providerMetadataSchema.optional()
});
var coreMessageSchema = lib.z.union([
  coreSystemMessageSchema,
  coreUserMessageSchema,
  coreAssistantMessageSchema,
  coreToolMessageSchema
]);

// core/prompt/standardize-prompt.ts
function standardizePrompt({
  prompt,
  tools
}) {
  if (prompt.prompt == null && prompt.messages == null) {
    throw new InvalidPromptError({
      prompt,
      message: "prompt or messages must be defined"
    });
  }
  if (prompt.prompt != null && prompt.messages != null) {
    throw new InvalidPromptError({
      prompt,
      message: "prompt and messages cannot be defined at the same time"
    });
  }
  if (prompt.system != null && typeof prompt.system !== "string") {
    throw new InvalidPromptError({
      prompt,
      message: "system must be a string"
    });
  }
  if (prompt.prompt != null) {
    if (typeof prompt.prompt !== "string") {
      throw new InvalidPromptError({
        prompt,
        message: "prompt must be a string"
      });
    }
    return {
      type: "prompt",
      system: prompt.system,
      messages: [
        {
          role: "user",
          content: prompt.prompt
        }
      ]
    };
  }
  if (prompt.messages != null) {
    const promptType = detectPromptType(prompt.messages);
    const messages = promptType === "ui-messages" ? convertToCoreMessages(prompt.messages, {
      tools
    }) : prompt.messages;
    if (messages.length === 0) {
      throw new InvalidPromptError({
        prompt,
        message: "messages must not be empty"
      });
    }
    const validationResult = safeValidateTypes({
      value: messages,
      schema: lib.z.array(coreMessageSchema)
    });
    if (!validationResult.success) {
      throw new InvalidPromptError({
        prompt,
        message: [
          "message must be a CoreMessage or a UI message",
          `Validation error: ${validationResult.error.message}`
        ].join("\n"),
        cause: validationResult.error
      });
    }
    return {
      type: "messages",
      messages,
      system: prompt.system
    };
  }
  throw new Error("unreachable");
}
function detectPromptType(prompt) {
  if (!Array.isArray(prompt)) {
    throw new InvalidPromptError({
      prompt,
      message: [
        "messages must be an array of CoreMessage or UIMessage",
        `Received non-array value: ${JSON.stringify(prompt)}`
      ].join("\n"),
      cause: prompt
    });
  }
  if (prompt.length === 0) {
    return "messages";
  }
  const characteristics = prompt.map(detectSingleMessageCharacteristics$1);
  if (characteristics.some((c) => c === "has-ui-specific-parts")) {
    return "ui-messages";
  }
  const nonMessageIndex = characteristics.findIndex(
    (c) => c !== "has-core-specific-parts" && c !== "message"
  );
  if (nonMessageIndex === -1) {
    return "messages";
  }
  throw new InvalidPromptError({
    prompt,
    message: [
      "messages must be an array of CoreMessage or UIMessage",
      `Received message of type: "${characteristics[nonMessageIndex]}" at index ${nonMessageIndex}`,
      `messages[${nonMessageIndex}]: ${JSON.stringify(prompt[nonMessageIndex])}`
    ].join("\n"),
    cause: prompt
  });
}
function detectSingleMessageCharacteristics$1(message) {
  if (typeof message === "object" && message !== null && (message.role === "function" || // UI-only role
  message.role === "data" || // UI-only role
  "toolInvocations" in message || // UI-specific field
  "parts" in message || // UI-specific field
  "experimental_attachments" in message)) {
    return "has-ui-specific-parts";
  } else if (typeof message === "object" && message !== null && "content" in message && (Array.isArray(message.content) || // Core messages can have array content
  "experimental_providerMetadata" in message || "providerOptions" in message)) {
    return "has-core-specific-parts";
  } else if (typeof message === "object" && message !== null && "role" in message && "content" in message && typeof message.content === "string" && ["system", "user", "assistant", "tool"].includes(message.role)) {
    return "message";
  } else {
    return "other";
  }
}

// core/types/usage.ts
function calculateLanguageModelUsage({
  promptTokens,
  completionTokens
}) {
  return {
    promptTokens,
    completionTokens,
    totalTokens: promptTokens + completionTokens
  };
}
function addLanguageModelUsage(usage1, usage2) {
  return {
    promptTokens: usage1.promptTokens + usage2.promptTokens,
    completionTokens: usage1.completionTokens + usage2.completionTokens,
    totalTokens: usage1.totalTokens + usage2.totalTokens
  };
}

// core/generate-object/inject-json-instruction.ts
var DEFAULT_SCHEMA_PREFIX = "JSON schema:";
var DEFAULT_SCHEMA_SUFFIX = "You MUST answer with a JSON object that matches the JSON schema above.";
var DEFAULT_GENERIC_SUFFIX = "You MUST answer with JSON.";
function injectJsonInstruction({
  prompt,
  schema,
  schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX : void 0,
  schemaSuffix = schema != null ? DEFAULT_SCHEMA_SUFFIX : DEFAULT_GENERIC_SUFFIX
}) {
  return [
    prompt != null && prompt.length > 0 ? prompt : void 0,
    prompt != null && prompt.length > 0 ? "" : void 0,
    // add a newline if prompt is not null
    schemaPrefix,
    schema != null ? JSON.stringify(schema) : void 0,
    schemaSuffix
  ].filter((line) => line != null).join("\n");
}

// core/util/async-iterable-stream.ts
function createAsyncIterableStream(source) {
  const stream = source.pipeThrough(new TransformStream());
  stream[Symbol.asyncIterator] = () => {
    const reader = stream.getReader();
    return {
      async next() {
        const { done, value } = await reader.read();
        return done ? { done: true, value: void 0 } : { done: false, value };
      }
    };
  };
  return stream;
}

// core/generate-object/output-strategy.ts
var noSchemaOutputStrategy = {
  type: "no-schema",
  jsonSchema: void 0,
  validatePartialResult({ value, textDelta }) {
    return { success: true, value: { partial: value, textDelta } };
  },
  validateFinalResult(value, context) {
    return value === void 0 ? {
      success: false,
      error: new NoObjectGeneratedError({
        message: "No object generated: response did not match schema.",
        text: context.text,
        response: context.response,
        usage: context.usage,
        finishReason: context.finishReason
      })
    } : { success: true, value };
  },
  createElementStream() {
    throw new UnsupportedFunctionalityError({
      functionality: "element streams in no-schema mode"
    });
  }
};
var objectOutputStrategy = (schema) => ({
  type: "object",
  jsonSchema: schema.jsonSchema,
  validatePartialResult({ value, textDelta }) {
    return {
      success: true,
      value: {
        // Note: currently no validation of partial results:
        partial: value,
        textDelta
      }
    };
  },
  validateFinalResult(value) {
    return safeValidateTypes({ value, schema });
  },
  createElementStream() {
    throw new UnsupportedFunctionalityError({
      functionality: "element streams in object mode"
    });
  }
});
var arrayOutputStrategy = (schema) => {
  const { $schema, ...itemSchema } = schema.jsonSchema;
  return {
    type: "enum",
    // wrap in object that contains array of elements, since most LLMs will not
    // be able to generate an array directly:
    // possible future optimization: use arrays directly when model supports grammar-guided generation
    jsonSchema: {
      $schema: "http://json-schema.org/draft-07/schema#",
      type: "object",
      properties: {
        elements: { type: "array", items: itemSchema }
      },
      required: ["elements"],
      additionalProperties: false
    },
    validatePartialResult({ value, latestObject, isFirstDelta, isFinalDelta }) {
      var _a17;
      if (!isJSONObject(value) || !isJSONArray(value.elements)) {
        return {
          success: false,
          error: new TypeValidationError({
            value,
            cause: "value must be an object that contains an array of elements"
          })
        };
      }
      const inputArray = value.elements;
      const resultArray = [];
      for (let i = 0; i < inputArray.length; i++) {
        const element = inputArray[i];
        const result = safeValidateTypes({ value: element, schema });
        if (i === inputArray.length - 1 && !isFinalDelta) {
          continue;
        }
        if (!result.success) {
          return result;
        }
        resultArray.push(result.value);
      }
      const publishedElementCount = (_a17 = latestObject == null ? void 0 : latestObject.length) != null ? _a17 : 0;
      let textDelta = "";
      if (isFirstDelta) {
        textDelta += "[";
      }
      if (publishedElementCount > 0) {
        textDelta += ",";
      }
      textDelta += resultArray.slice(publishedElementCount).map((element) => JSON.stringify(element)).join(",");
      if (isFinalDelta) {
        textDelta += "]";
      }
      return {
        success: true,
        value: {
          partial: resultArray,
          textDelta
        }
      };
    },
    validateFinalResult(value) {
      if (!isJSONObject(value) || !isJSONArray(value.elements)) {
        return {
          success: false,
          error: new TypeValidationError({
            value,
            cause: "value must be an object that contains an array of elements"
          })
        };
      }
      const inputArray = value.elements;
      for (const element of inputArray) {
        const result = safeValidateTypes({ value: element, schema });
        if (!result.success) {
          return result;
        }
      }
      return { success: true, value: inputArray };
    },
    createElementStream(originalStream) {
      let publishedElements = 0;
      return createAsyncIterableStream(
        originalStream.pipeThrough(
          new TransformStream({
            transform(chunk, controller) {
              switch (chunk.type) {
                case "object": {
                  const array = chunk.object;
                  for (; publishedElements < array.length; publishedElements++) {
                    controller.enqueue(array[publishedElements]);
                  }
                  break;
                }
                case "text-delta":
                case "finish":
                case "error":
                  break;
                default: {
                  const _exhaustiveCheck = chunk;
                  throw new Error(
                    `Unsupported chunk type: ${_exhaustiveCheck}`
                  );
                }
              }
            }
          })
        )
      );
    }
  };
};
var enumOutputStrategy = (enumValues) => {
  return {
    type: "enum",
    // wrap in object that contains result, since most LLMs will not
    // be able to generate an enum value directly:
    // possible future optimization: use enums directly when model supports top-level enums
    jsonSchema: {
      $schema: "http://json-schema.org/draft-07/schema#",
      type: "object",
      properties: {
        result: { type: "string", enum: enumValues }
      },
      required: ["result"],
      additionalProperties: false
    },
    validateFinalResult(value) {
      if (!isJSONObject(value) || typeof value.result !== "string") {
        return {
          success: false,
          error: new TypeValidationError({
            value,
            cause: 'value must be an object that contains a string in the "result" property.'
          })
        };
      }
      const result = value.result;
      return enumValues.includes(result) ? { success: true, value: result } : {
        success: false,
        error: new TypeValidationError({
          value,
          cause: "value must be a string in the enum"
        })
      };
    },
    validatePartialResult() {
      throw new UnsupportedFunctionalityError({
        functionality: "partial results in enum mode"
      });
    },
    createElementStream() {
      throw new UnsupportedFunctionalityError({
        functionality: "element streams in enum mode"
      });
    }
  };
};
function getOutputStrategy({
  output,
  schema,
  enumValues
}) {
  switch (output) {
    case "object":
      return objectOutputStrategy(asSchema(schema));
    case "array":
      return arrayOutputStrategy(asSchema(schema));
    case "enum":
      return enumOutputStrategy(enumValues);
    case "no-schema":
      return noSchemaOutputStrategy;
    default: {
      const _exhaustiveCheck = output;
      throw new Error(`Unsupported output: ${_exhaustiveCheck}`);
    }
  }
}

// core/generate-object/validate-object-generation-input.ts
function validateObjectGenerationInput({
  output,
  mode,
  schema,
  schemaName,
  schemaDescription,
  enumValues
}) {
  if (output != null && output !== "object" && output !== "array" && output !== "enum" && output !== "no-schema") {
    throw new InvalidArgumentError({
      parameter: "output",
      value: output,
      message: "Invalid output type."
    });
  }
  if (output === "no-schema") {
    if (mode === "auto" || mode === "tool") {
      throw new InvalidArgumentError({
        parameter: "mode",
        value: mode,
        message: 'Mode must be "json" for no-schema output.'
      });
    }
    if (schema != null) {
      throw new InvalidArgumentError({
        parameter: "schema",
        value: schema,
        message: "Schema is not supported for no-schema output."
      });
    }
    if (schemaDescription != null) {
      throw new InvalidArgumentError({
        parameter: "schemaDescription",
        value: schemaDescription,
        message: "Schema description is not supported for no-schema output."
      });
    }
    if (schemaName != null) {
      throw new InvalidArgumentError({
        parameter: "schemaName",
        value: schemaName,
        message: "Schema name is not supported for no-schema output."
      });
    }
    if (enumValues != null) {
      throw new InvalidArgumentError({
        parameter: "enumValues",
        value: enumValues,
        message: "Enum values are not supported for no-schema output."
      });
    }
  }
  if (output === "object") {
    if (schema == null) {
      throw new InvalidArgumentError({
        parameter: "schema",
        value: schema,
        message: "Schema is required for object output."
      });
    }
    if (enumValues != null) {
      throw new InvalidArgumentError({
        parameter: "enumValues",
        value: enumValues,
        message: "Enum values are not supported for object output."
      });
    }
  }
  if (output === "array") {
    if (schema == null) {
      throw new InvalidArgumentError({
        parameter: "schema",
        value: schema,
        message: "Element schema is required for array output."
      });
    }
    if (enumValues != null) {
      throw new InvalidArgumentError({
        parameter: "enumValues",
        value: enumValues,
        message: "Enum values are not supported for array output."
      });
    }
  }
  if (output === "enum") {
    if (schema != null) {
      throw new InvalidArgumentError({
        parameter: "schema",
        value: schema,
        message: "Schema is not supported for enum output."
      });
    }
    if (schemaDescription != null) {
      throw new InvalidArgumentError({
        parameter: "schemaDescription",
        value: schemaDescription,
        message: "Schema description is not supported for enum output."
      });
    }
    if (schemaName != null) {
      throw new InvalidArgumentError({
        parameter: "schemaName",
        value: schemaName,
        message: "Schema name is not supported for enum output."
      });
    }
    if (enumValues == null) {
      throw new InvalidArgumentError({
        parameter: "enumValues",
        value: enumValues,
        message: "Enum values are required for enum output."
      });
    }
    for (const value of enumValues) {
      if (typeof value !== "string") {
        throw new InvalidArgumentError({
          parameter: "enumValues",
          value,
          message: "Enum values must be strings."
        });
      }
    }
  }
}

// core/generate-object/generate-object.ts
var originalGenerateId = createIdGenerator({ prefix: "aiobj", size: 24 });
async function generateObject({
  model,
  enum: enumValues,
  // rename bc enum is reserved by typescript
  schema: inputSchema,
  schemaName,
  schemaDescription,
  mode,
  output = "object",
  system,
  prompt,
  messages,
  maxRetries: maxRetriesArg,
  abortSignal,
  headers,
  experimental_repairText: repairText,
  experimental_telemetry: telemetry,
  experimental_providerMetadata,
  providerOptions = experimental_providerMetadata,
  _internal: {
    generateId: generateId3 = originalGenerateId,
    currentDate = () => /* @__PURE__ */ new Date()
  } = {},
  ...settings
}) {
  validateObjectGenerationInput({
    output,
    mode,
    schema: inputSchema,
    schemaName,
    schemaDescription,
    enumValues
  });
  const { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg });
  const outputStrategy = getOutputStrategy({
    output,
    schema: inputSchema,
    enumValues
  });
  if (outputStrategy.type === "no-schema" && mode === void 0) {
    mode = "json";
  }
  const baseTelemetryAttributes = getBaseTelemetryAttributes({
    model,
    telemetry,
    headers,
    settings: { ...settings, maxRetries }
  });
  const tracer = getTracer(telemetry);
  return recordSpan({
    name: "ai.generateObject",
    attributes: selectTelemetryAttributes({
      telemetry,
      attributes: {
        ...assembleOperationName({
          operationId: "ai.generateObject",
          telemetry
        }),
        ...baseTelemetryAttributes,
        // specific settings that only make sense on the outer level:
        "ai.prompt": {
          input: () => JSON.stringify({ system, prompt, messages })
        },
        "ai.schema": outputStrategy.jsonSchema != null ? { input: () => JSON.stringify(outputStrategy.jsonSchema) } : void 0,
        "ai.schema.name": schemaName,
        "ai.schema.description": schemaDescription,
        "ai.settings.output": outputStrategy.type,
        "ai.settings.mode": mode
      }
    }),
    tracer,
    fn: async (span) => {
      var _a17, _b, _c, _d;
      if (mode === "auto" || mode == null) {
        mode = model.defaultObjectGenerationMode;
      }
      let result;
      let finishReason;
      let usage;
      let warnings;
      let rawResponse;
      let response;
      let request;
      let logprobs;
      let resultProviderMetadata;
      switch (mode) {
        case "json": {
          const standardizedPrompt = standardizePrompt({
            prompt: {
              system: outputStrategy.jsonSchema == null ? injectJsonInstruction({ prompt: system }) : model.supportsStructuredOutputs ? system : injectJsonInstruction({
                prompt: system,
                schema: outputStrategy.jsonSchema
              }),
              prompt,
              messages
            },
            tools: void 0
          });
          const promptMessages = await convertToLanguageModelPrompt({
            prompt: standardizedPrompt,
            modelSupportsImageUrls: model.supportsImageUrls,
            modelSupportsUrl: (_a17 = model.supportsUrl) == null ? void 0 : _a17.bind(model)
            // support 'this' context
          });
          const generateResult = await retry(
            () => recordSpan({
              name: "ai.generateObject.doGenerate",
              attributes: selectTelemetryAttributes({
                telemetry,
                attributes: {
                  ...assembleOperationName({
                    operationId: "ai.generateObject.doGenerate",
                    telemetry
                  }),
                  ...baseTelemetryAttributes,
                  "ai.prompt.format": {
                    input: () => standardizedPrompt.type
                  },
                  "ai.prompt.messages": {
                    input: () => JSON.stringify(promptMessages)
                  },
                  "ai.settings.mode": mode,
                  // standardized gen-ai llm span attributes:
                  "gen_ai.system": model.provider,
                  "gen_ai.request.model": model.modelId,
                  "gen_ai.request.frequency_penalty": settings.frequencyPenalty,
                  "gen_ai.request.max_tokens": settings.maxTokens,
                  "gen_ai.request.presence_penalty": settings.presencePenalty,
                  "gen_ai.request.temperature": settings.temperature,
                  "gen_ai.request.top_k": settings.topK,
                  "gen_ai.request.top_p": settings.topP
                }
              }),
              tracer,
              fn: async (span2) => {
                var _a18, _b2, _c2, _d2, _e, _f;
                const result2 = await model.doGenerate({
                  mode: {
                    type: "object-json",
                    schema: outputStrategy.jsonSchema,
                    name: schemaName,
                    description: schemaDescription
                  },
                  ...prepareCallSettings(settings),
                  inputFormat: standardizedPrompt.type,
                  prompt: promptMessages,
                  providerMetadata: providerOptions,
                  abortSignal,
                  headers
                });
                const responseData = {
                  id: (_b2 = (_a18 = result2.response) == null ? void 0 : _a18.id) != null ? _b2 : generateId3(),
                  timestamp: (_d2 = (_c2 = result2.response) == null ? void 0 : _c2.timestamp) != null ? _d2 : currentDate(),
                  modelId: (_f = (_e = result2.response) == null ? void 0 : _e.modelId) != null ? _f : model.modelId
                };
                if (result2.text === void 0) {
                  throw new NoObjectGeneratedError({
                    message: "No object generated: the model did not return a response.",
                    response: responseData,
                    usage: calculateLanguageModelUsage(result2.usage),
                    finishReason: result2.finishReason
                  });
                }
                span2.setAttributes(
                  selectTelemetryAttributes({
                    telemetry,
                    attributes: {
                      "ai.response.finishReason": result2.finishReason,
                      "ai.response.object": { output: () => result2.text },
                      "ai.response.id": responseData.id,
                      "ai.response.model": responseData.modelId,
                      "ai.response.timestamp": responseData.timestamp.toISOString(),
                      "ai.usage.promptTokens": result2.usage.promptTokens,
                      "ai.usage.completionTokens": result2.usage.completionTokens,
                      // standardized gen-ai llm span attributes:
                      "gen_ai.response.finish_reasons": [result2.finishReason],
                      "gen_ai.response.id": responseData.id,
                      "gen_ai.response.model": responseData.modelId,
                      "gen_ai.usage.prompt_tokens": result2.usage.promptTokens,
                      "gen_ai.usage.completion_tokens": result2.usage.completionTokens
                    }
                  })
                );
                return { ...result2, objectText: result2.text, responseData };
              }
            })
          );
          result = generateResult.objectText;
          finishReason = generateResult.finishReason;
          usage = generateResult.usage;
          warnings = generateResult.warnings;
          rawResponse = generateResult.rawResponse;
          logprobs = generateResult.logprobs;
          resultProviderMetadata = generateResult.providerMetadata;
          request = (_b = generateResult.request) != null ? _b : {};
          response = generateResult.responseData;
          break;
        }
        case "tool": {
          const standardizedPrompt = standardizePrompt({
            prompt: { system, prompt, messages },
            tools: void 0
          });
          const promptMessages = await convertToLanguageModelPrompt({
            prompt: standardizedPrompt,
            modelSupportsImageUrls: model.supportsImageUrls,
            modelSupportsUrl: (_c = model.supportsUrl) == null ? void 0 : _c.bind(model)
            // support 'this' context,
          });
          const inputFormat = standardizedPrompt.type;
          const generateResult = await retry(
            () => recordSpan({
              name: "ai.generateObject.doGenerate",
              attributes: selectTelemetryAttributes({
                telemetry,
                attributes: {
                  ...assembleOperationName({
                    operationId: "ai.generateObject.doGenerate",
                    telemetry
                  }),
                  ...baseTelemetryAttributes,
                  "ai.prompt.format": {
                    input: () => inputFormat
                  },
                  "ai.prompt.messages": {
                    input: () => JSON.stringify(promptMessages)
                  },
                  "ai.settings.mode": mode,
                  // standardized gen-ai llm span attributes:
                  "gen_ai.system": model.provider,
                  "gen_ai.request.model": model.modelId,
                  "gen_ai.request.frequency_penalty": settings.frequencyPenalty,
                  "gen_ai.request.max_tokens": settings.maxTokens,
                  "gen_ai.request.presence_penalty": settings.presencePenalty,
                  "gen_ai.request.temperature": settings.temperature,
                  "gen_ai.request.top_k": settings.topK,
                  "gen_ai.request.top_p": settings.topP
                }
              }),
              tracer,
              fn: async (span2) => {
                var _a18, _b2, _c2, _d2, _e, _f, _g, _h;
                const result2 = await model.doGenerate({
                  mode: {
                    type: "object-tool",
                    tool: {
                      type: "function",
                      name: schemaName != null ? schemaName : "json",
                      description: schemaDescription != null ? schemaDescription : "Respond with a JSON object.",
                      parameters: outputStrategy.jsonSchema
                    }
                  },
                  ...prepareCallSettings(settings),
                  inputFormat,
                  prompt: promptMessages,
                  providerMetadata: providerOptions,
                  abortSignal,
                  headers
                });
                const objectText = (_b2 = (_a18 = result2.toolCalls) == null ? void 0 : _a18[0]) == null ? void 0 : _b2.args;
                const responseData = {
                  id: (_d2 = (_c2 = result2.response) == null ? void 0 : _c2.id) != null ? _d2 : generateId3(),
                  timestamp: (_f = (_e = result2.response) == null ? void 0 : _e.timestamp) != null ? _f : currentDate(),
                  modelId: (_h = (_g = result2.response) == null ? void 0 : _g.modelId) != null ? _h : model.modelId
                };
                if (objectText === void 0) {
                  throw new NoObjectGeneratedError({
                    message: "No object generated: the tool was not called.",
                    response: responseData,
                    usage: calculateLanguageModelUsage(result2.usage),
                    finishReason: result2.finishReason
                  });
                }
                span2.setAttributes(
                  selectTelemetryAttributes({
                    telemetry,
                    attributes: {
                      "ai.response.finishReason": result2.finishReason,
                      "ai.response.object": { output: () => objectText },
                      "ai.response.id": responseData.id,
                      "ai.response.model": responseData.modelId,
                      "ai.response.timestamp": responseData.timestamp.toISOString(),
                      "ai.usage.promptTokens": result2.usage.promptTokens,
                      "ai.usage.completionTokens": result2.usage.completionTokens,
                      // standardized gen-ai llm span attributes:
                      "gen_ai.response.finish_reasons": [result2.finishReason],
                      "gen_ai.response.id": responseData.id,
                      "gen_ai.response.model": responseData.modelId,
                      "gen_ai.usage.input_tokens": result2.usage.promptTokens,
                      "gen_ai.usage.output_tokens": result2.usage.completionTokens
                    }
                  })
                );
                return { ...result2, objectText, responseData };
              }
            })
          );
          result = generateResult.objectText;
          finishReason = generateResult.finishReason;
          usage = generateResult.usage;
          warnings = generateResult.warnings;
          rawResponse = generateResult.rawResponse;
          logprobs = generateResult.logprobs;
          resultProviderMetadata = generateResult.providerMetadata;
          request = (_d = generateResult.request) != null ? _d : {};
          response = generateResult.responseData;
          break;
        }
        case void 0: {
          throw new Error(
            "Model does not have a default object generation mode."
          );
        }
        default: {
          const _exhaustiveCheck = mode;
          throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);
        }
      }
      function processResult(result2) {
        const parseResult = safeParseJSON({ text: result2 });
        if (!parseResult.success) {
          throw new NoObjectGeneratedError({
            message: "No object generated: could not parse the response.",
            cause: parseResult.error,
            text: result2,
            response,
            usage: calculateLanguageModelUsage(usage),
            finishReason
          });
        }
        const validationResult = outputStrategy.validateFinalResult(
          parseResult.value,
          {
            text: result2,
            response,
            usage: calculateLanguageModelUsage(usage)
          }
        );
        if (!validationResult.success) {
          throw new NoObjectGeneratedError({
            message: "No object generated: response did not match schema.",
            cause: validationResult.error,
            text: result2,
            response,
            usage: calculateLanguageModelUsage(usage),
            finishReason
          });
        }
        return validationResult.value;
      }
      let object2;
      try {
        object2 = processResult(result);
      } catch (error) {
        if (repairText != null && NoObjectGeneratedError.isInstance(error) && (JSONParseError.isInstance(error.cause) || TypeValidationError.isInstance(error.cause))) {
          const repairedText = await repairText({
            text: result,
            error: error.cause
          });
          if (repairedText === null) {
            throw error;
          }
          object2 = processResult(repairedText);
        } else {
          throw error;
        }
      }
      span.setAttributes(
        selectTelemetryAttributes({
          telemetry,
          attributes: {
            "ai.response.finishReason": finishReason,
            "ai.response.object": {
              output: () => JSON.stringify(object2)
            },
            "ai.usage.promptTokens": usage.promptTokens,
            "ai.usage.completionTokens": usage.completionTokens
          }
        })
      );
      return new DefaultGenerateObjectResult({
        object: object2,
        finishReason,
        usage: calculateLanguageModelUsage(usage),
        warnings,
        request,
        response: {
          ...response,
          headers: rawResponse == null ? void 0 : rawResponse.headers,
          body: rawResponse == null ? void 0 : rawResponse.body
        },
        logprobs,
        providerMetadata: resultProviderMetadata
      });
    }
  });
}
var DefaultGenerateObjectResult = class {
  constructor(options) {
    this.object = options.object;
    this.finishReason = options.finishReason;
    this.usage = options.usage;
    this.warnings = options.warnings;
    this.providerMetadata = options.providerMetadata;
    this.experimental_providerMetadata = options.providerMetadata;
    this.response = options.response;
    this.request = options.request;
    this.logprobs = options.logprobs;
  }
  toJsonResponse(init) {
    var _a17;
    return new Response(JSON.stringify(this.object), {
      status: (_a17 = init == null ? void 0 : init.status) != null ? _a17 : 200,
      headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {
        contentType: "application/json; charset=utf-8"
      })
    });
  }
};

// util/delayed-promise.ts
var DelayedPromise = class {
  constructor() {
    this.status = { type: "pending" };
    this._resolve = void 0;
    this._reject = void 0;
  }
  get value() {
    if (this.promise) {
      return this.promise;
    }
    this.promise = new Promise((resolve, reject) => {
      if (this.status.type === "resolved") {
        resolve(this.status.value);
      } else if (this.status.type === "rejected") {
        reject(this.status.error);
      }
      this._resolve = resolve;
      this._reject = reject;
    });
    return this.promise;
  }
  resolve(value) {
    var _a17;
    this.status = { type: "resolved", value };
    if (this.promise) {
      (_a17 = this._resolve) == null ? void 0 : _a17.call(this, value);
    }
  }
  reject(error) {
    var _a17;
    this.status = { type: "rejected", error };
    if (this.promise) {
      (_a17 = this._reject) == null ? void 0 : _a17.call(this, error);
    }
  }
};

// util/create-resolvable-promise.ts
function createResolvablePromise() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return {
    promise,
    resolve,
    reject
  };
}

// core/util/create-stitchable-stream.ts
function createStitchableStream() {
  let innerStreamReaders = [];
  let controller = null;
  let isClosed = false;
  let waitForNewStream = createResolvablePromise();
  const processPull = async () => {
    if (isClosed && innerStreamReaders.length === 0) {
      controller == null ? void 0 : controller.close();
      return;
    }
    if (innerStreamReaders.length === 0) {
      waitForNewStream = createResolvablePromise();
      await waitForNewStream.promise;
      return processPull();
    }
    try {
      const { value, done } = await innerStreamReaders[0].read();
      if (done) {
        innerStreamReaders.shift();
        if (innerStreamReaders.length > 0) {
          await processPull();
        } else if (isClosed) {
          controller == null ? void 0 : controller.close();
        }
      } else {
        controller == null ? void 0 : controller.enqueue(value);
      }
    } catch (error) {
      controller == null ? void 0 : controller.error(error);
      innerStreamReaders.shift();
      if (isClosed && innerStreamReaders.length === 0) {
        controller == null ? void 0 : controller.close();
      }
    }
  };
  return {
    stream: new ReadableStream({
      start(controllerParam) {
        controller = controllerParam;
      },
      pull: processPull,
      async cancel() {
        for (const reader of innerStreamReaders) {
          await reader.cancel();
        }
        innerStreamReaders = [];
        isClosed = true;
      }
    }),
    addStream: (innerStream) => {
      if (isClosed) {
        throw new Error("Cannot add inner stream: outer stream is closed");
      }
      innerStreamReaders.push(innerStream.getReader());
      waitForNewStream.resolve();
    },
    /**
     * Gracefully close the outer stream. This will let the inner streams
     * finish processing and then close the outer stream.
     */
    close: () => {
      isClosed = true;
      waitForNewStream.resolve();
      if (innerStreamReaders.length === 0) {
        controller == null ? void 0 : controller.close();
      }
    },
    /**
     * Immediately close the outer stream. This will cancel all inner streams
     * and close the outer stream.
     */
    terminate: () => {
      isClosed = true;
      waitForNewStream.resolve();
      innerStreamReaders.forEach((reader) => reader.cancel());
      innerStreamReaders = [];
      controller == null ? void 0 : controller.close();
    }
  };
}

// core/util/now.ts
function now() {
  var _a17, _b;
  return (_b = (_a17 = globalThis == null ? void 0 : globalThis.performance) == null ? void 0 : _a17.now()) != null ? _b : Date.now();
}

// core/generate-object/stream-object.ts
var originalGenerateId2 = createIdGenerator({ prefix: "aiobj", size: 24 });
function streamObject({
  model,
  schema: inputSchema,
  schemaName,
  schemaDescription,
  mode,
  output = "object",
  system,
  prompt,
  messages,
  maxRetries,
  abortSignal,
  headers,
  experimental_telemetry: telemetry,
  experimental_providerMetadata,
  providerOptions = experimental_providerMetadata,
  onError,
  onFinish,
  _internal: {
    generateId: generateId3 = originalGenerateId2,
    currentDate = () => /* @__PURE__ */ new Date(),
    now: now2 = now
  } = {},
  ...settings
}) {
  validateObjectGenerationInput({
    output,
    mode,
    schema: inputSchema,
    schemaName,
    schemaDescription
  });
  const outputStrategy = getOutputStrategy({ output, schema: inputSchema });
  if (outputStrategy.type === "no-schema" && mode === void 0) {
    mode = "json";
  }
  return new DefaultStreamObjectResult({
    model,
    telemetry,
    headers,
    settings,
    maxRetries,
    abortSignal,
    outputStrategy,
    system,
    prompt,
    messages,
    schemaName,
    schemaDescription,
    providerOptions,
    mode,
    onError,
    onFinish,
    generateId: generateId3,
    currentDate,
    now: now2
  });
}
var DefaultStreamObjectResult = class {
  constructor({
    model,
    headers,
    telemetry,
    settings,
    maxRetries: maxRetriesArg,
    abortSignal,
    outputStrategy,
    system,
    prompt,
    messages,
    schemaName,
    schemaDescription,
    providerOptions,
    mode,
    onError,
    onFinish,
    generateId: generateId3,
    currentDate,
    now: now2
  }) {
    this.objectPromise = new DelayedPromise();
    this.usagePromise = new DelayedPromise();
    this.providerMetadataPromise = new DelayedPromise();
    this.warningsPromise = new DelayedPromise();
    this.requestPromise = new DelayedPromise();
    this.responsePromise = new DelayedPromise();
    const { maxRetries, retry } = prepareRetries({
      maxRetries: maxRetriesArg
    });
    const baseTelemetryAttributes = getBaseTelemetryAttributes({
      model,
      telemetry,
      headers,
      settings: { ...settings, maxRetries }
    });
    const tracer = getTracer(telemetry);
    const self = this;
    const stitchableStream = createStitchableStream();
    const eventProcessor = new TransformStream({
      transform(chunk, controller) {
        controller.enqueue(chunk);
        if (chunk.type === "error") {
          onError == null ? void 0 : onError({ error: chunk.error });
        }
      }
    });
    this.baseStream = stitchableStream.stream.pipeThrough(eventProcessor);
    recordSpan({
      name: "ai.streamObject",
      attributes: selectTelemetryAttributes({
        telemetry,
        attributes: {
          ...assembleOperationName({
            operationId: "ai.streamObject",
            telemetry
          }),
          ...baseTelemetryAttributes,
          // specific settings that only make sense on the outer level:
          "ai.prompt": {
            input: () => JSON.stringify({ system, prompt, messages })
          },
          "ai.schema": outputStrategy.jsonSchema != null ? { input: () => JSON.stringify(outputStrategy.jsonSchema) } : void 0,
          "ai.schema.name": schemaName,
          "ai.schema.description": schemaDescription,
          "ai.settings.output": outputStrategy.type,
          "ai.settings.mode": mode
        }
      }),
      tracer,
      endWhenDone: false,
      fn: async (rootSpan) => {
        var _a17, _b;
        if (mode === "auto" || mode == null) {
          mode = model.defaultObjectGenerationMode;
        }
        let callOptions;
        let transformer;
        switch (mode) {
          case "json": {
            const standardizedPrompt = standardizePrompt({
              prompt: {
                system: outputStrategy.jsonSchema == null ? injectJsonInstruction({ prompt: system }) : model.supportsStructuredOutputs ? system : injectJsonInstruction({
                  prompt: system,
                  schema: outputStrategy.jsonSchema
                }),
                prompt,
                messages
              },
              tools: void 0
            });
            callOptions = {
              mode: {
                type: "object-json",
                schema: outputStrategy.jsonSchema,
                name: schemaName,
                description: schemaDescription
              },
              ...prepareCallSettings(settings),
              inputFormat: standardizedPrompt.type,
              prompt: await convertToLanguageModelPrompt({
                prompt: standardizedPrompt,
                modelSupportsImageUrls: model.supportsImageUrls,
                modelSupportsUrl: (_a17 = model.supportsUrl) == null ? void 0 : _a17.bind(model)
                // support 'this' context
              }),
              providerMetadata: providerOptions,
              abortSignal,
              headers
            };
            transformer = {
              transform: (chunk, controller) => {
                switch (chunk.type) {
                  case "text-delta":
                    controller.enqueue(chunk.textDelta);
                    break;
                  case "response-metadata":
                  case "finish":
                  case "error":
                    controller.enqueue(chunk);
                    break;
                }
              }
            };
            break;
          }
          case "tool": {
            const standardizedPrompt = standardizePrompt({
              prompt: { system, prompt, messages },
              tools: void 0
            });
            callOptions = {
              mode: {
                type: "object-tool",
                tool: {
                  type: "function",
                  name: schemaName != null ? schemaName : "json",
                  description: schemaDescription != null ? schemaDescription : "Respond with a JSON object.",
                  parameters: outputStrategy.jsonSchema
                }
              },
              ...prepareCallSettings(settings),
              inputFormat: standardizedPrompt.type,
              prompt: await convertToLanguageModelPrompt({
                prompt: standardizedPrompt,
                modelSupportsImageUrls: model.supportsImageUrls,
                modelSupportsUrl: (_b = model.supportsUrl) == null ? void 0 : _b.bind(model)
                // support 'this' context,
              }),
              providerMetadata: providerOptions,
              abortSignal,
              headers
            };
            transformer = {
              transform(chunk, controller) {
                switch (chunk.type) {
                  case "tool-call-delta":
                    controller.enqueue(chunk.argsTextDelta);
                    break;
                  case "response-metadata":
                  case "finish":
                  case "error":
                    controller.enqueue(chunk);
                    break;
                }
              }
            };
            break;
          }
          case void 0: {
            throw new Error(
              "Model does not have a default object generation mode."
            );
          }
          default: {
            const _exhaustiveCheck = mode;
            throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);
          }
        }
        const {
          result: { stream, warnings, rawResponse, request },
          doStreamSpan,
          startTimestampMs
        } = await retry(
          () => recordSpan({
            name: "ai.streamObject.doStream",
            attributes: selectTelemetryAttributes({
              telemetry,
              attributes: {
                ...assembleOperationName({
                  operationId: "ai.streamObject.doStream",
                  telemetry
                }),
                ...baseTelemetryAttributes,
                "ai.prompt.format": {
                  input: () => callOptions.inputFormat
                },
                "ai.prompt.messages": {
                  input: () => JSON.stringify(callOptions.prompt)
                },
                "ai.settings.mode": mode,
                // standardized gen-ai llm span attributes:
                "gen_ai.system": model.provider,
                "gen_ai.request.model": model.modelId,
                "gen_ai.request.frequency_penalty": settings.frequencyPenalty,
                "gen_ai.request.max_tokens": settings.maxTokens,
                "gen_ai.request.presence_penalty": settings.presencePenalty,
                "gen_ai.request.temperature": settings.temperature,
                "gen_ai.request.top_k": settings.topK,
                "gen_ai.request.top_p": settings.topP
              }
            }),
            tracer,
            endWhenDone: false,
            fn: async (doStreamSpan2) => ({
              startTimestampMs: now2(),
              doStreamSpan: doStreamSpan2,
              result: await model.doStream(callOptions)
            })
          })
        );
        self.requestPromise.resolve(request != null ? request : {});
        let usage;
        let finishReason;
        let providerMetadata;
        let object2;
        let error;
        let accumulatedText = "";
        let textDelta = "";
        let response = {
          id: generateId3(),
          timestamp: currentDate(),
          modelId: model.modelId
        };
        let latestObjectJson = void 0;
        let latestObject = void 0;
        let isFirstChunk = true;
        let isFirstDelta = true;
        const transformedStream = stream.pipeThrough(new TransformStream(transformer)).pipeThrough(
          new TransformStream({
            async transform(chunk, controller) {
              var _a18, _b2, _c;
              if (isFirstChunk) {
                const msToFirstChunk = now2() - startTimestampMs;
                isFirstChunk = false;
                doStreamSpan.addEvent("ai.stream.firstChunk", {
                  "ai.stream.msToFirstChunk": msToFirstChunk
                });
                doStreamSpan.setAttributes({
                  "ai.stream.msToFirstChunk": msToFirstChunk
                });
              }
              if (typeof chunk === "string") {
                accumulatedText += chunk;
                textDelta += chunk;
                const { value: currentObjectJson, state: parseState } = parsePartialJson(accumulatedText);
                if (currentObjectJson !== void 0 && !isDeepEqualData(latestObjectJson, currentObjectJson)) {
                  const validationResult = outputStrategy.validatePartialResult({
                    value: currentObjectJson,
                    textDelta,
                    latestObject,
                    isFirstDelta,
                    isFinalDelta: parseState === "successful-parse"
                  });
                  if (validationResult.success && !isDeepEqualData(
                    latestObject,
                    validationResult.value.partial
                  )) {
                    latestObjectJson = currentObjectJson;
                    latestObject = validationResult.value.partial;
                    controller.enqueue({
                      type: "object",
                      object: latestObject
                    });
                    controller.enqueue({
                      type: "text-delta",
                      textDelta: validationResult.value.textDelta
                    });
                    textDelta = "";
                    isFirstDelta = false;
                  }
                }
                return;
              }
              switch (chunk.type) {
                case "response-metadata": {
                  response = {
                    id: (_a18 = chunk.id) != null ? _a18 : response.id,
                    timestamp: (_b2 = chunk.timestamp) != null ? _b2 : response.timestamp,
                    modelId: (_c = chunk.modelId) != null ? _c : response.modelId
                  };
                  break;
                }
                case "finish": {
                  if (textDelta !== "") {
                    controller.enqueue({ type: "text-delta", textDelta });
                  }
                  finishReason = chunk.finishReason;
                  usage = calculateLanguageModelUsage(chunk.usage);
                  providerMetadata = chunk.providerMetadata;
                  controller.enqueue({ ...chunk, usage, response });
                  self.usagePromise.resolve(usage);
                  self.providerMetadataPromise.resolve(providerMetadata);
                  self.responsePromise.resolve({
                    ...response,
                    headers: rawResponse == null ? void 0 : rawResponse.headers
                  });
                  const validationResult = outputStrategy.validateFinalResult(
                    latestObjectJson,
                    {
                      text: accumulatedText,
                      response,
                      usage
                    }
                  );
                  if (validationResult.success) {
                    object2 = validationResult.value;
                    self.objectPromise.resolve(object2);
                  } else {
                    error = new NoObjectGeneratedError({
                      message: "No object generated: response did not match schema.",
                      cause: validationResult.error,
                      text: accumulatedText,
                      response,
                      usage,
                      finishReason
                    });
                    self.objectPromise.reject(error);
                  }
                  break;
                }
                default: {
                  controller.enqueue(chunk);
                  break;
                }
              }
            },
            // invoke onFinish callback and resolve toolResults promise when the stream is about to close:
            async flush(controller) {
              try {
                const finalUsage = usage != null ? usage : {
                  promptTokens: NaN,
                  completionTokens: NaN,
                  totalTokens: NaN
                };
                doStreamSpan.setAttributes(
                  selectTelemetryAttributes({
                    telemetry,
                    attributes: {
                      "ai.response.finishReason": finishReason,
                      "ai.response.object": {
                        output: () => JSON.stringify(object2)
                      },
                      "ai.response.id": response.id,
                      "ai.response.model": response.modelId,
                      "ai.response.timestamp": response.timestamp.toISOString(),
                      "ai.usage.promptTokens": finalUsage.promptTokens,
                      "ai.usage.completionTokens": finalUsage.completionTokens,
                      // standardized gen-ai llm span attributes:
                      "gen_ai.response.finish_reasons": [finishReason],
                      "gen_ai.response.id": response.id,
                      "gen_ai.response.model": response.modelId,
                      "gen_ai.usage.input_tokens": finalUsage.promptTokens,
                      "gen_ai.usage.output_tokens": finalUsage.completionTokens
                    }
                  })
                );
                doStreamSpan.end();
                rootSpan.setAttributes(
                  selectTelemetryAttributes({
                    telemetry,
                    attributes: {
                      "ai.usage.promptTokens": finalUsage.promptTokens,
                      "ai.usage.completionTokens": finalUsage.completionTokens,
                      "ai.response.object": {
                        output: () => JSON.stringify(object2)
                      }
                    }
                  })
                );
                await (onFinish == null ? void 0 : onFinish({
                  usage: finalUsage,
                  object: object2,
                  error,
                  response: {
                    ...response,
                    headers: rawResponse == null ? void 0 : rawResponse.headers
                  },
                  warnings,
                  providerMetadata,
                  experimental_providerMetadata: providerMetadata
                }));
              } catch (error2) {
                controller.enqueue({ type: "error", error: error2 });
              } finally {
                rootSpan.end();
              }
            }
          })
        );
        stitchableStream.addStream(transformedStream);
      }
    }).catch((error) => {
      stitchableStream.addStream(
        new ReadableStream({
          start(controller) {
            controller.enqueue({ type: "error", error });
            controller.close();
          }
        })
      );
    }).finally(() => {
      stitchableStream.close();
    });
    this.outputStrategy = outputStrategy;
  }
  get object() {
    return this.objectPromise.value;
  }
  get usage() {
    return this.usagePromise.value;
  }
  get experimental_providerMetadata() {
    return this.providerMetadataPromise.value;
  }
  get providerMetadata() {
    return this.providerMetadataPromise.value;
  }
  get warnings() {
    return this.warningsPromise.value;
  }
  get request() {
    return this.requestPromise.value;
  }
  get response() {
    return this.responsePromise.value;
  }
  get partialObjectStream() {
    return createAsyncIterableStream(
      this.baseStream.pipeThrough(
        new TransformStream({
          transform(chunk, controller) {
            switch (chunk.type) {
              case "object":
                controller.enqueue(chunk.object);
                break;
              case "text-delta":
              case "finish":
              case "error":
                break;
              default: {
                const _exhaustiveCheck = chunk;
                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);
              }
            }
          }
        })
      )
    );
  }
  get elementStream() {
    return this.outputStrategy.createElementStream(this.baseStream);
  }
  get textStream() {
    return createAsyncIterableStream(
      this.baseStream.pipeThrough(
        new TransformStream({
          transform(chunk, controller) {
            switch (chunk.type) {
              case "text-delta":
                controller.enqueue(chunk.textDelta);
                break;
              case "object":
              case "finish":
              case "error":
                break;
              default: {
                const _exhaustiveCheck = chunk;
                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);
              }
            }
          }
        })
      )
    );
  }
  get fullStream() {
    return createAsyncIterableStream(this.baseStream);
  }
  pipeTextStreamToResponse(response, init) {
    writeToServerResponse({
      response,
      status: init == null ? void 0 : init.status,
      statusText: init == null ? void 0 : init.statusText,
      headers: prepareOutgoingHttpHeaders(init == null ? void 0 : init.headers, {
        contentType: "text/plain; charset=utf-8"
      }),
      stream: this.textStream.pipeThrough(new TextEncoderStream())
    });
  }
  toTextStreamResponse(init) {
    var _a17;
    return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {
      status: (_a17 = init == null ? void 0 : init.status) != null ? _a17 : 200,
      headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {
        contentType: "text/plain; charset=utf-8"
      })
    });
  }
};
var name9 = "AI_NoOutputSpecifiedError";
var marker9 = `vercel.ai.error.${name9}`;
var symbol9 = Symbol.for(marker9);
var _a9;
var NoOutputSpecifiedError = class extends AISDKError {
  // used in isInstance
  constructor({ message = "No output specified." } = {}) {
    super({ name: name9, message });
    this[_a9] = true;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker9);
  }
};
_a9 = symbol9;
var name10 = "AI_ToolExecutionError";
var marker10 = `vercel.ai.error.${name10}`;
var symbol10 = Symbol.for(marker10);
var _a10;
var ToolExecutionError = class extends AISDKError {
  constructor({
    toolArgs,
    toolName,
    toolCallId,
    cause,
    message = `Error executing tool ${toolName}: ${getErrorMessage$1(cause)}`
  }) {
    super({ name: name10, message, cause });
    this[_a10] = true;
    this.toolArgs = toolArgs;
    this.toolName = toolName;
    this.toolCallId = toolCallId;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker10);
  }
};
_a10 = symbol10;

// core/util/is-non-empty-object.ts
function isNonEmptyObject(object2) {
  return object2 != null && Object.keys(object2).length > 0;
}

// core/prompt/prepare-tools-and-tool-choice.ts
function prepareToolsAndToolChoice({
  tools,
  toolChoice,
  activeTools
}) {
  if (!isNonEmptyObject(tools)) {
    return {
      tools: void 0,
      toolChoice: void 0
    };
  }
  const filteredTools = activeTools != null ? Object.entries(tools).filter(
    ([name17]) => activeTools.includes(name17)
  ) : Object.entries(tools);
  return {
    tools: filteredTools.map(([name17, tool2]) => {
      const toolType = tool2.type;
      switch (toolType) {
        case void 0:
        case "function":
          return {
            type: "function",
            name: name17,
            description: tool2.description,
            parameters: asSchema(tool2.parameters).jsonSchema
          };
        case "provider-defined":
          return {
            type: "provider-defined",
            name: name17,
            id: tool2.id,
            args: tool2.args
          };
        default: {
          const exhaustiveCheck = toolType;
          throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);
        }
      }
    }),
    toolChoice: toolChoice == null ? { type: "auto" } : typeof toolChoice === "string" ? { type: toolChoice } : { type: "tool", toolName: toolChoice.toolName }
  };
}

// core/util/split-on-last-whitespace.ts
var lastWhitespaceRegexp = /^([\s\S]*?)(\s+)(\S*)$/;
function splitOnLastWhitespace(text2) {
  const match = text2.match(lastWhitespaceRegexp);
  return match ? { prefix: match[1], whitespace: match[2], suffix: match[3] } : void 0;
}

// core/util/remove-text-after-last-whitespace.ts
function removeTextAfterLastWhitespace(text2) {
  const match = splitOnLastWhitespace(text2);
  return match ? match.prefix + match.whitespace : text2;
}
var name11 = "AI_InvalidToolArgumentsError";
var marker11 = `vercel.ai.error.${name11}`;
var symbol11 = Symbol.for(marker11);
var _a11;
var InvalidToolArgumentsError = class extends AISDKError {
  constructor({
    toolArgs,
    toolName,
    cause,
    message = `Invalid arguments for tool ${toolName}: ${getErrorMessage$1(
      cause
    )}`
  }) {
    super({ name: name11, message, cause });
    this[_a11] = true;
    this.toolArgs = toolArgs;
    this.toolName = toolName;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker11);
  }
};
_a11 = symbol11;
var name12 = "AI_NoSuchToolError";
var marker12 = `vercel.ai.error.${name12}`;
var symbol12 = Symbol.for(marker12);
var _a12;
var NoSuchToolError = class extends AISDKError {
  constructor({
    toolName,
    availableTools = void 0,
    message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? "No tools are available." : `Available tools: ${availableTools.join(", ")}.`}`
  }) {
    super({ name: name12, message });
    this[_a12] = true;
    this.toolName = toolName;
    this.availableTools = availableTools;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker12);
  }
};
_a12 = symbol12;
var name13 = "AI_ToolCallRepairError";
var marker13 = `vercel.ai.error.${name13}`;
var symbol13 = Symbol.for(marker13);
var _a13;
var ToolCallRepairError = class extends AISDKError {
  constructor({
    cause,
    originalError,
    message = `Error repairing tool call: ${getErrorMessage$1(cause)}`
  }) {
    super({ name: name13, message, cause });
    this[_a13] = true;
    this.originalError = originalError;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker13);
  }
};
_a13 = symbol13;

// core/generate-text/parse-tool-call.ts
async function parseToolCall({
  toolCall,
  tools,
  repairToolCall,
  system,
  messages
}) {
  if (tools == null) {
    throw new NoSuchToolError({ toolName: toolCall.toolName });
  }
  try {
    return await doParseToolCall({ toolCall, tools });
  } catch (error) {
    if (repairToolCall == null || !(NoSuchToolError.isInstance(error) || InvalidToolArgumentsError.isInstance(error))) {
      throw error;
    }
    let repairedToolCall = null;
    try {
      repairedToolCall = await repairToolCall({
        toolCall,
        tools,
        parameterSchema: ({ toolName }) => asSchema(tools[toolName].parameters).jsonSchema,
        system,
        messages,
        error
      });
    } catch (repairError) {
      throw new ToolCallRepairError({
        cause: repairError,
        originalError: error
      });
    }
    if (repairedToolCall == null) {
      throw error;
    }
    return await doParseToolCall({ toolCall: repairedToolCall, tools });
  }
}
async function doParseToolCall({
  toolCall,
  tools
}) {
  const toolName = toolCall.toolName;
  const tool2 = tools[toolName];
  if (tool2 == null) {
    throw new NoSuchToolError({
      toolName: toolCall.toolName,
      availableTools: Object.keys(tools)
    });
  }
  const schema = asSchema(tool2.parameters);
  const parseResult = toolCall.args.trim() === "" ? safeValidateTypes({ value: {}, schema }) : safeParseJSON({ text: toolCall.args, schema });
  if (parseResult.success === false) {
    throw new InvalidToolArgumentsError({
      toolName,
      toolArgs: toolCall.args,
      cause: parseResult.error
    });
  }
  return {
    type: "tool-call",
    toolCallId: toolCall.toolCallId,
    toolName,
    args: parseResult.value
  };
}

// core/generate-text/reasoning-detail.ts
function asReasoningText(reasoning) {
  const reasoningText = reasoning.filter((part) => part.type === "text").map((part) => part.text).join("");
  return reasoningText.length > 0 ? reasoningText : void 0;
}

// core/generate-text/to-response-messages.ts
function toResponseMessages({
  text: text2 = "",
  files,
  reasoning,
  tools,
  toolCalls,
  toolResults,
  messageId,
  generateMessageId
}) {
  const responseMessages = [];
  const content = [];
  if (reasoning.length > 0) {
    content.push(
      ...reasoning.map(
        (part) => part.type === "text" ? { ...part, type: "reasoning" } : { ...part, type: "redacted-reasoning" }
      )
    );
  }
  if (files.length > 0) {
    content.push(
      ...files.map((file) => ({
        type: "file",
        data: file.base64,
        mimeType: file.mimeType
      }))
    );
  }
  if (text2.length > 0) {
    content.push({ type: "text", text: text2 });
  }
  if (toolCalls.length > 0) {
    content.push(...toolCalls);
  }
  if (content.length > 0) {
    responseMessages.push({
      role: "assistant",
      content,
      id: messageId
    });
  }
  if (toolResults.length > 0) {
    responseMessages.push({
      role: "tool",
      id: generateMessageId(),
      content: toolResults.map((toolResult) => {
        const tool2 = tools[toolResult.toolName];
        return (tool2 == null ? void 0 : tool2.experimental_toToolResultContent) != null ? {
          type: "tool-result",
          toolCallId: toolResult.toolCallId,
          toolName: toolResult.toolName,
          result: tool2.experimental_toToolResultContent(toolResult.result),
          experimental_content: tool2.experimental_toToolResultContent(
            toolResult.result
          )
        } : {
          type: "tool-result",
          toolCallId: toolResult.toolCallId,
          toolName: toolResult.toolName,
          result: toolResult.result
        };
      })
    });
  }
  return responseMessages;
}

// core/generate-text/generate-text.ts
var originalGenerateId3 = createIdGenerator({
  prefix: "aitxt",
  size: 24
});
var originalGenerateMessageId = createIdGenerator({
  prefix: "msg",
  size: 24
});
async function generateText({
  model,
  tools,
  toolChoice,
  system,
  prompt,
  messages,
  maxRetries: maxRetriesArg,
  abortSignal,
  headers,
  maxSteps = 1,
  experimental_generateMessageId: generateMessageId = originalGenerateMessageId,
  experimental_output: output,
  experimental_continueSteps: continueSteps = false,
  experimental_telemetry: telemetry,
  experimental_providerMetadata,
  providerOptions = experimental_providerMetadata,
  experimental_activeTools: activeTools,
  experimental_prepareStep: prepareStep,
  experimental_repairToolCall: repairToolCall,
  _internal: {
    generateId: generateId3 = originalGenerateId3,
    currentDate = () => /* @__PURE__ */ new Date()
  } = {},
  onStepFinish,
  ...settings
}) {
  var _a17;
  if (maxSteps < 1) {
    throw new InvalidArgumentError({
      parameter: "maxSteps",
      value: maxSteps,
      message: "maxSteps must be at least 1"
    });
  }
  const { maxRetries, retry } = prepareRetries({ maxRetries: maxRetriesArg });
  const baseTelemetryAttributes = getBaseTelemetryAttributes({
    model,
    telemetry,
    headers,
    settings: { ...settings, maxRetries }
  });
  const initialPrompt = standardizePrompt({
    prompt: {
      system: (_a17 = output == null ? void 0 : output.injectIntoSystemPrompt({ system, model })) != null ? _a17 : system,
      prompt,
      messages
    },
    tools
  });
  const tracer = getTracer(telemetry);
  return recordSpan({
    name: "ai.generateText",
    attributes: selectTelemetryAttributes({
      telemetry,
      attributes: {
        ...assembleOperationName({
          operationId: "ai.generateText",
          telemetry
        }),
        ...baseTelemetryAttributes,
        // model:
        "ai.model.provider": model.provider,
        "ai.model.id": model.modelId,
        // specific settings that only make sense on the outer level:
        "ai.prompt": {
          input: () => JSON.stringify({ system, prompt, messages })
        },
        "ai.settings.maxSteps": maxSteps
      }
    }),
    tracer,
    fn: async (span) => {
      var _a18, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
      const callSettings = prepareCallSettings(settings);
      let currentModelResponse;
      let currentToolCalls = [];
      let currentToolResults = [];
      let currentReasoningDetails = [];
      let stepCount = 0;
      const responseMessages = [];
      let text2 = "";
      const sources = [];
      const steps = [];
      let usage = {
        completionTokens: 0,
        promptTokens: 0,
        totalTokens: 0
      };
      let stepType = "initial";
      do {
        const promptFormat = stepCount === 0 ? initialPrompt.type : "messages";
        const stepInputMessages = [
          ...initialPrompt.messages,
          ...responseMessages
        ];
        const prepareStepResult = await (prepareStep == null ? void 0 : prepareStep({
          model,
          steps,
          maxSteps,
          stepNumber: stepCount
        }));
        const stepToolChoice = (_a18 = prepareStepResult == null ? void 0 : prepareStepResult.toolChoice) != null ? _a18 : toolChoice;
        const stepActiveTools = (_b = prepareStepResult == null ? void 0 : prepareStepResult.experimental_activeTools) != null ? _b : activeTools;
        const stepModel = (_c = prepareStepResult == null ? void 0 : prepareStepResult.model) != null ? _c : model;
        const promptMessages = await convertToLanguageModelPrompt({
          prompt: {
            system: initialPrompt.system,
            messages: stepInputMessages
          },
          modelSupportsImageUrls: stepModel.supportsImageUrls,
          modelSupportsUrl: (_d = stepModel.supportsUrl) == null ? void 0 : _d.bind(stepModel)
          // support 'this' context
        });
        const mode = {
          type: "regular",
          ...prepareToolsAndToolChoice({
            tools,
            toolChoice: stepToolChoice,
            activeTools: stepActiveTools
          })
        };
        currentModelResponse = await retry(
          () => recordSpan({
            name: "ai.generateText.doGenerate",
            attributes: selectTelemetryAttributes({
              telemetry,
              attributes: {
                ...assembleOperationName({
                  operationId: "ai.generateText.doGenerate",
                  telemetry
                }),
                ...baseTelemetryAttributes,
                // model:
                "ai.model.provider": stepModel.provider,
                "ai.model.id": stepModel.modelId,
                // prompt:
                "ai.prompt.format": { input: () => promptFormat },
                "ai.prompt.messages": {
                  input: () => JSON.stringify(promptMessages)
                },
                "ai.prompt.tools": {
                  // convert the language model level tools:
                  input: () => {
                    var _a19;
                    return (_a19 = mode.tools) == null ? void 0 : _a19.map((tool2) => JSON.stringify(tool2));
                  }
                },
                "ai.prompt.toolChoice": {
                  input: () => mode.toolChoice != null ? JSON.stringify(mode.toolChoice) : void 0
                },
                // standardized gen-ai llm span attributes:
                "gen_ai.system": stepModel.provider,
                "gen_ai.request.model": stepModel.modelId,
                "gen_ai.request.frequency_penalty": settings.frequencyPenalty,
                "gen_ai.request.max_tokens": settings.maxTokens,
                "gen_ai.request.presence_penalty": settings.presencePenalty,
                "gen_ai.request.stop_sequences": settings.stopSequences,
                "gen_ai.request.temperature": settings.temperature,
                "gen_ai.request.top_k": settings.topK,
                "gen_ai.request.top_p": settings.topP
              }
            }),
            tracer,
            fn: async (span2) => {
              var _a19, _b2, _c2, _d2, _e2, _f2;
              const result = await stepModel.doGenerate({
                mode,
                ...callSettings,
                inputFormat: promptFormat,
                responseFormat: output == null ? void 0 : output.responseFormat({ model }),
                prompt: promptMessages,
                providerMetadata: providerOptions,
                abortSignal,
                headers
              });
              const responseData = {
                id: (_b2 = (_a19 = result.response) == null ? void 0 : _a19.id) != null ? _b2 : generateId3(),
                timestamp: (_d2 = (_c2 = result.response) == null ? void 0 : _c2.timestamp) != null ? _d2 : currentDate(),
                modelId: (_f2 = (_e2 = result.response) == null ? void 0 : _e2.modelId) != null ? _f2 : stepModel.modelId
              };
              span2.setAttributes(
                selectTelemetryAttributes({
                  telemetry,
                  attributes: {
                    "ai.response.finishReason": result.finishReason,
                    "ai.response.text": {
                      output: () => result.text
                    },
                    "ai.response.toolCalls": {
                      output: () => JSON.stringify(result.toolCalls)
                    },
                    "ai.response.id": responseData.id,
                    "ai.response.model": responseData.modelId,
                    "ai.response.timestamp": responseData.timestamp.toISOString(),
                    "ai.usage.promptTokens": result.usage.promptTokens,
                    "ai.usage.completionTokens": result.usage.completionTokens,
                    // standardized gen-ai llm span attributes:
                    "gen_ai.response.finish_reasons": [result.finishReason],
                    "gen_ai.response.id": responseData.id,
                    "gen_ai.response.model": responseData.modelId,
                    "gen_ai.usage.input_tokens": result.usage.promptTokens,
                    "gen_ai.usage.output_tokens": result.usage.completionTokens
                  }
                })
              );
              return { ...result, response: responseData };
            }
          })
        );
        currentToolCalls = await Promise.all(
          ((_e = currentModelResponse.toolCalls) != null ? _e : []).map(
            (toolCall) => parseToolCall({
              toolCall,
              tools,
              repairToolCall,
              system,
              messages: stepInputMessages
            })
          )
        );
        currentToolResults = tools == null ? [] : await executeTools({
          toolCalls: currentToolCalls,
          tools,
          tracer,
          telemetry,
          messages: stepInputMessages,
          abortSignal
        });
        const currentUsage = calculateLanguageModelUsage(
          currentModelResponse.usage
        );
        usage = addLanguageModelUsage(usage, currentUsage);
        let nextStepType = "done";
        if (++stepCount < maxSteps) {
          if (continueSteps && currentModelResponse.finishReason === "length" && // only use continue when there are no tool calls:
          currentToolCalls.length === 0) {
            nextStepType = "continue";
          } else if (
            // there are tool calls:
            currentToolCalls.length > 0 && // all current tool calls have results:
            currentToolResults.length === currentToolCalls.length
          ) {
            nextStepType = "tool-result";
          }
        }
        const originalText = (_f = currentModelResponse.text) != null ? _f : "";
        const stepTextLeadingWhitespaceTrimmed = stepType === "continue" && // only for continue steps
        text2.trimEnd() !== text2 ? originalText.trimStart() : originalText;
        const stepText = nextStepType === "continue" ? removeTextAfterLastWhitespace(stepTextLeadingWhitespaceTrimmed) : stepTextLeadingWhitespaceTrimmed;
        text2 = nextStepType === "continue" || stepType === "continue" ? text2 + stepText : stepText;
        currentReasoningDetails = asReasoningDetails(
          currentModelResponse.reasoning
        );
        sources.push(...(_g = currentModelResponse.sources) != null ? _g : []);
        if (stepType === "continue") {
          const lastMessage = responseMessages[responseMessages.length - 1];
          if (typeof lastMessage.content === "string") {
            lastMessage.content += stepText;
          } else {
            lastMessage.content.push({
              text: stepText,
              type: "text"
            });
          }
        } else {
          responseMessages.push(
            ...toResponseMessages({
              text: text2,
              files: asFiles(currentModelResponse.files),
              reasoning: asReasoningDetails(currentModelResponse.reasoning),
              tools: tools != null ? tools : {},
              toolCalls: currentToolCalls,
              toolResults: currentToolResults,
              messageId: generateMessageId(),
              generateMessageId
            })
          );
        }
        const currentStepResult = {
          stepType,
          text: stepText,
          // TODO v5: rename reasoning to reasoningText (and use reasoning for composite array)
          reasoning: asReasoningText(currentReasoningDetails),
          reasoningDetails: currentReasoningDetails,
          files: asFiles(currentModelResponse.files),
          sources: (_h = currentModelResponse.sources) != null ? _h : [],
          toolCalls: currentToolCalls,
          toolResults: currentToolResults,
          finishReason: currentModelResponse.finishReason,
          usage: currentUsage,
          warnings: currentModelResponse.warnings,
          logprobs: currentModelResponse.logprobs,
          request: (_i = currentModelResponse.request) != null ? _i : {},
          response: {
            ...currentModelResponse.response,
            headers: (_j = currentModelResponse.rawResponse) == null ? void 0 : _j.headers,
            body: (_k = currentModelResponse.rawResponse) == null ? void 0 : _k.body,
            // deep clone msgs to avoid mutating past messages in multi-step:
            messages: structuredClone(responseMessages)
          },
          providerMetadata: currentModelResponse.providerMetadata,
          experimental_providerMetadata: currentModelResponse.providerMetadata,
          isContinued: nextStepType === "continue"
        };
        steps.push(currentStepResult);
        await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));
        stepType = nextStepType;
      } while (stepType !== "done");
      span.setAttributes(
        selectTelemetryAttributes({
          telemetry,
          attributes: {
            "ai.response.finishReason": currentModelResponse.finishReason,
            "ai.response.text": {
              output: () => currentModelResponse.text
            },
            "ai.response.toolCalls": {
              output: () => JSON.stringify(currentModelResponse.toolCalls)
            },
            "ai.usage.promptTokens": currentModelResponse.usage.promptTokens,
            "ai.usage.completionTokens": currentModelResponse.usage.completionTokens
          }
        })
      );
      return new DefaultGenerateTextResult({
        text: text2,
        files: asFiles(currentModelResponse.files),
        reasoning: asReasoningText(currentReasoningDetails),
        reasoningDetails: currentReasoningDetails,
        sources,
        outputResolver: () => {
          if (output == null) {
            throw new NoOutputSpecifiedError();
          }
          return output.parseOutput(
            { text: text2 },
            {
              response: currentModelResponse.response,
              usage,
              finishReason: currentModelResponse.finishReason
            }
          );
        },
        toolCalls: currentToolCalls,
        toolResults: currentToolResults,
        finishReason: currentModelResponse.finishReason,
        usage,
        warnings: currentModelResponse.warnings,
        request: (_l = currentModelResponse.request) != null ? _l : {},
        response: {
          ...currentModelResponse.response,
          headers: (_m = currentModelResponse.rawResponse) == null ? void 0 : _m.headers,
          body: (_n = currentModelResponse.rawResponse) == null ? void 0 : _n.body,
          messages: responseMessages
        },
        logprobs: currentModelResponse.logprobs,
        steps,
        providerMetadata: currentModelResponse.providerMetadata
      });
    }
  });
}
async function executeTools({
  toolCalls,
  tools,
  tracer,
  telemetry,
  messages,
  abortSignal
}) {
  const toolResults = await Promise.all(
    toolCalls.map(async ({ toolCallId, toolName, args }) => {
      const tool2 = tools[toolName];
      if ((tool2 == null ? void 0 : tool2.execute) == null) {
        return void 0;
      }
      const result = await recordSpan({
        name: "ai.toolCall",
        attributes: selectTelemetryAttributes({
          telemetry,
          attributes: {
            ...assembleOperationName({
              operationId: "ai.toolCall",
              telemetry
            }),
            "ai.toolCall.name": toolName,
            "ai.toolCall.id": toolCallId,
            "ai.toolCall.args": {
              output: () => JSON.stringify(args)
            }
          }
        }),
        tracer,
        fn: async (span) => {
          try {
            const result2 = await tool2.execute(args, {
              toolCallId,
              messages,
              abortSignal
            });
            try {
              span.setAttributes(
                selectTelemetryAttributes({
                  telemetry,
                  attributes: {
                    "ai.toolCall.result": {
                      output: () => JSON.stringify(result2)
                    }
                  }
                })
              );
            } catch (ignored) {
            }
            return result2;
          } catch (error) {
            throw new ToolExecutionError({
              toolCallId,
              toolName,
              toolArgs: args,
              cause: error
            });
          }
        }
      });
      return {
        type: "tool-result",
        toolCallId,
        toolName,
        args,
        result
      };
    })
  );
  return toolResults.filter(
    (result) => result != null
  );
}
var DefaultGenerateTextResult = class {
  constructor(options) {
    this.text = options.text;
    this.files = options.files;
    this.reasoning = options.reasoning;
    this.reasoningDetails = options.reasoningDetails;
    this.toolCalls = options.toolCalls;
    this.toolResults = options.toolResults;
    this.finishReason = options.finishReason;
    this.usage = options.usage;
    this.warnings = options.warnings;
    this.request = options.request;
    this.response = options.response;
    this.steps = options.steps;
    this.experimental_providerMetadata = options.providerMetadata;
    this.providerMetadata = options.providerMetadata;
    this.logprobs = options.logprobs;
    this.outputResolver = options.outputResolver;
    this.sources = options.sources;
  }
  get experimental_output() {
    return this.outputResolver();
  }
};
function asReasoningDetails(reasoning) {
  if (reasoning == null) {
    return [];
  }
  if (typeof reasoning === "string") {
    return [{ type: "text", text: reasoning }];
  }
  return reasoning;
}
function asFiles(files) {
  var _a17;
  return (_a17 = files == null ? void 0 : files.map((file) => new DefaultGeneratedFile(file))) != null ? _a17 : [];
}

// core/generate-text/output.ts
var output_exports = {};
__export(output_exports, {
  object: () => object,
  text: () => text
});
var name14 = "AI_InvalidStreamPartError";
var marker14 = `vercel.ai.error.${name14}`;
var symbol14 = Symbol.for(marker14);
var _a14;
var InvalidStreamPartError = class extends AISDKError {
  constructor({
    chunk,
    message
  }) {
    super({ name: name14, message });
    this[_a14] = true;
    this.chunk = chunk;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker14);
  }
};
_a14 = symbol14;

// core/generate-text/output.ts
var text = () => ({
  type: "text",
  responseFormat: () => ({ type: "text" }),
  injectIntoSystemPrompt({ system }) {
    return system;
  },
  parsePartial({ text: text2 }) {
    return { partial: text2 };
  },
  parseOutput({ text: text2 }) {
    return text2;
  }
});
var object = ({
  schema: inputSchema
}) => {
  const schema = asSchema(inputSchema);
  return {
    type: "object",
    responseFormat: ({ model }) => ({
      type: "json",
      schema: model.supportsStructuredOutputs ? schema.jsonSchema : void 0
    }),
    injectIntoSystemPrompt({ system, model }) {
      return model.supportsStructuredOutputs ? system : injectJsonInstruction({
        prompt: system,
        schema: schema.jsonSchema
      });
    },
    parsePartial({ text: text2 }) {
      const result = parsePartialJson(text2);
      switch (result.state) {
        case "failed-parse":
        case "undefined-input":
          return void 0;
        case "repaired-parse":
        case "successful-parse":
          return {
            // Note: currently no validation of partial results:
            partial: result.value
          };
        default: {
          const _exhaustiveCheck = result.state;
          throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);
        }
      }
    },
    parseOutput({ text: text2 }, context) {
      const parseResult = safeParseJSON({ text: text2 });
      if (!parseResult.success) {
        throw new NoObjectGeneratedError({
          message: "No object generated: could not parse the response.",
          cause: parseResult.error,
          text: text2,
          response: context.response,
          usage: context.usage,
          finishReason: context.finishReason
        });
      }
      const validationResult = safeValidateTypes({
        value: parseResult.value,
        schema
      });
      if (!validationResult.success) {
        throw new NoObjectGeneratedError({
          message: "No object generated: response did not match schema.",
          cause: validationResult.error,
          text: text2,
          response: context.response,
          usage: context.usage,
          finishReason: context.finishReason
        });
      }
      return validationResult.value;
    }
  };
};

// util/as-array.ts
function asArray(value) {
  return value === void 0 ? [] : Array.isArray(value) ? value : [value];
}

// util/consume-stream.ts
async function consumeStream({
  stream,
  onError
}) {
  const reader = stream.getReader();
  try {
    while (true) {
      const { done } = await reader.read();
      if (done)
        break;
    }
  } catch (error) {
    onError == null ? void 0 : onError(error);
  } finally {
    reader.releaseLock();
  }
}

// core/util/merge-streams.ts
function mergeStreams(stream1, stream2) {
  const reader1 = stream1.getReader();
  const reader2 = stream2.getReader();
  let lastRead1 = void 0;
  let lastRead2 = void 0;
  let stream1Done = false;
  let stream2Done = false;
  async function readStream1(controller) {
    try {
      if (lastRead1 == null) {
        lastRead1 = reader1.read();
      }
      const result = await lastRead1;
      lastRead1 = void 0;
      if (!result.done) {
        controller.enqueue(result.value);
      } else {
        controller.close();
      }
    } catch (error) {
      controller.error(error);
    }
  }
  async function readStream2(controller) {
    try {
      if (lastRead2 == null) {
        lastRead2 = reader2.read();
      }
      const result = await lastRead2;
      lastRead2 = void 0;
      if (!result.done) {
        controller.enqueue(result.value);
      } else {
        controller.close();
      }
    } catch (error) {
      controller.error(error);
    }
  }
  return new ReadableStream({
    async pull(controller) {
      try {
        if (stream1Done) {
          await readStream2(controller);
          return;
        }
        if (stream2Done) {
          await readStream1(controller);
          return;
        }
        if (lastRead1 == null) {
          lastRead1 = reader1.read();
        }
        if (lastRead2 == null) {
          lastRead2 = reader2.read();
        }
        const { result, reader } = await Promise.race([
          lastRead1.then((result2) => ({ result: result2, reader: reader1 })),
          lastRead2.then((result2) => ({ result: result2, reader: reader2 }))
        ]);
        if (!result.done) {
          controller.enqueue(result.value);
        }
        if (reader === reader1) {
          lastRead1 = void 0;
          if (result.done) {
            await readStream2(controller);
            stream1Done = true;
          }
        } else {
          lastRead2 = void 0;
          if (result.done) {
            stream2Done = true;
            await readStream1(controller);
          }
        }
      } catch (error) {
        controller.error(error);
      }
    },
    cancel() {
      reader1.cancel();
      reader2.cancel();
    }
  });
}
function runToolsTransformation({
  tools,
  generatorStream,
  toolCallStreaming,
  tracer,
  telemetry,
  system,
  messages,
  abortSignal,
  repairToolCall
}) {
  let toolResultsStreamController = null;
  const toolResultsStream = new ReadableStream({
    start(controller) {
      toolResultsStreamController = controller;
    }
  });
  const activeToolCalls = {};
  const outstandingToolResults = /* @__PURE__ */ new Set();
  let canClose = false;
  let finishChunk = void 0;
  function attemptClose() {
    if (canClose && outstandingToolResults.size === 0) {
      if (finishChunk != null) {
        toolResultsStreamController.enqueue(finishChunk);
      }
      toolResultsStreamController.close();
    }
  }
  const forwardStream = new TransformStream({
    async transform(chunk, controller) {
      const chunkType = chunk.type;
      switch (chunkType) {
        case "text-delta":
        case "reasoning":
        case "reasoning-signature":
        case "redacted-reasoning":
        case "source":
        case "response-metadata":
        case "error": {
          controller.enqueue(chunk);
          break;
        }
        case "file": {
          controller.enqueue(
            new DefaultGeneratedFileWithType({
              data: chunk.data,
              mimeType: chunk.mimeType
            })
          );
          break;
        }
        case "tool-call-delta": {
          if (toolCallStreaming) {
            if (!activeToolCalls[chunk.toolCallId]) {
              controller.enqueue({
                type: "tool-call-streaming-start",
                toolCallId: chunk.toolCallId,
                toolName: chunk.toolName
              });
              activeToolCalls[chunk.toolCallId] = true;
            }
            controller.enqueue({
              type: "tool-call-delta",
              toolCallId: chunk.toolCallId,
              toolName: chunk.toolName,
              argsTextDelta: chunk.argsTextDelta
            });
          }
          break;
        }
        case "tool-call": {
          try {
            const toolCall = await parseToolCall({
              toolCall: chunk,
              tools,
              repairToolCall,
              system,
              messages
            });
            controller.enqueue(toolCall);
            const tool2 = tools[toolCall.toolName];
            if (tool2.execute != null) {
              const toolExecutionId = generateId();
              outstandingToolResults.add(toolExecutionId);
              recordSpan({
                name: "ai.toolCall",
                attributes: selectTelemetryAttributes({
                  telemetry,
                  attributes: {
                    ...assembleOperationName({
                      operationId: "ai.toolCall",
                      telemetry
                    }),
                    "ai.toolCall.name": toolCall.toolName,
                    "ai.toolCall.id": toolCall.toolCallId,
                    "ai.toolCall.args": {
                      output: () => JSON.stringify(toolCall.args)
                    }
                  }
                }),
                tracer,
                fn: async (span) => tool2.execute(toolCall.args, {
                  toolCallId: toolCall.toolCallId,
                  messages,
                  abortSignal
                }).then(
                  (result) => {
                    toolResultsStreamController.enqueue({
                      ...toolCall,
                      type: "tool-result",
                      result
                    });
                    outstandingToolResults.delete(toolExecutionId);
                    attemptClose();
                    try {
                      span.setAttributes(
                        selectTelemetryAttributes({
                          telemetry,
                          attributes: {
                            "ai.toolCall.result": {
                              output: () => JSON.stringify(result)
                            }
                          }
                        })
                      );
                    } catch (ignored) {
                    }
                  },
                  (error) => {
                    toolResultsStreamController.enqueue({
                      type: "error",
                      error: new ToolExecutionError({
                        toolCallId: toolCall.toolCallId,
                        toolName: toolCall.toolName,
                        toolArgs: toolCall.args,
                        cause: error
                      })
                    });
                    outstandingToolResults.delete(toolExecutionId);
                    attemptClose();
                  }
                )
              });
            }
          } catch (error) {
            toolResultsStreamController.enqueue({
              type: "error",
              error
            });
          }
          break;
        }
        case "finish": {
          finishChunk = {
            type: "finish",
            finishReason: chunk.finishReason,
            logprobs: chunk.logprobs,
            usage: calculateLanguageModelUsage(chunk.usage),
            experimental_providerMetadata: chunk.providerMetadata
          };
          break;
        }
        default: {
          const _exhaustiveCheck = chunkType;
          throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);
        }
      }
    },
    flush() {
      canClose = true;
      attemptClose();
    }
  });
  return new ReadableStream({
    async start(controller) {
      return Promise.all([
        generatorStream.pipeThrough(forwardStream).pipeTo(
          new WritableStream({
            write(chunk) {
              controller.enqueue(chunk);
            },
            close() {
            }
          })
        ),
        toolResultsStream.pipeTo(
          new WritableStream({
            write(chunk) {
              controller.enqueue(chunk);
            },
            close() {
              controller.close();
            }
          })
        )
      ]);
    }
  });
}

// core/generate-text/stream-text.ts
var originalGenerateId4 = createIdGenerator({
  prefix: "aitxt",
  size: 24
});
var originalGenerateMessageId2 = createIdGenerator({
  prefix: "msg",
  size: 24
});
function streamText({
  model,
  tools,
  toolChoice,
  system,
  prompt,
  messages,
  maxRetries,
  abortSignal,
  headers,
  maxSteps = 1,
  experimental_generateMessageId: generateMessageId = originalGenerateMessageId2,
  experimental_output: output,
  experimental_continueSteps: continueSteps = false,
  experimental_telemetry: telemetry,
  experimental_providerMetadata,
  providerOptions = experimental_providerMetadata,
  experimental_toolCallStreaming = false,
  toolCallStreaming = experimental_toolCallStreaming,
  experimental_activeTools: activeTools,
  experimental_repairToolCall: repairToolCall,
  experimental_transform: transform,
  onChunk,
  onError,
  onFinish,
  onStepFinish,
  _internal: {
    now: now2 = now,
    generateId: generateId3 = originalGenerateId4,
    currentDate = () => /* @__PURE__ */ new Date()
  } = {},
  ...settings
}) {
  return new DefaultStreamTextResult({
    model,
    telemetry,
    headers,
    settings,
    maxRetries,
    abortSignal,
    system,
    prompt,
    messages,
    tools,
    toolChoice,
    toolCallStreaming,
    transforms: asArray(transform),
    activeTools,
    repairToolCall,
    maxSteps,
    output,
    continueSteps,
    providerOptions,
    onChunk,
    onError,
    onFinish,
    onStepFinish,
    now: now2,
    currentDate,
    generateId: generateId3,
    generateMessageId
  });
}
function createOutputTransformStream(output) {
  if (!output) {
    return new TransformStream({
      transform(chunk, controller) {
        controller.enqueue({ part: chunk, partialOutput: void 0 });
      }
    });
  }
  let text2 = "";
  let textChunk = "";
  let lastPublishedJson = "";
  function publishTextChunk({
    controller,
    partialOutput = void 0
  }) {
    controller.enqueue({
      part: { type: "text-delta", textDelta: textChunk },
      partialOutput
    });
    textChunk = "";
  }
  return new TransformStream({
    transform(chunk, controller) {
      if (chunk.type === "step-finish") {
        publishTextChunk({ controller });
      }
      if (chunk.type !== "text-delta") {
        controller.enqueue({ part: chunk, partialOutput: void 0 });
        return;
      }
      text2 += chunk.textDelta;
      textChunk += chunk.textDelta;
      const result = output.parsePartial({ text: text2 });
      if (result != null) {
        const currentJson = JSON.stringify(result.partial);
        if (currentJson !== lastPublishedJson) {
          publishTextChunk({ controller, partialOutput: result.partial });
          lastPublishedJson = currentJson;
        }
      }
    },
    flush(controller) {
      if (textChunk.length > 0) {
        publishTextChunk({ controller });
      }
    }
  });
}
var DefaultStreamTextResult = class {
  constructor({
    model,
    telemetry,
    headers,
    settings,
    maxRetries: maxRetriesArg,
    abortSignal,
    system,
    prompt,
    messages,
    tools,
    toolChoice,
    toolCallStreaming,
    transforms,
    activeTools,
    repairToolCall,
    maxSteps,
    output,
    continueSteps,
    providerOptions,
    now: now2,
    currentDate,
    generateId: generateId3,
    generateMessageId,
    onChunk,
    onError,
    onFinish,
    onStepFinish
  }) {
    this.warningsPromise = new DelayedPromise();
    this.usagePromise = new DelayedPromise();
    this.finishReasonPromise = new DelayedPromise();
    this.providerMetadataPromise = new DelayedPromise();
    this.textPromise = new DelayedPromise();
    this.reasoningPromise = new DelayedPromise();
    this.reasoningDetailsPromise = new DelayedPromise();
    this.sourcesPromise = new DelayedPromise();
    this.filesPromise = new DelayedPromise();
    this.toolCallsPromise = new DelayedPromise();
    this.toolResultsPromise = new DelayedPromise();
    this.requestPromise = new DelayedPromise();
    this.responsePromise = new DelayedPromise();
    this.stepsPromise = new DelayedPromise();
    var _a17;
    if (maxSteps < 1) {
      throw new InvalidArgumentError({
        parameter: "maxSteps",
        value: maxSteps,
        message: "maxSteps must be at least 1"
      });
    }
    this.output = output;
    let recordedStepText = "";
    let recordedContinuationText = "";
    let recordedFullText = "";
    let stepReasoning = [];
    let stepFiles = [];
    let activeReasoningText = void 0;
    let recordedStepSources = [];
    const recordedSources = [];
    const recordedResponse = {
      id: generateId3(),
      timestamp: currentDate(),
      modelId: model.modelId,
      messages: []
    };
    let recordedToolCalls = [];
    let recordedToolResults = [];
    let recordedFinishReason = void 0;
    let recordedUsage = void 0;
    let stepType = "initial";
    const recordedSteps = [];
    let rootSpan;
    const eventProcessor = new TransformStream({
      async transform(chunk, controller) {
        controller.enqueue(chunk);
        const { part } = chunk;
        if (part.type === "text-delta" || part.type === "reasoning" || part.type === "source" || part.type === "tool-call" || part.type === "tool-result" || part.type === "tool-call-streaming-start" || part.type === "tool-call-delta") {
          await (onChunk == null ? void 0 : onChunk({ chunk: part }));
        }
        if (part.type === "error") {
          await (onError == null ? void 0 : onError({ error: part.error }));
        }
        if (part.type === "text-delta") {
          recordedStepText += part.textDelta;
          recordedContinuationText += part.textDelta;
          recordedFullText += part.textDelta;
        }
        if (part.type === "reasoning") {
          if (activeReasoningText == null) {
            activeReasoningText = { type: "text", text: part.textDelta };
            stepReasoning.push(activeReasoningText);
          } else {
            activeReasoningText.text += part.textDelta;
          }
        }
        if (part.type === "reasoning-signature") {
          if (activeReasoningText == null) {
            throw new AISDKError({
              name: "InvalidStreamPart",
              message: "reasoning-signature without reasoning"
            });
          }
          activeReasoningText.signature = part.signature;
          activeReasoningText = void 0;
        }
        if (part.type === "redacted-reasoning") {
          stepReasoning.push({ type: "redacted", data: part.data });
        }
        if (part.type === "file") {
          stepFiles.push(part);
        }
        if (part.type === "source") {
          recordedSources.push(part.source);
          recordedStepSources.push(part.source);
        }
        if (part.type === "tool-call") {
          recordedToolCalls.push(part);
        }
        if (part.type === "tool-result") {
          recordedToolResults.push(part);
        }
        if (part.type === "step-finish") {
          const stepMessages = toResponseMessages({
            text: recordedContinuationText,
            files: stepFiles,
            reasoning: stepReasoning,
            tools: tools != null ? tools : {},
            toolCalls: recordedToolCalls,
            toolResults: recordedToolResults,
            messageId: part.messageId,
            generateMessageId
          });
          const currentStep = recordedSteps.length;
          let nextStepType = "done";
          if (currentStep + 1 < maxSteps) {
            if (continueSteps && part.finishReason === "length" && // only use continue when there are no tool calls:
            recordedToolCalls.length === 0) {
              nextStepType = "continue";
            } else if (
              // there are tool calls:
              recordedToolCalls.length > 0 && // all current tool calls have results:
              recordedToolResults.length === recordedToolCalls.length
            ) {
              nextStepType = "tool-result";
            }
          }
          const currentStepResult = {
            stepType,
            text: recordedStepText,
            reasoning: asReasoningText(stepReasoning),
            reasoningDetails: stepReasoning,
            files: stepFiles,
            sources: recordedStepSources,
            toolCalls: recordedToolCalls,
            toolResults: recordedToolResults,
            finishReason: part.finishReason,
            usage: part.usage,
            warnings: part.warnings,
            logprobs: part.logprobs,
            request: part.request,
            response: {
              ...part.response,
              messages: [...recordedResponse.messages, ...stepMessages]
            },
            providerMetadata: part.experimental_providerMetadata,
            experimental_providerMetadata: part.experimental_providerMetadata,
            isContinued: part.isContinued
          };
          await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));
          recordedSteps.push(currentStepResult);
          recordedToolCalls = [];
          recordedToolResults = [];
          recordedStepText = "";
          recordedStepSources = [];
          stepReasoning = [];
          stepFiles = [];
          activeReasoningText = void 0;
          if (nextStepType !== "done") {
            stepType = nextStepType;
          }
          if (nextStepType !== "continue") {
            recordedResponse.messages.push(...stepMessages);
            recordedContinuationText = "";
          }
        }
        if (part.type === "finish") {
          recordedResponse.id = part.response.id;
          recordedResponse.timestamp = part.response.timestamp;
          recordedResponse.modelId = part.response.modelId;
          recordedResponse.headers = part.response.headers;
          recordedUsage = part.usage;
          recordedFinishReason = part.finishReason;
        }
      },
      async flush(controller) {
        var _a18;
        try {
          if (recordedSteps.length === 0) {
            return;
          }
          const lastStep = recordedSteps[recordedSteps.length - 1];
          self.warningsPromise.resolve(lastStep.warnings);
          self.requestPromise.resolve(lastStep.request);
          self.responsePromise.resolve(lastStep.response);
          self.toolCallsPromise.resolve(lastStep.toolCalls);
          self.toolResultsPromise.resolve(lastStep.toolResults);
          self.providerMetadataPromise.resolve(
            lastStep.experimental_providerMetadata
          );
          self.reasoningPromise.resolve(lastStep.reasoning);
          self.reasoningDetailsPromise.resolve(lastStep.reasoningDetails);
          const finishReason = recordedFinishReason != null ? recordedFinishReason : "unknown";
          const usage = recordedUsage != null ? recordedUsage : {
            completionTokens: NaN,
            promptTokens: NaN,
            totalTokens: NaN
          };
          self.finishReasonPromise.resolve(finishReason);
          self.usagePromise.resolve(usage);
          self.textPromise.resolve(recordedFullText);
          self.sourcesPromise.resolve(recordedSources);
          self.filesPromise.resolve(lastStep.files);
          self.stepsPromise.resolve(recordedSteps);
          await (onFinish == null ? void 0 : onFinish({
            finishReason,
            logprobs: void 0,
            usage,
            text: recordedFullText,
            reasoning: lastStep.reasoning,
            reasoningDetails: lastStep.reasoningDetails,
            files: lastStep.files,
            sources: lastStep.sources,
            toolCalls: lastStep.toolCalls,
            toolResults: lastStep.toolResults,
            request: (_a18 = lastStep.request) != null ? _a18 : {},
            response: lastStep.response,
            warnings: lastStep.warnings,
            providerMetadata: lastStep.providerMetadata,
            experimental_providerMetadata: lastStep.experimental_providerMetadata,
            steps: recordedSteps
          }));
          rootSpan.setAttributes(
            selectTelemetryAttributes({
              telemetry,
              attributes: {
                "ai.response.finishReason": finishReason,
                "ai.response.text": { output: () => recordedFullText },
                "ai.response.toolCalls": {
                  output: () => {
                    var _a19;
                    return ((_a19 = lastStep.toolCalls) == null ? void 0 : _a19.length) ? JSON.stringify(lastStep.toolCalls) : void 0;
                  }
                },
                "ai.usage.promptTokens": usage.promptTokens,
                "ai.usage.completionTokens": usage.completionTokens
              }
            })
          );
        } catch (error) {
          controller.error(error);
        } finally {
          rootSpan.end();
        }
      }
    });
    const stitchableStream = createStitchableStream();
    this.addStream = stitchableStream.addStream;
    this.closeStream = stitchableStream.close;
    let stream = stitchableStream.stream;
    for (const transform of transforms) {
      stream = stream.pipeThrough(
        transform({
          tools,
          stopStream() {
            stitchableStream.terminate();
          }
        })
      );
    }
    this.baseStream = stream.pipeThrough(createOutputTransformStream(output)).pipeThrough(eventProcessor);
    const { maxRetries, retry } = prepareRetries({
      maxRetries: maxRetriesArg
    });
    const tracer = getTracer(telemetry);
    const baseTelemetryAttributes = getBaseTelemetryAttributes({
      model,
      telemetry,
      headers,
      settings: { ...settings, maxRetries }
    });
    const initialPrompt = standardizePrompt({
      prompt: {
        system: (_a17 = output == null ? void 0 : output.injectIntoSystemPrompt({ system, model })) != null ? _a17 : system,
        prompt,
        messages
      },
      tools
    });
    const self = this;
    recordSpan({
      name: "ai.streamText",
      attributes: selectTelemetryAttributes({
        telemetry,
        attributes: {
          ...assembleOperationName({ operationId: "ai.streamText", telemetry }),
          ...baseTelemetryAttributes,
          // specific settings that only make sense on the outer level:
          "ai.prompt": {
            input: () => JSON.stringify({ system, prompt, messages })
          },
          "ai.settings.maxSteps": maxSteps
        }
      }),
      tracer,
      endWhenDone: false,
      fn: async (rootSpanArg) => {
        rootSpan = rootSpanArg;
        async function streamStep({
          currentStep,
          responseMessages,
          usage,
          stepType: stepType2,
          previousStepText,
          hasLeadingWhitespace,
          messageId
        }) {
          var _a18;
          const promptFormat = responseMessages.length === 0 ? initialPrompt.type : "messages";
          const stepInputMessages = [
            ...initialPrompt.messages,
            ...responseMessages
          ];
          const promptMessages = await convertToLanguageModelPrompt({
            prompt: {
              system: initialPrompt.system,
              messages: stepInputMessages
            },
            modelSupportsImageUrls: model.supportsImageUrls,
            modelSupportsUrl: (_a18 = model.supportsUrl) == null ? void 0 : _a18.bind(model)
            // support 'this' context
          });
          const mode = {
            type: "regular",
            ...prepareToolsAndToolChoice({ tools, toolChoice, activeTools })
          };
          const {
            result: { stream: stream2, warnings, rawResponse, request },
            doStreamSpan,
            startTimestampMs
          } = await retry(
            () => recordSpan({
              name: "ai.streamText.doStream",
              attributes: selectTelemetryAttributes({
                telemetry,
                attributes: {
                  ...assembleOperationName({
                    operationId: "ai.streamText.doStream",
                    telemetry
                  }),
                  ...baseTelemetryAttributes,
                  "ai.prompt.format": {
                    input: () => promptFormat
                  },
                  "ai.prompt.messages": {
                    input: () => JSON.stringify(promptMessages)
                  },
                  "ai.prompt.tools": {
                    // convert the language model level tools:
                    input: () => {
                      var _a19;
                      return (_a19 = mode.tools) == null ? void 0 : _a19.map((tool2) => JSON.stringify(tool2));
                    }
                  },
                  "ai.prompt.toolChoice": {
                    input: () => mode.toolChoice != null ? JSON.stringify(mode.toolChoice) : void 0
                  },
                  // standardized gen-ai llm span attributes:
                  "gen_ai.system": model.provider,
                  "gen_ai.request.model": model.modelId,
                  "gen_ai.request.frequency_penalty": settings.frequencyPenalty,
                  "gen_ai.request.max_tokens": settings.maxTokens,
                  "gen_ai.request.presence_penalty": settings.presencePenalty,
                  "gen_ai.request.stop_sequences": settings.stopSequences,
                  "gen_ai.request.temperature": settings.temperature,
                  "gen_ai.request.top_k": settings.topK,
                  "gen_ai.request.top_p": settings.topP
                }
              }),
              tracer,
              endWhenDone: false,
              fn: async (doStreamSpan2) => ({
                startTimestampMs: now2(),
                // get before the call
                doStreamSpan: doStreamSpan2,
                result: await model.doStream({
                  mode,
                  ...prepareCallSettings(settings),
                  inputFormat: promptFormat,
                  responseFormat: output == null ? void 0 : output.responseFormat({ model }),
                  prompt: promptMessages,
                  providerMetadata: providerOptions,
                  abortSignal,
                  headers
                })
              })
            })
          );
          const transformedStream = runToolsTransformation({
            tools,
            generatorStream: stream2,
            toolCallStreaming,
            tracer,
            telemetry,
            system,
            messages: stepInputMessages,
            repairToolCall,
            abortSignal
          });
          const stepRequest = request != null ? request : {};
          const stepToolCalls = [];
          const stepToolResults = [];
          const stepReasoning2 = [];
          const stepFiles2 = [];
          let activeReasoningText2 = void 0;
          let stepFinishReason = "unknown";
          let stepUsage = {
            promptTokens: 0,
            completionTokens: 0,
            totalTokens: 0
          };
          let stepProviderMetadata;
          let stepFirstChunk = true;
          let stepText = "";
          let fullStepText = stepType2 === "continue" ? previousStepText : "";
          let stepLogProbs;
          let stepResponse = {
            id: generateId3(),
            timestamp: currentDate(),
            modelId: model.modelId
          };
          let chunkBuffer = "";
          let chunkTextPublished = false;
          let inWhitespacePrefix = true;
          let hasWhitespaceSuffix = false;
          async function publishTextChunk({
            controller,
            chunk
          }) {
            controller.enqueue(chunk);
            stepText += chunk.textDelta;
            fullStepText += chunk.textDelta;
            chunkTextPublished = true;
            hasWhitespaceSuffix = chunk.textDelta.trimEnd() !== chunk.textDelta;
          }
          self.addStream(
            transformedStream.pipeThrough(
              new TransformStream({
                async transform(chunk, controller) {
                  var _a19, _b, _c;
                  if (stepFirstChunk) {
                    const msToFirstChunk = now2() - startTimestampMs;
                    stepFirstChunk = false;
                    doStreamSpan.addEvent("ai.stream.firstChunk", {
                      "ai.response.msToFirstChunk": msToFirstChunk
                    });
                    doStreamSpan.setAttributes({
                      "ai.response.msToFirstChunk": msToFirstChunk
                    });
                    controller.enqueue({
                      type: "step-start",
                      messageId,
                      request: stepRequest,
                      warnings: warnings != null ? warnings : []
                    });
                  }
                  if (chunk.type === "text-delta" && chunk.textDelta.length === 0) {
                    return;
                  }
                  const chunkType = chunk.type;
                  switch (chunkType) {
                    case "text-delta": {
                      if (continueSteps) {
                        const trimmedChunkText = inWhitespacePrefix && hasLeadingWhitespace ? chunk.textDelta.trimStart() : chunk.textDelta;
                        if (trimmedChunkText.length === 0) {
                          break;
                        }
                        inWhitespacePrefix = false;
                        chunkBuffer += trimmedChunkText;
                        const split = splitOnLastWhitespace(chunkBuffer);
                        if (split != null) {
                          chunkBuffer = split.suffix;
                          await publishTextChunk({
                            controller,
                            chunk: {
                              type: "text-delta",
                              textDelta: split.prefix + split.whitespace
                            }
                          });
                        }
                      } else {
                        await publishTextChunk({ controller, chunk });
                      }
                      break;
                    }
                    case "reasoning": {
                      controller.enqueue(chunk);
                      if (activeReasoningText2 == null) {
                        activeReasoningText2 = {
                          type: "text",
                          text: chunk.textDelta
                        };
                        stepReasoning2.push(activeReasoningText2);
                      } else {
                        activeReasoningText2.text += chunk.textDelta;
                      }
                      break;
                    }
                    case "reasoning-signature": {
                      controller.enqueue(chunk);
                      if (activeReasoningText2 == null) {
                        throw new InvalidStreamPartError({
                          chunk,
                          message: "reasoning-signature without reasoning"
                        });
                      }
                      activeReasoningText2.signature = chunk.signature;
                      activeReasoningText2 = void 0;
                      break;
                    }
                    case "redacted-reasoning": {
                      controller.enqueue(chunk);
                      stepReasoning2.push({
                        type: "redacted",
                        data: chunk.data
                      });
                      break;
                    }
                    case "tool-call": {
                      controller.enqueue(chunk);
                      stepToolCalls.push(chunk);
                      break;
                    }
                    case "tool-result": {
                      controller.enqueue(chunk);
                      stepToolResults.push(chunk);
                      break;
                    }
                    case "response-metadata": {
                      stepResponse = {
                        id: (_a19 = chunk.id) != null ? _a19 : stepResponse.id,
                        timestamp: (_b = chunk.timestamp) != null ? _b : stepResponse.timestamp,
                        modelId: (_c = chunk.modelId) != null ? _c : stepResponse.modelId
                      };
                      break;
                    }
                    case "finish": {
                      stepUsage = chunk.usage;
                      stepFinishReason = chunk.finishReason;
                      stepProviderMetadata = chunk.experimental_providerMetadata;
                      stepLogProbs = chunk.logprobs;
                      const msToFinish = now2() - startTimestampMs;
                      doStreamSpan.addEvent("ai.stream.finish");
                      doStreamSpan.setAttributes({
                        "ai.response.msToFinish": msToFinish,
                        "ai.response.avgCompletionTokensPerSecond": 1e3 * stepUsage.completionTokens / msToFinish
                      });
                      break;
                    }
                    case "file": {
                      stepFiles2.push(chunk);
                      controller.enqueue(chunk);
                      break;
                    }
                    case "source":
                    case "tool-call-streaming-start":
                    case "tool-call-delta": {
                      controller.enqueue(chunk);
                      break;
                    }
                    case "error": {
                      controller.enqueue(chunk);
                      stepFinishReason = "error";
                      break;
                    }
                    default: {
                      const exhaustiveCheck = chunkType;
                      throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);
                    }
                  }
                },
                // invoke onFinish callback and resolve toolResults promise when the stream is about to close:
                async flush(controller) {
                  const stepToolCallsJson = stepToolCalls.length > 0 ? JSON.stringify(stepToolCalls) : void 0;
                  let nextStepType = "done";
                  if (currentStep + 1 < maxSteps) {
                    if (continueSteps && stepFinishReason === "length" && // only use continue when there are no tool calls:
                    stepToolCalls.length === 0) {
                      nextStepType = "continue";
                    } else if (
                      // there are tool calls:
                      stepToolCalls.length > 0 && // all current tool calls have results:
                      stepToolResults.length === stepToolCalls.length
                    ) {
                      nextStepType = "tool-result";
                    }
                  }
                  if (continueSteps && chunkBuffer.length > 0 && (nextStepType !== "continue" || // when the next step is a regular step, publish the buffer
                  stepType2 === "continue" && !chunkTextPublished)) {
                    await publishTextChunk({
                      controller,
                      chunk: {
                        type: "text-delta",
                        textDelta: chunkBuffer
                      }
                    });
                    chunkBuffer = "";
                  }
                  try {
                    doStreamSpan.setAttributes(
                      selectTelemetryAttributes({
                        telemetry,
                        attributes: {
                          "ai.response.finishReason": stepFinishReason,
                          "ai.response.text": { output: () => stepText },
                          "ai.response.toolCalls": {
                            output: () => stepToolCallsJson
                          },
                          "ai.response.id": stepResponse.id,
                          "ai.response.model": stepResponse.modelId,
                          "ai.response.timestamp": stepResponse.timestamp.toISOString(),
                          "ai.usage.promptTokens": stepUsage.promptTokens,
                          "ai.usage.completionTokens": stepUsage.completionTokens,
                          // standardized gen-ai llm span attributes:
                          "gen_ai.response.finish_reasons": [stepFinishReason],
                          "gen_ai.response.id": stepResponse.id,
                          "gen_ai.response.model": stepResponse.modelId,
                          "gen_ai.usage.input_tokens": stepUsage.promptTokens,
                          "gen_ai.usage.output_tokens": stepUsage.completionTokens
                        }
                      })
                    );
                  } catch (error) {
                  } finally {
                    doStreamSpan.end();
                  }
                  controller.enqueue({
                    type: "step-finish",
                    finishReason: stepFinishReason,
                    usage: stepUsage,
                    providerMetadata: stepProviderMetadata,
                    experimental_providerMetadata: stepProviderMetadata,
                    logprobs: stepLogProbs,
                    request: stepRequest,
                    response: {
                      ...stepResponse,
                      headers: rawResponse == null ? void 0 : rawResponse.headers
                    },
                    warnings,
                    isContinued: nextStepType === "continue",
                    messageId
                  });
                  const combinedUsage = addLanguageModelUsage(usage, stepUsage);
                  if (nextStepType === "done") {
                    controller.enqueue({
                      type: "finish",
                      finishReason: stepFinishReason,
                      usage: combinedUsage,
                      providerMetadata: stepProviderMetadata,
                      experimental_providerMetadata: stepProviderMetadata,
                      logprobs: stepLogProbs,
                      response: {
                        ...stepResponse,
                        headers: rawResponse == null ? void 0 : rawResponse.headers
                      }
                    });
                    self.closeStream();
                  } else {
                    if (stepType2 === "continue") {
                      const lastMessage = responseMessages[responseMessages.length - 1];
                      if (typeof lastMessage.content === "string") {
                        lastMessage.content += stepText;
                      } else {
                        lastMessage.content.push({
                          text: stepText,
                          type: "text"
                        });
                      }
                    } else {
                      responseMessages.push(
                        ...toResponseMessages({
                          text: stepText,
                          files: stepFiles2,
                          reasoning: stepReasoning2,
                          tools: tools != null ? tools : {},
                          toolCalls: stepToolCalls,
                          toolResults: stepToolResults,
                          messageId,
                          generateMessageId
                        })
                      );
                    }
                    await streamStep({
                      currentStep: currentStep + 1,
                      responseMessages,
                      usage: combinedUsage,
                      stepType: nextStepType,
                      previousStepText: fullStepText,
                      hasLeadingWhitespace: hasWhitespaceSuffix,
                      messageId: (
                        // keep the same id when continuing a step:
                        nextStepType === "continue" ? messageId : generateMessageId()
                      )
                    });
                  }
                }
              })
            )
          );
        }
        await streamStep({
          currentStep: 0,
          responseMessages: [],
          usage: {
            promptTokens: 0,
            completionTokens: 0,
            totalTokens: 0
          },
          previousStepText: "",
          stepType: "initial",
          hasLeadingWhitespace: false,
          messageId: generateMessageId()
        });
      }
    }).catch((error) => {
      self.addStream(
        new ReadableStream({
          start(controller) {
            controller.enqueue({ type: "error", error });
            controller.close();
          }
        })
      );
      self.closeStream();
    });
  }
  get warnings() {
    return this.warningsPromise.value;
  }
  get usage() {
    return this.usagePromise.value;
  }
  get finishReason() {
    return this.finishReasonPromise.value;
  }
  get experimental_providerMetadata() {
    return this.providerMetadataPromise.value;
  }
  get providerMetadata() {
    return this.providerMetadataPromise.value;
  }
  get text() {
    return this.textPromise.value;
  }
  get reasoning() {
    return this.reasoningPromise.value;
  }
  get reasoningDetails() {
    return this.reasoningDetailsPromise.value;
  }
  get sources() {
    return this.sourcesPromise.value;
  }
  get files() {
    return this.filesPromise.value;
  }
  get toolCalls() {
    return this.toolCallsPromise.value;
  }
  get toolResults() {
    return this.toolResultsPromise.value;
  }
  get request() {
    return this.requestPromise.value;
  }
  get response() {
    return this.responsePromise.value;
  }
  get steps() {
    return this.stepsPromise.value;
  }
  /**
  Split out a new stream from the original stream.
  The original stream is replaced to allow for further splitting,
  since we do not know how many times the stream will be split.
  
  Note: this leads to buffering the stream content on the server.
  However, the LLM results are expected to be small enough to not cause issues.
     */
  teeStream() {
    const [stream1, stream2] = this.baseStream.tee();
    this.baseStream = stream2;
    return stream1;
  }
  get textStream() {
    return createAsyncIterableStream(
      this.teeStream().pipeThrough(
        new TransformStream({
          transform({ part }, controller) {
            if (part.type === "text-delta") {
              controller.enqueue(part.textDelta);
            }
          }
        })
      )
    );
  }
  get fullStream() {
    return createAsyncIterableStream(
      this.teeStream().pipeThrough(
        new TransformStream({
          transform({ part }, controller) {
            controller.enqueue(part);
          }
        })
      )
    );
  }
  async consumeStream(options) {
    var _a17;
    try {
      await consumeStream({
        stream: this.fullStream,
        onError: options == null ? void 0 : options.onError
      });
    } catch (error) {
      (_a17 = options == null ? void 0 : options.onError) == null ? void 0 : _a17.call(options, error);
    }
  }
  get experimental_partialOutputStream() {
    if (this.output == null) {
      throw new NoOutputSpecifiedError();
    }
    return createAsyncIterableStream(
      this.teeStream().pipeThrough(
        new TransformStream({
          transform({ partialOutput }, controller) {
            if (partialOutput != null) {
              controller.enqueue(partialOutput);
            }
          }
        })
      )
    );
  }
  toDataStreamInternal({
    getErrorMessage: getErrorMessage5 = () => "An error occurred.",
    // mask error messages for safety by default
    sendUsage = true,
    sendReasoning = false,
    sendSources = false,
    experimental_sendFinish = true
  }) {
    return this.fullStream.pipeThrough(
      new TransformStream({
        transform: async (chunk, controller) => {
          const chunkType = chunk.type;
          switch (chunkType) {
            case "text-delta": {
              controller.enqueue(formatDataStreamPart("text", chunk.textDelta));
              break;
            }
            case "reasoning": {
              if (sendReasoning) {
                controller.enqueue(
                  formatDataStreamPart("reasoning", chunk.textDelta)
                );
              }
              break;
            }
            case "redacted-reasoning": {
              if (sendReasoning) {
                controller.enqueue(
                  formatDataStreamPart("redacted_reasoning", {
                    data: chunk.data
                  })
                );
              }
              break;
            }
            case "reasoning-signature": {
              if (sendReasoning) {
                controller.enqueue(
                  formatDataStreamPart("reasoning_signature", {
                    signature: chunk.signature
                  })
                );
              }
              break;
            }
            case "file": {
              controller.enqueue(
                formatDataStreamPart("file", {
                  mimeType: chunk.mimeType,
                  data: chunk.base64
                })
              );
              break;
            }
            case "source": {
              if (sendSources) {
                controller.enqueue(
                  formatDataStreamPart("source", chunk.source)
                );
              }
              break;
            }
            case "tool-call-streaming-start": {
              controller.enqueue(
                formatDataStreamPart("tool_call_streaming_start", {
                  toolCallId: chunk.toolCallId,
                  toolName: chunk.toolName
                })
              );
              break;
            }
            case "tool-call-delta": {
              controller.enqueue(
                formatDataStreamPart("tool_call_delta", {
                  toolCallId: chunk.toolCallId,
                  argsTextDelta: chunk.argsTextDelta
                })
              );
              break;
            }
            case "tool-call": {
              controller.enqueue(
                formatDataStreamPart("tool_call", {
                  toolCallId: chunk.toolCallId,
                  toolName: chunk.toolName,
                  args: chunk.args
                })
              );
              break;
            }
            case "tool-result": {
              controller.enqueue(
                formatDataStreamPart("tool_result", {
                  toolCallId: chunk.toolCallId,
                  result: chunk.result
                })
              );
              break;
            }
            case "error": {
              controller.enqueue(
                formatDataStreamPart("error", getErrorMessage5(chunk.error))
              );
              break;
            }
            case "step-start": {
              controller.enqueue(
                formatDataStreamPart("start_step", {
                  messageId: chunk.messageId
                })
              );
              break;
            }
            case "step-finish": {
              controller.enqueue(
                formatDataStreamPart("finish_step", {
                  finishReason: chunk.finishReason,
                  usage: sendUsage ? {
                    promptTokens: chunk.usage.promptTokens,
                    completionTokens: chunk.usage.completionTokens
                  } : void 0,
                  isContinued: chunk.isContinued
                })
              );
              break;
            }
            case "finish": {
              if (experimental_sendFinish) {
                controller.enqueue(
                  formatDataStreamPart("finish_message", {
                    finishReason: chunk.finishReason,
                    usage: sendUsage ? {
                      promptTokens: chunk.usage.promptTokens,
                      completionTokens: chunk.usage.completionTokens
                    } : void 0
                  })
                );
              }
              break;
            }
            default: {
              const exhaustiveCheck = chunkType;
              throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);
            }
          }
        }
      })
    );
  }
  pipeDataStreamToResponse(response, {
    status,
    statusText,
    headers,
    data,
    getErrorMessage: getErrorMessage5,
    sendUsage,
    sendReasoning,
    sendSources,
    experimental_sendFinish
  } = {}) {
    writeToServerResponse({
      response,
      status,
      statusText,
      headers: prepareOutgoingHttpHeaders(headers, {
        contentType: "text/plain; charset=utf-8",
        dataStreamVersion: "v1"
      }),
      stream: this.toDataStream({
        data,
        getErrorMessage: getErrorMessage5,
        sendUsage,
        sendReasoning,
        sendSources,
        experimental_sendFinish
      })
    });
  }
  pipeTextStreamToResponse(response, init) {
    writeToServerResponse({
      response,
      status: init == null ? void 0 : init.status,
      statusText: init == null ? void 0 : init.statusText,
      headers: prepareOutgoingHttpHeaders(init == null ? void 0 : init.headers, {
        contentType: "text/plain; charset=utf-8"
      }),
      stream: this.textStream.pipeThrough(new TextEncoderStream())
    });
  }
  // TODO breaking change 5.0: remove pipeThrough(new TextEncoderStream())
  toDataStream(options) {
    const stream = this.toDataStreamInternal({
      getErrorMessage: options == null ? void 0 : options.getErrorMessage,
      sendUsage: options == null ? void 0 : options.sendUsage,
      sendReasoning: options == null ? void 0 : options.sendReasoning,
      sendSources: options == null ? void 0 : options.sendSources,
      experimental_sendFinish: options == null ? void 0 : options.experimental_sendFinish
    }).pipeThrough(new TextEncoderStream());
    return (options == null ? void 0 : options.data) ? mergeStreams(options == null ? void 0 : options.data.stream, stream) : stream;
  }
  mergeIntoDataStream(writer, options) {
    writer.merge(
      this.toDataStreamInternal({
        getErrorMessage: writer.onError,
        sendUsage: options == null ? void 0 : options.sendUsage,
        sendReasoning: options == null ? void 0 : options.sendReasoning,
        sendSources: options == null ? void 0 : options.sendSources,
        experimental_sendFinish: options == null ? void 0 : options.experimental_sendFinish
      })
    );
  }
  toDataStreamResponse({
    headers,
    status,
    statusText,
    data,
    getErrorMessage: getErrorMessage5,
    sendUsage,
    sendReasoning,
    sendSources,
    experimental_sendFinish
  } = {}) {
    return new Response(
      this.toDataStream({
        data,
        getErrorMessage: getErrorMessage5,
        sendUsage,
        sendReasoning,
        sendSources,
        experimental_sendFinish
      }),
      {
        status,
        statusText,
        headers: prepareResponseHeaders(headers, {
          contentType: "text/plain; charset=utf-8",
          dataStreamVersion: "v1"
        })
      }
    );
  }
  toTextStreamResponse(init) {
    var _a17;
    return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {
      status: (_a17 = init == null ? void 0 : init.status) != null ? _a17 : 200,
      headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {
        contentType: "text/plain; charset=utf-8"
      })
    });
  }
};
var ClientOrServerImplementationSchema = lib.z.object({
  name: lib.z.string(),
  version: lib.z.string()
}).passthrough();
var BaseParamsSchema = lib.z.object({
  _meta: lib.z.optional(lib.z.object({}).passthrough())
}).passthrough();
var ResultSchema = BaseParamsSchema;
var RequestSchema = lib.z.object({
  method: lib.z.string(),
  params: lib.z.optional(BaseParamsSchema)
});
var ServerCapabilitiesSchema = lib.z.object({
  experimental: lib.z.optional(lib.z.object({}).passthrough()),
  logging: lib.z.optional(lib.z.object({}).passthrough()),
  prompts: lib.z.optional(
    lib.z.object({
      listChanged: lib.z.optional(lib.z.boolean())
    }).passthrough()
  ),
  resources: lib.z.optional(
    lib.z.object({
      subscribe: lib.z.optional(lib.z.boolean()),
      listChanged: lib.z.optional(lib.z.boolean())
    }).passthrough()
  ),
  tools: lib.z.optional(
    lib.z.object({
      listChanged: lib.z.optional(lib.z.boolean())
    }).passthrough()
  )
}).passthrough();
ResultSchema.extend({
  protocolVersion: lib.z.string(),
  capabilities: ServerCapabilitiesSchema,
  serverInfo: ClientOrServerImplementationSchema,
  instructions: lib.z.optional(lib.z.string())
});
var PaginatedResultSchema = ResultSchema.extend({
  nextCursor: lib.z.optional(lib.z.string())
});
var ToolSchema = lib.z.object({
  name: lib.z.string(),
  description: lib.z.optional(lib.z.string()),
  inputSchema: lib.z.object({
    type: lib.z.literal("object"),
    properties: lib.z.optional(lib.z.object({}).passthrough())
  }).passthrough()
}).passthrough();
PaginatedResultSchema.extend({
  tools: lib.z.array(ToolSchema)
});
var TextContentSchema = lib.z.object({
  type: lib.z.literal("text"),
  text: lib.z.string()
}).passthrough();
var ImageContentSchema = lib.z.object({
  type: lib.z.literal("image"),
  data: lib.z.string().base64(),
  mimeType: lib.z.string()
}).passthrough();
var ResourceContentsSchema = lib.z.object({
  /**
   * The URI of this resource.
   */
  uri: lib.z.string(),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: lib.z.optional(lib.z.string())
}).passthrough();
var TextResourceContentsSchema = ResourceContentsSchema.extend({
  text: lib.z.string()
});
var BlobResourceContentsSchema = ResourceContentsSchema.extend({
  blob: lib.z.string().base64()
});
var EmbeddedResourceSchema = lib.z.object({
  type: lib.z.literal("resource"),
  resource: lib.z.union([TextResourceContentsSchema, BlobResourceContentsSchema])
}).passthrough();
ResultSchema.extend({
  content: lib.z.array(
    lib.z.union([TextContentSchema, ImageContentSchema, EmbeddedResourceSchema])
  ),
  isError: lib.z.boolean().default(false).optional()
}).or(
  ResultSchema.extend({
    toolResult: lib.z.unknown()
  })
);

// core/tool/mcp/json-rpc-message.ts
var JSONRPC_VERSION = "2.0";
var JSONRPCRequestSchema = lib.z.object({
  jsonrpc: lib.z.literal(JSONRPC_VERSION),
  id: lib.z.union([lib.z.string(), lib.z.number().int()])
}).merge(RequestSchema).strict();
var JSONRPCResponseSchema = lib.z.object({
  jsonrpc: lib.z.literal(JSONRPC_VERSION),
  id: lib.z.union([lib.z.string(), lib.z.number().int()]),
  result: ResultSchema
}).strict();
var JSONRPCErrorSchema = lib.z.object({
  jsonrpc: lib.z.literal(JSONRPC_VERSION),
  id: lib.z.union([lib.z.string(), lib.z.number().int()]),
  error: lib.z.object({
    code: lib.z.number().int(),
    message: lib.z.string(),
    data: lib.z.optional(lib.z.unknown())
  })
}).strict();
var JSONRPCNotificationSchema = lib.z.object({
  jsonrpc: lib.z.literal(JSONRPC_VERSION)
}).merge(
  lib.z.object({
    method: lib.z.string(),
    params: lib.z.optional(BaseParamsSchema)
  })
).strict();
lib.z.union([
  JSONRPCRequestSchema,
  JSONRPCNotificationSchema,
  JSONRPCResponseSchema,
  JSONRPCErrorSchema
]);

// streams/langchain-adapter.ts
var langchain_adapter_exports = {};
__export(langchain_adapter_exports, {
  mergeIntoDataStream: () => mergeIntoDataStream,
  toDataStream: () => toDataStream,
  toDataStreamResponse: () => toDataStreamResponse
});

// streams/stream-callbacks.ts
function createCallbacksTransformer(callbacks = {}) {
  const textEncoder = new TextEncoder();
  let aggregatedResponse = "";
  return new TransformStream({
    async start() {
      if (callbacks.onStart)
        await callbacks.onStart();
    },
    async transform(message, controller) {
      controller.enqueue(textEncoder.encode(message));
      aggregatedResponse += message;
      if (callbacks.onToken)
        await callbacks.onToken(message);
      if (callbacks.onText && typeof message === "string") {
        await callbacks.onText(message);
      }
    },
    async flush() {
      if (callbacks.onCompletion) {
        await callbacks.onCompletion(aggregatedResponse);
      }
      if (callbacks.onFinal) {
        await callbacks.onFinal(aggregatedResponse);
      }
    }
  });
}

// streams/langchain-adapter.ts
function toDataStreamInternal(stream, callbacks) {
  return stream.pipeThrough(
    new TransformStream({
      transform: async (value, controller) => {
        var _a17;
        if (typeof value === "string") {
          controller.enqueue(value);
          return;
        }
        if ("event" in value) {
          if (value.event === "on_chat_model_stream") {
            forwardAIMessageChunk(
              (_a17 = value.data) == null ? void 0 : _a17.chunk,
              controller
            );
          }
          return;
        }
        forwardAIMessageChunk(value, controller);
      }
    })
  ).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(new TextDecoderStream()).pipeThrough(
    new TransformStream({
      transform: async (chunk, controller) => {
        controller.enqueue(formatDataStreamPart("text", chunk));
      }
    })
  );
}
function toDataStream(stream, callbacks) {
  return toDataStreamInternal(stream, callbacks).pipeThrough(
    new TextEncoderStream()
  );
}
function toDataStreamResponse(stream, options) {
  var _a17;
  const dataStream = toDataStreamInternal(
    stream,
    options == null ? void 0 : options.callbacks
  ).pipeThrough(new TextEncoderStream());
  const data = options == null ? void 0 : options.data;
  const init = options == null ? void 0 : options.init;
  const responseStream = data ? mergeStreams(data.stream, dataStream) : dataStream;
  return new Response(responseStream, {
    status: (_a17 = init == null ? void 0 : init.status) != null ? _a17 : 200,
    statusText: init == null ? void 0 : init.statusText,
    headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {
      contentType: "text/plain; charset=utf-8",
      dataStreamVersion: "v1"
    })
  });
}
function mergeIntoDataStream(stream, options) {
  options.dataStream.merge(toDataStreamInternal(stream, options.callbacks));
}
function forwardAIMessageChunk(chunk, controller) {
  if (typeof chunk.content === "string") {
    controller.enqueue(chunk.content);
  } else {
    const content = chunk.content;
    for (const item of content) {
      if (item.type === "text") {
        controller.enqueue(item.text);
      }
    }
  }
}

// streams/llamaindex-adapter.ts
var llamaindex_adapter_exports = {};
__export(llamaindex_adapter_exports, {
  mergeIntoDataStream: () => mergeIntoDataStream2,
  toDataStream: () => toDataStream2,
  toDataStreamResponse: () => toDataStreamResponse2
});
function toDataStreamInternal2(stream, callbacks) {
  const trimStart = trimStartOfStream();
  return convertAsyncIteratorToReadableStream(stream[Symbol.asyncIterator]()).pipeThrough(
    new TransformStream({
      async transform(message, controller) {
        controller.enqueue(trimStart(message.delta));
      }
    })
  ).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(new TextDecoderStream()).pipeThrough(
    new TransformStream({
      transform: async (chunk, controller) => {
        controller.enqueue(formatDataStreamPart("text", chunk));
      }
    })
  );
}
function toDataStream2(stream, callbacks) {
  return toDataStreamInternal2(stream, callbacks).pipeThrough(
    new TextEncoderStream()
  );
}
function toDataStreamResponse2(stream, options = {}) {
  var _a17;
  const { init, data, callbacks } = options;
  const dataStream = toDataStreamInternal2(stream, callbacks).pipeThrough(
    new TextEncoderStream()
  );
  const responseStream = data ? mergeStreams(data.stream, dataStream) : dataStream;
  return new Response(responseStream, {
    status: (_a17 = init == null ? void 0 : init.status) != null ? _a17 : 200,
    statusText: init == null ? void 0 : init.statusText,
    headers: prepareResponseHeaders(init == null ? void 0 : init.headers, {
      contentType: "text/plain; charset=utf-8",
      dataStreamVersion: "v1"
    })
  });
}
function mergeIntoDataStream2(stream, options) {
  options.dataStream.merge(toDataStreamInternal2(stream, options.callbacks));
}
function trimStartOfStream() {
  let isStreamStart = true;
  return (text2) => {
    if (isStreamStart) {
      text2 = text2.trimStart();
      if (text2)
        isStreamStart = false;
    }
    return text2;
  };
}

const parseAnyOf = (schema, refs) => {
    return schema.anyOf.length
        ? schema.anyOf.length === 1
            ? parseSchema(schema.anyOf[0], {
                ...refs,
                path: [...refs.path, "anyOf", 0],
            })
            : `z.union([${schema.anyOf
                .map((schema, i) => parseSchema(schema, { ...refs, path: [...refs.path, "anyOf", i] }))
                .join(", ")}])`
        : `z.any()`;
};

const parseBoolean = (_schema) => {
    return "z.boolean()";
};

const parseDefault = (_schema) => {
    return "z.any()";
};

const parseMultipleType = (schema, refs) => {
    return `z.union([${schema.type
        .map((type) => parseSchema({ ...schema, type }, { ...refs, withoutDefaults: true }))
        .join(", ")}])`;
};

const parseNot = (schema, refs) => {
    return `z.any().refine((value) => !${parseSchema(schema.not, {
        ...refs,
        path: [...refs.path, "not"],
    })}.safeParse(value).success, "Invalid input: Should NOT be valid against schema")`;
};

const parseNull = (_schema) => {
    return "z.null()";
};

const half = (arr) => {
    return [arr.slice(0, arr.length / 2), arr.slice(arr.length / 2)];
};

const originalIndex = Symbol("Original index");
const ensureOriginalIndex = (arr) => {
    let newArr = [];
    for (let i = 0; i < arr.length; i++) {
        const item = arr[i];
        if (typeof item === "boolean") {
            newArr.push(item ? { [originalIndex]: i } : { [originalIndex]: i, not: {} });
        }
        else if (originalIndex in item) {
            return arr;
        }
        else {
            newArr.push({ ...item, [originalIndex]: i });
        }
    }
    return newArr;
};
function parseAllOf(schema, refs) {
    if (schema.allOf.length === 0) {
        return "z.never()";
    }
    else if (schema.allOf.length === 1) {
        const item = schema.allOf[0];
        return parseSchema(item, {
            ...refs,
            path: [...refs.path, "allOf", item[originalIndex]],
        });
    }
    else {
        const [left, right] = half(ensureOriginalIndex(schema.allOf));
        return `z.intersection(${parseAllOf({ allOf: left }, refs)}, ${parseAllOf({
            allOf: right,
        }, refs)})`;
    }
}

function withMessage(schema, key, get) {
    const value = schema[key];
    let r = "";
    if (value !== undefined) {
        const got = get({ value, json: JSON.stringify(value) });
        if (got) {
            const opener = got[0];
            const prefix = got.length === 3 ? got[1] : "";
            const closer = got.length === 3 ? got[2] : got[1];
            r += opener;
            if (schema.errorMessage?.[key] !== undefined) {
                r += prefix + JSON.stringify(schema.errorMessage[key]);
            }
            r += closer;
        }
    }
    return r;
}

const parseArray = (schema, refs) => {
    if (Array.isArray(schema.items)) {
        return `z.tuple([${schema.items.map((v, i) => parseSchema(v, { ...refs, path: [...refs.path, "items", i] }))}])`;
    }
    let r = !schema.items
        ? "z.array(z.any())"
        : `z.array(${parseSchema(schema.items, {
            ...refs,
            path: [...refs.path, "items"],
        })})`;
    r += withMessage(schema, "minItems", ({ json }) => [
        `.min(${json}`,
        ", ",
        ")",
    ]);
    r += withMessage(schema, "maxItems", ({ json }) => [
        `.max(${json}`,
        ", ",
        ")",
    ]);
    return r;
};

const parseConst = (schema) => {
    return `z.literal(${JSON.stringify(schema.const)})`;
};

const parseEnum = (schema) => {
    if (schema.enum.length === 0) {
        return "z.never()";
    }
    else if (schema.enum.length === 1) {
        // union does not work when there is only one element
        return `z.literal(${JSON.stringify(schema.enum[0])})`;
    }
    else if (schema.enum.every((x) => typeof x === "string")) {
        return `z.enum([${schema.enum.map((x) => JSON.stringify(x))}])`;
    }
    else {
        return `z.union([${schema.enum
            .map((x) => `z.literal(${JSON.stringify(x)})`)
            .join(", ")}])`;
    }
};

const parseIfThenElse = (schema, refs) => {
    const $if = parseSchema(schema.if, { ...refs, path: [...refs.path, "if"] });
    const $then = parseSchema(schema.then, {
        ...refs,
        path: [...refs.path, "then"],
    });
    const $else = parseSchema(schema.else, {
        ...refs,
        path: [...refs.path, "else"],
    });
    return `z.union([${$then}, ${$else}]).superRefine((value,ctx) => {
  const result = ${$if}.safeParse(value).success
    ? ${$then}.safeParse(value)
    : ${$else}.safeParse(value);
  if (!result.success) {
    result.error.errors.forEach((error) => ctx.addIssue(error))
  }
})`;
};

const parseNumber = (schema) => {
    let r = "z.number()";
    if (schema.type === "integer") {
        r += withMessage(schema, "type", () => [".int(", ")"]);
    }
    else {
        r += withMessage(schema, "format", ({ value }) => {
            if (value === "int64") {
                return [".int(", ")"];
            }
        });
    }
    r += withMessage(schema, "multipleOf", ({ value, json }) => {
        if (value === 1) {
            if (r.startsWith("z.number().int(")) {
                return;
            }
            return [".int(", ")"];
        }
        return [`.multipleOf(${json}`, ", ", ")"];
    });
    if (typeof schema.minimum === "number") {
        if (schema.exclusiveMinimum === true) {
            r += withMessage(schema, "minimum", ({ json }) => [
                `.gt(${json}`,
                ", ",
                ")",
            ]);
        }
        else {
            r += withMessage(schema, "minimum", ({ json }) => [
                `.gte(${json}`,
                ", ",
                ")",
            ]);
        }
    }
    else if (typeof schema.exclusiveMinimum === "number") {
        r += withMessage(schema, "exclusiveMinimum", ({ json }) => [
            `.gt(${json}`,
            ", ",
            ")",
        ]);
    }
    if (typeof schema.maximum === "number") {
        if (schema.exclusiveMaximum === true) {
            r += withMessage(schema, "maximum", ({ json }) => [
                `.lt(${json}`,
                ", ",
                ")",
            ]);
        }
        else {
            r += withMessage(schema, "maximum", ({ json }) => [
                `.lte(${json}`,
                ", ",
                ")",
            ]);
        }
    }
    else if (typeof schema.exclusiveMaximum === "number") {
        r += withMessage(schema, "exclusiveMaximum", ({ json }) => [
            `.lt(${json}`,
            ", ",
            ")",
        ]);
    }
    return r;
};

const parseOneOf = (schema, refs) => {
    return schema.oneOf.length
        ? schema.oneOf.length === 1
            ? parseSchema(schema.oneOf[0], {
                ...refs,
                path: [...refs.path, "oneOf", 0],
            })
            : `z.any().superRefine((x, ctx) => {
    const schemas = [${schema.oneOf
                .map((schema, i) => parseSchema(schema, {
                ...refs,
                path: [...refs.path, "oneOf", i],
            }))
                .join(", ")}];
    const errors = schemas.reduce<z.ZodError[]>(
      (errors, schema) =>
        ((result) =>
          result.error ? [...errors, result.error] : errors)(
          schema.safeParse(x),
        ),
      [],
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })`
        : "z.any()";
};

const expandJsdocs = (jsdocs) => {
    const lines = jsdocs.split("\n");
    const result = lines.length === 1
        ? lines[0]
        : `\n${lines.map(x => `* ${x}`)
            .join("\n")}\n`;
    return `/**${result}*/\n`;
};
const addJsdocs = (schema, parsed) => {
    const description = schema.description;
    if (!description) {
        return parsed;
    }
    return `\n${expandJsdocs(description)}${parsed}`;
};

function parseObject(objectSchema, refs) {
    let properties = undefined;
    if (objectSchema.properties) {
        if (!Object.keys(objectSchema.properties).length) {
            properties = "z.object({})";
        }
        else {
            properties = "z.object({ ";
            properties += Object.keys(objectSchema.properties)
                .map((key) => {
                const propSchema = objectSchema.properties[key];
                let result = `${JSON.stringify(key)}: ${parseSchema(propSchema, {
                    ...refs,
                    path: [...refs.path, "properties", key],
                })}`;
                if (refs.withJsdocs && typeof propSchema === "object") {
                    result = addJsdocs(propSchema, result);
                }
                const hasDefault = typeof propSchema === "object" && propSchema.default !== undefined;
                const required = Array.isArray(objectSchema.required)
                    ? objectSchema.required.includes(key)
                    : typeof propSchema === "object" && propSchema.required === true;
                const optional = !hasDefault && !required;
                return optional ? `${result}.optional()` : result;
            })
                .join(", ");
            properties += " })";
        }
    }
    const additionalProperties = objectSchema.additionalProperties !== undefined
        ? parseSchema(objectSchema.additionalProperties, {
            ...refs,
            path: [...refs.path, "additionalProperties"],
        })
        : undefined;
    let patternProperties = undefined;
    if (objectSchema.patternProperties) {
        const parsedPatternProperties = Object.fromEntries(Object.entries(objectSchema.patternProperties).map(([key, value]) => {
            return [
                key,
                parseSchema(value, {
                    ...refs,
                    path: [...refs.path, "patternProperties", key],
                }),
            ];
        }, {}));
        patternProperties = "";
        if (properties) {
            if (additionalProperties) {
                patternProperties += `.catchall(z.union([${[
                    ...Object.values(parsedPatternProperties),
                    additionalProperties,
                ].join(", ")}]))`;
            }
            else if (Object.keys(parsedPatternProperties).length > 1) {
                patternProperties += `.catchall(z.union([${Object.values(parsedPatternProperties).join(", ")}]))`;
            }
            else {
                patternProperties += `.catchall(${Object.values(parsedPatternProperties)})`;
            }
        }
        else {
            if (additionalProperties) {
                patternProperties += `z.record(z.union([${[
                    ...Object.values(parsedPatternProperties),
                    additionalProperties,
                ].join(", ")}]))`;
            }
            else if (Object.keys(parsedPatternProperties).length > 1) {
                patternProperties += `z.record(z.union([${Object.values(parsedPatternProperties).join(", ")}]))`;
            }
            else {
                patternProperties += `z.record(${Object.values(parsedPatternProperties)})`;
            }
        }
        patternProperties += ".superRefine((value, ctx) => {\n";
        patternProperties += "for (const key in value) {\n";
        if (additionalProperties) {
            if (objectSchema.properties) {
                patternProperties += `let evaluated = [${Object.keys(objectSchema.properties)
                    .map((key) => JSON.stringify(key))
                    .join(", ")}].includes(key)\n`;
            }
            else {
                patternProperties += `let evaluated = false\n`;
            }
        }
        for (const key in objectSchema.patternProperties) {
            patternProperties +=
                "if (key.match(new RegExp(" + JSON.stringify(key) + "))) {\n";
            if (additionalProperties) {
                patternProperties += "evaluated = true\n";
            }
            patternProperties +=
                "const result = " +
                    parsedPatternProperties[key] +
                    ".safeParse(value[key])\n";
            patternProperties += "if (!result.success) {\n";
            patternProperties += `ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: \`Invalid input: Key matching regex /\${key}/ must match schema\`,
          params: {
            issues: result.error.issues
          }
        })\n`;
            patternProperties += "}\n";
            patternProperties += "}\n";
        }
        if (additionalProperties) {
            patternProperties += "if (!evaluated) {\n";
            patternProperties +=
                "const result = " + additionalProperties + ".safeParse(value[key])\n";
            patternProperties += "if (!result.success) {\n";
            patternProperties += `ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: \`Invalid input: must match catchall schema\`,
          params: {
            issues: result.error.issues
          }
        })\n`;
            patternProperties += "}\n";
            patternProperties += "}\n";
        }
        patternProperties += "}\n";
        patternProperties += "})";
    }
    let output = properties
        ? patternProperties
            ? properties + patternProperties
            : additionalProperties
                ? additionalProperties === "z.never()"
                    ? properties + ".strict()"
                    : properties + `.catchall(${additionalProperties})`
                : properties
        : patternProperties
            ? patternProperties
            : additionalProperties
                ? `z.record(${additionalProperties})`
                : "z.record(z.any())";
    if (its.an.anyOf(objectSchema)) {
        output += `.and(${parseAnyOf({
            anyOf: objectSchema.anyOf.map((x) => typeof x === "object" &&
                !x.type &&
                (x.properties || x.additionalProperties || x.patternProperties)
                ? { ...x, type: "object" }
                : x),
        }, refs)})`;
    }
    if (its.a.oneOf(objectSchema)) {
        output += `.and(${parseOneOf({
            oneOf: objectSchema.oneOf.map((x) => typeof x === "object" &&
                !x.type &&
                (x.properties || x.additionalProperties || x.patternProperties)
                ? { ...x, type: "object" }
                : x),
        }, refs)})`;
    }
    if (its.an.allOf(objectSchema)) {
        output += `.and(${parseAllOf({
            allOf: objectSchema.allOf.map((x) => typeof x === "object" &&
                !x.type &&
                (x.properties || x.additionalProperties || x.patternProperties)
                ? { ...x, type: "object" }
                : x),
        }, refs)})`;
    }
    return output;
}

const parseString = (schema) => {
    let r = "z.string()";
    r += withMessage(schema, "format", ({ value }) => {
        switch (value) {
            case "email":
                return [".email(", ")"];
            case "ip":
                return [".ip(", ")"];
            case "ipv4":
                return ['.ip({ version: "v4"', ", message: ", " })"];
            case "ipv6":
                return ['.ip({ version: "v6"', ", message: ", " })"];
            case "uri":
                return [".url(", ")"];
            case "uuid":
                return [".uuid(", ")"];
            case "date-time":
                return [".datetime({ offset: true", ", message: ", " })"];
            case "time":
                return [".time(", ")"];
            case "date":
                return [".date(", ")"];
            case "binary":
                return [".base64(", ")"];
            case "duration":
                return [".duration(", ")"];
        }
    });
    r += withMessage(schema, "pattern", ({ json }) => [
        `.regex(new RegExp(${json})`,
        ", ",
        ")",
    ]);
    r += withMessage(schema, "minLength", ({ json }) => [
        `.min(${json}`,
        ", ",
        ")",
    ]);
    r += withMessage(schema, "maxLength", ({ json }) => [
        `.max(${json}`,
        ", ",
        ")",
    ]);
    r += withMessage(schema, "contentEncoding", ({ value }) => {
        if (value === "base64") {
            return [".base64(", ")"];
        }
    });
    const contentMediaType = withMessage(schema, "contentMediaType", ({ value }) => {
        if (value === "application/json") {
            return [
                ".transform((str, ctx) => { try { return JSON.parse(str); } catch (err) { ctx.addIssue({ code: \"custom\", message: \"Invalid JSON\" }); }}",
                ", ",
                ")"
            ];
        }
    });
    if (contentMediaType != "") {
        r += contentMediaType;
        r += withMessage(schema, "contentSchema", ({ value }) => {
            if (value && value instanceof Object) {
                return [
                    `.pipe(${parseSchema(value)}`,
                    ", ",
                    ")"
                ];
            }
        });
    }
    return r;
};

const omit = (obj, ...keys) => Object.keys(obj).reduce((acc, key) => {
    if (!keys.includes(key)) {
        acc[key] = obj[key];
    }
    return acc;
}, {});

/**
 * For compatibility with open api 3.0 nullable
 */
const parseNullable = (schema, refs) => {
    return `${parseSchema(omit(schema, "nullable"), refs, true)}.nullable()`;
};

const parseSchema = (schema, refs = { seen: new Map(), path: [] }, blockMeta) => {
    if (typeof schema !== "object")
        return schema ? "z.any()" : "z.never()";
    if (refs.parserOverride) {
        const custom = refs.parserOverride(schema, refs);
        if (typeof custom === "string") {
            return custom;
        }
    }
    let seen = refs.seen.get(schema);
    if (seen) {
        if (seen.r !== undefined) {
            return seen.r;
        }
        if (refs.depth === undefined || seen.n >= refs.depth) {
            return "z.any()";
        }
        seen.n += 1;
    }
    else {
        seen = { r: undefined, n: 0 };
        refs.seen.set(schema, seen);
    }
    let parsed = selectParser(schema, refs);
    if (!blockMeta) {
        if (!refs.withoutDescribes) {
            parsed = addDescribes(schema, parsed);
        }
        if (!refs.withoutDefaults) {
            parsed = addDefaults(schema, parsed);
        }
        parsed = addAnnotations(schema, parsed);
    }
    seen.r = parsed;
    return parsed;
};
const addDescribes = (schema, parsed) => {
    if (schema.description) {
        parsed += `.describe(${JSON.stringify(schema.description)})`;
    }
    return parsed;
};
const addDefaults = (schema, parsed) => {
    if (schema.default !== undefined) {
        parsed += `.default(${JSON.stringify(schema.default)})`;
    }
    return parsed;
};
const addAnnotations = (schema, parsed) => {
    if (schema.readOnly) {
        parsed += ".readonly()";
    }
    return parsed;
};
const selectParser = (schema, refs) => {
    if (its.a.nullable(schema)) {
        return parseNullable(schema, refs);
    }
    else if (its.an.object(schema)) {
        return parseObject(schema, refs);
    }
    else if (its.an.array(schema)) {
        return parseArray(schema, refs);
    }
    else if (its.an.anyOf(schema)) {
        return parseAnyOf(schema, refs);
    }
    else if (its.an.allOf(schema)) {
        return parseAllOf(schema, refs);
    }
    else if (its.a.oneOf(schema)) {
        return parseOneOf(schema, refs);
    }
    else if (its.a.not(schema)) {
        return parseNot(schema, refs);
    }
    else if (its.an.enum(schema)) {
        return parseEnum(schema); //<-- needs to come before primitives
    }
    else if (its.a.const(schema)) {
        return parseConst(schema);
    }
    else if (its.a.multipleType(schema)) {
        return parseMultipleType(schema, refs);
    }
    else if (its.a.primitive(schema, "string")) {
        return parseString(schema);
    }
    else if (its.a.primitive(schema, "number") ||
        its.a.primitive(schema, "integer")) {
        return parseNumber(schema);
    }
    else if (its.a.primitive(schema, "boolean")) {
        return parseBoolean();
    }
    else if (its.a.primitive(schema, "null")) {
        return parseNull();
    }
    else if (its.a.conditional(schema)) {
        return parseIfThenElse(schema, refs);
    }
    else {
        return parseDefault();
    }
};
const its = {
    an: {
        object: (x) => x.type === "object",
        array: (x) => x.type === "array",
        anyOf: (x) => x.anyOf !== undefined,
        allOf: (x) => x.allOf !== undefined,
        enum: (x) => x.enum !== undefined,
    },
    a: {
        nullable: (x) => x.nullable === true,
        multipleType: (x) => Array.isArray(x.type),
        not: (x) => x.not !== undefined,
        const: (x) => x.const !== undefined,
        primitive: (x, p) => x.type === p,
        conditional: (x) => Boolean("if" in x && x.if && "then" in x && "else" in x && x.then && x.else),
        oneOf: (x) => x.oneOf !== undefined,
    },
};

const jsonSchemaToZod = (schema, { module, name, type, noImport, ...rest } = {}) => {
    if (type && (!name || module !== "esm")) {
        throw new Error("Option `type` requires `name` to be set and `module` to be `esm`");
    }
    let result = parseSchema(schema, {
        module,
        name,
        path: [],
        seen: new Map(),
        ...rest,
    });
    const jsdocs = rest.withJsdocs && typeof schema !== "boolean" && schema.description
        ? expandJsdocs(schema.description)
        : "";
    if (module === "cjs") {
        result = `${jsdocs}module.exports = ${name ? `{ ${JSON.stringify(name)}: ${result} }` : result}
`;
        if (!noImport) {
            result = `${jsdocs}const { z } = require("zod")

${result}`;
        }
    }
    else if (module === "esm") {
        result = `${jsdocs}export ${name ? `const ${name} =` : `default`} ${result}
`;
        if (!noImport) {
            result = `import { z } from "zod"

${result}`;
        }
    }
    else if (name) {
        result = `${jsdocs}const ${name} = ${result}`;
    }
    if (type && name) {
        let typeName = typeof type === "string"
            ? type
            : `${name[0].toUpperCase()}${name.substring(1)}`;
        result += `export type ${typeName} = z.infer<typeof ${name}>
`;
    }
    return result;
};

// src/index.ts
function convertJsonSchemaToZod(schema) {
  function addMetadata(zodSchema, jsonSchema) {
    if (jsonSchema.description) {
      zodSchema = zodSchema.describe(jsonSchema.description);
    }
    return zodSchema;
  }
  if (schema.const !== void 0) {
    if (typeof schema.const === "string") {
      return addMetadata(lib.z.literal(schema.const), schema);
    } else if (typeof schema.const === "number") {
      return addMetadata(lib.z.literal(schema.const), schema);
    } else if (typeof schema.const === "boolean") {
      return addMetadata(lib.z.literal(schema.const), schema);
    } else if (schema.const === null) {
      return addMetadata(lib.z.null(), schema);
    }
    return addMetadata(lib.z.literal(schema.const), schema);
  }
  if (schema.type) {
    switch (schema.type) {
      case "string": {
        if (schema.enum) {
          if (schema.enum.length === 0) {
            return addMetadata(lib.z.string(), schema);
          }
          return addMetadata(lib.z.enum(schema.enum), schema);
        }
        let stringSchema = lib.z.string();
        if (schema.minLength !== void 0) {
          stringSchema = stringSchema.min(schema.minLength);
        }
        if (schema.maxLength !== void 0) {
          stringSchema = stringSchema.max(schema.maxLength);
        }
        if (schema.pattern !== void 0) {
          const regex = new RegExp(schema.pattern);
          stringSchema = stringSchema.regex(regex);
        }
        return addMetadata(stringSchema, schema);
      }
      case "number":
      case "integer": {
        if (schema.enum) {
          if (schema.enum.length === 0) {
            return addMetadata(lib.z.number(), schema);
          }
          const options = schema.enum.map((val) => lib.z.literal(val));
          if (options.length === 1) {
            return addMetadata(options[0], schema);
          }
          if (options.length >= 2) {
            const unionSchema = lib.z.union([options[0], options[1], ...options.slice(2)]);
            return addMetadata(unionSchema, schema);
          }
        }
        let numberSchema = schema.type === "integer" ? lib.z.number().int() : lib.z.number();
        if (schema.minimum !== void 0) {
          numberSchema = numberSchema.min(schema.minimum);
        }
        if (schema.maximum !== void 0) {
          numberSchema = numberSchema.max(schema.maximum);
        }
        if (schema.exclusiveMinimum !== void 0) {
          numberSchema = numberSchema.gt(schema.exclusiveMinimum);
        }
        if (schema.exclusiveMaximum !== void 0) {
          numberSchema = numberSchema.lt(schema.exclusiveMaximum);
        }
        if (schema.multipleOf !== void 0) {
          numberSchema = numberSchema.multipleOf(schema.multipleOf);
        }
        return addMetadata(numberSchema, schema);
      }
      case "boolean":
        if (schema.enum) {
          if (schema.enum.length === 0) {
            return addMetadata(lib.z.boolean(), schema);
          }
          const options = schema.enum.map((val) => lib.z.literal(val));
          if (options.length === 1) {
            return addMetadata(options[0], schema);
          }
          if (options.length >= 2) {
            const unionSchema = lib.z.union([options[0], options[1], ...options.slice(2)]);
            return addMetadata(unionSchema, schema);
          }
        }
        return addMetadata(lib.z.boolean(), schema);
      case "null":
        return addMetadata(lib.z.null(), schema);
      case "object":
        if (schema.properties) {
          const shape = {};
          for (const [key, propSchema] of Object.entries(
            schema.properties
          )) {
            shape[key] = convertJsonSchemaToZod(propSchema);
          }
          if (schema.required && Array.isArray(schema.required)) {
            const required = new Set(schema.required);
            for (const key of Object.keys(shape)) {
              if (!required.has(key)) {
                shape[key] = shape[key].optional();
              }
            }
          } else {
            for (const key of Object.keys(shape)) {
              shape[key] = shape[key].optional();
            }
          }
          let zodSchema;
          if (schema.additionalProperties !== false) {
            zodSchema = lib.z.object(shape).passthrough();
          } else {
            zodSchema = lib.z.object(shape);
          }
          return addMetadata(zodSchema, schema);
        }
        return addMetadata(lib.z.object({}), schema);
      case "array": {
        let arraySchema;
        if (schema.items) {
          arraySchema = lib.z.array(convertJsonSchemaToZod(schema.items));
        } else {
          arraySchema = lib.z.array(lib.z.any());
        }
        if (schema.minItems !== void 0) {
          arraySchema = arraySchema.min(schema.minItems);
        }
        if (schema.maxItems !== void 0) {
          arraySchema = arraySchema.max(schema.maxItems);
        }
        if (schema.uniqueItems === true) {
          arraySchema = arraySchema.refine(
            (items) => {
              const seen = /* @__PURE__ */ new Set();
              return items.every((item) => {
                if (typeof item === "string" || typeof item === "number" || typeof item === "boolean") {
                  if (seen.has(item)) return false;
                  seen.add(item);
                  return true;
                }
                const serialized = JSON.stringify(item);
                if (seen.has(serialized)) return false;
                seen.add(serialized);
                return true;
              });
            },
            { message: "Array items must be unique" }
          );
        }
        return addMetadata(arraySchema, schema);
      }
    }
  }
  if (schema.enum) {
    if (schema.enum.length === 0) {
      return addMetadata(lib.z.never(), schema);
    }
    const allStrings = schema.enum.every((val) => typeof val === "string");
    if (allStrings) {
      return addMetadata(lib.z.enum(schema.enum), schema);
    } else {
      const options = schema.enum.map((val) => lib.z.literal(val));
      if (options.length === 1) {
        return addMetadata(options[0], schema);
      }
      if (options.length >= 2) {
        const unionSchema = lib.z.union([options[0], options[1], ...options.slice(2)]);
        return addMetadata(unionSchema, schema);
      }
    }
  }
  if (schema.anyOf && schema.anyOf.length >= 2) {
    const schemas = schema.anyOf.map(convertJsonSchemaToZod);
    return addMetadata(
      lib.z.union([schemas[0], schemas[1], ...schemas.slice(2)]),
      schema
    );
  }
  if (schema.allOf) {
    return addMetadata(
      schema.allOf.reduce(
        (acc, s) => lib.z.intersection(acc, convertJsonSchemaToZod(s)),
        lib.z.object({})
      ),
      schema
    );
  }
  if (schema.oneOf && schema.oneOf.length >= 2) {
    const schemas = schema.oneOf.map(convertJsonSchemaToZod);
    return addMetadata(
      lib.z.union([schemas[0], schemas[1], ...schemas.slice(2)]),
      schema
    );
  }
  return addMetadata(lib.z.any(), schema);
}
function jsonSchemaObjectToZodRawShape(schema) {
  var _a;
  let raw = {};
  for (const [key, value] of Object.entries((_a = schema.properties) != null ? _a : {})) {
    raw[key] = convertJsonSchemaToZod(value);
  }
  return raw;
}

// src/tools/tool.ts
var Tool = class {
  id;
  description;
  inputSchema;
  outputSchema;
  execute;
  mastra;
  constructor(opts) {
    this.id = opts.id;
    this.description = opts.description;
    this.inputSchema = opts.inputSchema;
    this.outputSchema = opts.outputSchema;
    this.execute = opts.execute;
    this.mastra = opts.mastra;
  }
};
var ALL_STRING_CHECKS = ["regex", "emoji", "email", "url", "uuid", "cuid", "min", "max"];
var ALL_NUMBER_CHECKS = [
  "min",
  // gte internally
  "max",
  // lte internally
  "multipleOf"
];
var ALL_ARRAY_CHECKS = ["min", "max", "length"];
var UNSUPPORTED_ZOD_TYPES = ["ZodIntersection", "ZodNever", "ZodNull", "ZodTuple", "ZodUndefined"];
var ToolCompatibility = class extends MastraBase {
  model;
  constructor(model) {
    super({ name: "SchemaCompatibility" });
    this.model = model;
  }
  getModel() {
    return this.model;
  }
  applyZodSchemaCompatibility(zodSchema2) {
    const newSchema = lib.z.object(
      Object.entries(zodSchema2.shape || {}).reduce(
        (acc, [key, value]) => ({
          ...acc,
          [key]: this.processZodType(value)
        }),
        {}
      )
    );
    return { schema: newSchema };
  }
  defaultZodObjectHandler(value) {
    const zodObject = value;
    const processedShape = Object.entries(zodObject.shape || {}).reduce(
      (acc, [key, propValue]) => {
        const typedPropValue = propValue;
        const processedValue = this.processZodType(typedPropValue);
        acc[key] = processedValue;
        return acc;
      },
      {}
    );
    let result = lib.z.object(processedShape);
    if (value.description) {
      result = result.describe(value.description);
    }
    return result;
  }
  mergeParameterDescription(description, constraints) {
    if (Object.keys(constraints).length > 0) {
      return (description ? description + "\n" : "") + JSON.stringify(constraints);
    } else {
      return description;
    }
  }
  defaultUnsupportedZodTypeHandler(value, throwOnTypes = UNSUPPORTED_ZOD_TYPES) {
    if (throwOnTypes.includes(value._def.typeName)) {
      throw new Error(`${this.model.modelId} does not support zod type: ${value._def.typeName}`);
    }
    return value;
  }
  defaultZodArrayHandler(value, handleChecks = ALL_ARRAY_CHECKS) {
    const zodArray = value._def;
    const arrayType = zodArray.type;
    const constraints = {};
    if (zodArray.minLength?.value !== void 0 && handleChecks.includes("min")) {
      constraints.minLength = zodArray.minLength.value;
    }
    if (zodArray.maxLength?.value !== void 0 && handleChecks.includes("max")) {
      constraints.maxLength = zodArray.maxLength.value;
    }
    if (zodArray.exactLength?.value !== void 0 && handleChecks.includes("length")) {
      constraints.exactLength = zodArray.exactLength.value;
    }
    const processedType = arrayType._def.typeName === "ZodObject" ? this.processZodType(arrayType) : arrayType;
    let result = lib.z.array(processedType);
    if (zodArray.minLength?.value !== void 0 && !handleChecks.includes("min")) {
      result = result.min(zodArray.minLength.value);
    }
    if (zodArray.maxLength?.value !== void 0 && !handleChecks.includes("max")) {
      result = result.max(zodArray.maxLength.value);
    }
    if (zodArray.exactLength?.value !== void 0 && !handleChecks.includes("length")) {
      result = result.length(zodArray.exactLength.value);
    }
    const description = this.mergeParameterDescription(value.description, constraints);
    if (description) {
      result = result.describe(description);
    }
    return result;
  }
  defaultZodUnionHandler(value) {
    const zodUnion = value;
    const processedOptions = zodUnion._def.options.map((option) => this.processZodType(option));
    if (processedOptions.length < 2) throw new Error("Union must have at least 2 options");
    let result = lib.z.union(processedOptions);
    if (value.description) {
      result = result.describe(value.description);
    }
    return result;
  }
  defaultZodStringHandler(value, handleChecks = ALL_STRING_CHECKS) {
    const zodString = value;
    const constraints = {};
    const checks = zodString._def.checks || [];
    const newChecks = [];
    for (const check of checks) {
      if ("kind" in check) {
        if (handleChecks.includes(check.kind)) {
          switch (check.kind) {
            case "regex": {
              constraints.regex = {
                pattern: check.regex.source,
                flags: check.regex.flags
              };
              break;
            }
            case "emoji": {
              constraints.emoji = true;
              break;
            }
            case "email": {
              constraints.email = true;
              break;
            }
            case "url": {
              constraints.url = true;
              break;
            }
            case "uuid": {
              constraints.uuid = true;
              break;
            }
            case "cuid": {
              constraints.cuid = true;
              break;
            }
            case "min": {
              constraints.minLength = check.value;
              break;
            }
            case "max": {
              constraints.maxLength = check.value;
              break;
            }
          }
        } else {
          newChecks.push(check);
        }
      }
    }
    let result = lib.z.string();
    for (const check of newChecks) {
      result = result._addCheck(check);
    }
    const description = this.mergeParameterDescription(value.description, constraints);
    if (description) {
      result = result.describe(description);
    }
    return result;
  }
  defaultZodNumberHandler(value, handleChecks = ALL_NUMBER_CHECKS) {
    const zodNumber = value;
    const constraints = {};
    const checks = zodNumber._def.checks || [];
    const newChecks = [];
    for (const check of checks) {
      if ("kind" in check) {
        if (handleChecks.includes(check.kind)) {
          switch (check.kind) {
            case "min":
              if (check.inclusive) {
                constraints.gte = check.value;
              } else {
                constraints.gt = check.value;
              }
              break;
            case "max":
              if (check.inclusive) {
                constraints.lte = check.value;
              } else {
                constraints.lt = check.value;
              }
              break;
            case "multipleOf": {
              constraints.multipleOf = check.value;
              break;
            }
          }
        } else {
          newChecks.push(check);
        }
      }
    }
    let result = lib.z.number();
    for (const check of newChecks) {
      switch (check.kind) {
        case "int":
          result = result.int();
          break;
        case "finite":
          result = result.finite();
          break;
        default:
          result = result._addCheck(check);
      }
    }
    const description = this.mergeParameterDescription(value.description, constraints);
    if (description) {
      result = result.describe(description);
    }
    return result;
  }
  defaultZodDateHandler(value) {
    const zodDate = value;
    const constraints = {};
    const checks = zodDate._def.checks || [];
    for (const check of checks) {
      if ("kind" in check) {
        switch (check.kind) {
          case "min":
            const minDate = new Date(check.value);
            if (!isNaN(minDate.getTime())) {
              constraints.minDate = minDate.toISOString();
            }
            break;
          case "max":
            const maxDate = new Date(check.value);
            if (!isNaN(maxDate.getTime())) {
              constraints.maxDate = maxDate.toISOString();
            }
            break;
        }
      }
    }
    constraints.dateFormat = "date-time";
    let result = lib.z.string().describe("date-time");
    const description = this.mergeParameterDescription(value.description, constraints);
    if (description) {
      result = result.describe(description);
    }
    return result;
  }
  process(tool) {
    if (isVercelTool(tool)) {
      return {
        description: tool.description,
        // TODO: should we also process vercel tool params?
        parameters: zodSchema(convertVercelToolParameters(tool))
      };
    }
    const { schema } = this.applyZodSchemaCompatibility(tool.inputSchema);
    return {
      description: tool.description,
      parameters: convertZodSchemaToAISDKSchema(schema, this.getSchemaTarget())
    };
  }
};

// src/tools/tool-compatibility/provider-compats/anthropic.ts
var AnthropicToolCompat = class extends ToolCompatibility {
  constructor(model) {
    super(model);
  }
  getSchemaTarget() {
    return "jsonSchema7";
  }
  shouldApply() {
    return this.getModel().modelId.includes("claude");
  }
  processZodType(value) {
    switch (value._def.typeName) {
      case "ZodObject": {
        return this.defaultZodObjectHandler(value);
      }
      case "ZodArray": {
        return this.defaultZodArrayHandler(value, []);
      }
      case "ZodUnion": {
        return this.defaultZodUnionHandler(value);
      }
      // the claude-3.5-haiku model support these properties but the model doesn't respect them, but it respects them when they're
      // added to the tool description
      case "ZodString": {
        if (this.getModel().modelId.includes("claude-3.5-haiku")) {
          return this.defaultZodStringHandler(value, ["max", "min"]);
        } else {
          return value;
        }
      }
      default:
        if (this.getModel().modelId.includes("claude-3.7")) {
          return this.defaultUnsupportedZodTypeHandler(value, ["ZodNever", "ZodTuple", "ZodUndefined"]);
        } else {
          return this.defaultUnsupportedZodTypeHandler(value, ["ZodNever", "ZodUndefined"]);
        }
    }
  }
};

// src/tools/tool-compatibility/provider-compats/deepseek.ts
var DeepSeekToolCompat = class extends ToolCompatibility {
  constructor(model) {
    super(model);
  }
  getSchemaTarget() {
    return "jsonSchema7";
  }
  shouldApply() {
    return this.getModel().modelId.includes("deepseek");
  }
  processZodType(value) {
    switch (value._def.typeName) {
      case "ZodObject": {
        return this.defaultZodObjectHandler(value);
      }
      case "ZodArray": {
        return this.defaultZodArrayHandler(value, ["min", "max"]);
      }
      case "ZodUnion": {
        return this.defaultZodUnionHandler(value);
      }
      case "ZodString": {
        return this.defaultZodStringHandler(value);
      }
      default:
        return value;
    }
  }
};

// src/tools/tool-compatibility/provider-compats/google.ts
var GoogleToolCompat = class extends ToolCompatibility {
  constructor(model) {
    super(model);
  }
  getSchemaTarget() {
    return "jsonSchema7";
  }
  shouldApply() {
    return this.getModel().provider.includes("google") || this.getModel().modelId.includes("google");
  }
  processZodType(value) {
    switch (value._def.typeName) {
      case "ZodObject": {
        return this.defaultZodObjectHandler(value);
      }
      case "ZodArray": {
        return this.defaultZodArrayHandler(value, []);
      }
      case "ZodUnion": {
        return this.defaultZodUnionHandler(value);
      }
      // Google models support these properties but the model doesn't respect them, but it respects them when they're
      // added to the tool description
      case "ZodString": {
        return this.defaultZodStringHandler(value);
      }
      case "ZodNumber": {
        return this.defaultZodNumberHandler(value);
      }
      default:
        return this.defaultUnsupportedZodTypeHandler(value);
    }
  }
};

// src/tools/tool-compatibility/provider-compats/meta.ts
var MetaToolCompat = class extends ToolCompatibility {
  constructor(model) {
    super(model);
  }
  getSchemaTarget() {
    return "jsonSchema7";
  }
  shouldApply() {
    return this.getModel().modelId.includes("meta");
  }
  processZodType(value) {
    switch (value._def.typeName) {
      case "ZodObject": {
        return this.defaultZodObjectHandler(value);
      }
      case "ZodArray": {
        return this.defaultZodArrayHandler(value, ["min", "max"]);
      }
      case "ZodUnion": {
        return this.defaultZodUnionHandler(value);
      }
      case "ZodNumber": {
        return this.defaultZodNumberHandler(value);
      }
      case "ZodString": {
        return this.defaultZodStringHandler(value);
      }
      default:
        return value;
    }
  }
};

// src/tools/tool-compatibility/provider-compats/openai.ts
var OpenAIToolCompat = class extends ToolCompatibility {
  constructor(model) {
    super(model);
  }
  getSchemaTarget() {
    return `jsonSchema7`;
  }
  shouldApply() {
    if (!this.getModel().supportsStructuredOutputs && (this.getModel().provider.includes(`openai`) || this.getModel().modelId.includes(`openai`))) {
      return true;
    }
    return false;
  }
  processZodType(value) {
    switch (value._def.typeName) {
      case "ZodObject": {
        return this.defaultZodObjectHandler(value);
      }
      case "ZodUnion": {
        return this.defaultZodUnionHandler(value);
      }
      case "ZodArray": {
        return this.defaultZodArrayHandler(value);
      }
      case "ZodString": {
        const model = this.getModel();
        const checks = ["emoji"];
        if (model.modelId.includes("gpt-4o-mini")) {
          checks.push("regex");
        }
        return this.defaultZodStringHandler(value, checks);
      }
      default:
        return this.defaultUnsupportedZodTypeHandler(value, ["ZodNever", "ZodUndefined", "ZodTuple"]);
    }
  }
};

// src/tools/tool-compatibility/provider-compats/openai-reasoning.ts
var OpenAIReasoningToolCompat = class extends ToolCompatibility {
  constructor(model) {
    super(model);
  }
  getSchemaTarget() {
    return `openApi3`;
  }
  isReasoningModel() {
    return this.getModel().modelId.includes(`o3`) || this.getModel().modelId.includes(`o4`);
  }
  shouldApply() {
    if ((this.getModel().supportsStructuredOutputs || this.isReasoningModel()) && (this.getModel().provider.includes(`openai`) || this.getModel().modelId.includes(`openai`))) {
      return true;
    }
    return false;
  }
  processZodType(value) {
    switch (value._def.typeName) {
      case "ZodOptional":
        return value.unwrap().nullable();
      case "ZodObject": {
        return this.defaultZodObjectHandler(value);
      }
      case "ZodArray": {
        return this.defaultZodArrayHandler(value);
      }
      case "ZodUnion": {
        return this.defaultZodUnionHandler(value);
      }
      case "ZodDefault": {
        const defaultDef = value._def;
        const innerType = defaultDef.innerType;
        const defaultValue = defaultDef.defaultValue();
        const constraints = {};
        if (defaultValue !== void 0) {
          constraints.defaultValue = defaultValue;
        }
        const description = this.mergeParameterDescription(value.description, constraints);
        let result = this.processZodType(innerType);
        if (description) {
          result = result.describe(description);
        }
        return result;
      }
      case "ZodNumber": {
        return this.defaultZodNumberHandler(value);
      }
      case "ZodString": {
        return this.defaultZodStringHandler(value);
      }
      case "ZodDate": {
        return this.defaultZodDateHandler(value);
      }
      default:
        return this.defaultUnsupportedZodTypeHandler(value);
    }
  }
};

// src/tools/tool-compatibility/builder.ts
function convertZodSchemaToAISDKSchema(zodSchema2, target = "jsonSchema7") {
  return jsonSchema(
    zodToJsonSchema(zodSchema2, {
      $refStrategy: "none",
      target
    }),
    {
      validate: (value) => {
        const result = zodSchema2.safeParse(value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }
    }
  );
}
function convertVercelToolParameters(tool) {
  const schema = tool.parameters ?? lib.z.object({});
  if (isZodType(schema)) {
    return schema;
  } else {
    const jsonSchemaToConvert = "jsonSchema" in schema ? schema.jsonSchema : schema;
    try {
      const rawShape = jsonSchemaObjectToZodRawShape(jsonSchemaToConvert);
      return lib.z.object(rawShape);
    } catch (e) {
      const errorMessage = `[CoreToolBuilder] Failed to convert Vercel tool JSON schema parameters to Zod. Original schema: ${JSON.stringify(jsonSchemaToConvert)}`;
      console.error(errorMessage, e);
      throw new Error(errorMessage + (e instanceof Error ? `
${e.stack}` : "\nUnknown error object"));
    }
  }
}
function convertInputSchema(tool) {
  const schema = tool.inputSchema ?? lib.z.object({});
  if (isZodType(schema)) {
    return schema;
  } else {
    try {
      const rawShape = jsonSchemaObjectToZodRawShape(schema);
      return lib.z.object(rawShape);
    } catch (e) {
      const errorMessage = `[CoreToolBuilder] Failed to convert tool input JSON schema to Zod. Original schema: ${JSON.stringify(schema)}`;
      console.error(errorMessage, e);
      throw new Error(errorMessage + (e instanceof Error ? `
${e.stack}` : "\nUnknown error object"));
    }
  }
}
var CoreToolBuilder = class extends MastraBase {
  originalTool;
  options;
  logType;
  constructor(input) {
    super({ name: "CoreToolBuilder" });
    this.originalTool = input.originalTool;
    this.options = input.options;
    this.logType = input.logType;
  }
  // Helper to get parameters based on tool type
  getParameters = () => {
    if (isVercelTool(this.originalTool)) {
      return convertVercelToolParameters(this.originalTool);
    }
    return convertInputSchema(this.originalTool);
  };
  // For provider-defined tools, we need to include all required properties
  buildProviderTool(tool) {
    if ("type" in tool && tool.type === "provider-defined" && "id" in tool && typeof tool.id === "string" && tool.id.includes(".")) {
      return {
        type: "provider-defined",
        id: tool.id,
        args: "args" in this.originalTool ? this.originalTool.args : {},
        description: tool.description,
        parameters: convertZodSchemaToAISDKSchema(this.getParameters()),
        execute: this.originalTool.execute ? this.createExecute(
          this.originalTool,
          { ...this.options, description: this.originalTool.description },
          this.logType
        ) : void 0
      };
    }
    return void 0;
  }
  createLogMessageOptions({ agentName, toolName, type }) {
    if (!agentName) {
      return {
        start: `Executing tool ${toolName}`,
        error: `Failed tool execution`
      };
    }
    const prefix = `[Agent:${agentName}]`;
    const toolType = type === "toolset" ? "toolset" : "tool";
    return {
      start: `${prefix} - Executing ${toolType} ${toolName}`,
      error: `${prefix} - Failed ${toolType} execution`
    };
  }
  createExecute(tool, options, logType) {
    const { logger, mastra: _mastra, memory: _memory, runtimeContext, ...rest } = options;
    const { start, error } = this.createLogMessageOptions({
      agentName: options.agentName,
      toolName: options.name,
      type: logType
    });
    const execFunction = async (args, execOptions) => {
      if (isVercelTool(tool)) {
        return tool?.execute?.(args, execOptions) ?? void 0;
      }
      return tool?.execute?.(
        {
          context: args,
          threadId: options.threadId,
          resourceId: options.resourceId,
          mastra: options.mastra,
          memory: options.memory,
          runId: options.runId,
          runtimeContext: options.runtimeContext ?? new RuntimeContext()
        },
        execOptions
      ) ?? void 0;
    };
    return async (args, execOptions) => {
      try {
        (options.logger || this.logger).debug(start, { ...rest, args });
        return await execFunction(args, execOptions);
      } catch (err) {
        (options.logger || this.logger).error(error, { ...rest, error: err, args });
        throw err;
      }
    };
  }
  build() {
    const providerTool = this.buildProviderTool(this.originalTool);
    if (providerTool) {
      return providerTool;
    }
    const definition = {
      type: "function",
      description: this.originalTool.description,
      parameters: this.getParameters(),
      execute: this.originalTool.execute ? this.createExecute(
        this.originalTool,
        { ...this.options, description: this.originalTool.description },
        this.logType
      ) : void 0
    };
    const parametersObject = {};
    if (isVercelTool(this.originalTool)) {
      parametersObject.parameters = this.getParameters();
    } else {
      parametersObject.inputSchema = this.getParameters();
    }
    const model = this.options.model;
    const hasParameters = parametersObject.parameters || parametersObject.inputSchema;
    if (model && hasParameters) {
      for (const compat of [
        new OpenAIReasoningToolCompat(model),
        new OpenAIToolCompat(model),
        new GoogleToolCompat(model),
        new AnthropicToolCompat(model),
        new DeepSeekToolCompat(model),
        new MetaToolCompat(model)
      ]) {
        if (compat.shouldApply()) {
          return { ...definition, ...compat.process({ ...this.originalTool, ...parametersObject }) };
        }
      }
    }
    return {
      ...definition,
      parameters: convertZodSchemaToAISDKSchema(this.getParameters())
    };
  }
};

// src/utils.ts
var delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
function resolveSerializedZodOutput(schema) {
  return Function("z", `"use strict";return (${schema});`)(lib.z);
}
function isVercelTool(tool) {
  return !!(tool && !(tool instanceof Tool) && "parameters" in tool);
}
function isZodType(value) {
  return typeof value === "object" && value !== null && "_def" in value && "parse" in value && typeof value.parse === "function" && "safeParse" in value && typeof value.safeParse === "function";
}
function createDeterministicId(input) {
  return createHash("sha256").update(input).digest("hex").slice(0, 8);
}
function setVercelToolProperties(tool) {
  const inputSchema = convertVercelToolParameters2(tool);
  const toolId = !("id" in tool) ? tool.description ? `tool-${createDeterministicId(tool.description)}` : `tool-${Math.random().toString(36).substring(2, 9)}` : tool.id;
  return {
    ...tool,
    id: toolId,
    inputSchema
  };
}
function ensureToolProperties(tools) {
  const toolsWithProperties = Object.keys(tools).reduce((acc, key) => {
    const tool = tools?.[key];
    if (tool) {
      if (isVercelTool(tool)) {
        acc[key] = setVercelToolProperties(tool);
      } else {
        acc[key] = tool;
      }
    }
    return acc;
  }, {});
  return toolsWithProperties;
}
function convertVercelToolParameters2(tool) {
  const schema = tool.parameters ?? lib.z.object({});
  return isZodType(schema) ? schema : resolveSerializedZodOutput(jsonSchemaToZod(schema));
}
function makeCoreTool(originalTool, options, logType) {
  return new CoreToolBuilder({ originalTool, options, logType }).build();
}
function createMastraProxy({ mastra, logger }) {
  return new Proxy(mastra, {
    get(target, prop) {
      const hasProp = Reflect.has(target, prop);
      if (hasProp) {
        const value = Reflect.get(target, prop);
        const isFunction = typeof value === "function";
        if (isFunction) {
          return value.bind(target);
        }
        return value;
      }
      if (prop === "logger") {
        logger.warn(`Please use 'getLogger' instead, logger is deprecated`);
        return Reflect.apply(target.getLogger, target, []);
      }
      if (prop === "telemetry") {
        logger.warn(`Please use 'getTelemetry' instead, telemetry is deprecated`);
        return Reflect.apply(target.getTelemetry, target, []);
      }
      if (prop === "storage") {
        logger.warn(`Please use 'getStorage' instead, storage is deprecated`);
        return Reflect.get(target, "storage");
      }
      if (prop === "agents") {
        logger.warn(`Please use 'getAgents' instead, agents is deprecated`);
        return Reflect.apply(target.getAgents, target, []);
      }
      if (prop === "tts") {
        logger.warn(`Please use 'getTTS' instead, tts is deprecated`);
        return Reflect.apply(target.getTTS, target, []);
      }
      if (prop === "vectors") {
        logger.warn(`Please use 'getVectors' instead, vectors is deprecated`);
        return Reflect.apply(target.getVectors, target, []);
      }
      if (prop === "memory") {
        logger.warn(`Please use 'getMemory' instead, memory is deprecated`);
        return Reflect.get(target, "memory");
      }
      return Reflect.get(target, prop);
    }
  });
}
function checkEvalStorageFields(traceObject, logger) {
  const missingFields = [];
  if (!traceObject.input) missingFields.push("input");
  if (!traceObject.output) missingFields.push("output");
  if (!traceObject.agentName) missingFields.push("agent_name");
  if (!traceObject.metricName) missingFields.push("metric_name");
  if (!traceObject.instructions) missingFields.push("instructions");
  if (!traceObject.globalRunId) missingFields.push("global_run_id");
  if (!traceObject.runId) missingFields.push("run_id");
  if (missingFields.length > 0) {
    if (logger) {
      logger.warn("Skipping evaluation storage due to missing required fields", {
        missingFields,
        runId: traceObject.runId,
        agentName: traceObject.agentName
      });
    } else {
      console.warn("Skipping evaluation storage due to missing required fields", {
        missingFields,
        runId: traceObject.runId,
        agentName: traceObject.agentName
      });
    }
    return false;
  }
  return true;
}
function detectSingleMessageCharacteristics(message) {
  if (typeof message === "object" && message !== null && (message.role === "function" || // UI-only role
  message.role === "data" || // UI-only role
  "toolInvocations" in message || // UI-specific field
  "parts" in message || // UI-specific field
  "experimental_attachments" in message)) {
    return "has-ui-specific-parts";
  } else if (typeof message === "object" && message !== null && "content" in message && (Array.isArray(message.content) || // Core messages can have array content
  "experimental_providerMetadata" in message || "providerOptions" in message)) {
    return "has-core-specific-parts";
  } else if (typeof message === "object" && message !== null && "role" in message && "content" in message && typeof message.content === "string" && ["system", "user", "assistant", "tool"].includes(message.role)) {
    return "message";
  } else {
    return "other";
  }
}
function isUiMessage(message) {
  return detectSingleMessageCharacteristics(message) === `has-ui-specific-parts`;
}
function isCoreMessage(message) {
  return [`has-core-specific-parts`, `message`].includes(detectSingleMessageCharacteristics(message));
}
function ensureAllMessagesAreCoreMessages(messages) {
  return messages.map((message) => {
    if (isUiMessage(message)) {
      return convertToCoreMessages([message]);
    }
    if (isCoreMessage(message)) {
      return message;
    }
    const characteristics = detectSingleMessageCharacteristics(message);
    throw new Error(
      `Message does not appear to be a core message or a UI message but must be one of the two, found "${characteristics}" type for message:

${JSON.stringify(message, null, 2)}
`
    );
  }).flat();
}

// src/hooks/mitt.ts
function mitt(all) {
  all = all || /* @__PURE__ */ new Map();
  return {
    /**
     * A Map of event names to registered handler functions.
     */
    all,
    /**
     * Register an event handler for the given type.
     * @param {string|symbol} type Type of event to listen for, or `'*'` for all events
     * @param {Function} handler Function to call in response to given event
     * @memberOf mitt
     */
    on(type, handler) {
      const handlers = all.get(type);
      if (handlers) {
        handlers.push(handler);
      } else {
        all.set(type, [handler]);
      }
    },
    /**
     * Remove an event handler for the given type.
     * If `handler` is omitted, all handlers of the given type are removed.
     * @param {string|symbol} type Type of event to unregister `handler` from (`'*'` to remove a wildcard handler)
     * @param {Function} [handler] Handler function to remove
     * @memberOf mitt
     */
    off(type, handler) {
      const handlers = all.get(type);
      if (handlers) {
        if (handler) {
          handlers.splice(handlers.indexOf(handler) >>> 0, 1);
        } else {
          all.set(type, []);
        }
      }
    },
    /**
     * Invoke all handlers for the given type.
     * If present, `'*'` handlers are invoked after type-matched handlers.
     *
     * Note: Manually firing '*' handlers is not supported.
     *
     * @param {string|symbol} type The event type to invoke
     * @param {Any} [evt] Any value (object is recommended and powerful), passed to each handler
     * @memberOf mitt
     */
    emit(type, evt) {
      let handlers = all.get(type);
      if (handlers) {
        handlers.slice().map((handler) => {
          handler(evt);
        });
      }
      handlers = all.get("*");
      if (handlers) {
        handlers.slice().map((handler) => {
          handler(type, evt);
        });
      }
    }
  };
}

// src/hooks/index.ts
var AvailableHooks = /* @__PURE__ */ ((AvailableHooks2) => {
  AvailableHooks2["ON_EVALUATION"] = "onEvaluation";
  AvailableHooks2["ON_GENERATION"] = "onGeneration";
  return AvailableHooks2;
})(AvailableHooks || {});
var hooks = mitt();
function registerHook(hook, action) {
  hooks.on(hook, action);
}
function executeHook(hook, data) {
  setImmediate(() => {
    hooks.emit(hook, data);
  });
}

// src/voice/voice.ts
var _MastraVoice_decorators, _init$1, _a$1;
_MastraVoice_decorators = [InstrumentClass({
  prefix: "voice",
  excludeMethods: ["__setTools", "__setLogger", "__setTelemetry", "#log"]
})];
var MastraVoice = class extends (_a$1 = MastraBase) {
  listeningModel;
  speechModel;
  speaker;
  realtimeConfig;
  constructor({
    listeningModel,
    speechModel,
    speaker,
    realtimeConfig,
    name
  } = {}) {
    super({
      component: "VOICE",
      name
    });
    this.listeningModel = listeningModel;
    this.speechModel = speechModel;
    this.speaker = speaker;
    this.realtimeConfig = realtimeConfig;
  }
  traced(method, methodName) {
    return this.telemetry?.traceMethod(method, {
      spanName: `voice.${methodName}`,
      attributes: {
        "voice.type": this.speechModel?.name || this.listeningModel?.name || "unknown"
      }
    }) ?? method;
  }
  updateConfig(_options) {
    this.logger.warn("updateConfig not implemented by this voice provider");
  }
  /**
   * Initializes a WebSocket or WebRTC connection for real-time communication
   * @returns Promise that resolves when the connection is established
   */
  connect(_options) {
    this.logger.warn("connect not implemented by this voice provider");
    return Promise.resolve();
  }
  /**
   * Relay audio data to the voice provider for real-time processing
   * @param audioData Audio data to relay
   */
  send(_audioData) {
    this.logger.warn("relay not implemented by this voice provider");
    return Promise.resolve();
  }
  /**
   * Trigger voice providers to respond
   */
  answer(_options) {
    this.logger.warn("answer not implemented by this voice provider");
    return Promise.resolve();
  }
  /**
   * Equip the voice provider with instructions
   * @param instructions Instructions to add
   */
  addInstructions(_instructions) {}
  /**
   * Equip the voice provider with tools
   * @param tools Array of tools to add
   */
  addTools(_tools) {}
  /**
   * Disconnect from the WebSocket or WebRTC connection
   */
  close() {
    this.logger.warn("close not implemented by this voice provider");
  }
  /**
   * Register an event listener
   * @param event Event name (e.g., 'speaking', 'writing', 'error')
   * @param callback Callback function that receives event data
   */
  on(_event, _callback) {
    this.logger.warn("on not implemented by this voice provider");
  }
  /**
   * Remove an event listener
   * @param event Event name (e.g., 'speaking', 'writing', 'error')
   * @param callback Callback function to remove
   */
  off(_event, _callback) {
    this.logger.warn("off not implemented by this voice provider");
  }
  /**
   * Get available speakers/voices
   * @returns Array of available voice IDs and their metadata
   */
  getSpeakers() {
    this.logger.warn("getSpeakers not implemented by this voice provider");
    return Promise.resolve([]);
  }
};
MastraVoice = /*@__PURE__*/(_ => {
  _init$1 = __decoratorStart(_a$1);
  MastraVoice = __decorateElement(_init$1, 0, "MastraVoice", _MastraVoice_decorators, MastraVoice);
  __runInitializers(_init$1, 1, MastraVoice);

  // src/voice/composite-voice.ts
  return MastraVoice;
})();

// src/voice/default-voice.ts
var DefaultVoice = class extends MastraVoice {
  constructor() {
    super();
  }
  async speak(_input) {
    throw new Error("No voice provider configured");
  }
  async listen(_input) {
    throw new Error("No voice provider configured");
  }
  async getSpeakers() {
    throw new Error("No voice provider configured");
  }
};

// src/llm/model/base.ts
var MastraLLMBase = class extends MastraBase {
  // @ts-ignore
  #mastra;
  #model;
  constructor({ name, model }) {
    super({
      component: RegisteredLogger.LLM,
      name
    });
    this.#model = model;
  }
  getProvider() {
    return this.#model.provider;
  }
  getModelId() {
    return this.#model.modelId;
  }
  getModel() {
    return this.#model;
  }
  convertToMessages(messages) {
    if (Array.isArray(messages)) {
      return messages.map((m) => {
        if (typeof m === "string") {
          return {
            role: "user",
            content: m
          };
        }
        return m;
      });
    }
    return [
      {
        role: "user",
        content: messages
      }
    ];
  }
  __registerPrimitives(p) {
    if (p.telemetry) {
      this.__setTelemetry(p.telemetry);
    }
    if (p.logger) {
      this.__setLogger(p.logger);
    }
  }
  __registerMastra(p) {
    this.#mastra = p;
  }
  async __text(input) {
    this.logger.debug(`[LLMs:${this.name}] Generating text.`, { input });
    throw new Error("Method not implemented.");
  }
  async __textObject(input) {
    this.logger.debug(`[LLMs:${this.name}] Generating object.`, { input });
    throw new Error("Method not implemented.");
  }
  async generate(messages, options) {
    this.logger.debug(`[LLMs:${this.name}] Generating text.`, { messages, options });
    throw new Error("Method not implemented.");
  }
  async __stream(input) {
    this.logger.debug(`[LLMs:${this.name}] Streaming text.`, { input });
    throw new Error("Method not implemented.");
  }
  async __streamObject(input) {
    this.logger.debug(`[LLMs:${this.name}] Streaming object.`, { input });
    throw new Error("Method not implemented.");
  }
  async stream(messages, options) {
    this.logger.debug(`[LLMs:${this.name}] Streaming text.`, { messages, options });
    throw new Error("Method not implemented.");
  }
};

// src/llm/model/model.ts
var MastraLLM = class extends MastraLLMBase {
  #model;
  #mastra;
  constructor({ model, mastra }) {
    super({ name: "aisdk", model });
    this.#model = model;
    if (mastra) {
      this.#mastra = mastra;
      if (mastra.getLogger()) {
        this.__setLogger(mastra.getLogger());
      }
    }
  }
  __registerPrimitives(p) {
    if (p.telemetry) {
      this.__setTelemetry(p.telemetry);
    }
    if (p.logger) {
      this.__setLogger(p.logger);
    }
  }
  __registerMastra(p) {
    this.#mastra = p;
  }
  getProvider() {
    return this.#model.provider;
  }
  getModelId() {
    return this.#model.modelId;
  }
  getModel() {
    return this.#model;
  }
  async __text({
    runId,
    messages,
    maxSteps = 5,
    tools = {},
    temperature,
    toolChoice = "auto",
    onStepFinish,
    experimental_output,
    telemetry,
    threadId,
    resourceId,
    memory,
    runtimeContext,
    ...rest
  }) {
    const model = this.#model;
    this.logger.debug(`[LLM] - Generating text`, {
      runId,
      messages,
      maxSteps,
      threadId,
      resourceId,
      tools: Object.keys(tools)
    });
    const argsForExecute = {
      model,
      temperature,
      tools: {
        ...tools
      },
      toolChoice,
      maxSteps,
      onStepFinish: async (props) => {
        void onStepFinish?.(props);
        this.logger.debug("[LLM] - Step Change:", {
          text: props?.text,
          toolCalls: props?.toolCalls,
          toolResults: props?.toolResults,
          finishReason: props?.finishReason,
          usage: props?.usage,
          runId
        });
        if (props?.response?.headers?.["x-ratelimit-remaining-tokens"] && parseInt(props?.response?.headers?.["x-ratelimit-remaining-tokens"], 10) < 2e3) {
          this.logger.warn("Rate limit approaching, waiting 10 seconds", { runId });
          await delay(10 * 1e3);
        }
      },
      ...rest
    };
    let schema;
    if (experimental_output) {
      this.logger.debug("[LLM] - Using experimental output", {
        runId
      });
      if (typeof experimental_output.parse === "function") {
        schema = experimental_output;
        if (schema instanceof lib.z.ZodArray) {
          schema = schema._def.type;
        }
      } else {
        schema = jsonSchema(experimental_output);
      }
    }
    return await generateText({
      messages,
      ...argsForExecute,
      experimental_telemetry: {
        ...this.experimental_telemetry,
        ...telemetry
      },
      experimental_output: schema ? output_exports.object({
        schema
      }) : void 0
    });
  }
  async __textObject({
    messages,
    onStepFinish,
    maxSteps = 5,
    tools = {},
    structuredOutput,
    runId,
    temperature,
    toolChoice = "auto",
    telemetry,
    threadId,
    resourceId,
    memory,
    runtimeContext,
    ...rest
  }) {
    const model = this.#model;
    this.logger.debug(`[LLM] - Generating a text object`, { runId });
    const argsForExecute = {
      model,
      temperature,
      tools: {
        ...tools
      },
      maxSteps,
      toolChoice,
      onStepFinish: async (props) => {
        void onStepFinish?.(props);
        this.logger.debug("[LLM] - Step Change:", {
          text: props?.text,
          toolCalls: props?.toolCalls,
          toolResults: props?.toolResults,
          finishReason: props?.finishReason,
          usage: props?.usage,
          runId
        });
        if (props?.response?.headers?.["x-ratelimit-remaining-tokens"] && parseInt(props?.response?.headers?.["x-ratelimit-remaining-tokens"], 10) < 2e3) {
          this.logger.warn("Rate limit approaching, waiting 10 seconds", { runId });
          await delay(10 * 1e3);
        }
      },
      ...rest
    };
    let schema;
    let output = "object";
    if (typeof structuredOutput.parse === "function") {
      schema = structuredOutput;
      if (schema instanceof lib.z.ZodArray) {
        output = "array";
        schema = schema._def.type;
      }
    } else {
      schema = jsonSchema(structuredOutput);
    }
    return await generateObject({
      messages,
      ...argsForExecute,
      output,
      schema,
      experimental_telemetry: {
        ...this.experimental_telemetry,
        ...telemetry
      }
    });
  }
  async __stream({
    messages,
    onStepFinish,
    onFinish,
    maxSteps = 5,
    tools = {},
    runId,
    temperature,
    toolChoice = "auto",
    experimental_output,
    telemetry,
    threadId,
    resourceId,
    memory,
    runtimeContext,
    ...rest
  }) {
    const model = this.#model;
    this.logger.debug(`[LLM] - Streaming text`, {
      runId,
      threadId,
      resourceId,
      messages,
      maxSteps,
      tools: Object.keys(tools || {})
    });
    const argsForExecute = {
      model,
      temperature,
      tools: {
        ...tools
      },
      maxSteps,
      toolChoice,
      onStepFinish: async (props) => {
        void onStepFinish?.(props);
        this.logger.debug("[LLM] - Stream Step Change:", {
          text: props?.text,
          toolCalls: props?.toolCalls,
          toolResults: props?.toolResults,
          finishReason: props?.finishReason,
          usage: props?.usage,
          runId
        });
        if (props?.response?.headers?.["x-ratelimit-remaining-tokens"] && parseInt(props?.response?.headers?.["x-ratelimit-remaining-tokens"], 10) < 2e3) {
          this.logger.warn("Rate limit approaching, waiting 10 seconds", { runId });
          await delay(10 * 1e3);
        }
      },
      onFinish: async (props) => {
        void onFinish?.(props);
        this.logger.debug("[LLM] - Stream Finished:", {
          text: props?.text,
          toolCalls: props?.toolCalls,
          toolResults: props?.toolResults,
          finishReason: props?.finishReason,
          usage: props?.usage,
          runId,
          threadId,
          resourceId
        });
      },
      ...rest
    };
    let schema;
    if (experimental_output) {
      this.logger.debug("[LLM] - Using experimental output", {
        runId
      });
      if (typeof experimental_output.parse === "function") {
        schema = experimental_output;
        if (schema instanceof lib.z.ZodArray) {
          schema = schema._def.type;
        }
      } else {
        schema = jsonSchema(experimental_output);
      }
    }
    return await streamText({
      messages,
      ...argsForExecute,
      experimental_telemetry: {
        ...this.experimental_telemetry,
        ...telemetry
      },
      experimental_output: schema ? output_exports.object({
        schema
      }) : void 0
    });
  }
  async __streamObject({
    messages,
    runId,
    tools = {},
    maxSteps = 5,
    toolChoice = "auto",
    runtimeContext,
    threadId,
    resourceId,
    memory,
    temperature,
    onStepFinish,
    onFinish,
    structuredOutput,
    telemetry,
    ...rest
  }) {
    const model = this.#model;
    this.logger.debug(`[LLM] - Streaming structured output`, {
      runId,
      messages,
      maxSteps,
      tools: Object.keys(tools || {})
    });
    const finalTools = tools;
    const argsForExecute = {
      model,
      temperature,
      tools: {
        ...finalTools
      },
      maxSteps,
      toolChoice,
      onStepFinish: async (props) => {
        void onStepFinish?.(props);
        this.logger.debug("[LLM] - Stream Step Change:", {
          text: props?.text,
          toolCalls: props?.toolCalls,
          toolResults: props?.toolResults,
          finishReason: props?.finishReason,
          usage: props?.usage,
          runId,
          threadId,
          resourceId
        });
        if (props?.response?.headers?.["x-ratelimit-remaining-tokens"] && parseInt(props?.response?.headers?.["x-ratelimit-remaining-tokens"], 10) < 2e3) {
          this.logger.warn("Rate limit approaching, waiting 10 seconds", { runId });
          await delay(10 * 1e3);
        }
      },
      onFinish: async (props) => {
        void onFinish?.(props);
        this.logger.debug("[LLM] - Stream Finished:", {
          text: props?.text,
          toolCalls: props?.toolCalls,
          toolResults: props?.toolResults,
          finishReason: props?.finishReason,
          usage: props?.usage,
          runId,
          threadId,
          resourceId
        });
      },
      ...rest
    };
    let schema;
    let output = "object";
    if (typeof structuredOutput.parse === "function") {
      schema = structuredOutput;
      if (schema instanceof lib.z.ZodArray) {
        output = "array";
        schema = schema._def.type;
      }
    } else {
      schema = jsonSchema(structuredOutput);
    }
    return streamObject({
      messages,
      ...argsForExecute,
      output,
      schema,
      experimental_telemetry: {
        ...this.experimental_telemetry,
        ...telemetry
      }
    });
  }
  async generate(messages, { maxSteps = 5, output, ...rest }) {
    const msgs = this.convertToMessages(messages);
    if (!output) {
      return await this.__text({
        messages: msgs,
        maxSteps,
        ...rest
      });
    }
    return await this.__textObject({
      messages: msgs,
      structuredOutput: output,
      maxSteps,
      ...rest
    });
  }
  async stream(messages, { maxSteps = 5, output, ...rest }) {
    const msgs = this.convertToMessages(messages);
    if (!output) {
      return await this.__stream({
        messages: msgs,
        maxSteps,
        ...rest
      });
    }
    return await this.__streamObject({
      messages: msgs,
      structuredOutput: output,
      maxSteps,
      ...rest
    });
  }
  convertToUIMessages(messages) {
    function addToolMessageToChat({
      toolMessage,
      messages: messages2,
      toolResultContents
    }) {
      const chatMessages2 = messages2.map((message) => {
        if (message.toolInvocations) {
          return {
            ...message,
            toolInvocations: message.toolInvocations.map((toolInvocation) => {
              const toolResult = toolMessage.content.find((tool) => tool.toolCallId === toolInvocation.toolCallId);
              if (toolResult) {
                return {
                  ...toolInvocation,
                  state: "result",
                  result: toolResult.result
                };
              }
              return toolInvocation;
            })
          };
        }
        return message;
      });
      const resultContents = [...toolResultContents, ...toolMessage.content];
      return { chatMessages: chatMessages2, toolResultContents: resultContents };
    }
    const { chatMessages } = messages.reduce(
      (obj, message) => {
        if (message.role === "tool") {
          return addToolMessageToChat({
            toolMessage: message,
            messages: obj.chatMessages,
            toolResultContents: obj.toolResultContents
          });
        }
        let textContent = "";
        let toolInvocations = [];
        if (typeof message.content === "string") {
          textContent = message.content;
        } else if (typeof message.content === "number") {
          textContent = String(message.content);
        } else if (Array.isArray(message.content)) {
          for (const content of message.content) {
            if (content.type === "text") {
              textContent += content.text;
            } else if (content.type === "tool-call") {
              const toolResult = obj.toolResultContents.find((tool) => tool.toolCallId === content.toolCallId);
              toolInvocations.push({
                state: toolResult ? "result" : "call",
                toolCallId: content.toolCallId,
                toolName: content.toolName,
                args: content.args,
                result: toolResult?.result
              });
            }
          }
        }
        obj.chatMessages.push({
          id: message.id,
          role: message.role,
          content: textContent,
          toolInvocations
        });
        return obj;
      },
      { chatMessages: [], toolResultContents: [] }
    );
    return chatMessages;
  }
};

// src/workflows/step.ts
var Step = class {
  id;
  description;
  inputSchema;
  outputSchema;
  payload;
  execute;
  retryConfig;
  mastra;
  constructor({
    id,
    description,
    execute,
    payload,
    outputSchema,
    inputSchema,
    retryConfig
  }) {
    this.id = id;
    this.description = description ?? "";
    this.inputSchema = inputSchema;
    this.payload = payload;
    this.outputSchema = outputSchema;
    this.execute = execute;
    this.retryConfig = retryConfig;
  }
};
function resolveMaybePromise(value, cb) {
  if (value instanceof Promise) {
    return value.then(cb);
  }
  return cb(value);
}
var _Agent_decorators, _init, _a;
_Agent_decorators = [InstrumentClass({
  prefix: "agent",
  excludeMethods: ["hasOwnMemory", "getMemory", "__primitive", "__registerMastra", "__registerPrimitives", "__setTools", "__setLogger", "__setTelemetry", "log", "getModel", "getInstructions", "getTools", "getLLM", "getWorkflows"]
})];
var Agent = class extends (_a = MastraBase) {
  id;
  name;
  #instructions;
  model;
  #mastra;
  #memory;
  #workflows;
  #defaultGenerateOptions;
  #defaultStreamOptions;
  #tools;
  /** @deprecated This property is deprecated. Use evals instead. */
  metrics;
  evals;
  #voice;
  constructor(config) {
    super({
      component: RegisteredLogger.AGENT
    });
    this.name = config.name;
    this.id = config.name;
    this.#instructions = config.instructions;
    if (!config.model) {
      throw new Error(`LanguageModel is required to create an Agent. Please provide the 'model'.`);
    }
    this.model = config.model;
    if (config.workflows) {
      this.#workflows = config.workflows;
    }
    this.#defaultGenerateOptions = config.defaultGenerateOptions || {};
    this.#defaultStreamOptions = config.defaultStreamOptions || {};
    this.#tools = config.tools || {};
    this.metrics = {};
    this.evals = {};
    if (config.mastra) {
      this.__registerMastra(config.mastra);
      this.__registerPrimitives({
        telemetry: config.mastra.getTelemetry(),
        logger: config.mastra.getLogger()
      });
    }
    if (config.metrics) {
      this.logger.warn("The metrics property is deprecated. Please use evals instead to add evaluation metrics.");
      this.metrics = config.metrics;
      this.evals = config.metrics;
    }
    if (config.evals) {
      this.evals = config.evals;
    }
    if (config.memory) {
      this.#memory = config.memory;
    }
    if (config.voice) {
      this.#voice = config.voice;
      if (typeof config.tools !== "function") {
        this.#voice?.addTools(this.tools);
      }
      if (typeof config.instructions === "string") {
        this.#voice?.addInstructions(config.instructions);
      }
    } else {
      this.#voice = new DefaultVoice();
    }
  }
  hasOwnMemory() {
    return Boolean(this.#memory);
  }
  getMemory() {
    return this.#memory ?? this.#mastra?.memory;
  }
  get voice() {
    if (typeof this.#instructions === "function") {
      throw new Error("Voice is not compatible when instructions are a function. Please use getVoice() instead.");
    }
    return this.#voice;
  }
  async getWorkflows({
    runtimeContext = new RuntimeContext()
  } = {}) {
    let workflowRecord;
    if (typeof this.#workflows === "function") {
      workflowRecord = await Promise.resolve(this.#workflows({
        runtimeContext
      }));
    } else {
      workflowRecord = this.#workflows ?? {};
    }
    Object.entries(workflowRecord || {}).forEach(([_workflowName, workflow]) => {
      if (this.#mastra) {
        workflow.__registerMastra(this.#mastra);
      }
    });
    return workflowRecord;
  }
  async getVoice({
    runtimeContext
  } = {}) {
    if (this.#voice) {
      const voice = this.#voice;
      voice?.addTools(await this.getTools({
        runtimeContext
      }));
      voice?.addInstructions(await this.getInstructions({
        runtimeContext
      }));
      return voice;
    } else {
      return new DefaultVoice();
    }
  }
  get instructions() {
    this.logger.warn("The instructions property is deprecated. Please use getInstructions() instead.");
    if (typeof this.#instructions === "function") {
      throw new Error("Instructions are not compatible when instructions are a function. Please use getInstructions() instead.");
    }
    return this.#instructions;
  }
  getInstructions({
    runtimeContext = new RuntimeContext()
  } = {}) {
    if (typeof this.#instructions === "string") {
      return this.#instructions;
    }
    const result = this.#instructions({
      runtimeContext
    });
    return resolveMaybePromise(result, instructions => {
      if (!instructions) {
        this.logger.error(`[Agent:${this.name}] - Function-based instructions returned empty value`);
        throw new Error("Instructions are required to use an Agent. The function-based instructions returned an empty value.");
      }
      return instructions;
    });
  }
  get tools() {
    this.logger.warn("The tools property is deprecated. Please use getTools() instead.");
    if (typeof this.#tools === "function") {
      throw new Error("Tools are not compatible when tools are a function. Please use getTools() instead.");
    }
    return ensureToolProperties(this.#tools);
  }
  getTools({
    runtimeContext = new RuntimeContext()
  } = {}) {
    if (typeof this.#tools !== "function") {
      return ensureToolProperties(this.#tools);
    }
    const result = this.#tools({
      runtimeContext
    });
    return resolveMaybePromise(result, tools => {
      if (!tools) {
        this.logger.error(`[Agent:${this.name}] - Function-based tools returned empty value`);
        throw new Error("Tools are required when using a function to provide them. The function returned an empty value.");
      }
      return ensureToolProperties(tools);
    });
  }
  get llm() {
    this.logger.warn("The llm property is deprecated. Please use getLLM() instead.");
    if (typeof this.model === "function") {
      throw new Error("LLM is not compatible when model is a function. Please use getLLM() instead.");
    }
    return this.getLLM();
  }
  /**
   * Gets or creates an LLM instance based on the current model
   * @param options Options for getting the LLM
   * @returns A promise that resolves to the LLM instance
   */
  getLLM({
    runtimeContext = new RuntimeContext()
  } = {}) {
    const model = this.getModel({
      runtimeContext
    });
    return resolveMaybePromise(model, model2 => {
      const llm = new MastraLLM({
        model: model2,
        mastra: this.#mastra
      });
      if (this.#primitives) {
        llm.__registerPrimitives(this.#primitives);
      }
      if (this.#mastra) {
        llm.__registerMastra(this.#mastra);
      }
      return llm;
    });
  }
  /**
   * Gets the model, resolving it if it's a function
   * @param options Options for getting the model
   * @returns A promise that resolves to the model
   */
  getModel({
    runtimeContext = new RuntimeContext()
  } = {}) {
    if (typeof this.model !== "function") {
      if (!this.model) {
        this.logger.error(`[Agent:${this.name}] - No model provided`);
        throw new Error("Model is required to use an Agent.");
      }
      return this.model;
    }
    const result = this.model({
      runtimeContext
    });
    return resolveMaybePromise(result, model => {
      if (!model) {
        this.logger.error(`[Agent:${this.name}] - Function-based model returned empty value`);
        throw new Error("Model is required to use an Agent. The function-based model returned an empty value.");
      }
      return model;
    });
  }
  __updateInstructions(newInstructions) {
    this.#instructions = newInstructions;
    this.logger.debug(`[Agents:${this.name}] Instructions updated.`, {
      model: this.model,
      name: this.name
    });
  }
  #primitives;
  __registerPrimitives(p) {
    if (p.telemetry) {
      this.__setTelemetry(p.telemetry);
    }
    if (p.logger) {
      this.__setLogger(p.logger);
    }
    this.#primitives = p;
    this.logger.debug(`[Agents:${this.name}] initialized.`, {
      model: this.model,
      name: this.name
    });
  }
  __registerMastra(mastra) {
    this.#mastra = mastra;
  }
  /**
   * Set the concrete tools for the agent
   * @param tools
   */
  __setTools(tools) {
    this.#tools = tools;
    this.logger.debug(`[Agents:${this.name}] Tools set for agent ${this.name}`, {
      model: this.model,
      name: this.name
    });
  }
  async generateTitleFromUserMessage({
    message,
    runtimeContext = new RuntimeContext()
  }) {
    const llm = await this.getLLM({
      runtimeContext
    });
    const {
      text
    } = await llm.__text({
      runtimeContext,
      messages: [{
        role: "system",
        content: `

    - you will generate a short title based on the first message a user begins a conversation with
    - ensure it is not more than 80 characters long
    - the title should be a summary of the user's message
    - do not use quotes or colons
    - the entire text you return will be used as the title`
      }, {
        role: "user",
        content: JSON.stringify(message)
      }]
    });
    const cleanedText = text.replace(/<think>[\s\S]*?<\/think>/g, "").trim();
    return cleanedText;
  }
  getMostRecentUserMessage(messages) {
    const userMessages = messages.filter(message => message.role === "user");
    return userMessages.at(-1);
  }
  async genTitle(userMessage) {
    let title = `New Thread ${(/* @__PURE__ */new Date()).toISOString()}`;
    try {
      if (userMessage) {
        title = await this.generateTitleFromUserMessage({
          message: userMessage
        });
      }
    } catch (e) {
      console.error("Error generating title:", e);
    }
    return title;
  }
  async fetchMemory({
    threadId,
    thread: passedThread,
    memoryConfig,
    resourceId,
    userMessages,
    systemMessage,
    runId
  }) {
    const memory = this.getMemory();
    if (memory) {
      const thread = passedThread ?? (await memory.getThreadById({
        threadId
      }));
      if (!thread) {
        return {
          threadId: threadId || "",
          messages: userMessages
        };
      }
      const newMessages = ensureAllMessagesAreCoreMessages(userMessages);
      const now = Date.now();
      const messages = newMessages.map((u, index) => {
        return {
          id: this.getMemory()?.generateId(),
          createdAt: new Date(now + index),
          threadId,
          ...u,
          content: u.content,
          role: u.role,
          type: "text"
        };
      });
      const [memoryMessages, memorySystemMessage] = threadId && memory ? await Promise.all([memory.rememberMessages({
        threadId,
        resourceId,
        config: memoryConfig,
        systemMessage,
        vectorMessageSearch: messages.slice(-1).map(m => {
          if (typeof m === `string`) {
            return m;
          }
          return m?.content || ``;
        }).join(`
`)
      }).then(r => r.messages), memory.getSystemMessage({
        threadId,
        memoryConfig
      })]) : [[], null];
      this.logger.debug("Saved messages to memory", {
        threadId,
        runId
      });
      const processedMessages = memory.processMessages({
        messages: this.sanitizeResponseMessages(memoryMessages),
        newMessages,
        systemMessage: typeof systemMessage?.content === `string` ? systemMessage.content : void 0,
        memorySystemMessage: memorySystemMessage ?? ``
      });
      return {
        threadId: thread.id,
        messages: [memorySystemMessage ? {
          role: "system",
          content: memorySystemMessage
        } : null, ...processedMessages, ...newMessages].filter(message => Boolean(message))
      };
    }
    return {
      threadId: threadId || "",
      messages: userMessages
    };
  }
  getResponseMessages({
    messages,
    threadId,
    resourceId,
    now,
    experimental_generateMessageId
  }) {
    if (!messages) return [];
    const messagesArray = Array.isArray(messages) ? messages : [messages];
    return this.sanitizeResponseMessages(messagesArray).map((message, index) => {
      const messageId = `id` in message && message.id || experimental_generateMessageId?.() || randomUUID();
      let toolCallIds;
      let toolCallArgs;
      let toolNames;
      let type = "text";
      if (message.role === "tool") {
        toolCallIds = message.content.map(content => content.toolCallId);
        type = "tool-result";
      }
      if (message.role === "assistant") {
        const assistantContent = message.content;
        const assistantToolCalls = assistantContent.map(content => {
          if (content.type === "tool-call") {
            return {
              toolCallId: content.toolCallId,
              toolArgs: content.args,
              toolName: content.toolName
            };
          }
          return void 0;
        })?.filter(Boolean);
        toolCallIds = assistantToolCalls?.map(toolCall => toolCall.toolCallId);
        toolCallArgs = assistantToolCalls?.map(toolCall => toolCall.toolArgs);
        toolNames = assistantToolCalls?.map(toolCall => toolCall.toolName);
        type = assistantContent?.[0]?.type;
      }
      return {
        id: messageId,
        threadId,
        resourceId,
        role: message.role,
        content: message.content,
        createdAt: new Date(now + index),
        // use Date.now() + index to make sure every message is atleast one millisecond apart
        toolCallIds: toolCallIds?.length ? toolCallIds : void 0,
        toolCallArgs: toolCallArgs?.length ? toolCallArgs : void 0,
        toolNames: toolNames?.length ? toolNames : void 0,
        type
      };
    });
  }
  sanitizeResponseMessages(messages) {
    let toolResultIds = [];
    let toolCallIds = [];
    for (const message of messages) {
      if (!Array.isArray(message.content)) continue;
      if (message.role === "tool") {
        for (const content of message.content) {
          if (content.type === "tool-result") {
            toolResultIds.push(content.toolCallId);
          }
        }
      } else if (message.role === "assistant" || message.role === "user") {
        for (const content of message.content) {
          if (typeof content !== `string`) {
            if (content.type === `tool-call`) {
              toolCallIds.push(content.toolCallId);
            }
          }
        }
      }
    }
    const messagesBySanitizedContent = messages.map(message => {
      if (message.role !== "assistant" && message.role !== `tool` && message.role !== `user`) return message;
      if (!Array.isArray(message.content)) {
        return message;
      }
      const sanitizedContent = message.content.filter(content => {
        if (content.type === `tool-call`) {
          return toolResultIds.includes(content.toolCallId);
        }
        if (content.type === `text`) {
          return content.text.trim() !== ``;
        }
        if (content.type === `tool-result`) {
          return toolCallIds.includes(content.toolCallId);
        }
        return true;
      });
      return {
        ...message,
        content: sanitizedContent
      };
    });
    return messagesBySanitizedContent.filter(message => {
      if (typeof message.content === `string`) {
        if (message.role === "assistant") {
          return true;
        }
        return message.content !== "";
      }
      if (Array.isArray(message.content)) {
        return message.content.length && message.content.every(c => {
          if (c.type === `text`) {
            return c.text && c.text !== "";
          }
          return true;
        });
      }
      return true;
    });
  }
  async getMemoryTools({
    runId,
    resourceId,
    threadId,
    runtimeContext,
    mastraProxy
  }) {
    let convertedMemoryTools = {};
    const memory = this.getMemory();
    const memoryTools = memory?.getTools?.();
    if (memoryTools) {
      const memoryToolEntries = await Promise.all(Object.entries(memoryTools).map(async ([k, tool]) => {
        return [k, {
          description: tool.description,
          parameters: tool.parameters,
          execute: typeof tool?.execute === "function" ? async (args, options) => {
            try {
              this.logger.debug(`[Agent:${this.name}] - Executing memory tool ${k}`, {
                name: k,
                description: tool.description,
                args,
                runId,
                threadId,
                resourceId
              });
              return tool?.execute?.({
                context: args,
                mastra: mastraProxy,
                memory,
                runId,
                threadId,
                resourceId,
                logger: this.logger,
                agentName: this.name,
                runtimeContext
              }, options) ?? void 0;
            } catch (err) {
              this.logger.error(`[Agent:${this.name}] - Failed memory tool execution`, {
                error: err,
                runId,
                threadId,
                resourceId
              });
              throw err;
            }
          } : void 0
        }];
      }));
      convertedMemoryTools = Object.fromEntries(memoryToolEntries.filter(entry => Boolean(entry)));
    }
    return convertedMemoryTools;
  }
  async getAssignedTools({
    runtimeContext,
    runId,
    resourceId,
    threadId,
    mastraProxy
  }) {
    let toolsForRequest = {};
    this.logger.debug(`[Agents:${this.name}] - Assembling assigned tools`, {
      runId,
      threadId,
      resourceId
    });
    const memory = this.getMemory();
    const assignedTools = await this.getTools({
      runtimeContext
    });
    const assignedToolEntries = Object.entries(assignedTools || {});
    const assignedCoreToolEntries = await Promise.all(assignedToolEntries.map(async ([k, tool]) => {
      if (!tool) {
        return;
      }
      const options = {
        name: k,
        runId,
        threadId,
        resourceId,
        logger: this.logger,
        mastra: mastraProxy,
        memory,
        agentName: this.name,
        runtimeContext,
        model: typeof this.model === "function" ? await this.getModel({
          runtimeContext
        }) : this.model
      };
      return [k, makeCoreTool(tool, options)];
    }));
    const assignedToolEntriesConverted = Object.fromEntries(assignedCoreToolEntries.filter(entry => Boolean(entry)));
    toolsForRequest = {
      ...assignedToolEntriesConverted
    };
    return toolsForRequest;
  }
  async getToolsets({
    runId,
    threadId,
    resourceId,
    toolsets,
    runtimeContext,
    mastraProxy
  }) {
    let toolsForRequest = {};
    const memory = this.getMemory();
    const toolsFromToolsets = Object.values(toolsets || {});
    if (toolsFromToolsets.length > 0) {
      this.logger.debug(`[Agent:${this.name}] - Adding tools from toolsets ${Object.keys(toolsets || {}).join(", ")}`, {
        runId
      });
      for (const toolset of toolsFromToolsets) {
        for (const [toolName, tool] of Object.entries(toolset)) {
          const toolObj = tool;
          const options = {
            name: toolName,
            runId,
            threadId,
            resourceId,
            logger: this.logger,
            mastra: mastraProxy,
            memory,
            agentName: this.name,
            runtimeContext,
            model: typeof this.model === "function" ? await this.getModel({
              runtimeContext
            }) : this.model
          };
          const convertedToCoreTool = makeCoreTool(toolObj, options, "toolset");
          toolsForRequest[toolName] = convertedToCoreTool;
        }
      }
    }
    return toolsForRequest;
  }
  async getClientTools({
    runId,
    threadId,
    resourceId,
    runtimeContext,
    mastraProxy,
    clientTools
  }) {
    let toolsForRequest = {};
    const memory = this.getMemory();
    const clientToolsForInput = Object.entries(clientTools || {});
    if (clientToolsForInput.length > 0) {
      this.logger.debug(`[Agent:${this.name}] - Adding client tools ${Object.keys(clientTools || {}).join(", ")}`, {
        runId
      });
      for (const [toolName, tool] of clientToolsForInput) {
        const {
          execute,
          ...rest
        } = tool;
        const options = {
          name: toolName,
          runId,
          threadId,
          resourceId,
          logger: this.logger,
          mastra: mastraProxy,
          memory,
          agentName: this.name,
          runtimeContext,
          model: typeof this.model === "function" ? await this.getModel({
            runtimeContext
          }) : this.model
        };
        const convertedToCoreTool = makeCoreTool(rest, options, "client-tool");
        toolsForRequest[toolName] = convertedToCoreTool;
      }
    }
    return toolsForRequest;
  }
  async getWorkflowTools({
    runId,
    threadId,
    resourceId,
    runtimeContext
  }) {
    let convertedWorkflowTools = {};
    const workflows = await this.getWorkflows({
      runtimeContext
    });
    if (Object.keys(workflows).length > 0) {
      convertedWorkflowTools = Object.entries(workflows).reduce((memo, [workflowName, workflow]) => {
        memo[workflowName] = {
          description: workflow.description || `Workflow: ${workflowName}`,
          parameters: workflow.inputSchema || {
            type: "object",
            properties: {}
          },
          execute: async args => {
            try {
              this.logger.debug(`[Agent:${this.name}] - Executing workflow as tool ${workflowName}`, {
                name: workflowName,
                description: workflow.description,
                args,
                runId,
                threadId,
                resourceId
              });
              const run = workflow.createRun();
              const result = await run.start({
                inputData: args,
                runtimeContext
              });
              return result;
            } catch (err) {
              this.logger.error(`[Agent:${this.name}] - Failed workflow tool execution`, {
                error: err,
                runId,
                threadId,
                resourceId
              });
              throw err;
            }
          }
        };
        return memo;
      }, {});
    }
    return convertedWorkflowTools;
  }
  async convertTools({
    toolsets,
    clientTools,
    threadId,
    resourceId,
    runId,
    runtimeContext
  }) {
    let mastraProxy = void 0;
    const logger = this.logger;
    if (this.#mastra) {
      mastraProxy = createMastraProxy({
        mastra: this.#mastra,
        logger
      });
    }
    const assignedTools = await this.getAssignedTools({
      runId,
      resourceId,
      threadId,
      runtimeContext,
      mastraProxy
    });
    const memoryTools = await this.getMemoryTools({
      runId,
      resourceId,
      threadId,
      runtimeContext,
      mastraProxy
    });
    const toolsetTools = await this.getToolsets({
      runId,
      resourceId,
      threadId,
      runtimeContext,
      mastraProxy,
      toolsets
    });
    const clientsideTools = await this.getClientTools({
      runId,
      resourceId,
      threadId,
      runtimeContext,
      mastraProxy,
      clientTools
    });
    const workflowTools = await this.getWorkflowTools({
      runId,
      resourceId,
      threadId,
      runtimeContext
    });
    return {
      ...assignedTools,
      ...memoryTools,
      ...toolsetTools,
      ...clientsideTools,
      ...workflowTools
    };
  }
  async preExecute({
    resourceId,
    runId,
    threadId,
    thread,
    memoryConfig,
    messages,
    systemMessage
  }) {
    let coreMessages = [];
    let threadIdToUse = threadId;
    this.logger.debug(`Saving user messages in memory for agent ${this.name}`, {
      runId
    });
    const saveMessageResponse = await this.fetchMemory({
      threadId,
      thread,
      resourceId,
      userMessages: messages,
      memoryConfig,
      systemMessage
    });
    coreMessages = saveMessageResponse.messages;
    threadIdToUse = saveMessageResponse.threadId;
    return {
      coreMessages,
      threadIdToUse
    };
  }
  __primitive({
    instructions,
    messages,
    context,
    threadId,
    memoryConfig,
    resourceId,
    runId,
    toolsets,
    clientTools,
    runtimeContext
  }) {
    return {
      before: async () => {
        if (process.env.NODE_ENV !== "test") {
          this.logger.debug(`[Agents:${this.name}] - Starting generation`, {
            runId
          });
        }
        const systemMessage = {
          role: "system",
          content: instructions || `${this.instructions}.`
        };
        let coreMessages = messages;
        let threadIdToUse = threadId;
        let thread;
        const memory = this.getMemory();
        if (threadId && memory && !resourceId) {
          throw new Error(`A resourceId must be provided when passing a threadId and using Memory. Saw threadId ${threadId} but resourceId is ${resourceId}`);
        }
        if (memory && resourceId) {
          this.logger.debug(`[Agent:${this.name}] - Memory persistence enabled: store=${this.getMemory()?.constructor.name}, resourceId=${resourceId}`, {
            runId,
            resourceId,
            threadId: threadIdToUse,
            memoryStore: this.getMemory()?.constructor.name
          });
          thread = threadIdToUse ? await memory.getThreadById({
            threadId: threadIdToUse
          }) : void 0;
          if (!thread) {
            thread = await memory.createThread({
              threadId: threadIdToUse,
              resourceId,
              memoryConfig
            });
          }
          threadIdToUse = thread.id;
          const preExecuteResult = await this.preExecute({
            resourceId,
            runId,
            threadId: threadIdToUse,
            thread,
            memoryConfig,
            messages,
            systemMessage
          });
          coreMessages = preExecuteResult.coreMessages;
          threadIdToUse = preExecuteResult.threadIdToUse;
        }
        let convertedTools;
        const reasons = [];
        if (toolsets && Object.keys(toolsets || {}).length > 0) {
          reasons.push(`toolsets present (${Object.keys(toolsets || {}).length} tools)`);
        }
        if (this.getMemory() && resourceId) {
          reasons.push("memory and resourceId available");
        }
        this.logger.debug(`[Agent:${this.name}] - Enhancing tools: ${reasons.join(", ")}`, {
          runId,
          toolsets: toolsets ? Object.keys(toolsets) : void 0,
          clientTools: clientTools ? Object.keys(clientTools) : void 0,
          hasMemory: !!this.getMemory(),
          hasResourceId: !!resourceId
        });
        convertedTools = await this.convertTools({
          toolsets,
          clientTools,
          threadId: threadIdToUse,
          resourceId,
          runId,
          runtimeContext
        });
        const messageObjects = [systemMessage, ...(context || []), ...coreMessages];
        return {
          messageObjects,
          convertedTools,
          threadId: threadIdToUse,
          thread
        };
      },
      after: async ({
        result,
        thread: threadAfter,
        threadId: threadId2,
        memoryConfig: memoryConfig2,
        outputText,
        runId: runId2,
        experimental_generateMessageId
      }) => {
        const resToLog = {
          text: result?.text,
          object: result?.object,
          toolResults: result?.toolResults,
          toolCalls: result?.toolCalls,
          usage: result?.usage,
          steps: result?.steps?.map(s => {
            return {
              stepType: s?.stepType,
              text: result?.text,
              object: result?.object,
              toolResults: result?.toolResults,
              toolCalls: result?.toolCalls,
              usage: result?.usage
            };
          })
        };
        this.logger.debug(`[Agent:${this.name}] - Post processing LLM response`, {
          runId: runId2,
          result: resToLog,
          threadId: threadId2
        });
        const memory = this.getMemory();
        const thread = threadAfter || (threadId2 ? await memory?.getThreadById({
          threadId: threadId2
        }) : void 0);
        if (memory && resourceId && thread) {
          try {
            const userMessage = this.getMostRecentUserMessage(messages);
            const now = Date.now();
            const threadMessages = this.sanitizeResponseMessages(ensureAllMessagesAreCoreMessages(messages)).map((u, index) => {
              return {
                id: `id` in u && u.id || experimental_generateMessageId ? experimental_generateMessageId() : this.getMemory()?.generateId(),
                createdAt: new Date(now + index),
                threadId: thread.id,
                resourceId,
                ...u,
                content: u.content,
                role: u.role,
                type: "text"
              };
            });
            const dateResponseMessagesFrom = (threadMessages.at(-1)?.createdAt?.getTime?.() || Date.now()) + 1;
            void (async () => {
              if (!thread.title?.startsWith("New Thread")) {
                return;
              }
              const config = memory.getMergedThreadConfig(memoryConfig2);
              const title = config?.threads?.generateTitle ? await this.genTitle(userMessage) : void 0;
              if (!title) {
                return;
              }
              return memory.createThread({
                threadId: thread.id,
                resourceId,
                memoryConfig: memoryConfig2,
                title,
                metadata: thread.metadata
              });
            })();
            let responseMessages = result.response.messages;
            if (!responseMessages && result.object) {
              responseMessages = [{
                role: "assistant",
                content: [{
                  type: "text",
                  text: outputText
                }]
              }];
            }
            await memory.saveMessages({
              messages: [...threadMessages, ...this.getResponseMessages({
                threadId: threadId2,
                resourceId,
                messages: responseMessages,
                now: dateResponseMessagesFrom,
                experimental_generateMessageId
              })],
              memoryConfig: memoryConfig2
            });
          } catch (e) {
            const message = e instanceof Error ? e.message : JSON.stringify(e);
            this.logger.error("Error saving response", {
              error: message,
              runId: runId2,
              result: resToLog,
              threadId: threadId2
            });
          }
        }
        if (Object.keys(this.evals || {}).length > 0) {
          const input = messages.map(message => message.content).join("\n");
          const runIdToUse = runId2 || crypto.randomUUID();
          for (const metric of Object.values(this.evals || {})) {
            executeHook("onGeneration" /* ON_GENERATION */, {
              input,
              output: outputText,
              runId: runIdToUse,
              metric,
              agentName: this.name,
              instructions: instructions || this.instructions
            });
          }
        }
      }
    };
  }
  async generate(messages, generateOptions = {}) {
    const {
      instructions,
      context,
      threadId: threadIdInFn,
      memoryOptions,
      resourceId,
      maxSteps,
      onStepFinish,
      runId,
      output,
      toolsets,
      clientTools,
      temperature,
      toolChoice = "auto",
      experimental_output,
      telemetry,
      runtimeContext = new RuntimeContext(),
      ...rest
    } = Object.assign({}, this.#defaultGenerateOptions, generateOptions);
    let messagesToUse = [];
    if (typeof messages === `string`) {
      messagesToUse = [{
        role: "user",
        content: messages
      }];
    } else if (Array.isArray(messages)) {
      messagesToUse = messages.map(message => {
        if (typeof message === `string`) {
          return {
            role: "user",
            content: message
          };
        }
        return message;
      });
    } else {
      messagesToUse = [messages];
    }
    const runIdToUse = runId || randomUUID();
    const instructionsToUse = instructions || (await this.getInstructions({
      runtimeContext
    }));
    const llm = await this.getLLM({
      runtimeContext
    });
    const {
      before,
      after
    } = this.__primitive({
      instructions: instructionsToUse,
      messages: messagesToUse,
      context,
      threadId: threadIdInFn,
      memoryConfig: memoryOptions,
      resourceId,
      runId: runIdToUse,
      toolsets,
      clientTools,
      runtimeContext
    });
    const {
      threadId,
      thread,
      messageObjects,
      convertedTools
    } = await before();
    if (!output && experimental_output) {
      const result2 = await llm.__text({
        messages: messageObjects,
        tools: convertedTools,
        onStepFinish: result3 => {
          void onStepFinish?.(result3);
        },
        maxSteps,
        runId: runIdToUse,
        temperature,
        toolChoice: toolChoice || "auto",
        experimental_output,
        threadId,
        resourceId,
        memory: this.getMemory(),
        runtimeContext,
        ...rest
      });
      const outputText2 = result2.text;
      await after({
        result: result2,
        threadId,
        thread,
        memoryConfig: memoryOptions,
        outputText: outputText2,
        runId: runIdToUse,
        experimental_generateMessageId: `experimental_generateMessageId` in rest ? rest.experimental_generateMessageId : void 0
      });
      const newResult = result2;
      newResult.object = result2.experimental_output;
      return newResult;
    }
    if (!output) {
      const result2 = await llm.__text({
        messages: messageObjects,
        tools: convertedTools,
        onStepFinish: result3 => {
          void onStepFinish?.(result3);
        },
        maxSteps,
        runId: runIdToUse,
        temperature,
        toolChoice,
        telemetry,
        threadId,
        resourceId,
        memory: this.getMemory(),
        runtimeContext,
        ...rest
      });
      const outputText2 = result2.text;
      await after({
        result: result2,
        thread,
        threadId,
        memoryConfig: memoryOptions,
        outputText: outputText2,
        runId: runIdToUse,
        experimental_generateMessageId: `experimental_generateMessageId` in rest ? rest.experimental_generateMessageId : void 0
      });
      return result2;
    }
    const result = await llm.__textObject({
      messages: messageObjects,
      tools: convertedTools,
      structuredOutput: output,
      onStepFinish: result2 => {
        void onStepFinish?.(result2);
      },
      maxSteps,
      runId: runIdToUse,
      temperature,
      toolChoice,
      telemetry,
      memory: this.getMemory(),
      runtimeContext,
      ...rest
    });
    const outputText = JSON.stringify(result.object);
    await after({
      result,
      thread,
      threadId,
      memoryConfig: memoryOptions,
      outputText,
      runId: runIdToUse,
      experimental_generateMessageId: `experimental_generateMessageId` in rest ? rest.experimental_generateMessageId : void 0
    });
    return result;
  }
  async stream(messages, streamOptions = {}) {
    const {
      instructions,
      context,
      threadId: threadIdInFn,
      memoryOptions,
      resourceId,
      maxSteps,
      onFinish,
      onStepFinish,
      runId,
      toolsets,
      clientTools,
      output,
      temperature,
      toolChoice = "auto",
      experimental_output,
      telemetry,
      runtimeContext = new RuntimeContext(),
      ...rest
    } = Object.assign({}, this.#defaultStreamOptions, streamOptions);
    const runIdToUse = runId || randomUUID();
    const instructionsToUse = instructions || (await this.getInstructions({
      runtimeContext
    }));
    const llm = await this.getLLM({
      runtimeContext
    });
    let messagesToUse = [];
    if (typeof messages === `string`) {
      messagesToUse = [{
        role: "user",
        content: messages
      }];
    } else {
      messagesToUse = messages.map(message => {
        if (typeof message === `string`) {
          return {
            role: "user",
            content: message
          };
        }
        return message;
      });
    }
    const {
      before,
      after
    } = this.__primitive({
      instructions: instructionsToUse,
      messages: messagesToUse,
      context,
      threadId: threadIdInFn,
      memoryConfig: memoryOptions,
      resourceId,
      runId: runIdToUse,
      toolsets,
      clientTools,
      runtimeContext
    });
    const {
      threadId,
      thread,
      messageObjects,
      convertedTools
    } = await before();
    if (!output && experimental_output) {
      this.logger.debug(`Starting agent ${this.name} llm stream call`, {
        runId
      });
      const streamResult = await llm.__stream({
        messages: messageObjects,
        temperature,
        tools: convertedTools,
        onStepFinish: result => {
          void onStepFinish?.(result);
        },
        onFinish: async result => {
          try {
            const outputText = result.text;
            await after({
              result,
              thread,
              threadId,
              memoryConfig: memoryOptions,
              outputText,
              runId: runIdToUse,
              experimental_generateMessageId: `experimental_generateMessageId` in rest ? rest.experimental_generateMessageId : void 0
            });
          } catch (e) {
            this.logger.error("Error saving memory on finish", {
              error: e,
              runId
            });
          }
          void onFinish?.(result);
        },
        maxSteps,
        runId: runIdToUse,
        toolChoice,
        experimental_output,
        memory: this.getMemory(),
        runtimeContext,
        ...rest
      });
      const newStreamResult = streamResult;
      newStreamResult.partialObjectStream = streamResult.experimental_partialOutputStream;
      return newStreamResult;
    } else if (!output) {
      this.logger.debug(`Starting agent ${this.name} llm stream call`, {
        runId
      });
      return llm.__stream({
        messages: messageObjects,
        temperature,
        tools: convertedTools,
        onStepFinish: result => {
          void onStepFinish?.(result);
        },
        onFinish: async result => {
          try {
            const outputText = result.text;
            await after({
              result,
              thread,
              threadId,
              memoryConfig: memoryOptions,
              outputText,
              runId: runIdToUse,
              experimental_generateMessageId: `experimental_generateMessageId` in rest ? rest.experimental_generateMessageId : void 0
            });
          } catch (e) {
            this.logger.error("Error saving memory on finish", {
              error: e,
              runId
            });
          }
          void onFinish?.(result);
        },
        maxSteps,
        runId: runIdToUse,
        toolChoice,
        telemetry,
        memory: this.getMemory(),
        runtimeContext,
        ...rest
      });
    }
    this.logger.debug(`Starting agent ${this.name} llm streamObject call`, {
      runId
    });
    return llm.__streamObject({
      messages: messageObjects,
      tools: convertedTools,
      temperature,
      structuredOutput: output,
      onStepFinish: result => {
        void onStepFinish?.(result);
      },
      onFinish: async result => {
        try {
          const outputText = JSON.stringify(result.object);
          await after({
            result,
            thread,
            threadId,
            memoryConfig: memoryOptions,
            outputText,
            runId: runIdToUse,
            experimental_generateMessageId: `experimental_generateMessageId` in rest ? rest.experimental_generateMessageId : void 0
          });
        } catch (e) {
          this.logger.error("Error saving memory on finish", {
            error: e,
            runId
          });
        }
        void onFinish?.(result);
      },
      runId: runIdToUse,
      toolChoice,
      telemetry,
      memory: this.getMemory(),
      runtimeContext,
      ...rest
    });
  }
  /**
   * Convert text to speech using the configured voice provider
   * @param input Text or text stream to convert to speech
   * @param options Speech options including speaker and provider-specific options
   * @returns Audio stream
   * @deprecated Use agent.voice.speak() instead
   */
  async speak(input, options) {
    if (!this.voice) {
      throw new Error("No voice provider configured");
    }
    this.logger.warn("Warning: agent.speak() is deprecated. Please use agent.voice.speak() instead.");
    try {
      return this.voice.speak(input, options);
    } catch (e) {
      this.logger.error("Error during agent speak", {
        error: e
      });
      throw e;
    }
  }
  /**
   * Convert speech to text using the configured voice provider
   * @param audioStream Audio stream to transcribe
   * @param options Provider-specific transcription options
   * @returns Text or text stream
   * @deprecated Use agent.voice.listen() instead
   */
  async listen(audioStream, options) {
    if (!this.voice) {
      throw new Error("No voice provider configured");
    }
    this.logger.warn("Warning: agent.listen() is deprecated. Please use agent.voice.listen() instead");
    try {
      return this.voice.listen(audioStream, options);
    } catch (e) {
      this.logger.error("Error during agent listen", {
        error: e
      });
      throw e;
    }
  }
  /**
   * Get a list of available speakers from the configured voice provider
   * @throws {Error} If no voice provider is configured
   * @returns {Promise<Array<{voiceId: string}>>} List of available speakers
   * @deprecated Use agent.voice.getSpeakers() instead
   */
  async getSpeakers() {
    if (!this.voice) {
      throw new Error("No voice provider configured");
    }
    this.logger.warn("Warning: agent.getSpeakers() is deprecated. Please use agent.voice.getSpeakers() instead.");
    try {
      return await this.voice.getSpeakers();
    } catch (e) {
      this.logger.error("Error during agent getSpeakers", {
        error: e
      });
      throw e;
    }
  }
  toStep() {
    const x = agentToStep(this);
    return new Step(x);
  }
};
Agent = /*@__PURE__*/(_ => {
  _init = __decoratorStart(_a);
  Agent = __decorateElement(_init, 0, "Agent", _Agent_decorators, Agent);
  __runInitializers(_init, 1, Agent);

  // src/workflows/utils.ts
  return Agent;
})();
function agentToStep(agent, {
  mastra
} = {}) {
  return {
    id: agent.name,
    inputSchema: lib.z.object({
      prompt: lib.z.string(),
      resourceId: lib.z.string().optional(),
      threadId: lib.z.string().optional()
    }),
    outputSchema: lib.z.object({
      text: lib.z.string()
    }),
    execute: async ({
      context,
      runId,
      mastra: mastraFromExecute
    }) => {
      const realMastra = mastraFromExecute ?? mastra;
      if (!realMastra) {
        throw new Error("Mastra instance not found");
      }
      agent.__registerMastra(realMastra);
      agent.__registerPrimitives({
        logger: realMastra.getLogger(),
        telemetry: realMastra.getTelemetry()
      });
      const result = await agent.generate(context.inputData.prompt, {
        runId,
        resourceId: context.inputData.resourceId,
        threadId: context.inputData.threadId
      });
      return {
        text: result.text
      };
    }
  };
}

// src/workflows/vNext/execution-engine.ts
var ExecutionEngine = class extends MastraBase {
  mastra;
  constructor({ mastra }) {
    super({ name: "ExecutionEngine", component: RegisteredLogger.WORKFLOW });
    this.mastra = mastra;
  }
  __registerMastra(mastra) {
    this.mastra = mastra;
  }
};

// src/workflows/vNext/default.ts
var DefaultExecutionEngine = class extends ExecutionEngine {
  async fmtReturnValue(executionSpan, emitter, stepResults, lastOutput, error) {
    const base = {
      status: lastOutput.status,
      steps: stepResults
    };
    if (lastOutput.status === "success") {
      await emitter.emit("watch", {
        type: "watch",
        payload: {
          workflowState: {
            status: lastOutput.status,
            steps: stepResults,
            result: lastOutput.output
          }
        },
        eventTimestamp: Date.now()
      });
      base.result = lastOutput.output;
    } else if (lastOutput.status === "failed") {
      await emitter.emit("watch", {
        type: "watch",
        payload: {
          workflowState: {
            status: lastOutput.status,
            steps: stepResults,
            result: null,
            error: lastOutput.error
          }
        },
        eventTimestamp: Date.now()
      });
      base.error = error instanceof Error ? error : lastOutput.error ?? new Error("Unknown error: " + error);
    } else if (lastOutput.status === "suspended") {
      const suspendedStepIds = Object.entries(stepResults).flatMap(([stepId, stepResult]) => {
        if (stepResult?.status === "suspended") {
          const nestedPath = stepResult?.payload?.__workflow_meta?.path;
          return nestedPath ? [[stepId, ...nestedPath]] : [[stepId]];
        }
        return [];
      });
      base.suspended = suspendedStepIds;
      await emitter.emit("watch", {
        type: "watch",
        payload: {
          workflowState: {
            status: lastOutput.status,
            steps: stepResults,
            result: null,
            error: null
          }
        },
        eventTimestamp: Date.now()
      });
    }
    executionSpan?.end();
    return base;
  }
  /**
   * Executes a workflow run with the provided execution graph and input
   * @param graph The execution graph to execute
   * @param input The input data for the workflow
   * @returns A promise that resolves to the workflow output
   */
  async execute(params) {
    const { workflowId, runId, graph, input, resume, retryConfig } = params;
    const { attempts = 0, delay = 0 } = retryConfig ?? {};
    const steps = graph.steps;
    if (steps.length === 0) {
      throw new Error("Workflow must have at least one step");
    }
    const executionSpan = this.mastra?.getTelemetry()?.tracer.startSpan(`workflow.${workflowId}.execute`, {
      attributes: { componentName: workflowId, runId }
    });
    await this.mastra?.getStorage()?.init();
    let startIdx = 0;
    if (resume?.resumePath) {
      startIdx = resume.resumePath[0];
      resume.resumePath.shift();
    }
    const stepResults = resume?.stepResults || { input };
    let lastOutput;
    for (let i = startIdx; i < steps.length; i++) {
      const entry = steps[i];
      try {
        lastOutput = await this.executeEntry({
          workflowId,
          runId,
          entry,
          prevStep: steps[i - 1],
          stepResults,
          resume,
          executionContext: {
            workflowId,
            runId,
            executionPath: [i],
            suspendedPaths: {},
            retryConfig: { attempts, delay },
            executionSpan
          },
          emitter: params.emitter,
          runtimeContext: params.runtimeContext
        });
        if (lastOutput.status !== "success") {
          return this.fmtReturnValue(executionSpan, params.emitter, stepResults, lastOutput);
        }
      } catch (e) {
        this.logger.error("Error executing step: " + (e?.stack ?? e));
        return this.fmtReturnValue(executionSpan, params.emitter, stepResults, lastOutput, e);
      }
    }
    return this.fmtReturnValue(executionSpan, params.emitter, stepResults, lastOutput);
  }
  getStepOutput(stepResults, step) {
    if (!step) {
      return stepResults.input;
    } else if (step.type === "step") {
      return stepResults[step.step.id]?.output;
    } else if (step.type === "parallel" || step.type === "conditional") {
      return step.steps.reduce(
        (acc, entry) => {
          if (entry.type === "step") {
            acc[entry.step.id] = stepResults[entry.step.id]?.output;
          } else if (entry.type === "parallel" || entry.type === "conditional") {
            const parallelResult = this.getStepOutput(stepResults, entry)?.output;
            acc = { ...acc, ...parallelResult };
          } else if (entry.type === "loop") {
            acc[entry.step.id] = stepResults[entry.step.id]?.output;
          } else if (entry.type === "foreach") {
            acc[entry.step.id] = stepResults[entry.step.id]?.output;
          }
          return acc;
        },
        {}
      );
    } else if (step.type === "loop") {
      return stepResults[step.step.id]?.output;
    } else if (step.type === "foreach") {
      return stepResults[step.step.id]?.output;
    }
  }
  async executeStep({
    workflowId,
    runId,
    step,
    stepResults,
    executionContext,
    resume,
    prevOutput,
    emitter,
    runtimeContext
  }) {
    await emitter.emit("watch", {
      type: "watch",
      payload: {
        currentStep: {
          id: step.id,
          status: "running"
        },
        workflowState: {
          status: "running",
          steps: {
            ...stepResults,
            [step.id]: {
              status: "running"
            }
          },
          result: null,
          error: null
        }
      },
      eventTimestamp: Date.now()
    });
    const _runStep = (step2, spanName, attributes) => {
      return async (data) => {
        const telemetry = this.mastra?.getTelemetry();
        const span = executionContext.executionSpan;
        if (!telemetry || !span) {
          return step2.execute(data);
        }
        return context.with(trace.setSpan(context.active(), span), async () => {
          return telemetry.traceMethod(step2.execute.bind(step2), {
            spanName,
            attributes
          })(data);
        });
      };
    };
    const runStep = _runStep(step, `workflow.${workflowId}.step.${step.id}`, {
      componentName: workflowId,
      runId
    });
    let execResults;
    const retries = step.retries ?? executionContext.retryConfig.attempts ?? 0;
    for (let i = 0; i < retries + 1; i++) {
      try {
        let suspended;
        const result = await runStep({
          mastra: this.mastra,
          runtimeContext,
          inputData: prevOutput,
          resumeData: resume?.steps[0] === step.id ? resume?.resumePayload : void 0,
          getInitData: () => stepResults?.input,
          getStepResult: (step2) => {
            if (!step2?.id) {
              return null;
            }
            const result2 = stepResults[step2.id];
            if (result2?.status === "success") {
              return result2.output;
            }
            return null;
          },
          suspend: async (suspendPayload) => {
            executionContext.suspendedPaths[step.id] = executionContext.executionPath;
            suspended = { payload: suspendPayload };
          },
          resume: {
            steps: resume?.steps?.slice(1) || [],
            resumePayload: resume?.resumePayload,
            // @ts-ignore
            runId: stepResults[step.id]?.payload?.__workflow_meta?.runId
          },
          emitter
        });
        if (suspended) {
          execResults = { status: "suspended", payload: suspended.payload };
        } else {
          execResults = { status: "success", output: result };
        }
        break;
      } catch (e) {
        this.logger.error("Error executing step: " + (e?.stack ?? e));
        execResults = { status: "failed", error: e instanceof Error ? e : new Error("Unknown error: " + e) };
      }
    }
    await emitter.emit("watch", {
      type: "watch",
      payload: {
        currentStep: {
          id: step.id,
          status: execResults.status,
          output: execResults.output
        },
        workflowState: {
          status: "running",
          steps: {
            ...stepResults,
            [step.id]: {
              status: execResults.status,
              output: execResults.output,
              error: execResults.error,
              payload: execResults.payload
            }
          },
          result: null,
          error: null
        }
      },
      eventTimestamp: Date.now()
    });
    return execResults;
  }
  async executeParallel({
    workflowId,
    runId,
    entry,
    prevStep,
    stepResults,
    resume,
    executionContext,
    emitter,
    runtimeContext
  }) {
    let execResults;
    const results = await Promise.all(
      entry.steps.map(
        (step, i) => this.executeEntry({
          workflowId,
          runId,
          entry: step,
          prevStep,
          stepResults,
          resume,
          executionContext: {
            workflowId,
            runId,
            executionPath: [...executionContext.executionPath, i],
            suspendedPaths: executionContext.suspendedPaths,
            retryConfig: executionContext.retryConfig,
            executionSpan: executionContext.executionSpan
          },
          emitter,
          runtimeContext
        })
      )
    );
    const hasFailed = results.find((result) => result.status === "failed");
    const hasSuspended = results.find((result) => result.status === "suspended");
    if (hasFailed) {
      execResults = { status: "failed", error: hasFailed.error };
    } else if (hasSuspended) {
      execResults = { status: "suspended", payload: hasSuspended.payload };
    } else {
      execResults = {
        status: "success",
        output: results.reduce((acc, result, index) => {
          if (result.status === "success") {
            acc[entry.steps[index].step.id] = result.output;
          }
          return acc;
        }, {})
      };
    }
    return execResults;
  }
  async executeConditional({
    workflowId,
    runId,
    entry,
    prevOutput,
    prevStep,
    stepResults,
    resume,
    executionContext,
    emitter,
    runtimeContext
  }) {
    let execResults;
    const truthyIndexes = (await Promise.all(
      entry.conditions.map(async (cond, index) => {
        try {
          const result = await cond({
            mastra: this.mastra,
            runtimeContext,
            inputData: prevOutput,
            getInitData: () => stepResults?.input,
            getStepResult: (step) => {
              if (!step?.id) {
                return null;
              }
              const result2 = stepResults[step.id];
              if (result2?.status === "success") {
                return result2.output;
              }
              return null;
            },
            // TODO: this function shouldn't have suspend probably?
            suspend: async (_suspendPayload) => {
            },
            emitter
          });
          return result ? index : null;
        } catch (e) {
          this.logger.error("Error evaluating condition: " + (e?.stack ?? e));
          return null;
        }
      })
    )).filter((index) => index !== null);
    const stepsToRun = entry.steps.filter((_, index) => truthyIndexes.includes(index));
    const results = await Promise.all(
      stepsToRun.map(
        (step, index) => this.executeEntry({
          workflowId,
          runId,
          entry: step,
          prevStep,
          stepResults,
          resume,
          executionContext: {
            workflowId,
            runId,
            executionPath: [...executionContext.executionPath, index],
            suspendedPaths: executionContext.suspendedPaths,
            retryConfig: executionContext.retryConfig,
            executionSpan: executionContext.executionSpan
          },
          emitter,
          runtimeContext
        })
      )
    );
    const hasFailed = results.find((result) => result.status === "failed");
    const hasSuspended = results.find((result) => result.status === "suspended");
    if (hasFailed) {
      execResults = { status: "failed", error: hasFailed.error };
    } else if (hasSuspended) {
      execResults = { status: "suspended", payload: hasSuspended.payload };
    } else {
      execResults = {
        status: "success",
        output: results.reduce((acc, result, index) => {
          if (result.status === "success") {
            acc[stepsToRun[index].step.id] = result.output;
          }
          return acc;
        }, {})
      };
    }
    return execResults;
  }
  async executeLoop({
    workflowId,
    runId,
    entry,
    prevOutput,
    stepResults,
    resume,
    executionContext,
    emitter,
    runtimeContext
  }) {
    const { step, condition } = entry;
    let isTrue = true;
    let result = { status: "success", output: prevOutput };
    do {
      result = await this.executeStep({
        workflowId,
        runId,
        step,
        stepResults,
        executionContext,
        resume,
        prevOutput: result.output,
        emitter,
        runtimeContext
      });
      if (result.status !== "success") {
        return result;
      }
      isTrue = await condition({
        mastra: this.mastra,
        runtimeContext,
        inputData: result.output,
        getInitData: () => stepResults?.input,
        getStepResult: (step2) => {
          if (!step2?.id) {
            return null;
          }
          const result2 = stepResults[step2.id];
          return result2?.status === "success" ? result2.output : null;
        },
        suspend: async (_suspendPayload) => {
        },
        emitter
      });
    } while (entry.loopType === "dowhile" ? isTrue : !isTrue);
    return result;
  }
  async executeForeach({
    workflowId,
    runId,
    entry,
    prevOutput,
    stepResults,
    resume,
    executionContext,
    emitter,
    runtimeContext
  }) {
    const { step, opts } = entry;
    const results = [];
    const concurrency = opts.concurrency;
    for (let i = 0; i < prevOutput.length; i += concurrency) {
      const items = prevOutput.slice(i, i + concurrency);
      const itemsResults = await Promise.all(
        items.map((item) => {
          return this.executeStep({
            workflowId,
            runId,
            step,
            stepResults,
            executionContext,
            resume,
            prevOutput: item,
            emitter,
            runtimeContext
          });
        })
      );
      for (const result of itemsResults) {
        if (result.status !== "success") {
          return result;
        }
        results.push(result?.output);
      }
    }
    return { status: "success", output: results };
  }
  async persistStepUpdate({
    workflowId,
    runId,
    stepResults,
    executionContext
  }) {
    await this.mastra?.getStorage()?.persistWorkflowSnapshot({
      workflowName: workflowId,
      runId,
      snapshot: {
        runId,
        value: {},
        context: stepResults,
        activePaths: [],
        suspendedPaths: executionContext.suspendedPaths,
        // @ts-ignore
        timestamp: Date.now()
      }
    });
  }
  async executeEntry({
    workflowId,
    runId,
    entry,
    prevStep,
    stepResults,
    resume,
    executionContext,
    emitter,
    runtimeContext
  }) {
    const prevOutput = this.getStepOutput(stepResults, prevStep);
    let execResults;
    if (entry.type === "step") {
      const { step } = entry;
      execResults = await this.executeStep({
        workflowId,
        runId,
        step,
        stepResults,
        executionContext,
        resume,
        prevOutput,
        emitter,
        runtimeContext
      });
    } else if (resume?.resumePath?.length && (entry.type === "parallel" || entry.type === "conditional")) {
      const idx = resume.resumePath.shift();
      return this.executeEntry({
        workflowId,
        runId,
        entry: entry.steps[idx],
        prevStep,
        stepResults,
        resume,
        executionContext: {
          workflowId,
          runId,
          executionPath: [...executionContext.executionPath, idx],
          suspendedPaths: executionContext.suspendedPaths,
          retryConfig: executionContext.retryConfig,
          executionSpan: executionContext.executionSpan
        },
        emitter,
        runtimeContext
      });
    } else if (entry.type === "parallel") {
      execResults = await this.executeParallel({
        workflowId,
        runId,
        entry,
        prevStep,
        stepResults,
        resume,
        executionContext,
        emitter,
        runtimeContext
      });
    } else if (entry.type === "conditional") {
      execResults = await this.executeConditional({
        workflowId,
        runId,
        entry,
        prevStep,
        prevOutput,
        stepResults,
        resume,
        executionContext,
        emitter,
        runtimeContext
      });
    } else if (entry.type === "loop") {
      execResults = await this.executeLoop({
        workflowId,
        runId,
        entry,
        prevStep,
        prevOutput,
        stepResults,
        resume,
        executionContext,
        emitter,
        runtimeContext
      });
    } else if (entry.type === "foreach") {
      execResults = await this.executeForeach({
        workflowId,
        runId,
        entry,
        prevStep,
        prevOutput,
        stepResults,
        resume,
        executionContext,
        emitter,
        runtimeContext
      });
    }
    if (entry.type === "step" || entry.type === "loop" || entry.type === "foreach") {
      stepResults[entry.step.id] = execResults;
    }
    await this.persistStepUpdate({
      workflowId,
      runId,
      stepResults,
      executionContext
    });
    return execResults;
  }
};

// src/workflows/vNext/workflow.ts
function createStep$1(params) {
  if (params instanceof Agent) {
    return {
      id: params.name,
      // @ts-ignore
      inputSchema: lib.z.object({
        prompt: lib.z.string()
        // resourceId: z.string().optional(),
        // threadId: z.string().optional(),
      }),
      // @ts-ignore
      outputSchema: lib.z.object({
        text: lib.z.string()
      }),
      execute: async ({ inputData }) => {
        const result = await params.generate(inputData.prompt, {
          // resourceId: inputData.resourceId,
          // threadId: inputData.threadId,
        });
        return {
          text: result.text
        };
      }
    };
  }
  if (params instanceof Tool) {
    if (!params.inputSchema || !params.outputSchema) {
      throw new Error("Tool must have input and output schemas defined");
    }
    return {
      // TODO: tool probably should have strong id type
      // @ts-ignore
      id: params.id,
      inputSchema: params.inputSchema,
      outputSchema: params.outputSchema,
      execute: async ({ inputData, mastra }) => {
        return await params.execute({
          context: inputData,
          mastra
        });
      }
    };
  }
  return {
    id: params.id,
    description: params.description,
    inputSchema: params.inputSchema,
    outputSchema: params.outputSchema,
    resumeSchema: params.resumeSchema,
    suspendSchema: params.suspendSchema,
    execute: params.execute
  };
}
function cloneStep(step, opts) {
  return {
    id: opts.id,
    description: step.description,
    inputSchema: step.inputSchema,
    outputSchema: step.outputSchema,
    execute: step.execute
  };
}
var NewWorkflow = class extends MastraBase {
  id;
  description;
  inputSchema;
  outputSchema;
  steps;
  stepDefs;
  stepFlow;
  serializedStepFlow;
  executionEngine;
  executionGraph;
  retryConfig;
  #mastra;
  #runs = /* @__PURE__ */ new Map();
  constructor({
    mastra,
    id,
    inputSchema,
    outputSchema,
    description,
    executionEngine,
    retryConfig,
    steps
  }) {
    super({ name: id, component: RegisteredLogger.WORKFLOW });
    this.id = id;
    this.description = description;
    this.inputSchema = inputSchema;
    this.outputSchema = outputSchema;
    this.retryConfig = retryConfig ?? { attempts: 0, delay: 0 };
    this.executionGraph = this.buildExecutionGraph();
    this.stepFlow = [];
    this.serializedStepFlow = [];
    this.#mastra = mastra;
    this.steps = {};
    this.stepDefs = steps;
    if (!executionEngine) {
      this.executionEngine = new DefaultExecutionEngine({ mastra: this.#mastra });
    } else {
      this.executionEngine = executionEngine;
    }
    this.#runs = /* @__PURE__ */ new Map();
  }
  get runs() {
    return this.#runs;
  }
  get mastra() {
    return this.#mastra;
  }
  __registerMastra(mastra) {
    this.#mastra = mastra;
    this.executionEngine.__registerMastra(mastra);
  }
  __registerPrimitives(p) {
    if (p.telemetry) {
      this.__setTelemetry(p.telemetry);
    }
    if (p.logger) {
      this.__setLogger(p.logger);
    }
  }
  setStepFlow(stepFlow) {
    this.stepFlow = stepFlow;
  }
  /**
   * Adds a step to the workflow
   * @param step The step to add to the workflow
   * @returns The workflow instance for chaining
   */
  then(step) {
    this.stepFlow.push({ type: "step", step });
    this.serializedStepFlow.push({
      type: "step",
      step: {
        id: step.id,
        description: step.description,
        component: step.component,
        serializedStepFlow: step.serializedStepFlow
      }
    });
    this.steps[step.id] = step;
    return this;
  }
  map(mappingConfig) {
    if (typeof mappingConfig === "function") {
      const mappingStep2 = createStep$1({
        id: `mapping_${randomUUID()}`,
        inputSchema: lib.z.object({}),
        outputSchema: lib.z.object({}),
        execute: mappingConfig
      });
      this.stepFlow.push({ type: "step", step: mappingStep2 });
      this.serializedStepFlow.push({
        type: "step",
        step: {
          id: mappingStep2.id,
          description: mappingStep2.description,
          component: mappingStep2.component,
          serializedStepFlow: mappingStep2.serializedStepFlow
        }
      });
      return this;
    }
    const mappingStep = createStep$1({
      id: `mapping_${randomUUID()}`,
      inputSchema: lib.z.object({}),
      outputSchema: lib.z.object({}),
      execute: async (ctx) => {
        const { getStepResult, getInitData, runtimeContext } = ctx;
        const result = {};
        for (const [key, mapping] of Object.entries(mappingConfig)) {
          const m = mapping;
          if (m.value !== void 0) {
            result[key] = m.value;
            continue;
          }
          if (m.fn !== void 0) {
            result[key] = await m.fn(ctx);
            continue;
          }
          if (m.runtimeContextPath) {
            result[key] = runtimeContext.get(m.runtimeContextPath);
            continue;
          }
          const stepResult = m.initData ? getInitData() : getStepResult(Array.isArray(m.step) ? m.step.find((s) => getStepResult(s)) : m.step);
          if (m.path === ".") {
            result[key] = stepResult;
            continue;
          }
          const pathParts = m.path.split(".");
          let value = stepResult;
          for (const part of pathParts) {
            if (typeof value === "object" && value !== null) {
              value = value[part];
            } else {
              throw new Error(`Invalid path ${m.path} in step ${m.step.id}`);
            }
          }
          result[key] = value;
        }
        return result;
      }
    });
    this.stepFlow.push({ type: "step", step: mappingStep });
    this.serializedStepFlow.push({
      type: "step",
      step: {
        id: mappingStep.id,
        description: mappingStep.description,
        component: mappingStep.component,
        serializedStepFlow: mappingStep.serializedStepFlow
      }
    });
    return this;
  }
  // TODO: make typing better here
  parallel(steps) {
    this.stepFlow.push({ type: "parallel", steps: steps.map((step) => ({ type: "step", step })) });
    this.serializedStepFlow.push({
      type: "parallel",
      steps: steps.map((step) => ({
        type: "step",
        step: {
          id: step.id,
          description: step.description,
          component: step.component,
          serializedStepFlow: step.serializedStepFlow
        }
      }))
    });
    steps.forEach((step) => {
      this.steps[step.id] = step;
    });
    return this;
  }
  // TODO: make typing better here
  branch(steps) {
    this.stepFlow.push({
      type: "conditional",
      steps: steps.map(([_cond, step]) => ({ type: "step", step })),
      conditions: steps.map(([cond]) => cond),
      serializedConditions: steps.map(([cond, _step]) => ({ id: `${_step.id}-condition`, fn: cond.toString() }))
    });
    this.serializedStepFlow.push({
      type: "conditional",
      steps: steps.map(([_cond, step]) => ({
        type: "step",
        step: {
          id: step.id,
          description: step.description,
          component: step.component,
          serializedStepFlow: step.serializedStepFlow
        }
      })),
      serializedConditions: steps.map(([cond, _step]) => ({ id: `${_step.id}-condition`, fn: cond.toString() }))
    });
    steps.forEach(([_, step]) => {
      this.steps[step.id] = step;
    });
    return this;
  }
  dowhile(step, condition) {
    this.stepFlow.push({
      type: "loop",
      step,
      condition,
      loopType: "dowhile",
      serializedCondition: { id: `${step.id}-condition`, fn: condition.toString() }
    });
    this.serializedStepFlow.push({
      type: "loop",
      step: {
        id: step.id,
        description: step.description,
        component: step.component,
        serializedStepFlow: step.serializedStepFlow
      },
      serializedCondition: { id: `${step.id}-condition`, fn: condition.toString() },
      loopType: "dowhile"
    });
    this.steps[step.id] = step;
    return this;
  }
  dountil(step, condition) {
    this.stepFlow.push({
      type: "loop",
      step,
      condition,
      loopType: "dountil",
      serializedCondition: { id: `${step.id}-condition`, fn: condition.toString() }
    });
    this.serializedStepFlow.push({
      type: "loop",
      step: {
        id: step.id,
        description: step.description,
        component: step.component,
        serializedStepFlow: step.serializedStepFlow
      },
      serializedCondition: { id: `${step.id}-condition`, fn: condition.toString() },
      loopType: "dountil"
    });
    this.steps[step.id] = step;
    return this;
  }
  foreach(step, opts) {
    this.stepFlow.push({ type: "foreach", step, opts: opts ?? { concurrency: 1 } });
    this.serializedStepFlow.push({
      type: "foreach",
      step: {
        id: step.id,
        description: step.description,
        component: step.component,
        serializedStepFlow: step.serializedStepFlow
      },
      opts: opts ?? { concurrency: 1 }
    });
    this.steps[step.id] = step;
    return this;
  }
  /**
   * Builds the execution graph for this workflow
   * @returns The execution graph that can be used to execute the workflow
   */
  buildExecutionGraph() {
    return {
      id: randomUUID(),
      steps: this.stepFlow
    };
  }
  /**
   * Finalizes the workflow definition and prepares it for execution
   * This method should be called after all steps have been added to the workflow
   * @returns A built workflow instance ready for execution
   */
  commit() {
    this.executionGraph = this.buildExecutionGraph();
    return this;
  }
  get stepGraph() {
    return this.stepFlow;
  }
  get serializedStepGraph() {
    return this.serializedStepFlow;
  }
  /**
   * Creates a new workflow run instance
   * @param options Optional configuration for the run
   * @returns A Run instance that can be used to execute the workflow
   */
  createRun(options) {
    if (this.stepFlow.length === 0) {
      throw new Error("Execution flow of workflow is not defined. Add steps to the workflow via .then(), .branch(), etc.");
    }
    if (!this.executionGraph.steps) {
      throw new Error("Uncommitted step flow changes detected. Call .commit() to register the steps.");
    }
    const runIdToUse = options?.runId || randomUUID();
    const run = this.#runs.get(runIdToUse) ?? new Run({
      workflowId: this.id,
      runId: runIdToUse,
      executionEngine: this.executionEngine,
      executionGraph: this.executionGraph,
      mastra: this.#mastra,
      retryConfig: this.retryConfig,
      cleanup: () => this.#runs.delete(runIdToUse)
    });
    this.#runs.set(runIdToUse, run);
    return run;
  }
  async execute({
    inputData,
    resumeData,
    suspend,
    resume,
    emitter,
    mastra
  }) {
    this.__registerMastra(mastra);
    const run = resume?.steps?.length ? this.createRun({ runId: resume.runId }) : this.createRun();
    const unwatch = run.watch((event) => {
      emitter.emit("nested-watch", { event, workflowId: this.id, runId: run.runId, isResume: !!resume?.steps?.length });
    });
    const res = resume?.steps?.length ? await run.resume({ resumeData, step: resume.steps }) : await run.start({ inputData });
    unwatch();
    const suspendedSteps = Object.entries(res.steps).filter(([_stepName, stepResult]) => {
      const stepRes = stepResult;
      return stepRes?.status === "suspended";
    });
    if (suspendedSteps?.length) {
      for (const [stepName, stepResult] of suspendedSteps) {
        const suspendPath = [stepName, ...stepResult?.payload?.__workflow_meta?.path ?? []];
        await suspend({
          ...stepResult?.payload,
          __workflow_meta: { runId: run.runId, path: suspendPath }
        });
      }
    }
    if (res.status === "failed") {
      throw res.error;
    }
    return res.status === "success" ? res.result : void 0;
  }
  async getWorkflowRuns(args) {
    const storage = this.#mastra?.getStorage();
    if (!storage) {
      this.logger.debug("Cannot get workflow runs. Mastra engine is not initialized");
      return { runs: [], total: 0 };
    }
    return storage.getWorkflowRuns({ workflowName: this.id, ...args ?? {} });
  }
  async getWorkflowRunById(runId) {
    const storage = this.#mastra?.getStorage();
    if (!storage) {
      this.logger.debug("Cannot get workflow runs. Mastra engine is not initialized");
      return null;
    }
    const run = await storage.getWorkflowRunById({ runId, workflowName: this.id });
    return run ?? (this.#runs.get(runId) ? { ...this.#runs.get(runId), workflowName: this.id } : null);
  }
};
var Run = class {
  emitter;
  /**
   * Unique identifier for this workflow
   */
  workflowId;
  /**
   * Unique identifier for this run
   */
  runId;
  /**
   * Internal state of the workflow run
   */
  state = {};
  /**
   * The execution engine for this run
   */
  executionEngine;
  /**
   * The execution graph for this run
   */
  executionGraph;
  /**
   * The storage for this run
   */
  #mastra;
  cleanup;
  retryConfig;
  constructor(params) {
    this.workflowId = params.workflowId;
    this.runId = params.runId;
    this.executionEngine = params.executionEngine;
    this.executionGraph = params.executionGraph;
    this.#mastra = params.mastra;
    this.emitter = new require$$2();
    this.retryConfig = params.retryConfig;
    this.cleanup = params.cleanup;
  }
  /**
   * Starts the workflow execution with the provided input
   * @param input The input data for the workflow
   * @returns A promise that resolves to the workflow output
   */
  async start({
    inputData,
    runtimeContext
  }) {
    const result = await this.executionEngine.execute({
      workflowId: this.workflowId,
      runId: this.runId,
      graph: this.executionGraph,
      input: inputData,
      emitter: {
        emit: (event, data) => {
          this.emitter.emit(event, data);
          return Promise.resolve();
        }
      },
      retryConfig: this.retryConfig,
      runtimeContext: runtimeContext ?? new RuntimeContext()
    });
    this.cleanup?.();
    return result;
  }
  watch(cb) {
    const watchCb = (event) => {
      this.updateState(event.payload);
      cb({ type: event.type, payload: this.getState(), eventTimestamp: event.eventTimestamp });
    };
    this.emitter.on("watch", watchCb);
    const nestedWatchCb = ({ event, workflowId }) => {
      try {
        const { type, payload, eventTimestamp } = event;
        const prefixedSteps = Object.fromEntries(
          Object.entries(payload?.workflowState?.steps ?? {}).map(([stepId, step]) => [
            `${this.workflowId}.${stepId}`,
            step
          ])
        );
        const newPayload = {
          currentStep: {
            ...payload?.currentStep,
            id: `${workflowId}.${payload?.currentStep?.id}`
          },
          workflowState: {
            steps: prefixedSteps
          }
        };
        this.updateState(newPayload);
        cb({ type, payload: this.getState(), eventTimestamp });
      } catch (e) {
        console.error(e);
      }
    };
    this.emitter.on("nested-watch", nestedWatchCb);
    return () => {
      this.emitter.off("watch", watchCb);
      this.emitter.off("nested-watch", nestedWatchCb);
    };
  }
  async resume(params) {
    const steps = (Array.isArray(params.step) ? params.step : [params.step]).map(
      (step) => typeof step === "string" ? step : step?.id
    );
    const snapshot = await this.#mastra?.storage?.loadWorkflowSnapshot({
      workflowName: this.workflowId,
      runId: this.runId
    });
    return this.executionEngine.execute({
      workflowId: this.workflowId,
      runId: this.runId,
      graph: this.executionGraph,
      input: params.resumeData,
      resume: {
        steps,
        stepResults: snapshot?.context,
        resumePayload: params.resumeData,
        // @ts-ignore
        resumePath: snapshot?.suspendedPaths?.[steps?.[0]]
      },
      emitter: {
        emit: (event, data) => {
          this.emitter.emit(event, data);
          return Promise.resolve();
        }
      },
      runtimeContext: params.runtimeContext ?? new RuntimeContext()
    });
  }
  /**
   * Returns the current state of the workflow run
   * @returns The current state of the workflow run
   */
  getState() {
    return this.state;
  }
  updateState(state) {
    if (state.currentStep) {
      this.state.currentStep = state.currentStep;
    } else if (state.workflowState?.status !== "running") {
      delete this.state.currentStep;
    }
    if (state.workflowState) {
      this.state.workflowState = deepMerge(this.state.workflowState ?? {}, state.workflowState ?? {});
    }
  }
};
function deepMerge(a, b) {
  if (!a || typeof a !== "object") return b;
  if (!b || typeof b !== "object") return a;
  const result = { ...a };
  for (const key in b) {
    if (b[key] === void 0) continue;
    if (b[key] !== null && typeof b[key] === "object") {
      const aVal = result[key];
      const bVal = b[key];
      if (Array.isArray(bVal)) {
        result[key] = Array.isArray(aVal) ? [...aVal, ...bVal].filter((item) => item !== void 0) : bVal.filter((item) => item !== void 0);
      } else if (typeof aVal === "object" && aVal !== null) {
        result[key] = deepMerge(aVal, bVal);
      } else {
        result[key] = bVal;
      }
    } else {
      result[key] = b[key];
    }
  }
  return result;
}

var hono = {};

// src/helper/adapter/index.ts
var env = (c, runtime) => {
  const global = globalThis;
  const globalEnv = global?.process?.env;
  runtime ??= getRuntimeKey();
  const runtimeEnvHandlers = {
    bun: () => globalEnv,
    node: () => globalEnv,
    "edge-light": () => globalEnv,
    deno: () => {
      return Deno.env.toObject();
    },
    workerd: () => c.env,
    fastly: () => ({}),
    other: () => ({})
  };
  return runtimeEnvHandlers[runtime]();
};
var knownUserAgents = {
  deno: "Deno",
  bun: "Bun",
  workerd: "Cloudflare-Workers",
  node: "Node.js"
};
var getRuntimeKey = () => {
  const global = globalThis;
  const userAgentSupported = typeof navigator !== "undefined" && typeof navigator.userAgent === "string";
  if (userAgentSupported) {
    for (const [runtimeKey, userAgent] of Object.entries(knownUserAgents)) {
      if (checkUserAgentEquals(userAgent)) {
        return runtimeKey;
      }
    }
  }
  if (typeof global?.EdgeRuntime === "string") {
    return "edge-light";
  }
  if (global?.fastly !== void 0) {
    return "fastly";
  }
  if (global?.process?.release?.name === "node") {
    return "node";
  }
  return "other";
};
var checkUserAgentEquals = (platform) => {
  const userAgent = navigator.userAgent;
  return userAgent.startsWith(platform);
};

var adapter = /*#__PURE__*/Object.freeze({
  __proto__: null,
  checkUserAgentEquals: checkUserAgentEquals,
  env: env,
  getRuntimeKey: getRuntimeKey,
  knownUserAgents: knownUserAgents
});

var require$$0 = /*@__PURE__*/getAugmentedNamespace(adapter);

(function (exports) {
	/**
	 * An adapter for Hono to serve and register any declared functions with
	 * Inngest, making them available to be triggered by events.
	 *
	 * @example
	 * ```ts
	 * const handler = serve({
	 *   client: inngest,
	 *   functions
	 * });
	 *
	 * app.use('/api/inngest',  async (c) => {
	 *   return handler(c);
	 * });
	 * ```
	 *
	 * @module
	 */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.serve = exports.frameworkName = void 0;
	const adapter_1 = require$$0;
	const InngestCommHandler_js_1 = InngestCommHandler$1;
	/**
	 * The name of the framework, used to identify the framework in Inngest
	 * dashboards and during testing.
	 */
	exports.frameworkName = "hono";
	/**
	 * Using Hono, serve and register any declared functions with Inngest,
	 * making them available to be triggered by events.
	 *
	 * @example
	 * ```ts
	 * const handler = serve({
	 *   client: inngest,
	 *   functions
	 * });
	 *
	 * app.use('/api/inngest',  async (c) => {
	 *   return handler(c);
	 * });
	 * ```
	 *
	 * @public
	 */
	// Has explicit return type to avoid JSR-defined "slow types"
	const serve = (options) => {
	    const handler = new InngestCommHandler_js_1.InngestCommHandler(Object.assign(Object.assign({ fetch: fetch.bind(globalThis), frameworkName: exports.frameworkName }, options), { handler: (c) => {
	            return {
	                transformResponse: ({ headers, status, body }) => {
	                    return c.body(body, { headers, status });
	                },
	                url: () => {
	                    try {
	                        // If this is an absolute URL, use it right now.
	                        return new URL(c.req.url);
	                    }
	                    catch (_a) {
	                        // no-op
	                    }
	                    // We now know that `c.req.url` is a relative URL, so let's try
	                    // to build a base URL to pair it with.
	                    const host = options.serveHost || c.req.header("host");
	                    if (!host) {
	                        throw new Error("No host header found in request and no `serveHost` given either.");
	                    }
	                    let baseUrl = host;
	                    // Only set the scheme if we don't already have one, as a user may
	                    // have specified the protocol in `serveHost` as a way to force it
	                    // in their environment, e.g. for testing.
	                    if (!baseUrl.includes("://")) {
	                        let scheme = "https";
	                        try {
	                            // If we're in dev, assume `http` instead. Not that we directly
	                            // access the environment instead of using any helpers here to
	                            // ensure compatibility with tools with Webpack which will replace
	                            // this with a literal.
	                            // eslint-disable-next-line @inngest/internal/process-warn
	                            if (process.env.NODE_ENV !== "production") {
	                                scheme = "http";
	                            }
	                        }
	                        catch (err) {
	                            // no-op
	                        }
	                        baseUrl = `${scheme}://${baseUrl}`;
	                    }
	                    return new URL(c.req.url, baseUrl);
	                },
	                queryString: (key) => c.req.query(key),
	                headers: (key) => c.req.header(key),
	                method: () => c.req.method,
	                body: () => c.req.json(),
	                env: () => (0, adapter_1.env)(c),
	            };
	        } }));
	    return handler.createHandler();
	};
	exports.serve = serve;
	
} (hono));

// src/index.ts
function serve({ mastra, inngest }) {
  const wfs = mastra.vnext_getWorkflows();
  const functions = Object.values(wfs).flatMap((wf) => {
    if (wf instanceof InngestWorkflow) {
      wf.__registerMastra(mastra);
      return wf.getFunctions();
    }
    return [];
  });
  return hono.serve({
    client: inngest,
    functions
  });
}
var InngestRun = class extends Run {
  inngest;
  #mastra;
  constructor(params, inngest) {
    super(params);
    this.inngest = inngest;
    this.#mastra = params.mastra;
  }
  async getRuns(eventId) {
    const response = await fetch(`${this.inngest.apiBaseUrl}/v1/events/${eventId}/runs`, {
      headers: {
        Authorization: `Bearer ${process.env.INNGEST_SIGNING_KEY}`
      }
    });
    const json = await response.json();
    return json.data;
  }
  async getRunOutput(eventId) {
    let runs = await this.getRuns(eventId);
    while (runs?.[0]?.status !== "Completed") {
      await new Promise((resolve) => setTimeout(resolve, 1e3));
      runs = await this.getRuns(eventId);
      if (runs?.[0]?.status === "Failed" || runs?.[0]?.status === "Cancelled") {
        throw new Error(`Function run ${runs?.[0]?.status}`);
      }
    }
    return runs?.[0];
  }
  async start({
    inputData
  }) {
    await this.#mastra.getStorage()?.persistWorkflowSnapshot({
      workflowName: this.workflowId,
      runId: this.runId,
      snapshot: {
        runId: this.runId,
        value: {},
        context: {},
        activePaths: [],
        suspendedPaths: {},
        timestamp: Date.now()
      }
    });
    const eventOutput = await this.inngest.send({
      name: `workflow.${this.workflowId}`,
      data: {
        inputData,
        runId: this.runId
      }
    });
    const eventId = eventOutput.ids[0];
    if (!eventId) {
      throw new Error("Event ID is not set");
    }
    const runOutput = await this.getRunOutput(eventId);
    const result = runOutput?.output?.result;
    if (result.status === "failed") {
      result.error = new Error(result.error);
    }
    this.cleanup?.();
    return result;
  }
  async resume(params) {
    const steps = (Array.isArray(params.step) ? params.step : [params.step]).map(
      (step) => typeof step === "string" ? step : step?.id
    );
    const snapshot = await this.#mastra?.storage?.loadWorkflowSnapshot({
      workflowName: this.workflowId,
      runId: this.runId
    });
    const eventOutput = await this.inngest.send({
      name: `workflow.${this.workflowId}`,
      data: {
        inputData: params.resumeData,
        runId: this.runId,
        stepResults: snapshot?.context,
        resume: {
          steps,
          stepResults: snapshot?.context,
          resumePayload: params.resumeData,
          // @ts-ignore
          resumePath: snapshot?.suspendedPaths?.[steps?.[0]]
        }
      }
    });
    const eventId = eventOutput.ids[0];
    if (!eventId) {
      throw new Error("Event ID is not set");
    }
    const runOutput = await this.getRunOutput(eventId);
    const result = runOutput?.output?.result;
    if (result.status === "failed") {
      result.error = new Error(result.error);
    }
    return result;
  }
  watch(cb) {
    const streamPromise = dist.subscribe(
      {
        channel: `workflow:${this.workflowId}:${this.runId}`,
        topics: ["watch"],
        app: this.inngest
      },
      (message) => {
        cb(message.data);
      }
    );
    return () => {
      streamPromise.then((stream) => {
        stream.cancel();
      }).catch((err) => {
        console.error(err);
      });
    };
  }
};
var InngestWorkflow = class _InngestWorkflow extends NewWorkflow {
  #mastra;
  inngest;
  function;
  constructor(params, inngest) {
    super(params);
    this.#mastra = params.mastra;
    this.inngest = inngest;
  }
  async getWorkflowRuns(args) {
    const storage = this.#mastra?.getStorage();
    if (!storage) {
      this.logger.debug("Cannot get workflow runs. Mastra engine is not initialized");
      return { runs: [], total: 0 };
    }
    return storage.getWorkflowRuns({ workflowName: this.id, ...args ?? {} });
  }
  async getWorkflowRunById(runId) {
    const storage = this.#mastra?.getStorage();
    if (!storage) {
      this.logger.debug("Cannot get workflow runs. Mastra engine is not initialized");
      return null;
    }
    const run = await storage.getWorkflowRunById({ runId, workflowName: this.id });
    return run ?? (this.runs.get(runId) ? { ...this.runs.get(runId), workflowName: this.id } : null);
  }
  __registerMastra(mastra) {
    this.#mastra = mastra;
    this.executionEngine.__registerMastra(mastra);
    const updateNested = (step) => {
      if ((step.type === "step" || step.type === "loop" || step.type === "foreach") && step.step instanceof _InngestWorkflow) {
        step.step.__registerMastra(mastra);
      } else if (step.type === "parallel" || step.type === "conditional") {
        for (const subStep of step.steps) {
          updateNested(subStep);
        }
      }
    };
    if (this.executionGraph.steps.length) {
      for (const step of this.executionGraph.steps) {
        updateNested(step);
      }
    }
  }
  createRun(options) {
    const runIdToUse = options?.runId || randomUUID();
    const run = this.runs.get(runIdToUse) ?? new InngestRun(
      {
        workflowId: this.id,
        runId: runIdToUse,
        executionEngine: this.executionEngine,
        executionGraph: this.executionGraph,
        mastra: this.#mastra,
        retryConfig: this.retryConfig,
        cleanup: () => this.runs.delete(runIdToUse)
      },
      this.inngest
    );
    this.runs.set(runIdToUse, run);
    return run;
  }
  getFunction() {
    if (this.function) {
      return this.function;
    }
    this.function = this.inngest.createFunction(
      // @ts-ignore
      { id: `workflow.${this.id}`, retries: this.retryConfig?.attempts ?? 0 },
      { event: `workflow.${this.id}` },
      async ({ event, step, attempt, publish }) => {
        let { inputData, runId, resume } = event.data;
        if (!runId) {
          runId = await step.run(`workflow.${this.id}.runIdGen`, async () => {
            return randomUUID();
          });
        }
        const emitter = {
          emit: async (event2, data) => {
            if (!publish) {
              return;
            }
            try {
              await publish({
                channel: `workflow:${this.id}:${runId}`,
                topic: "watch",
                data
              });
            } catch (err) {
              this.logger.error("Error emitting event: " + (err?.stack ?? err?.message ?? err));
            }
          }
        };
        const engine = new InngestExecutionEngine(this.#mastra, step, attempt);
        const result = await engine.execute({
          workflowId: this.id,
          runId,
          graph: this.executionGraph,
          input: inputData,
          emitter,
          retryConfig: this.retryConfig,
          runtimeContext: new RuntimeContext(),
          // TODO
          resume
        });
        return { result, runId };
      }
    );
    return this.function;
  }
  getNestedFunctions(steps) {
    return steps.flatMap((step) => {
      if (step.type === "step" || step.type === "loop" || step.type === "foreach") {
        if (step.step instanceof _InngestWorkflow) {
          return [step.step.getFunction(), ...step.step.getNestedFunctions(step.step.executionGraph.steps)];
        }
        return [];
      } else if (step.type === "parallel" || step.type === "conditional") {
        return this.getNestedFunctions(step.steps);
      }
      return [];
    });
  }
  getFunctions() {
    return [this.getFunction(), ...this.getNestedFunctions(this.executionGraph.steps)];
  }
};
function cloneWorkflow(workflow, opts) {
  const wf = new InngestWorkflow(
    {
      id: opts.id,
      inputSchema: workflow.inputSchema,
      outputSchema: workflow.outputSchema,
      steps: workflow.stepDefs,
      mastra: workflow.mastra
    },
    workflow.inngest
  );
  wf.setStepFlow(workflow.stepGraph);
  wf.commit();
  return wf;
}
function init(inngest) {
  return {
    createWorkflow(params) {
      return new InngestWorkflow(params, inngest);
    },
    createStep: createStep$1,
    cloneStep,
    cloneWorkflow
  };
}
var InngestExecutionEngine = class extends DefaultExecutionEngine {
  inngestStep;
  inngestAttempts;
  constructor(mastra, inngestStep, inngestAttempts = 0) {
    super({ mastra });
    this.inngestStep = inngestStep;
    this.inngestAttempts = inngestAttempts;
  }
  async fmtReturnValue(executionSpan, emitter, stepResults, lastOutput, error) {
    const base = {
      status: lastOutput.status,
      steps: stepResults
    };
    if (lastOutput.status === "success") {
      await emitter.emit("watch", {
        type: "watch",
        payload: {
          workflowState: {
            status: lastOutput.status,
            steps: stepResults,
            result: lastOutput.output
          }
        },
        eventTimestamp: Date.now()
      });
      base.result = lastOutput.output;
    } else if (lastOutput.status === "failed") {
      base.error = error instanceof Error ? error?.stack ?? error.message : lastOutput?.error instanceof Error ? lastOutput.error.message : lastOutput.error ?? error ?? "Unknown error";
      await emitter.emit("watch", {
        type: "watch",
        payload: {
          workflowState: {
            status: lastOutput.status,
            steps: stepResults,
            result: null,
            error: base.error
          }
        },
        eventTimestamp: Date.now()
      });
    } else if (lastOutput.status === "suspended") {
      await emitter.emit("watch", {
        type: "watch",
        payload: {
          workflowState: {
            status: lastOutput.status,
            steps: stepResults,
            result: null,
            error: null
          }
        },
        eventTimestamp: Date.now()
      });
      const suspendedStepIds = Object.entries(stepResults).flatMap(([stepId, stepResult]) => {
        if (stepResult?.status === "suspended") {
          const nestedPath = stepResult?.payload?.__workflow_meta?.path;
          return nestedPath ? [[stepId, ...nestedPath]] : [[stepId]];
        }
        return [];
      });
      base.suspended = suspendedStepIds;
    }
    executionSpan?.end();
    return base;
  }
  async superExecuteStep({
    workflowId,
    runId,
    step,
    stepResults,
    executionContext,
    resume,
    prevOutput,
    emitter,
    runtimeContext
  }) {
    return super.executeStep({
      workflowId,
      runId,
      step,
      stepResults,
      executionContext,
      resume,
      prevOutput,
      emitter,
      runtimeContext
    });
  }
  async executeStep({
    step,
    stepResults,
    executionContext,
    resume,
    prevOutput,
    emitter,
    runtimeContext
  }) {
    await this.inngestStep.run(
      `workflow.${executionContext.workflowId}.run.${executionContext.runId}.step.${step.id}.running_ev`,
      async () => {
        await emitter.emit("watch", {
          type: "watch",
          payload: {
            currentStep: {
              id: step.id,
              status: "running"
            },
            workflowState: {
              status: "running",
              steps: {
                ...stepResults,
                [step.id]: {
                  status: "running"
                }
              },
              result: null,
              error: null
            }
          },
          eventTimestamp: Date.now()
        });
      }
    );
    if (step instanceof InngestWorkflow) {
      const isResume = !!resume?.steps?.length;
      let result;
      let runId;
      if (isResume) {
        runId = stepResults[resume?.steps?.[0]]?.payload?.__workflow_meta?.runId ?? randomUUID();
        const snapshot = await this.mastra?.getStorage()?.loadWorkflowSnapshot({
          workflowName: step.id,
          runId
        });
        const invokeResp = await this.inngestStep.invoke(`workflow.${executionContext.workflowId}.step.${step.id}`, {
          function: step.getFunction(),
          data: {
            inputData: prevOutput,
            runId,
            resume: {
              runId,
              steps: resume.steps.slice(1),
              stepResults: snapshot?.context,
              resumePayload: resume.resumePayload,
              // @ts-ignore
              resumePath: snapshot?.suspendedPaths?.[resume.steps?.[1]]
            }
          }
        });
        result = invokeResp.result;
        runId = invokeResp.runId;
      } else {
        const invokeResp = await this.inngestStep.invoke(`workflow.${executionContext.workflowId}.step.${step.id}`, {
          function: step.getFunction(),
          data: {
            inputData: prevOutput
          }
        });
        result = invokeResp.result;
        runId = invokeResp.runId;
      }
      const res = await this.inngestStep.run(
        `workflow.${executionContext.workflowId}.step.${step.id}.nestedwf-results`,
        async () => {
          if (result.status === "failed") {
            await emitter.emit("watch", {
              type: "watch",
              payload: {
                currentStep: {
                  id: step.id,
                  status: "failed",
                  error: result?.error
                },
                workflowState: {
                  status: "running",
                  steps: stepResults,
                  result: null,
                  error: null
                }
              },
              eventTimestamp: Date.now()
            });
            return { executionContext, result: { status: "failed", error: result?.error } };
          } else if (result.status === "suspended") {
            const suspendedSteps = Object.entries(result.steps).filter(([_stepName, stepResult]) => {
              const stepRes2 = stepResult;
              return stepRes2?.status === "suspended";
            });
            for (const [stepName, stepResult] of suspendedSteps) {
              const suspendPath = [stepName, ...stepResult?.payload?.__workflow_meta?.path ?? []];
              executionContext.suspendedPaths[step.id] = executionContext.executionPath;
              await emitter.emit("watch", {
                type: "watch",
                payload: {
                  currentStep: {
                    id: step.id,
                    status: "suspended",
                    payload: { ...stepResult?.payload, __workflow_meta: { runId, path: suspendPath } }
                  },
                  workflowState: {
                    status: "running",
                    steps: stepResults,
                    result: null,
                    error: null
                  }
                },
                eventTimestamp: Date.now()
              });
              return {
                executionContext,
                result: {
                  status: "suspended",
                  payload: { ...stepResult?.payload, __workflow_meta: { runId, path: suspendPath } }
                }
              };
            }
            await emitter.emit("watch", {
              type: "watch",
              payload: {
                currentStep: {
                  id: step.id,
                  status: "suspended",
                  payload: {}
                },
                workflowState: {
                  status: "running",
                  steps: stepResults,
                  result: null,
                  error: null
                }
              },
              eventTimestamp: Date.now()
            });
            return {
              executionContext,
              result: {
                status: "suspended",
                payload: {}
              }
            };
          }
          await emitter.emit("watch", {
            type: "watch",
            payload: {
              currentStep: {
                id: step.id,
                status: "success",
                output: result?.result
              },
              workflowState: {
                status: "running",
                steps: stepResults,
                result: null,
                error: null
              }
            },
            eventTimestamp: Date.now()
          });
          return { executionContext, result: { status: "success", output: result?.result } };
        }
      );
      Object.assign(executionContext, res.executionContext);
      return res.result;
    }
    const stepRes = await this.inngestStep.run(`workflow.${executionContext.workflowId}.step.${step.id}`, async () => {
      let execResults;
      let suspended;
      try {
        const result = await step.execute({
          mastra: this.mastra,
          runtimeContext,
          inputData: prevOutput,
          resumeData: resume?.steps[0] === step.id ? resume?.resumePayload : void 0,
          getInitData: () => stepResults?.input,
          getStepResult: (step2) => {
            const result2 = stepResults[step2.id];
            if (result2?.status === "success") {
              return result2.output;
            }
            return null;
          },
          suspend: async (suspendPayload) => {
            executionContext.suspendedPaths[step.id] = executionContext.executionPath;
            suspended = { payload: suspendPayload };
          },
          resume: {
            steps: resume?.steps?.slice(1) || [],
            resumePayload: resume?.resumePayload,
            // @ts-ignore
            runId: stepResults[step.id]?.payload?.__workflow_meta?.runId
          },
          emitter
        });
        execResults = { status: "success", output: result };
      } catch (e) {
        execResults = { status: "failed", error: e instanceof Error ? e.message : String(e) };
      }
      if (suspended) {
        execResults = { status: "suspended", payload: suspended.payload };
      }
      if (execResults.status === "failed") {
        if (executionContext.retryConfig.attempts > 0 && this.inngestAttempts < executionContext.retryConfig.attempts) {
          throw execResults.error;
        }
      }
      await emitter.emit("watch", {
        type: "watch",
        payload: {
          currentStep: {
            id: step.id,
            status: execResults.status,
            output: execResults.output
          },
          workflowState: {
            status: "running",
            steps: stepResults,
            result: null,
            error: null
          }
        },
        eventTimestamp: Date.now()
      });
      return { result: execResults, executionContext, stepResults };
    });
    Object.assign(executionContext.suspendedPaths, stepRes.executionContext.suspendedPaths);
    Object.assign(stepResults, stepRes.stepResults);
    return stepRes.result;
  }
  async persistStepUpdate({
    workflowId,
    runId,
    stepResults,
    executionContext
  }) {
    await this.inngestStep.run(
      `workflow.${workflowId}.run.${runId}.path.${JSON.stringify(executionContext.executionPath)}.stepUpdate`,
      async () => {
        await this.mastra?.getStorage()?.persistWorkflowSnapshot({
          workflowName: workflowId,
          runId,
          snapshot: {
            runId,
            value: {},
            context: stepResults,
            activePaths: [],
            suspendedPaths: executionContext.suspendedPaths,
            // @ts-ignore
            timestamp: Date.now()
          }
        });
      }
    );
  }
  async executeConditional({
    workflowId,
    runId,
    entry,
    prevOutput,
    prevStep,
    stepResults,
    resume,
    executionContext,
    emitter,
    runtimeContext
  }) {
    let execResults;
    const truthyIndexes = (await Promise.all(
      entry.conditions.map(
        (cond, index) => this.inngestStep.run(`workflow.${workflowId}.conditional.${index}`, async () => {
          try {
            const result = await cond({
              mastra: this.mastra,
              runtimeContext,
              inputData: prevOutput,
              getInitData: () => stepResults?.input,
              getStepResult: (step) => {
                if (!step?.id) {
                  return null;
                }
                const result2 = stepResults[step.id];
                if (result2?.status === "success") {
                  return result2.output;
                }
                return null;
              },
              // TODO: this function shouldn't have suspend probably?
              suspend: async (_suspendPayload) => {
              },
              emitter
            });
            return result ? index : null;
          } catch (e) {
            return null;
          }
        })
      )
    )).filter((index) => index !== null);
    const stepsToRun = entry.steps.filter((_, index) => truthyIndexes.includes(index));
    const results = await Promise.all(
      stepsToRun.map(
        (step, index) => this.executeEntry({
          workflowId,
          runId,
          entry: step,
          prevStep,
          stepResults,
          resume,
          executionContext: {
            workflowId,
            runId,
            executionPath: [...executionContext.executionPath, index],
            suspendedPaths: executionContext.suspendedPaths,
            retryConfig: executionContext.retryConfig,
            executionSpan: executionContext.executionSpan
          },
          emitter,
          runtimeContext
        })
      )
    );
    const hasFailed = results.find((result) => result.status === "failed");
    const hasSuspended = results.find((result) => result.status === "suspended");
    if (hasFailed) {
      execResults = { status: "failed", error: hasFailed.error };
    } else if (hasSuspended) {
      execResults = { status: "suspended", payload: hasSuspended.payload };
    } else {
      execResults = {
        status: "success",
        output: results.reduce((acc, result, index) => {
          if (result.status === "success") {
            acc[stepsToRun[index].step.id] = result.output;
          }
          return acc;
        }, {})
      };
    }
    return execResults;
  }
};

var Inngest = inngest$1.Inngest;

var realtimeMiddleware = dist.realtimeMiddleware;

const inngest = new Inngest({
  id: "mastra",
  baseUrl: "https://api.inngest.com" ,
  middleware: [realtimeMiddleware()]
});

var ZodFirstPartyTypeKind = lib.ZodFirstPartyTypeKind;
var ZodOptional = lib.ZodOptional;
var z = lib.z;

const { createWorkflow, createStep } = init(inngest);
const incrementStep = createStep({
  id: "increment",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async ({ inputData }) => {
    return { value: inputData.value + 1 };
  }
});
const sideEffectStep = createStep({
  id: "side-effect",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async ({ inputData }) => {
    console.log("Current value:", inputData.value);
    return { value: inputData.value };
  }
});
const finalStep = createStep({
  id: "final",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  }),
  execute: async ({ inputData }) => {
    return { value: inputData.value };
  }
});
const workflow = createWorkflow({
  id: "increment-workflow",
  inputSchema: z.object({
    value: z.number()
  }),
  outputSchema: z.object({
    value: z.number()
  })
}).dountil(
  createWorkflow({
    id: "increment-subworkflow",
    inputSchema: z.object({
      value: z.number()
    }),
    outputSchema: z.object({
      value: z.number()
    }),
    steps: [incrementStep, sideEffectStep]
  }).then(incrementStep).then(sideEffectStep).commit(),
  async ({ inputData }) => inputData.value >= 10
).then(finalStep);
workflow.commit();

const mastra = new Mastra({
  vnext_workflows: {
    incrementWorkflow: workflow
  },
  server: {
    host: "0.0.0.0",
    apiRoutes: [{
      path: "/api/inngest",
      method: "ALL",
      createHandler: async ({
        mastra: mastra2
      }) => serve({
        mastra: mastra2,
        inngest
      })
    }]
  },
  logger: createLogger({
    name: "Mastra",
    level: "info"
  })
});

export { AvailableHooks as A, TABLE_MESSAGES as B, TABLE_TRACES as C, InstrumentClass as I, MastraBase as M, RegisteredLogger as R, Telemetry as T, ZodFirstPartyTypeKind as Z, __decoratorStart as _, ZodOptional as a, RuntimeContext as b, ensureAllMessagesAreCoreMessages as c, createMastraProxy as d, ensureToolProperties as e, executeHook as f, __decorateElement as g, __runInitializers as h, generateText as i, generateObject as j, streamObject as k, lib as l, makeCoreTool as m, delay as n, output_exports as o, jsonSchema as p, isVercelTool as q, registerHook as r, streamText as s, mastra as t, checkEvalStorageFields as u, TABLE_EVALS as v, MastraStorage as w, TABLE_WORKFLOW_SNAPSHOT as x, TABLE_THREADS as y, z };
